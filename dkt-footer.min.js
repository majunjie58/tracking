/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */
/**
 * @namespace ScrollMagic
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		module.exports = factory();
	} else {
		// Browser global
		root.ScrollMagic = factory();
	}
}(this, function () {
	"use strict";

	var ScrollMagic = function () {
		_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
	};

	ScrollMagic.version = "2.0.5";

	// TODO: temporary workaround for chrome's scroll jitter bug
	window.addEventListener("mousewheel", function () {});

	// global const
	var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";

	/**
	 * The main class that is needed once per scroll container.
	 *
	 * @class
	 *
	 * @example
	 * // basic initialization
	 * var controller = new ScrollMagic.Controller();
	 *
	 * // passing options
	 * var controller = new ScrollMagic.Controller({container: "#myContainer", loglevel: 3});
	 *
	 * @param {object} [options] - An object containing one or more options for the controller.
	 * @param {(string|object)} [options.container=window] - A selector, DOM object that references the main container for scrolling.
	 * @param {boolean} [options.vertical=true] - Sets the scroll mode to vertical (`true`) or horizontal (`false`) scrolling.
	 * @param {object} [options.globalSceneOptions={}] - These options will be passed to every Scene that is added to the controller using the addScene method. For more information on Scene options see {@link ScrollMagic.Scene}.
	 * @param {number} [options.loglevel=2] Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
	 ** `0` => silent
	 ** `1` => errors
	 ** `2` => errors, warnings
	 ** `3` => errors, warnings, debuginfo
	 * @param {boolean} [options.refreshInterval=100] - Some changes don't call events by default, like changing the container size or moving a scene trigger element.  
	 This interval polls these parameters to fire the necessary events.  
	 If you don't use custom containers, trigger elements or have static layouts, where the positions of the trigger elements don't change, you can set this to 0 disable interval checking and improve performance.
	 *
	 */
	ScrollMagic.Controller = function (options) {
/*
	 * ----------------------------------------------------------------
	 * settings
	 * ----------------------------------------------------------------
	 */
		var
		NAMESPACE = 'ScrollMagic.Controller',
			SCROLL_DIRECTION_FORWARD = 'FORWARD',
			SCROLL_DIRECTION_REVERSE = 'REVERSE',
			SCROLL_DIRECTION_PAUSED = 'PAUSED',
			DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;

/*
	 * ----------------------------------------------------------------
	 * private vars
	 * ----------------------------------------------------------------
	 */
		var
		Controller = this,
			_options = _util.extend({}, DEFAULT_OPTIONS, options),
			_sceneObjects = [],
			_updateScenesOnNextCycle = false,
			// can be boolean (true => all scenes) or an array of scenes to be updated
			_scrollPos = 0,
			_scrollDirection = SCROLL_DIRECTION_PAUSED,
			_isDocument = true,
			_viewPortSize = 0,
			_enabled = true,
			_updateTimeout, _refreshTimeout;

/*
	 * ----------------------------------------------------------------
	 * private functions
	 * ----------------------------------------------------------------
	 */

		/**
		 * Internal constructor function of the ScrollMagic Controller
		 * @private
		 */
		var construct = function () {
			for (var key in _options) {
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			_options.container = _util.get.elements(_options.container)[0];
			// check ScrollContainer
			if (!_options.container) {
				log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
				throw NAMESPACE + " init failed."; // cancel
			}
			_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
			// normalize to window
			if (_isDocument) {
				_options.container = window;
			}
			// update container size immediately
			_viewPortSize = getViewportSize();
			// set event handlers
			_options.container.addEventListener("resize", onChange);
			_options.container.addEventListener("scroll", onChange);

			_options.refreshInterval = parseInt(_options.refreshInterval) || DEFAULT_OPTIONS.refreshInterval;
			scheduleRefresh();

			log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
		};

		/**
		 * Schedule the next execution of the refresh function
		 * @private
		 */
		var scheduleRefresh = function () {
			if (_options.refreshInterval > 0) {
				_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
			}
		};

		/**
		 * Default function to get scroll pos - overwriteable using `Controller.scrollPos(newFunction)`
		 * @private
		 */
		var getScrollPos = function () {
			return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
		};

		/**
		 * Returns the current viewport Size (width vor horizontal, height for vertical)
		 * @private
		 */
		var getViewportSize = function () {
			return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
		};

		/**
		 * Default function to set scroll pos - overwriteable using `Controller.scrollTo(newFunction)`
		 * Make available publicly for pinned mousewheel workaround.
		 * @private
		 */
		var setScrollPos = this._setScrollPos = function (pos) {
			if (_options.vertical) {
				if (_isDocument) {
					window.scrollTo(_util.get.scrollLeft(), pos);
				} else {
					_options.container.scrollTop = pos;
				}
			} else {
				if (_isDocument) {
					window.scrollTo(pos, _util.get.scrollTop());
				} else {
					_options.container.scrollLeft = pos;
				}
			}
		};

		/**
		 * Handle updates in cycles instead of on scroll (performance)
		 * @private
		 */
		var updateScenes = function () {
			if (_enabled && _updateScenesOnNextCycle) {
				// determine scenes to update
				var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
				// reset scenes
				_updateScenesOnNextCycle = false;
				var oldScrollPos = _scrollPos;
				// update scroll pos now instead of onChange, as it might have changed since scheduling (i.e. in-browser smooth scroll)
				_scrollPos = Controller.scrollPos();
				var deltaScroll = _scrollPos - oldScrollPos;
				if (deltaScroll !== 0) { // scroll position changed?
					_scrollDirection = (deltaScroll > 0) ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
				}
				// reverse order of scenes if scrolling reverse
				if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
					scenesToUpdate.reverse();
				}
				// update scenes
				scenesToUpdate.forEach(function (scene, index) {
					log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
					scene.update(true);
				});
				if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
					log(3, "updating 0 Scenes (nothing added to controller)");
				}
			}
		};

		/**
		 * Initializes rAF callback
		 * @private
		 */
		var debounceUpdate = function () {
			_updateTimeout = _util.rAF(updateScenes);
		};

		/**
		 * Handles Container changes
		 * @private
		 */
		var onChange = function (e) {
			log(3, "event fired causing an update:", e.type);
			if (e.type == "resize") {
				// resize
				_viewPortSize = getViewportSize();
				_scrollDirection = SCROLL_DIRECTION_PAUSED;
			}
			// schedule update
			if (_updateScenesOnNextCycle !== true) {
				_updateScenesOnNextCycle = true;
				debounceUpdate();
			}
		};

		var refresh = function () {
			if (!_isDocument) {
				// simulate resize event. Only works for viewport relevant param (performance)
				if (_viewPortSize != getViewportSize()) {
					var resizeEvent;
					try {
						resizeEvent = new Event('resize', {
							bubbles: false,
							cancelable: false
						});
					} catch (e) { // stupid IE
						resizeEvent = document.createEvent("Event");
						resizeEvent.initEvent("resize", false, false);
					}
					_options.container.dispatchEvent(resizeEvent);
				}
			}
			_sceneObjects.forEach(function (scene, index) { // refresh all scenes
				scene.refresh();
			});
			scheduleRefresh();
		};

		/**
		 * Send a debug message to the console.
		 * provided publicly with _log for plugins
		 * @private
		 *
		 * @param {number} loglevel - The loglevel required to initiate output for the message.
		 * @param {...mixed} output - One or more variables that should be passed to the console.
		 */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};
		// for scenes we have getters for each option, but for the controller we don't, so we need to make it available externally for plugins
		this._options = _options;

		/**
		 * Sort scenes in ascending order of their start offset.
		 * @private
		 *
		 * @param {array} ScenesArray - an array of ScrollMagic Scenes that should be sorted
		 * @return {array} The sorted array of Scenes.
		 */
		var sortScenes = function (ScenesArray) {
			if (ScenesArray.length <= 1) {
				return ScenesArray;
			} else {
				var scenes = ScenesArray.slice(0);
				scenes.sort(function (a, b) {
					return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
				});
				return scenes;
			}
		};

		/**
		 * ----------------------------------------------------------------
		 * public functions
		 * ----------------------------------------------------------------
		 */

		/**
		 * Add one ore more scene(s) to the controller.  
		 * This is the equivalent to `Scene.addTo(controller)`.
		 * @public
		 * @example
		 * // with a previously defined scene
		 * controller.addScene(scene);
		 *
		 * // with a newly created scene.
		 * controller.addScene(new ScrollMagic.Scene({duration : 0}));
		 *
		 * // adding multiple scenes
		 * controller.addScene([scene, scene2, new ScrollMagic.Scene({duration : 0})]);
		 *
		 * @param {(ScrollMagic.Scene|array)} newScene - ScrollMagic Scene or Array of Scenes to be added to the controller.
		 * @return {Controller} Parent object for chaining.
		 */
		this.addScene = function (newScene) {
			if (_util.type.Array(newScene)) {
				newScene.forEach(function (scene, index) {
					Controller.addScene(scene);
				});
			} else if (newScene instanceof ScrollMagic.Scene) {
				if (newScene.controller() !== Controller) {
					newScene.addTo(Controller);
				} else if (_sceneObjects.indexOf(newScene) < 0) {
					// new scene
					_sceneObjects.push(newScene); // add to array
					_sceneObjects = sortScenes(_sceneObjects); // sort
					newScene.on("shift.controller_sort", function () { // resort whenever scene moves
						_sceneObjects = sortScenes(_sceneObjects);
					});
					// insert Global defaults.
					for (var key in _options.globalSceneOptions) {
						if (newScene[key]) {
							newScene[key].call(newScene, _options.globalSceneOptions[key]);
						}
					}
					log(3, "adding Scene (now " + _sceneObjects.length + " total)");
				}
			} else {
				log(1, "ERROR: invalid argument supplied for '.addScene()'");
			}
			return Controller;
		};

		/**
		 * Remove one ore more scene(s) from the controller.  
		 * This is the equivalent to `Scene.remove()`.
		 * @public
		 * @example
		 * // remove a scene from the controller
		 * controller.removeScene(scene);
		 *
		 * // remove multiple scenes from the controller
		 * controller.removeScene([scene, scene2, scene3]);
		 *
		 * @param {(ScrollMagic.Scene|array)} Scene - ScrollMagic Scene or Array of Scenes to be removed from the controller.
		 * @returns {Controller} Parent object for chaining.
		 */
		this.removeScene = function (Scene) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.removeScene(scene);
				});
			} else {
				var index = _sceneObjects.indexOf(Scene);
				if (index > -1) {
					Scene.off("shift.controller_sort");
					_sceneObjects.splice(index, 1);
					log(3, "removing Scene (now " + _sceneObjects.length + " left)");
					Scene.remove();
				}
			}
			return Controller;
		};

		/**
		 * Update one ore more scene(s) according to the scroll position of the container.  
		 * This is the equivalent to `Scene.update()`.  
		 * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
		 * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.  
		 * _**Note:** This method gets called constantly whenever Controller detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
		 * @public
		 * @example
		 * // update a specific scene on next cycle
		 * controller.updateScene(scene);
		 *
		 * // update a specific scene immediately
		 * controller.updateScene(scene, true);
		 *
		 * // update multiple scenes scene on next cycle
		 * controller.updateScene([scene1, scene2, scene3]);
		 *
		 * @param {ScrollMagic.Scene} Scene - ScrollMagic Scene or Array of Scenes that is/are supposed to be updated.
		 * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle.  
		 This is useful when changing multiple properties of the scene - this way it will only be updated once all new properties are set (updateScenes).
		 * @return {Controller} Parent object for chaining.
		 */
		this.updateScene = function (Scene, immediately) {
			if (_util.type.Array(Scene)) {
				Scene.forEach(function (scene, index) {
					Controller.updateScene(scene, immediately);
				});
			} else {
				if (immediately) {
					Scene.update(true);
				} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) { // if _updateScenesOnNextCycle is true, all connected scenes are already scheduled for update
					// prep array for next update cycle
					_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
					if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
						_updateScenesOnNextCycle.push(Scene);
					}
					_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle); // sort
					debounceUpdate();
				}
			}
			return Controller;
		};

		/**
		 * Updates the controller params and calls updateScene on every scene, that is attached to the controller.  
		 * See `Controller.updateScene()` for more information about what this means.  
		 * In most cases you will not need this function, as it is called constantly, whenever ScrollMagic detects a state change event, like resize or scroll.  
		 * The only application for this method is when ScrollMagic fails to detect these events.  
		 * One application is with some external scroll libraries (like iScroll) that move an internal container to a negative offset instead of actually scrolling. In this case the update on the controller needs to be called whenever the child container's position changes.
		 * For this case there will also be the need to provide a custom function to calculate the correct scroll position. See `Controller.scrollPos()` for details.
		 * @public
		 * @example
		 * // update the controller on next cycle (saves performance due to elimination of redundant updates)
		 * controller.update();
		 *
		 * // update the controller immediately
		 * controller.update(true);
		 *
		 * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance)
		 * @return {Controller} Parent object for chaining.
		 */
		this.update = function (immediately) {
			onChange({
				type: "resize"
			}); // will update size and set _updateScenesOnNextCycle to true
			if (immediately) {
				updateScenes();
			}
			return Controller;
		};

		/**
		 * Scroll to a numeric scroll offset, a DOM element, the start of a scene or provide an alternate method for scrolling.  
		 * For vertical controllers it will change the top scroll offset and for horizontal applications it will change the left offset.
		 * @public
		 *
		 * @since 1.1.0
		 * @example
		 * // scroll to an offset of 100
		 * controller.scrollTo(100);
		 *
		 * // scroll to a DOM element
		 * controller.scrollTo("#anchor");
		 *
		 * // scroll to the beginning of a scene
		 * var scene = new ScrollMagic.Scene({offset: 200});
		 * controller.scrollTo(scene);
		 *
		 * // define a new scroll position modification function (jQuery animate instead of jump)
		 * controller.scrollTo(function (newScrollPos) {
		 *	$("html, body").animate({scrollTop: newScrollPos});
		 * });
		 * controller.scrollTo(100); // call as usual, but the new function will be used instead
		 *
		 * // define a new scroll function with an additional parameter
		 * controller.scrollTo(function (newScrollPos, message) {
		 *  console.log(message);
		 *	$(this).animate({scrollTop: newScrollPos});
		 * });
		 * // call as usual, but supply an extra parameter to the defined custom function
		 * controller.scrollTo(100, "my message");
		 *
		 * // define a new scroll function with an additional parameter containing multiple variables
		 * controller.scrollTo(function (newScrollPos, options) {
		 *  someGlobalVar = options.a + options.b;
		 *	$(this).animate({scrollTop: newScrollPos});
		 * });
		 * // call as usual, but supply an extra parameter containing multiple options
		 * controller.scrollTo(100, {a: 1, b: 2});
		 *
		 * // define a new scroll function with a callback supplied as an additional parameter
		 * controller.scrollTo(function (newScrollPos, callback) {
		 *	$(this).animate({scrollTop: newScrollPos}, 400, "swing", callback);
		 * });
		 * // call as usual, but supply an extra parameter, which is used as a callback in the previously defined custom scroll function
		 * controller.scrollTo(100, function() {
		 *	console.log("scroll has finished.");
		 * });
		 *
		 * @param {mixed} scrollTarget - The supplied argument can be one of these types:
		 * 1. `number` -> The container will scroll to this new scroll offset.
		 * 2. `string` or `object` -> Can be a selector or a DOM object.  
		 *  The container will scroll to the position of this element.
		 * 3. `ScrollMagic Scene` -> The container will scroll to the start of this scene.
		 * 4. `function` -> This function will be used for future scroll position modifications.  
		 *  This provides a way for you to change the behaviour of scrolling and adding new behaviour like animation. The function receives the new scroll position as a parameter and a reference to the container element using `this`.  
		 *  It may also optionally receive an optional additional parameter (see below)  
		 *  _**NOTE:**  
		 *  All other options will still work as expected, using the new function to scroll._
		 * @param {mixed} [additionalParameter] - If a custom scroll function was defined (see above 4.), you may want to supply additional parameters to it, when calling it. You can do this using this parameter – see examples for details. Please note, that this parameter will have no effect, if you use the default scrolling function.
		 * @returns {Controller} Parent object for chaining.
		 */
		this.scrollTo = function (scrollTarget, additionalParameter) {
			if (_util.type.Number(scrollTarget)) { // excecute
				setScrollPos.call(_options.container, scrollTarget, additionalParameter);
			} else if (scrollTarget instanceof ScrollMagic.Scene) { // scroll to scene
				if (scrollTarget.controller() === Controller) { // check if the controller is associated with this scene
					Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
				}
			} else if (_util.type.Function(scrollTarget)) { // assign new scroll function
				setScrollPos = scrollTarget;
			} else { // scroll to element
				var elem = _util.get.elements(scrollTarget)[0];
				if (elem) {
					// if parent is pin spacer, use spacer position instead so correct start position is returned for pinned elements.
					while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
						elem = elem.parentNode;
					}

					var
					param = _options.vertical ? "top" : "left",
						// which param is of interest ?
						containerOffset = _util.get.offset(_options.container),
						// container position is needed because element offset is returned in relation to document, not in relation to container.
						elementOffset = _util.get.offset(elem);

					if (!_isDocument) { // container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
						containerOffset[param] -= Controller.scrollPos();
					}

					Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
				} else {
					log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
				}
			}
			return Controller;
		};

		/**
		 * **Get** the current scrollPosition or **Set** a new method to calculate it.  
		 * -> **GET**:
		 * When used as a getter this function will return the current scroll position.  
		 * To get a cached value use Controller.info("scrollPos"), which will be updated in the update cycle.  
		 * For vertical controllers it will return the top scroll offset and for horizontal applications it will return the left offset.
		 *
		 * -> **SET**:
		 * When used as a setter this method prodes a way to permanently overwrite the controller's scroll position calculation.  
		 * A typical usecase is when the scroll position is not reflected by the containers scrollTop or scrollLeft values, but for example by the inner offset of a child container.  
		 * Moving a child container inside a parent is a commonly used method for several scrolling frameworks, including iScroll.  
		 * By providing an alternate calculation function you can make sure ScrollMagic receives the correct scroll position.  
		 * Please also bear in mind that your function should return y values for vertical scrolls an x for horizontals.
		 *
		 * To change the current scroll position please use `Controller.scrollTo()`.
		 * @public
		 *
		 * @example
		 * // get the current scroll Position
		 * var scrollPos = controller.scrollPos();
		 *
		 * // set a new scroll position calculation method
		 * controller.scrollPos(function () {
		 *	return this.info("vertical") ? -mychildcontainer.y : -mychildcontainer.x
		 * });
		 *
		 * @param {function} [scrollPosMethod] - The function to be used for the scroll position calculation of the container.
		 * @returns {(number|Controller)} Current scroll position or parent object for chaining.
		 */
		this.scrollPos = function (scrollPosMethod) {
			if (!arguments.length) { // get
				return getScrollPos.call(Controller);
			} else { // set
				if (_util.type.Function(scrollPosMethod)) {
					getScrollPos = scrollPosMethod;
				} else {
					log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
				}
			}
			return Controller;
		};

		/**
		 * **Get** all infos or one in particular about the controller.
		 * @public
		 * @example
		 * // returns the current scroll position (number)
		 * var scrollPos = controller.info("scrollPos");
		 *
		 * // returns all infos as an object
		 * var infos = controller.info();
		 *
		 * @param {string} [about] - If passed only this info will be returned instead of an object containing all.  
		 Valid options are:
		 ** `"size"` => the current viewport size of the container
		 ** `"vertical"` => true if vertical scrolling, otherwise false
		 ** `"scrollPos"` => the current scroll position
		 ** `"scrollDirection"` => the last known direction of the scroll
		 ** `"container"` => the container element
		 ** `"isDocument"` => true if container element is the document.
		 * @returns {(mixed|object)} The requested info(s).
		 */
		this.info = function (about) {
			var values = {
				size: _viewPortSize,
				// contains height or width (in regard to orientation);
				vertical: _options.vertical,
				scrollPos: _scrollPos,
				scrollDirection: _scrollDirection,
				container: _options.container,
				isDocument: _isDocument
			};
			if (!arguments.length) { // get all as an object
				return values;
			} else if (values[about] !== undefined) {
				return values[about];
			} else {
				log(1, "ERROR: option \"" + about + "\" is not available");
				return;
			}
		};

		/**
		 * **Get** or **Set** the current loglevel option value.
		 * @public
		 *
		 * @example
		 * // get the current value
		 * var loglevel = controller.loglevel();
		 *
		 * // set a new value
		 * controller.loglevel(3);
		 *
		 * @param {number} [newLoglevel] - The new loglevel setting of the Controller. `[0-3]`
		 * @returns {(number|Controller)} Current loglevel or parent object for chaining.
		 */
		this.loglevel = function (newLoglevel) {
			if (!arguments.length) { // get
				return _options.loglevel;
			} else if (_options.loglevel != newLoglevel) { // set
				_options.loglevel = newLoglevel;
			}
			return Controller;
		};

		/**
		 * **Get** or **Set** the current enabled state of the controller.  
		 * This can be used to disable all Scenes connected to the controller without destroying or removing them.
		 * @public
		 *
		 * @example
		 * // get the current value
		 * var enabled = controller.enabled();
		 *
		 * // disable the controller
		 * controller.enabled(false);
		 *
		 * @param {boolean} [newState] - The new enabled state of the controller `true` or `false`.
		 * @returns {(boolean|Controller)} Current enabled state or parent object for chaining.
		 */
		this.enabled = function (newState) {
			if (!arguments.length) { // get
				return _enabled;
			} else if (_enabled != newState) { // set
				_enabled = !! newState;
				Controller.updateScene(_sceneObjects, true);
			}
			return Controller;
		};

		/**
		 * Destroy the Controller, all Scenes and everything.
		 * @public
		 *
		 * @example
		 * // without resetting the scenes
		 * controller = controller.destroy();
		 *
		 * // with scene reset
		 * controller = controller.destroy(true);
		 *
		 * @param {boolean} [resetScenes=false] - If `true` the pins and tweens (if existent) of all scenes will be reset.
		 * @returns {null} Null to unset handler variables.
		 */
		this.destroy = function (resetScenes) {
			window.clearTimeout(_refreshTimeout);
			var i = _sceneObjects.length;
			while (i--) {
				_sceneObjects[i].destroy(resetScenes);
			}
			_options.container.removeEventListener("resize", onChange);
			_options.container.removeEventListener("scroll", onChange);
			_util.cAF(_updateTimeout);
			log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
			return null;
		};

		// INIT
		construct();
		return Controller;
	};

	// store pagewide controller options
	var CONTROLLER_OPTIONS = {
		defaults: {
			container: window,
			vertical: true,
			globalSceneOptions: {},
			loglevel: 2,
			refreshInterval: 100
		}
	};
/*
 * method used to add an option to ScrollMagic Scenes.
 */
	ScrollMagic.Controller.addOption = function (name, defaultValue) {
		CONTROLLER_OPTIONS.defaults[name] = defaultValue;
	};
	// instance extension function for plugins
	ScrollMagic.Controller.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Controller = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Controller, oldClass); // copy properties
		ScrollMagic.Controller.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller; // restore constructor
	};


	/**
	 * A Scene defines where the controller should react and how.
	 *
	 * @class
	 *
	 * @example
	 * // create a standard scene and add it to a controller
	 * new ScrollMagic.Scene()
	 *		.addTo(controller);
	 *
	 * // create a scene with custom options and assign a handler to it.
	 * var scene = new ScrollMagic.Scene({
	 * 		duration: 100,
	 *		offset: 200,
	 *		triggerHook: "onEnter",
	 *		reverse: false
	 * });
	 *
	 * @param {object} [options] - Options for the Scene. The options can be updated at any time.  
	 Instead of setting the options for each scene individually you can also set them globally in the controller as the controllers `globalSceneOptions` option. The object accepts the same properties as the ones below.  
	 When a scene is added to the controller the options defined using the Scene constructor will be overwritten by those set in `globalSceneOptions`.
	 * @param {(number|function)} [options.duration=0] - The duration of the scene. 
	 If `0` tweens will auto-play when reaching the scene start point, pins will be pinned indefinetly starting at the start position.  
	 A function retuning the duration value is also supported. Please see `Scene.duration()` for details.
	 * @param {number} [options.offset=0] - Offset Value for the Trigger Position. If no triggerElement is defined this will be the scroll distance from the start of the page, after which the scene will start.
	 * @param {(string|object)} [options.triggerElement=null] - Selector or DOM object that defines the start of the scene. If undefined the scene will start right at the start of the page (unless an offset is set).
	 * @param {(number|string)} [options.triggerHook="onCenter"] - Can be a number between 0 and 1 defining the position of the trigger Hook in relation to the viewport.  
	 Can also be defined using a string:
	 ** `"onEnter"` => `1`
	 ** `"onCenter"` => `0.5`
	 ** `"onLeave"` => `0`
	 * @param {boolean} [options.reverse=true] - Should the scene reverse, when scrolling up?
	 * @param {number} [options.loglevel=2] - Loglevel for debugging. Note that logging is disabled in the minified version of ScrollMagic.
	 ** `0` => silent
	 ** `1` => errors
	 ** `2` => errors, warnings
	 ** `3` => errors, warnings, debuginfo
	 * 
	 */
	ScrollMagic.Scene = function (options) {

/*
	 * ----------------------------------------------------------------
	 * settings
	 * ----------------------------------------------------------------
	 */

		var
		NAMESPACE = 'ScrollMagic.Scene',
			SCENE_STATE_BEFORE = 'BEFORE',
			SCENE_STATE_DURING = 'DURING',
			SCENE_STATE_AFTER = 'AFTER',
			DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;

/*
	 * ----------------------------------------------------------------
	 * private vars
	 * ----------------------------------------------------------------
	 */

		var
		Scene = this,
			_options = _util.extend({}, DEFAULT_OPTIONS, options),
			_state = SCENE_STATE_BEFORE,
			_progress = 0,
			_scrollOffset = {
				start: 0,
				end: 0
			},
			// reflects the controllers's scroll position for the start and end of the scene respectively
			_triggerPos = 0,
			_enabled = true,
			_durationUpdateMethod, _controller;

		/**
		 * Internal constructor function of the ScrollMagic Scene
		 * @private
		 */
		var construct = function () {
			for (var key in _options) { // check supplied options
				if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
					log(2, "WARNING: Unknown option \"" + key + "\"");
					delete _options[key];
				}
			}
			// add getters/setters for all possible options
			for (var optionName in DEFAULT_OPTIONS) {
				addSceneOption(optionName);
			}
			// validate all options
			validateOption();
		};

/*
 * ----------------------------------------------------------------
 * Event Management
 * ----------------------------------------------------------------
 */

		var _listeners = {};
		/**
		 * Scene start event.  
		 * Fires whenever the scroll position its the starting point of the scene.  
		 * It will also fire when scrolling back up going over the start position of the scene. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#start
		 *
		 * @example
		 * scene.on("start", function (event) {
		 * 	console.log("Hit start point of scene.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"BEFORE"` or `"DURING"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene end event.  
		 * Fires whenever the scroll position its the ending point of the scene.  
		 * It will also fire when scrolling back up from after the scene and going over its end position. If you want something to happen only when scrolling down/right, use the scrollDirection parameter passed to the callback.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#end
		 *
		 * @example
		 * scene.on("end", function (event) {
		 * 	console.log("Hit end point of scene.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"DURING"` or `"AFTER"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene enter event.  
		 * Fires whenever the scene enters the "DURING" state.  
		 * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene enters its active scroll timeframe, regardless of the scroll-direction.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#enter
		 *
		 * @example
		 * scene.on("enter", function (event) {
		 * 	console.log("Scene entered.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene - always `"DURING"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene leave event.  
		 * Fires whenever the scene's state goes from "DURING" to either "BEFORE" or "AFTER".  
		 * Keep in mind that it doesn't matter if the scene plays forward or backward: This event always fires when the scene leaves its active scroll timeframe, regardless of the scroll-direction.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#leave
		 *
		 * @example
		 * scene.on("leave", function (event) {
		 * 	console.log("Scene left.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"BEFORE"` or `"AFTER"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene update event.  
		 * Fires whenever the scene is updated (but not necessarily changes the progress).
		 *
		 * @event ScrollMagic.Scene#update
		 *
		 * @example
		 * scene.on("update", function (event) {
		 * 	console.log("Scene updated.");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.startPos - The starting position of the scene (in relation to the conainer)
		 * @property {number} event.endPos - The ending position of the scene (in relation to the conainer)
		 * @property {number} event.scrollPos - The current scroll position of the container
		 */
		/**
		 * Scene progress event.  
		 * Fires whenever the progress of the scene changes.
		 *
		 * For details on this event and the order in which it is fired, please review the {@link Scene.progress} method.
		 *
		 * @event ScrollMagic.Scene#progress
		 *
		 * @example
		 * scene.on("progress", function (event) {
		 * 	console.log("Scene progress changed to " + event.progress);
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {number} event.progress - Reflects the current progress of the scene
		 * @property {string} event.state - The current state of the scene `"BEFORE"`, `"DURING"` or `"AFTER"`
		 * @property {string} event.scrollDirection - Indicates which way we are scrolling `"PAUSED"`, `"FORWARD"` or `"REVERSE"`
		 */
		/**
		 * Scene change event.  
		 * Fires whenvever a property of the scene is changed.
		 *
		 * @event ScrollMagic.Scene#change
		 *
		 * @example
		 * scene.on("change", function (event) {
		 * 	console.log("Scene Property \"" + event.what + "\" changed to " + event.newval);
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {string} event.what - Indicates what value has been changed
		 * @property {mixed} event.newval - The new value of the changed property
		 */
		/**
		 * Scene shift event.  
		 * Fires whenvever the start or end **scroll offset** of the scene change.
		 * This happens explicitely, when one of these values change: `offset`, `duration` or `triggerHook`.
		 * It will fire implicitly when the `triggerElement` changes, if the new element has a different position (most cases).
		 * It will also fire implicitly when the size of the container changes and the triggerHook is anything other than `onLeave`.
		 *
		 * @event ScrollMagic.Scene#shift
		 * @since 1.1.0
		 *
		 * @example
		 * scene.on("shift", function (event) {
		 * 	console.log("Scene moved, because the " + event.reason + " has changed.)");
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {string} event.reason - Indicates why the scene has shifted
		 */
		/**
		 * Scene destroy event.  
		 * Fires whenvever the scene is destroyed.
		 * This can be used to tidy up custom behaviour used in events.
		 *
		 * @event ScrollMagic.Scene#destroy
		 * @since 1.1.0
		 *
		 * @example
		 * scene.on("enter", function (event) {
		 *        // add custom action
		 *        $("#my-elem").left("200");
		 *      })
		 *      .on("destroy", function (event) {
		 *        // reset my element to start position
		 *        if (event.reset) {
		 *          $("#my-elem").left("0");
		 *        }
		 *      });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {boolean} event.reset - Indicates if the destroy method was called with reset `true` or `false`.
		 */
		/**
		 * Scene add event.  
		 * Fires when the scene is added to a controller.
		 * This is mostly used by plugins to know that change might be due.
		 *
		 * @event ScrollMagic.Scene#add
		 * @since 2.0.0
		 *
		 * @example
		 * scene.on("add", function (event) {
		 * 	console.log('Scene was added to a new controller.');
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 * @property {boolean} event.controller - The controller object the scene was added to.
		 */
		/**
		 * Scene remove event.  
		 * Fires when the scene is removed from a controller.
		 * This is mostly used by plugins to know that change might be due.
		 *
		 * @event ScrollMagic.Scene#remove
		 * @since 2.0.0
		 *
		 * @example
		 * scene.on("remove", function (event) {
		 * 	console.log('Scene was removed from its controller.');
		 * });
		 *
		 * @property {object} event - The event Object passed to each callback
		 * @property {string} event.type - The name of the event
		 * @property {Scene} event.target - The Scene object that triggered this event
		 */

		/**
		 * Add one ore more event listener.  
		 * The callback function will be fired at the respective event, and an object containing relevant data will be passed to the callback.
		 * @method ScrollMagic.Scene#on
		 *
		 * @example
		 * function callback (event) {
		 * 		console.log("Event fired! (" + event.type + ")");
		 * }
		 * // add listeners
		 * scene.on("change update progress start end enter leave", callback);
		 *
		 * @param {string} names - The name or names of the event the callback should be attached to.
		 * @param {function} callback - A function that should be executed, when the event is dispatched. An event object will be passed to the callback.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.on = function (names, callback) {
			if (_util.type.Function(callback)) {
				names = names.trim().split(' ');
				names.forEach(function (fullname) {
					var
					nameparts = fullname.split('.'),
						eventname = nameparts[0],
						namespace = nameparts[1];
					if (eventname != "*") { // disallow wildcards
						if (!_listeners[eventname]) {
							_listeners[eventname] = [];
						}
						_listeners[eventname].push({
							namespace: namespace || '',
							callback: callback
						});
					}
				});
			} else {
				log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
			}
			return Scene;
		};

		/**
		 * Remove one or more event listener.
		 * @method ScrollMagic.Scene#off
		 *
		 * @example
		 * function callback (event) {
		 * 		console.log("Event fired! (" + event.type + ")");
		 * }
		 * // add listeners
		 * scene.on("change update", callback);
		 * // remove listeners
		 * scene.off("change update", callback);
		 *
		 * @param {string} names - The name or names of the event that should be removed.
		 * @param {function} [callback] - A specific callback function that should be removed. If none is passed all callbacks to the event listener will be removed.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.off = function (names, callback) {
			if (!names) {
				log(1, "ERROR: Invalid event name supplied.");
				return Scene;
			}
			names = names.trim().split(' ');
			names.forEach(function (fullname, key) {
				var
				nameparts = fullname.split('.'),
					eventname = nameparts[0],
					namespace = nameparts[1] || '',
					removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
				removeList.forEach(function (remove) {
					var
					list = _listeners[remove] || [],
						i = list.length;
					while (i--) {
						var listener = list[i];
						if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
							list.splice(i, 1);
						}
					}
					if (!list.length) {
						delete _listeners[remove];
					}
				});
			});
			return Scene;
		};

		/**
		 * Trigger an event.
		 * @method ScrollMagic.Scene#trigger
		 *
		 * @example
		 * this.trigger("change");
		 *
		 * @param {string} name - The name of the event that should be triggered.
		 * @param {object} [vars] - An object containing info that should be passed to the callback.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.trigger = function (name, vars) {
			if (name) {
				var
				nameparts = name.trim().split('.'),
					eventname = nameparts[0],
					namespace = nameparts[1],
					listeners = _listeners[eventname];
				log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
				if (listeners) {
					listeners.forEach(function (listener, key) {
						if (!namespace || namespace === listener.namespace) {
							listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
						}
					});
				}
			} else {
				log(1, "ERROR: Invalid event name supplied.");
			}
			return Scene;
		};

		// set event listeners
		Scene.on("change.internal", function (e) {
			if (e.what !== "loglevel" && e.what !== "tweenChanges") { // no need for a scene update scene with these options...
				if (e.what === "triggerElement") {
					updateTriggerElementPosition();
				} else if (e.what === "reverse") { // the only property left that may have an impact on the current scene state. Everything else is handled by the shift event.
					Scene.update();
				}
			}
		}).on("shift.internal", function (e) {
			updateScrollOffset();
			Scene.update(); // update scene to reflect new position
		});

		/**
		 * Send a debug message to the console.
		 * @private
		 * but provided publicly with _log for plugins
		 *
		 * @param {number} loglevel - The loglevel required to initiate output for the message.
		 * @param {...mixed} output - One or more variables that should be passed to the console.
		 */
		var log = this._log = function (loglevel, output) {
			if (_options.loglevel >= loglevel) {
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
				_util.log.apply(window, arguments);
			}
		};

		/**
		 * Add the scene to a controller.  
		 * This is the equivalent to `Controller.addScene(scene)`.
		 * @method ScrollMagic.Scene#addTo
		 *
		 * @example
		 * // add a scene to a ScrollMagic Controller
		 * scene.addTo(controller);
		 *
		 * @param {ScrollMagic.Controller} controller - The controller to which the scene should be added.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.addTo = function (controller) {
			if (!(controller instanceof ScrollMagic.Controller)) {
				log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
			} else if (_controller != controller) {
				// new controller
				if (_controller) { // was associated to a different controller before, so remove it...
					_controller.removeScene(Scene);
				}
				_controller = controller;
				validateOption();
				updateDuration(true);
				updateTriggerElementPosition(true);
				updateScrollOffset();
				_controller.info("container").addEventListener('resize', onContainerResize);
				controller.addScene(Scene);
				Scene.trigger("add", {
					controller: _controller
				});
				log(3, "added " + NAMESPACE + " to controller");
				Scene.update();
			}
			return Scene;
		};

		/**
		 * **Get** or **Set** the current enabled state of the scene.  
		 * This can be used to disable this scene without removing or destroying it.
		 * @method ScrollMagic.Scene#enabled
		 *
		 * @example
		 * // get the current value
		 * var enabled = scene.enabled();
		 *
		 * // disable the scene
		 * scene.enabled(false);
		 *
		 * @param {boolean} [newState] - The new enabled state of the scene `true` or `false`.
		 * @returns {(boolean|Scene)} Current enabled state or parent object for chaining.
		 */
		this.enabled = function (newState) {
			if (!arguments.length) { // get
				return _enabled;
			} else if (_enabled != newState) { // set
				_enabled = !! newState;
				Scene.update(true);
			}
			return Scene;
		};

		/**
		 * Remove the scene from the controller.  
		 * This is the equivalent to `Controller.removeScene(scene)`.
		 * The scene will not be updated anymore until you readd it to a controller.
		 * To remove the pin or the tween you need to call removeTween() or removePin() respectively.
		 * @method ScrollMagic.Scene#remove
		 * @example
		 * // remove the scene from its controller
		 * scene.remove();
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.remove = function () {
			if (_controller) {
				_controller.info("container").removeEventListener('resize', onContainerResize);
				var tmpParent = _controller;
				_controller = undefined;
				tmpParent.removeScene(Scene);
				Scene.trigger("remove");
				log(3, "removed " + NAMESPACE + " from controller");
			}
			return Scene;
		};

		/**
		 * Destroy the scene and everything.
		 * @method ScrollMagic.Scene#destroy
		 * @example
		 * // destroy the scene without resetting the pin and tween to their initial positions
		 * scene = scene.destroy();
		 *
		 * // destroy the scene and reset the pin and tween
		 * scene = scene.destroy(true);
		 *
		 * @param {boolean} [reset=false] - If `true` the pin and tween (if existent) will be reset.
		 * @returns {null} Null to unset handler variables.
		 */
		this.destroy = function (reset) {
			Scene.trigger("destroy", {
				reset: reset
			});
			Scene.remove();
			Scene.off("*.*");
			log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
			return null;
		};


		/**
		 * Updates the Scene to reflect the current state.  
		 * This is the equivalent to `Controller.updateScene(scene, immediately)`.  
		 * The update method calculates the scene's start and end position (based on the trigger element, trigger hook, duration and offset) and checks it against the current scroll position of the container.  
		 * It then updates the current scene state accordingly (or does nothing, if the state is already correct) – Pins will be set to their correct position and tweens will be updated to their correct progress.
		 * This means an update doesn't necessarily result in a progress change. The `progress` event will be fired if the progress has indeed changed between this update and the last.  
		 * _**NOTE:** This method gets called constantly whenever ScrollMagic detects a change. The only application for you is if you change something outside of the realm of ScrollMagic, like moving the trigger or changing tween parameters._
		 * @method ScrollMagic.Scene#update
		 * @example
		 * // update the scene on next tick
		 * scene.update();
		 *
		 * // update the scene immediately
		 * scene.update(true);
		 *
		 * @fires Scene.update
		 *
		 * @param {boolean} [immediately=false] - If `true` the update will be instant, if `false` it will wait until next update cycle (better performance).
		 * @returns {Scene} Parent object for chaining.
		 */
		this.update = function (immediately) {
			if (_controller) {
				if (immediately) {
					if (_controller.enabled() && _enabled) {
						var
						scrollPos = _controller.info("scrollPos"),
							newProgress;

						if (_options.duration > 0) {
							newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
						} else {
							newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
						}

						Scene.trigger("update", {
							startPos: _scrollOffset.start,
							endPos: _scrollOffset.end,
							scrollPos: scrollPos
						});

						Scene.progress(newProgress);
					} else if (_pin && _state === SCENE_STATE_DURING) {
						updatePinState(true); // unpin in position
					}
				} else {
					_controller.updateScene(Scene, false);
				}
			}
			return Scene;
		};

		/**
		 * Updates dynamic scene variables like the trigger element position or the duration.
		 * This method is automatically called in regular intervals from the controller. See {@link ScrollMagic.Controller} option `refreshInterval`.
		 * 
		 * You can call it to minimize lag, for example when you intentionally change the position of the triggerElement.
		 * If you don't it will simply be updated in the next refresh interval of the container, which is usually sufficient.
		 *
		 * @method ScrollMagic.Scene#refresh
		 * @since 1.1.0
		 * @example
		 * scene = new ScrollMagic.Scene({triggerElement: "#trigger"});
		 * 
		 * // change the position of the trigger
		 * $("#trigger").css("top", 500);
		 * // immediately let the scene know of this change
		 * scene.refresh();
		 *
		 * @fires {@link Scene.shift}, if the trigger element position or the duration changed
		 * @fires {@link Scene.change}, if the duration changed
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.refresh = function () {
			updateDuration();
			updateTriggerElementPosition();
			// update trigger element position
			return Scene;
		};

		/**
		 * **Get** or **Set** the scene's progress.  
		 * Usually it shouldn't be necessary to use this as a setter, as it is set automatically by scene.update().  
		 * The order in which the events are fired depends on the duration of the scene:
		 *  1. Scenes with `duration == 0`:  
		 *  Scenes that have no duration by definition have no ending. Thus the `end` event will never be fired.  
		 *  When the trigger position of the scene is passed the events are always fired in this order:  
		 *  `enter`, `start`, `progress` when scrolling forward  
		 *  and  
		 *  `progress`, `start`, `leave` when scrolling in reverse
		 *  2. Scenes with `duration > 0`:  
		 *  Scenes with a set duration have a defined start and end point.  
		 *  When scrolling past the start position of the scene it will fire these events in this order:  
		 *  `enter`, `start`, `progress`  
		 *  When continuing to scroll and passing the end point it will fire these events:  
		 *  `progress`, `end`, `leave`  
		 *  When reversing through the end point these events are fired:  
		 *  `enter`, `end`, `progress`  
		 *  And when continuing to scroll past the start position in reverse it will fire:  
		 *  `progress`, `start`, `leave`  
		 *  In between start and end the `progress` event will be called constantly, whenever the progress changes.
		 * 
		 * In short:  
		 * `enter` events will always trigger **before** the progress update and `leave` envents will trigger **after** the progress update.  
		 * `start` and `end` will always trigger at their respective position.
		 * 
		 * Please review the event descriptions for details on the events and the event object that is passed to the callback.
		 * 
		 * @method ScrollMagic.Scene#progress
		 * @example
		 * // get the current scene progress
		 * var progress = scene.progress();
		 *
		 * // set new scene progress
		 * scene.progress(0.3);
		 *
		 * @fires {@link Scene.enter}, when used as setter
		 * @fires {@link Scene.start}, when used as setter
		 * @fires {@link Scene.progress}, when used as setter
		 * @fires {@link Scene.end}, when used as setter
		 * @fires {@link Scene.leave}, when used as setter
		 *
		 * @param {number} [progress] - The new progress value of the scene `[0-1]`.
		 * @returns {number} `get` -  Current scene progress.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */
		this.progress = function (progress) {
			if (!arguments.length) { // get
				return _progress;
			} else { // set
				var
				doUpdate = false,
					oldState = _state,
					scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
					reverseOrForward = _options.reverse || progress >= _progress;
				if (_options.duration === 0) {
					// zero duration scenes
					doUpdate = _progress != progress;
					_progress = progress < 1 && reverseOrForward ? 0 : 1;
					_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
				} else {
					// scenes with start and end
					if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
						// go back to initial state
						_progress = 0;
						_state = SCENE_STATE_BEFORE;
						doUpdate = true;
					} else if (progress >= 0 && progress < 1 && reverseOrForward) {
						_progress = progress;
						_state = SCENE_STATE_DURING;
						doUpdate = true;
					} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
						_progress = 1;
						_state = SCENE_STATE_AFTER;
						doUpdate = true;
					} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
						updatePinState(); // in case we scrolled backwards mid-scene and reverse is disabled => update the pin position, so it doesn't move back as well.
					}
				}
				if (doUpdate) {
					// fire events
					var
					eventVars = {
						progress: _progress,
						state: _state,
						scrollDirection: scrollDirection
					},
						stateChanged = _state != oldState;

					var trigger = function (eventName) { // tmp helper to simplify code
						Scene.trigger(eventName, eventVars);
					};

					if (stateChanged) { // enter events
						if (oldState !== SCENE_STATE_DURING) {
							trigger("enter");
							trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
						}
					}
					trigger("progress");
					if (stateChanged) { // leave events
						if (_state !== SCENE_STATE_DURING) {
							trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
							trigger("leave");
						}
					}
				}

				return Scene;
			}
		};


		/**
		 * Update the start and end scrollOffset of the container.
		 * The positions reflect what the controller's scroll position will be at the start and end respectively.
		 * Is called, when:
		 *   - Scene event "change" is called with: offset, triggerHook, duration 
		 *   - scroll container event "resize" is called
		 *   - the position of the triggerElement changes
		 *   - the controller changes -> addTo()
		 * @private
		 */
		var updateScrollOffset = function () {
			_scrollOffset = {
				start: _triggerPos + _options.offset
			};
			if (_controller && _options.triggerElement) {
				// take away triggerHook portion to get relative to top
				_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
			}
			_scrollOffset.end = _scrollOffset.start + _options.duration;
		};

		/**
		 * Updates the duration if set to a dynamic function.
		 * This method is called when the scene is added to a controller and in regular intervals from the controller through scene.refresh().
		 * 
		 * @fires {@link Scene.change}, if the duration changed
		 * @fires {@link Scene.shift}, if the duration changed
		 *
		 * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
		 * @private
		 */
		var updateDuration = function (suppressEvents) {
			// update duration
			if (_durationUpdateMethod) {
				var varname = "duration";
				if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) { // set
					Scene.trigger("change", {
						what: varname,
						newval: _options[varname]
					});
					Scene.trigger("shift", {
						reason: varname
					});
				}
			}
		};

		/**
		 * Updates the position of the triggerElement, if present.
		 * This method is called ...
		 *  - ... when the triggerElement is changed
		 *  - ... when the scene is added to a (new) controller
		 *  - ... in regular intervals from the controller through scene.refresh().
		 * 
		 * @fires {@link Scene.shift}, if the position changed
		 *
		 * @param {boolean} [suppressEvents=false] - If true the shift event will be suppressed.
		 * @private
		 */
		var updateTriggerElementPosition = function (suppressEvents) {
			var
			elementPos = 0,
				telem = _options.triggerElement;
			if (_controller && telem) {
				var
				controllerInfo = _controller.info(),
					containerOffset = _util.get.offset(controllerInfo.container),
					// container position is needed because element offset is returned in relation to document, not in relation to container.
					param = controllerInfo.vertical ? "top" : "left"; // which param is of interest ?
				// if parent is spacer, use spacer position instead so correct start position is returned for pinned elements.
				while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
					telem = telem.parentNode;
				}

				var elementOffset = _util.get.offset(telem);

				if (!controllerInfo.isDocument) { // container is not the document root, so substract scroll Position to get correct trigger element position relative to scrollcontent
					containerOffset[param] -= _controller.scrollPos();
				}

				elementPos = elementOffset[param] - containerOffset[param];
			}
			var changed = elementPos != _triggerPos;
			_triggerPos = elementPos;
			if (changed && !suppressEvents) {
				Scene.trigger("shift", {
					reason: "triggerElementPosition"
				});
			}
		};

		/**
		 * Trigger a shift event, when the container is resized and the triggerHook is > 1.
		 * @private
		 */
		var onContainerResize = function (e) {
			if (_options.triggerHook > 0) {
				Scene.trigger("shift", {
					reason: "containerResize"
				});
			}
		};

		var _validate = _util.extend(SCENE_OPTIONS.validate, {
			// validation for duration handled internally for reference to private var _durationMethod
			duration: function (val) {
				if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
					// percentage value
					var perc = parseFloat(val) / 100;
					val = function () {
						return _controller ? _controller.info("size") * perc : 0;
					};
				}
				if (_util.type.Function(val)) {
					// function
					_durationUpdateMethod = val;
					try {
						val = parseFloat(_durationUpdateMethod());
					} catch (e) {
						val = -1; // will cause error below
					}
				}
				// val has to be float
				val = parseFloat(val);
				if (!_util.type.Number(val) || val < 0) {
					if (_durationUpdateMethod) {
						_durationUpdateMethod = undefined;
						throw ["Invalid return value of supplied function for option \"duration\":", val];
					} else {
						throw ["Invalid value for option \"duration\":", val];
					}
				}
				return val;
			}
		});

		/**
		 * Checks the validity of a specific or all options and reset to default if neccessary.
		 * @private
		 */
		var validateOption = function (check) {
			check = arguments.length ? [check] : Object.keys(_validate);
			check.forEach(function (optionName, key) {
				var value;
				if (_validate[optionName]) { // there is a validation method for this option
					try { // validate value
						value = _validate[optionName](_options[optionName]);
					} catch (e) { // validation failed -> reset to default
						value = DEFAULT_OPTIONS[optionName];
						var logMSG = _util.type.String(e) ? [e] : e;
						if (_util.type.Array(logMSG)) {
							logMSG[0] = "ERROR: " + logMSG[0];
							logMSG.unshift(1); // loglevel 1 for error msg
							log.apply(this, logMSG);
						} else {
							log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
						}
					} finally {
						_options[optionName] = value;
					}
				}
			});
		};

		/**
		 * Helper used by the setter/getters for scene options
		 * @private
		 */
		var changeOption = function (varname, newval) {
			var
			changed = false,
				oldval = _options[varname];
			if (_options[varname] != newval) {
				_options[varname] = newval;
				validateOption(varname); // resets to default if necessary
				changed = oldval != _options[varname];
			}
			return changed;
		};

		// generate getters/setters for all options
		var addSceneOption = function (optionName) {
			if (!Scene[optionName]) {
				Scene[optionName] = function (newVal) {
					if (!arguments.length) { // get
						return _options[optionName];
					} else {
						if (optionName === "duration") { // new duration is set, so any previously set function must be unset
							_durationUpdateMethod = undefined;
						}
						if (changeOption(optionName, newVal)) { // set
							Scene.trigger("change", {
								what: optionName,
								newval: _options[optionName]
							});
							if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
								Scene.trigger("shift", {
									reason: optionName
								});
							}
						}
					}
					return Scene;
				};
			}
		};

		/**
		 * **Get** or **Set** the duration option value.
		 * As a setter it also accepts a function returning a numeric value.  
		 * This is particularly useful for responsive setups.
		 *
		 * The duration is updated using the supplied function every time `Scene.refresh()` is called, which happens periodically from the controller (see ScrollMagic.Controller option `refreshInterval`).  
		 * _**NOTE:** Be aware that it's an easy way to kill performance, if you supply a function that has high CPU demand.  
		 * Even for size and position calculations it is recommended to use a variable to cache the value. (see example)  
		 * This counts double if you use the same function for multiple scenes._
		 *
		 * @method ScrollMagic.Scene#duration
		 * @example
		 * // get the current duration value
		 * var duration = scene.duration();
		 *
		 * // set a new duration
		 * scene.duration(300);
		 *
		 * // use a function to automatically adjust the duration to the window height.
		 * var durationValueCache;
		 * function getDuration () {
		 *   return durationValueCache;
		 * }
		 * function updateDuration (e) {
		 *   durationValueCache = window.innerHeight;
		 * }
		 * $(window).on("resize", updateDuration); // update the duration when the window size changes
		 * $(window).triggerHandler("resize"); // set to initial value
		 * scene.duration(getDuration); // supply duration method
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @fires {@link Scene.shift}, when used as setter
		 * @param {(number|function)} [newDuration] - The new duration of the scene.
		 * @returns {number} `get` -  Current scene duration.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the offset option value.
		 * @method ScrollMagic.Scene#offset
		 * @example
		 * // get the current offset
		 * var offset = scene.offset();
		 *
		 * // set a new offset
		 * scene.offset(100);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @fires {@link Scene.shift}, when used as setter
		 * @param {number} [newOffset] - The new offset of the scene.
		 * @returns {number} `get` -  Current scene offset.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the triggerElement option value.
		 * Does **not** fire `Scene.shift`, because changing the trigger Element doesn't necessarily mean the start position changes. This will be determined in `Scene.refresh()`, which is automatically triggered.
		 * @method ScrollMagic.Scene#triggerElement
		 * @example
		 * // get the current triggerElement
		 * var triggerElement = scene.triggerElement();
		 *
		 * // set a new triggerElement using a selector
		 * scene.triggerElement("#trigger");
		 * // set a new triggerElement using a DOM object
		 * scene.triggerElement(document.getElementById("trigger"));
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @param {(string|object)} [newTriggerElement] - The new trigger element for the scene.
		 * @returns {(string|object)} `get` -  Current triggerElement.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the triggerHook option value.
		 * @method ScrollMagic.Scene#triggerHook
		 * @example
		 * // get the current triggerHook value
		 * var triggerHook = scene.triggerHook();
		 *
		 * // set a new triggerHook using a string
		 * scene.triggerHook("onLeave");
		 * // set a new triggerHook using a number
		 * scene.triggerHook(0.7);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @fires {@link Scene.shift}, when used as setter
		 * @param {(number|string)} [newTriggerHook] - The new triggerHook of the scene. See {@link Scene} parameter description for value options.
		 * @returns {number} `get` -  Current triggerHook (ALWAYS numerical).
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the reverse option value.
		 * @method ScrollMagic.Scene#reverse
		 * @example
		 * // get the current reverse option
		 * var reverse = scene.reverse();
		 *
		 * // set new reverse option
		 * scene.reverse(false);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @param {boolean} [newReverse] - The new reverse setting of the scene.
		 * @returns {boolean} `get` -  Current reverse option value.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** or **Set** the loglevel option value.
		 * @method ScrollMagic.Scene#loglevel
		 * @example
		 * // get the current loglevel
		 * var loglevel = scene.loglevel();
		 *
		 * // set new loglevel
		 * scene.loglevel(3);
		 *
		 * @fires {@link Scene.change}, when used as setter
		 * @param {number} [newLoglevel] - The new loglevel setting of the scene. `[0-3]`
		 * @returns {number} `get` -  Current loglevel.
		 * @returns {Scene} `set` -  Parent object for chaining.
		 */

		/**
		 * **Get** the associated controller.
		 * @method ScrollMagic.Scene#controller
		 * @example
		 * // get the controller of a scene
		 * var controller = scene.controller();
		 *
		 * @returns {ScrollMagic.Controller} Parent controller or `undefined`
		 */
		this.controller = function () {
			return _controller;
		};

		/**
		 * **Get** the current state.
		 * @method ScrollMagic.Scene#state
		 * @example
		 * // get the current state
		 * var state = scene.state();
		 *
		 * @returns {string} `"BEFORE"`, `"DURING"` or `"AFTER"`
		 */
		this.state = function () {
			return _state;
		};

		/**
		 * **Get** the current scroll offset for the start of the scene.  
		 * Mind, that the scrollOffset is related to the size of the container, if `triggerHook` is bigger than `0` (or `"onLeave"`).  
		 * This means, that resizing the container or changing the `triggerHook` will influence the scene's start offset.
		 * @method ScrollMagic.Scene#scrollOffset
		 * @example
		 * // get the current scroll offset for the start and end of the scene.
		 * var start = scene.scrollOffset();
		 * var end = scene.scrollOffset() + scene.duration();
		 * console.log("the scene starts at", start, "and ends at", end);
		 *
		 * @returns {number} The scroll offset (of the container) at which the scene will trigger. Y value for vertical and X value for horizontal scrolls.
		 */
		this.scrollOffset = function () {
			return _scrollOffset.start;
		};

		/**
		 * **Get** the trigger position of the scene (including the value of the `offset` option).  
		 * @method ScrollMagic.Scene#triggerPosition
		 * @example
		 * // get the scene's trigger position
		 * var triggerPosition = scene.triggerPosition();
		 *
		 * @returns {number} Start position of the scene. Top position value for vertical and left position value for horizontal scrolls.
		 */
		this.triggerPosition = function () {
			var pos = _options.offset; // the offset is the basis
			if (_controller) {
				// get the trigger position
				if (_options.triggerElement) {
					// Element as trigger
					pos += _triggerPos;
				} else {
					// return the height of the triggerHook to start at the beginning
					pos += _controller.info("size") * Scene.triggerHook();
				}
			}
			return pos;
		};

		var
		_pin, _pinOptions;

		Scene.on("shift.internal", function (e) {
			var durationChanged = e.reason === "duration";
			if ((_state === SCENE_STATE_AFTER && durationChanged) || (_state === SCENE_STATE_DURING && _options.duration === 0)) {
				// if [duration changed after a scene (inside scene progress updates pin position)] or [duration is 0, we are in pin phase and some other value changed].
				updatePinState();
			}
			if (durationChanged) {
				updatePinDimensions();
			}
		}).on("progress.internal", function (e) {
			updatePinState();
		}).on("add.internal", function (e) {
			updatePinDimensions();
		}).on("destroy.internal", function (e) {
			Scene.removePin(e.reset);
		});
		/**
		 * Update the pin state.
		 * @private
		 */
		var updatePinState = function (forceUnpin) {
			if (_pin && _controller) {
				var
				containerInfo = _controller.info(),
					pinTarget = _pinOptions.spacer.firstChild; // may be pin element or another spacer, if cascading pins
				if (!forceUnpin && _state === SCENE_STATE_DURING) { // during scene or if duration is 0 and we are past the trigger
					// pinned state
					if (_util.css(pinTarget, "position") != "fixed") {
						// change state before updating pin spacer (position changes due to fixed collapsing might occur.)
						_util.css(pinTarget, {
							"position": "fixed"
						});
						// update pin spacer
						updatePinDimensions();
					}

					var
					fixedPos = _util.get.offset(_pinOptions.spacer, true),
						// get viewport position of spacer
						scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start // quicker
						: Math.round(_progress * _options.duration * 10) / 10; // if no reverse and during pin the position needs to be recalculated using the progress
					// add scrollDistance
					fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;

					// set new values
					_util.css(_pinOptions.spacer.firstChild, {
						top: fixedPos.top,
						left: fixedPos.left
					});
				} else {
					// unpinned state
					var
					newCSS = {
						position: _pinOptions.inFlow ? "relative" : "absolute",
						top: 0,
						left: 0
					},
						change = _util.css(pinTarget, "position") != newCSS.position;

					if (!_pinOptions.pushFollowers) {
						newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
					} else if (_options.duration > 0) { // only concerns scenes with duration
						if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
							change = true; // if in after state but havent updated spacer yet (jumped past pin)
						} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) { // before
							change = true; // jumped past fixed state upward direction
						}
					}
					// set new values
					_util.css(pinTarget, newCSS);
					if (change) {
						// update pin spacer if state changed
						updatePinDimensions();
					}
				}
			}
		};

		/**
		 * Update the pin spacer and/or element size.
		 * The size of the spacer needs to be updated whenever the duration of the scene changes, if it is to push down following elements.
		 * @private
		 */
		var updatePinDimensions = function () {
			if (_pin && _controller && _pinOptions.inFlow) { // no spacerresize, if original position is absolute
				var
				after = (_state === SCENE_STATE_AFTER),
					before = (_state === SCENE_STATE_BEFORE),
					during = (_state === SCENE_STATE_DURING),
					vertical = _controller.info("vertical"),
					pinTarget = _pinOptions.spacer.firstChild,
					// usually the pined element but can also be another spacer (cascaded pins)
					marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
					css = {};

				// set new size
				// if relsize: spacer -> pin | else: pin -> spacer
				if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
					if (during) {
						_util.css(_pin, {
							"width": _util.get.width(_pinOptions.spacer)
						});
					} else {
						_util.css(_pin, {
							"width": "100%"
						});
					}
				} else {
					// minwidth is needed for cascaded pins.
					css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
					css.width = during ? css["min-width"] : "auto";
				}
				if (_pinOptions.relSize.height) {
					if (during) {
						// the only padding the spacer should ever include is the duration (if pushFollowers = true), so we need to substract that.
						_util.css(_pin, {
							"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
						});
					} else {
						_util.css(_pin, {
							"height": "100%"
						});
					}
				} else {
					// margin is only included if it's a cascaded pin to resolve an IE9 bug
					css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse); // needed for cascading pins
					css.height = during ? css["min-height"] : "auto";
				}

				// add space for duration if pushFollowers is true
				if (_pinOptions.pushFollowers) {
					css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
					css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
				}
				_util.css(_pinOptions.spacer, css);
			}
		};

		/**
		 * Updates the Pin state (in certain scenarios)
		 * If the controller container is not the document and we are mid-pin-phase scrolling or resizing the main document can result to wrong pin positions.
		 * So this function is called on resize and scroll of the document.
		 * @private
		 */
		var updatePinInContainer = function () {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
				updatePinState();
			}
		};

		/**
		 * Updates the Pin spacer size state (in certain scenarios)
		 * If container is resized during pin and relatively sized the size of the pin might need to be updated...
		 * So this function is called on resize of the container.
		 * @private
		 */
		var updateRelativePinSpacer = function () {
			if (_controller && _pin && // well, duh
			_state === SCENE_STATE_DURING && // element in pinned state?
			( // is width or height relatively sized, but not in relation to body? then we need to recalc.
			((_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode)) || (_pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode)))) {
				updatePinDimensions();
			}
		};

		/**
		 * Is called, when the mousewhel is used while over a pinned element inside a div container.
		 * If the scene is in fixed state scroll events would be counted towards the body. This forwards the event to the scroll container.
		 * @private
		 */
		var onMousewheelOverPin = function (e) {
			if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) { // in pin state
				e.preventDefault();
				_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
			}
		};

		/**
		 * Pin an element for the duration of the tween.  
		 * If the scene duration is 0 the element will only be unpinned, if the user scrolls back past the start position.  
		 * Make sure only one pin is applied to an element at the same time.
		 * An element can be pinned multiple times, but only successively.
		 * _**NOTE:** The option `pushFollowers` has no effect, when the scene duration is 0._
		 * @method ScrollMagic.Scene#setPin
		 * @example
		 * // pin element and push all following elements down by the amount of the pin duration.
		 * scene.setPin("#pin");
		 *
		 * // pin element and keeping all following elements in their place. The pinned element will move past them.
		 * scene.setPin("#pin", {pushFollowers: false});
		 *
		 * @param {(string|object)} element - A Selector targeting an element or a DOM object that is supposed to be pinned.
		 * @param {object} [settings] - settings for the pin
		 * @param {boolean} [settings.pushFollowers=true] - If `true` following elements will be "pushed" down for the duration of the pin, if `false` the pinned element will just scroll past them.  
		 Ignored, when duration is `0`.
		 * @param {string} [settings.spacerClass="scrollmagic-pin-spacer"] - Classname of the pin spacer element, which is used to replace the element.
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.setPin = function (element, settings) {
			var
			defaultSettings = {
				pushFollowers: true,
				spacerClass: "scrollmagic-pin-spacer"
			};
			settings = _util.extend({}, defaultSettings, settings);

			// validate Element
			element = _util.get.elements(element)[0];
			if (!element) {
				log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
				return Scene; // cancel
			} else if (_util.css(element, "position") === "fixed") {
				log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
				return Scene; // cancel
			}

			if (_pin) { // preexisting pin?
				if (_pin === element) {
					// same pin we already have -> do nothing
					return Scene; // cancel
				} else {
					// kill old pin
					Scene.removePin();
				}

			}
			_pin = element;

			var
			parentDisplay = _pin.parentNode.style.display,
				boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];

			_pin.parentNode.style.display = 'none'; // hack start to force css to return stylesheet values instead of calculated px values.
			var
			inFlow = _util.css(_pin, "position") != "absolute",
				pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
				sizeCSS = _util.css(_pin, ["width", "height"]);
			_pin.parentNode.style.display = parentDisplay; // hack end.
			if (!inFlow && settings.pushFollowers) {
				log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
				settings.pushFollowers = false;
			}
			window.setTimeout(function () { // wait until all finished, because with responsive duration it will only be set after scene is added to controller
				if (_pin && _options.duration === 0 && settings.pushFollowers) {
					log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
				}
			}, 0);

			// create spacer and insert
			var
			spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
				spacerCSS = _util.extend(pinCSS, {
					position: inFlow ? "relative" : "absolute",
					boxSizing: "content-box",
					mozBoxSizing: "content-box",
					webkitBoxSizing: "content-box"
				});

			if (!inFlow) { // copy size if positioned absolutely, to work for bottom/right positioned elements.
				_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
			}

			_util.css(spacer, spacerCSS);
			spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
			_util.addClass(spacer, settings.spacerClass);

			// set the pin Options
			_pinOptions = {
				spacer: spacer,
				relSize: { // save if size is defined using % values. if so, handle spacer resize differently...
					width: sizeCSS.width.slice(-1) === "%",
					height: sizeCSS.height.slice(-1) === "%",
					autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
				},
				pushFollowers: settings.pushFollowers,
				inFlow: inFlow,
				// stores if the element takes up space in the document flow
			};

			if (!_pin.___origStyle) {
				_pin.___origStyle = {};
				var
				pinInlineCSS = _pin.style,
					copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
				copyStyles.forEach(function (val) {
					_pin.___origStyle[val] = pinInlineCSS[val] || "";
				});
			}

			// if relative size, transfer it to spacer and make pin calculate it...
			if (_pinOptions.relSize.width) {
				_util.css(spacer, {
					width: sizeCSS.width
				});
			}
			if (_pinOptions.relSize.height) {
				_util.css(spacer, {
					height: sizeCSS.height
				});
			}

			// now place the pin element inside the spacer	
			spacer.appendChild(_pin);
			// and set new css
			_util.css(_pin, {
				position: inFlow ? "relative" : "absolute",
				margin: "auto",
				top: "auto",
				left: "auto",
				bottom: "auto",
				right: "auto"
			});

			if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
				_util.css(_pin, {
					boxSizing: "border-box",
					mozBoxSizing: "border-box",
					webkitBoxSizing: "border-box"
				});
			}

			// add listener to document to update pin position in case controller is not the document.
			window.addEventListener('scroll', updatePinInContainer);
			window.addEventListener('resize', updatePinInContainer);
			window.addEventListener('resize', updateRelativePinSpacer);
			// add mousewheel listener to catch scrolls over fixed elements
			_pin.addEventListener("mousewheel", onMousewheelOverPin);
			_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);

			log(3, "added pin");

			// finally update the pin to init
			updatePinState();

			return Scene;
		};

		/**
		 * Remove the pin from the scene.
		 * @method ScrollMagic.Scene#removePin
		 * @example
		 * // remove the pin from the scene without resetting it (the spacer is not removed)
		 * scene.removePin();
		 *
		 * // remove the pin from the scene and reset the pin element to its initial position (spacer is removed)
		 * scene.removePin(true);
		 *
		 * @param {boolean} [reset=false] - If `false` the spacer will not be removed and the element's position will not be reset.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.removePin = function (reset) {
			if (_pin) {
				if (_state === SCENE_STATE_DURING) {
					updatePinState(true); // force unpin at position
				}
				if (reset || !_controller) { // if there's no controller no progress was made anyway...
					var pinTarget = _pinOptions.spacer.firstChild; // usually the pin element, but may be another spacer (cascaded pins)...
					if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) { // copy margins to child spacer
						var
						style = _pinOptions.spacer.style,
							values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
						margins = {};
						values.forEach(function (val) {
							margins[val] = style[val] || "";
						});
						_util.css(pinTarget, margins);
					}
					_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
					_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
					if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) { // if it's the last pin for this element -> restore inline styles
						// TODO: only correctly set for first pin (when cascading) - how to fix?
						_util.css(_pin, _pin.___origStyle);
						delete _pin.___origStyle;
					}
				}
				window.removeEventListener('scroll', updatePinInContainer);
				window.removeEventListener('resize', updatePinInContainer);
				window.removeEventListener('resize', updateRelativePinSpacer);
				_pin.removeEventListener("mousewheel", onMousewheelOverPin);
				_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
				_pin = undefined;
				log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};


		var
		_cssClasses, _cssClassElems = [];

		Scene.on("destroy.internal", function (e) {
			Scene.removeClassToggle(e.reset);
		});
		/**
		 * Define a css class modification while the scene is active.  
		 * When the scene triggers the classes will be added to the supplied element and removed, when the scene is over.
		 * If the scene duration is 0 the classes will only be removed if the user scrolls back past the start position.
		 * @method ScrollMagic.Scene#setClassToggle
		 * @example
		 * // add the class 'myclass' to the element with the id 'my-elem' for the duration of the scene
		 * scene.setClassToggle("#my-elem", "myclass");
		 *
		 * // add multiple classes to multiple elements defined by the selector '.classChange'
		 * scene.setClassToggle(".classChange", "class1 class2 class3");
		 *
		 * @param {(string|object)} element - A Selector targeting one or more elements or a DOM object that is supposed to be modified.
		 * @param {string} classes - One or more Classnames (separated by space) that should be added to the element during the scene.
		 *
		 * @returns {Scene} Parent object for chaining.
		 */
		this.setClassToggle = function (element, classes) {
			var elems = _util.get.elements(element);
			if (elems.length === 0 || !_util.type.String(classes)) {
				log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
				return Scene;
			}
			if (_cssClassElems.length > 0) {
				// remove old ones
				Scene.removeClassToggle();
			}
			_cssClasses = classes;
			_cssClassElems = elems;
			Scene.on("enter.internal_class leave.internal_class", function (e) {
				var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
				_cssClassElems.forEach(function (elem, key) {
					toggle(elem, _cssClasses);
				});
			});
			return Scene;
		};

		/**
		 * Remove the class binding from the scene.
		 * @method ScrollMagic.Scene#removeClassToggle
		 * @example
		 * // remove class binding from the scene without reset
		 * scene.removeClassToggle();
		 *
		 * // remove class binding and remove the changes it caused
		 * scene.removeClassToggle(true);
		 *
		 * @param {boolean} [reset=false] - If `false` and the classes are currently active, they will remain on the element. If `true` they will be removed.
		 * @returns {Scene} Parent object for chaining.
		 */
		this.removeClassToggle = function (reset) {
			if (reset) {
				_cssClassElems.forEach(function (elem, key) {
					_util.removeClass(elem, _cssClasses);
				});
			}
			Scene.off("start.internal_class end.internal_class");
			_cssClasses = undefined;
			_cssClassElems = [];
			return Scene;
		};

		// INIT
		construct();
		return Scene;
	};

	// store pagewide scene options
	var SCENE_OPTIONS = {
		defaults: {
			duration: 0,
			offset: 0,
			triggerElement: undefined,
			triggerHook: 0.5,
			reverse: true,
			loglevel: 2
		},
		validate: {
			offset: function (val) {
				val = parseFloat(val);
				if (!_util.type.Number(val)) {
					throw ["Invalid value for option \"offset\":", val];
				}
				return val;
			},
			triggerElement: function (val) {
				val = val || undefined;
				if (val) {
					var elem = _util.get.elements(val)[0];
					if (elem) {
						val = elem;
					} else {
						throw ["Element defined in option \"triggerElement\" was not found:", val];
					}
				}
				return val;
			},
			triggerHook: function (val) {
				var translate = {
					"onCenter": 0.5,
					"onEnter": 1,
					"onLeave": 0
				};
				if (_util.type.Number(val)) {
					val = Math.max(0, Math.min(parseFloat(val), 1)); //  make sure its betweeen 0 and 1
				} else if (val in translate) {
					val = translate[val];
				} else {
					throw ["Invalid value for option \"triggerHook\": ", val];
				}
				return val;
			},
			reverse: function (val) {
				return !!val; // force boolean
			},
			loglevel: function (val) {
				val = parseInt(val);
				if (!_util.type.Number(val) || val < 0 || val > 3) {
					throw ["Invalid value for option \"loglevel\":", val];
				}
				return val;
			}
		},
		// holder for  validation methods. duration validation is handled in 'getters-setters.js'
		shifts: ["duration", "offset", "triggerHook"],
		// list of options that trigger a `shift` event
	};
/*
 * method used to add an option to ScrollMagic Scenes.
 * TODO: DOC (private for dev)
 */
	ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
		if (!(name in SCENE_OPTIONS.defaults)) {
			SCENE_OPTIONS.defaults[name] = defaultValue;
			SCENE_OPTIONS.validate[name] = validationCallback;
			if (shifts) {
				SCENE_OPTIONS.shifts.push(name);
			}
		} else {
			ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
		}
	};
	// instance extension function for plugins
	// TODO: DOC (private for dev)
	ScrollMagic.Scene.extend = function (extension) {
		var oldClass = this;
		ScrollMagic.Scene = function () {
			oldClass.apply(this, arguments);
			this.$super = _util.extend({}, this); // copy parent state
			return extension.apply(this, arguments) || this;
		};
		_util.extend(ScrollMagic.Scene, oldClass); // copy properties
		ScrollMagic.Scene.prototype = oldClass.prototype; // copy prototype
		ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene; // restore constructor
	};


	/**
	 * TODO: DOCS (private for dev)
	 * @class
	 * @private
	 */

	ScrollMagic.Event = function (type, namespace, target, vars) {
		vars = vars || {};
		for (var key in vars) {
			this[key] = vars[key];
		}
		this.type = type;
		this.target = this.currentTarget = target;
		this.namespace = namespace || '';
		this.timeStamp = this.timestamp = Date.now();
		return this;
	};

/*
 * TODO: DOCS (private for dev)
 */

	var _util = ScrollMagic._util = (function (window) {
		var U = {},
			i;

		/**
		 * ------------------------------
		 * internal helpers
		 * ------------------------------
		 */

		// parse float and fall back to 0.
		var floatval = function (number) {
			return parseFloat(number) || 0;
		};
		// get current style IE safe (otherwise IE would return calculated values for 'auto')
		var _getComputedStyle = function (elem) {
			return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
		};

		// get element dimension (width or height)
		var _dimension = function (which, elem, outer, includeMargin) {
			elem = (elem === document) ? window : elem;
			if (elem === window) {
				includeMargin = false;
			} else if (!_type.DomElement(elem)) {
				return 0;
			}
			which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
			var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
			if (outer && includeMargin) {
				var style = _getComputedStyle(elem);
				dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
			}
			return dimension;
		};
		// converts 'margin-top' into 'marginTop'
		var _camelCase = function (str) {
			return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
				return g[1].toUpperCase();
			});
		};

		/**
		 * ------------------------------
		 * external helpers
		 * ------------------------------
		 */

		// extend obj – same as jQuery.extend({}, objA, objB)
		U.extend = function (obj) {
			obj = obj || {};
			for (i = 1; i < arguments.length; i++) {
				if (!arguments[i]) {
					continue;
				}
				for (var key in arguments[i]) {
					if (arguments[i].hasOwnProperty(key)) {
						obj[key] = arguments[i][key];
					}
				}
			}
			return obj;
		};

		// check if a css display type results in margin-collapse or not
		U.isMarginCollapseType = function (str) {
			return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
		};

		// implementation of requestAnimationFrame
		// based on https://gist.github.com/paulirish/1579671
		var
		lastTime = 0,
			vendors = ['ms', 'moz', 'webkit', 'o'];
		var _requestAnimationFrame = window.requestAnimationFrame;
		var _cancelAnimationFrame = window.cancelAnimationFrame;
		// try vendor prefixes if the above doesn't work
		for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
			_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
			_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
		}

		// fallbacks
		if (!_requestAnimationFrame) {
			_requestAnimationFrame = function (callback) {
				var
				currTime = new Date().getTime(),
					timeToCall = Math.max(0, 16 - (currTime - lastTime)),
					id = window.setTimeout(function () {
						callback(currTime + timeToCall);
					}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}
		if (!_cancelAnimationFrame) {
			_cancelAnimationFrame = function (id) {
				window.clearTimeout(id);
			};
		}
		U.rAF = _requestAnimationFrame.bind(window);
		U.cAF = _cancelAnimationFrame.bind(window);

		var
		loglevels = ["error", "warn", "log"],
			console = window.console || {};

		console.log = console.log ||
		function () {}; // no console log, well - do nothing then...
		// make sure methods for all levels exist.
		for (i = 0; i < loglevels.length; i++) {
			var method = loglevels[i];
			if (!console[method]) {
				console[method] = console.log; // prefer .log over nothing
			}
		}
		U.log = function (loglevel) {
			if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
			var now = new Date(),
				time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
				method = loglevels[loglevel - 1],
				args = Array.prototype.splice.call(arguments, 1),
				func = Function.prototype.bind.call(console[method], console);
			args.unshift(time);
			func.apply(console, args);
		};

		/**
		 * ------------------------------
		 * type testing
		 * ------------------------------
		 */

		var _type = U.type = function (v) {
			return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
		};
		_type.String = function (v) {
			return _type(v) === 'string';
		};
		_type.Function = function (v) {
			return _type(v) === 'function';
		};
		_type.Array = function (v) {
			return Array.isArray(v);
		};
		_type.Number = function (v) {
			return !_type.Array(v) && (v - parseFloat(v) + 1) >= 0;
		};
		_type.DomElement = function (o) {
			return (
			typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
			o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string");
		};

		/**
		 * ------------------------------
		 * DOM Element info
		 * ------------------------------
		 */
		// always returns a list of matching DOM elements, from a selector, a DOM element or an list of elements or even an array of selectors
		var _get = U.get = {};
		_get.elements = function (selector) {
			var arr = [];
			if (_type.String(selector)) {
				try {
					selector = document.querySelectorAll(selector);
				} catch (e) { // invalid selector
					return arr;
				}
			}
			if (_type(selector) === 'nodelist' || _type.Array(selector)) {
				for (var i = 0, ref = arr.length = selector.length; i < ref; i++) { // list of elements
					var elem = selector[i];
					arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem); // if not an element, try to resolve recursively
				}
			} else if (_type.DomElement(selector) || selector === document || selector === window) {
				arr = [selector]; // only the element
			}
			return arr;
		};
		// get scroll top value
		_get.scrollTop = function (elem) {
			return (elem && typeof elem.scrollTop === 'number') ? elem.scrollTop : window.pageYOffset || 0;
		};
		// get scroll left value
		_get.scrollLeft = function (elem) {
			return (elem && typeof elem.scrollLeft === 'number') ? elem.scrollLeft : window.pageXOffset || 0;
		};
		// get element height
		_get.width = function (elem, outer, includeMargin) {
			return _dimension('width', elem, outer, includeMargin);
		};
		// get element width
		_get.height = function (elem, outer, includeMargin) {
			return _dimension('height', elem, outer, includeMargin);
		};

		// get element position (optionally relative to viewport)
		_get.offset = function (elem, relativeToViewport) {
			var offset = {
				top: 0,
				left: 0
			};
			if (elem && elem.getBoundingClientRect) { // check if available
				var rect = elem.getBoundingClientRect();
				offset.top = rect.top;
				offset.left = rect.left;
				if (!relativeToViewport) { // clientRect is by default relative to viewport...
					offset.top += _get.scrollTop();
					offset.left += _get.scrollLeft();
				}
			}
			return offset;
		};

		/**
		 * ------------------------------
		 * DOM Element manipulation
		 * ------------------------------
		 */

		U.addClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.add(classname);
				else elem.className += ' ' + classname;
			}
		};
		U.removeClass = function (elem, classname) {
			if (classname) {
				if (elem.classList) elem.classList.remove(classname);
				else elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
			}
		};
		// if options is string -> returns css value
		// if options is array -> returns object with css value pairs
		// if options is object -> set new css values
		U.css = function (elem, options) {
			if (_type.String(options)) {
				return _getComputedStyle(elem)[_camelCase(options)];
			} else if (_type.Array(options)) {
				var
				obj = {},
					style = _getComputedStyle(elem);
				options.forEach(function (option, key) {
					obj[option] = style[_camelCase(option)];
				});
				return obj;
			} else {
				for (var option in options) {
					var val = options[option];
					if (val == parseFloat(val)) { // assume pixel for seemingly numerical values
						val += 'px';
					}
					elem.style[_camelCase(option)] = val;
				}
			}
		};

		return U;
	}(window || {}));

	ScrollMagic.Scene.prototype.addIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	}
	ScrollMagic.Scene.prototype.removeIndicators = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
		return this;
	}
	ScrollMagic.Scene.prototype.setTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	}
	ScrollMagic.Scene.prototype.removeTween = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
		return this;
	}
	ScrollMagic.Scene.prototype.setVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	}
	ScrollMagic.Scene.prototype.removeVelocity = function () {
		ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
		return this;
	}

	return ScrollMagic;
}));
/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file Debug Extension for ScrollMagic.
 */
/**
 * This plugin was formerly known as the ScrollMagic debug extension.
 *
 * It enables you to add visual indicators to your page, to be able to see exactly when a scene is triggered.
 *
 * To have access to this extension, please include `plugins/debug.addIndicators.js`.
 * @mixin debug.addIndicators
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('scrollmagic'));
	} else {
		// no browser global export needed, just execute
		factory(root.ScrollMagic || (root.jQuery && root.jQuery.ScrollMagic));
	}
}(this, function (ScrollMagic) {
	"use strict";
	var NAMESPACE = "debug.addIndicators";

	var
	console = window.console || {},
		err = Function.prototype.bind.call(console.error || console.log ||
		function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}

	// plugin settings
	var
	FONT_SIZE = "0.85em",
		ZINDEX = "9999",
		EDGE_OFFSET = 15; // minimum edge distance, added to indentation

	// overall vars
	var
	_util = ScrollMagic._util,
		_autoindex = 0;



	ScrollMagic.Scene.extend(function () {
		var
		Scene = this,
			_indicator;

		var log = function () {
			if (Scene._log) { // not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		/**
		 * Add visual indicators for a ScrollMagic.Scene.  
		 * @memberof! debug.addIndicators#
		 *
		 * @example
		 * // add basic indicators
		 * scene.addIndicators()
		 *
		 * // passing options
		 * scene.addIndicators({name: "pin scene", colorEnd: "#FFFFFF"});
		 *
		 * @param {object} [options] - An object containing one or more options for the indicators.
		 * @param {(string|object)} [options.parent=undefined] - A selector, DOM Object or a jQuery object that the indicators should be added to.  
		 If undefined, the controller's container will be used.
		 * @param {number} [options.name=""] - This string will be displayed at the start and end indicators of the scene for identification purposes. If no name is supplied an automatic index will be used.
		 * @param {number} [options.indent=0] - Additional position offset for the indicators (useful, when having multiple scenes starting at the same position).
		 * @param {string} [options.colorStart=green] - CSS color definition for the start indicator.
		 * @param {string} [options.colorEnd=red] - CSS color definition for the end indicator.
		 * @param {string} [options.colorTrigger=blue] - CSS color definition for the trigger indicator.
		 */
		Scene.addIndicators = function (options) {
			if (!_indicator) {
				var
				DEFAULT_OPTIONS = {
					name: "",
					indent: 0,
					parent: undefined,
					colorStart: "green",
					colorEnd: "red",
					colorTrigger: "blue",
				};

				options = _util.extend({}, DEFAULT_OPTIONS, options);

				_autoindex++;
				_indicator = new Indicator(Scene, options);

				Scene.on("add.plugin_addIndicators", _indicator.add);
				Scene.on("remove.plugin_addIndicators", _indicator.remove);
				Scene.on("destroy.plugin_addIndicators", Scene.removeIndicators);

				// it the scene already has a controller we can start right away.
				if (Scene.controller()) {
					_indicator.add();
				}
			}
			return Scene;
		};

		/**
		 * Removes visual indicators from a ScrollMagic.Scene.
		 * @memberof! debug.addIndicators#
		 *
		 * @example
		 * // remove previously added indicators
		 * scene.removeIndicators()
		 *
		 */
		Scene.removeIndicators = function () {
			if (_indicator) {
				_indicator.remove();
				this.off("*.plugin_addIndicators");
				_indicator = undefined;
			}
			return Scene;
		};

	});


/*
	 * ----------------------------------------------------------------
	 * Extension for controller to store and update related indicators
	 * ----------------------------------------------------------------
	 */
	// add option to globally auto-add indicators to scenes
	/**
	 * Every ScrollMagic.Controller instance now accepts an additional option.  
	 * See {@link ScrollMagic.Controller} for a complete list of the standard options.
	 * @memberof! debug.addIndicators#
	 * @method new ScrollMagic.Controller(options)
	 * @example
	 * // make a controller and add indicators to all scenes attached
	 * var controller = new ScrollMagic.Controller({addIndicators: true});
	 * // this scene will automatically have indicators added to it
	 * new ScrollMagic.Scene()
	 *                .addTo(controller);
	 *
	 * @param {object} [options] - Options for the Controller.
	 * @param {boolean} [options.addIndicators=false] - If set to `true` every scene that is added to the controller will automatically get indicators added to it.
	 */
	ScrollMagic.Controller.addOption("addIndicators", false);
	// extend Controller
	ScrollMagic.Controller.extend(function () {
		var
		Controller = this,
			_info = Controller.info(),
			_container = _info.container,
			_isDocument = _info.isDocument,
			_vertical = _info.vertical,
			_indicators = { // container for all indicators and methods
				groups: []
			};

		var log = function () {
			if (Controller._log) { // not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Controller._log.apply(this, arguments);
			}
		};
		if (Controller._indicators) {
			log(2, "WARNING: Scene already has a property '_indicators', which will be overwritten by plugin.");
		}

		// add indicators container
		this._indicators = _indicators;
/*
			needed updates:
			+++++++++++++++
			start/end position on scene shift (handled in Indicator class)
			trigger parameters on triggerHook value change (handled in Indicator class)
			bounds position on container scroll or resize (to keep alignment to bottom/right)
			trigger position on container resize, window resize (if container isn't document) and window scroll (if container isn't document)
		*/

		// event handler for when associated bounds markers need to be repositioned
		var handleBoundsPositionChange = function () {
			_indicators.updateBoundsPositions();
		};

		// event handler for when associated trigger groups need to be repositioned
		var handleTriggerPositionChange = function () {
			_indicators.updateTriggerGroupPositions();
		};

		_container.addEventListener("resize", handleTriggerPositionChange);
		if (!_isDocument) {
			window.addEventListener("resize", handleTriggerPositionChange);
			window.addEventListener("scroll", handleTriggerPositionChange);
		}
		// update all related bounds containers
		_container.addEventListener("resize", handleBoundsPositionChange);
		_container.addEventListener("scroll", handleBoundsPositionChange);


		// updates the position of the bounds container to aligned to the right for vertical containers and to the bottom for horizontal
		this._indicators.updateBoundsPositions = function (specificIndicator) {
			var // constant for all bounds
			groups = specificIndicator ? [_util.extend({}, specificIndicator.triggerGroup, {
				members: [specificIndicator]
			})] : // create a group with only one element
			_indicators.groups,
				// use all
				g = groups.length,
				css = {},
				paramPos = _vertical ? "left" : "top",
				paramDimension = _vertical ? "width" : "height",
				edge = _vertical ? _util.get.scrollLeft(_container) + _util.get.width(_container) - EDGE_OFFSET : _util.get.scrollTop(_container) + _util.get.height(_container) - EDGE_OFFSET,
				b, triggerSize, group;
			while (g--) { // group loop
				group = groups[g];
				b = group.members.length;
				triggerSize = _util.get[paramDimension](group.element.firstChild);
				while (b--) { // indicators loop
					css[paramPos] = edge - triggerSize;
					_util.css(group.members[b].bounds, css);
				}
			}
		};

		// updates the positions of all trigger groups attached to a controller or a specific one, if provided
		this._indicators.updateTriggerGroupPositions = function (specificGroup) {
			var // constant vars
			groups = specificGroup ? [specificGroup] : _indicators.groups,
				i = groups.length,
				container = _isDocument ? document.body : _container,
				containerOffset = _isDocument ? {
					top: 0,
					left: 0
				} : _util.get.offset(container, true),
				edge = _vertical ? _util.get.width(_container) - EDGE_OFFSET : _util.get.height(_container) - EDGE_OFFSET,
				paramDimension = _vertical ? "width" : "height",
				paramTransform = _vertical ? "Y" : "X";
			var // changing vars
			group, elem, pos, elemSize, transform;
			while (i--) {
				group = groups[i];
				elem = group.element;
				pos = group.triggerHook * Controller.info("size");
				elemSize = _util.get[paramDimension](elem.firstChild.firstChild);
				transform = pos > elemSize ? "translate" + paramTransform + "(-100%)" : "";

				_util.css(elem, {
					top: containerOffset.top + (_vertical ? pos : edge - group.members[0].options.indent),
					left: containerOffset.left + (_vertical ? edge - group.members[0].options.indent : pos)
				});
				_util.css(elem.firstChild.firstChild, {
					"-ms-transform": transform,
					"-webkit-transform": transform,
					"transform": transform
				});
			}
		};

		// updates the label for the group to contain the name, if it only has one member
		this._indicators.updateTriggerGroupLabel = function (group) {
			var
			text = "trigger" + (group.members.length > 1 ? "" : " " + group.members[0].options.name),
				elem = group.element.firstChild.firstChild,
				doUpdate = elem.textContent !== text;
			if (doUpdate) {
				elem.textContent = text;
				if (_vertical) { // bounds position is dependent on text length, so update
					_indicators.updateBoundsPositions();
				}
			}
		};

		// add indicators if global option is set
		this.addScene = function (newScene) {

			if (this._options.addIndicators && newScene instanceof ScrollMagic.Scene && newScene.controller() === Controller) {
				newScene.addIndicators();
			}
			// call original destroy method
			this.$super.addScene.apply(this, arguments);
		};

		// remove all previously set listeners on destroy
		this.destroy = function () {
			_container.removeEventListener("resize", handleTriggerPositionChange);
			if (!_isDocument) {
				window.removeEventListener("resize", handleTriggerPositionChange);
				window.removeEventListener("scroll", handleTriggerPositionChange);
			}
			_container.removeEventListener("resize", handleBoundsPositionChange);
			_container.removeEventListener("scroll", handleBoundsPositionChange);
			// call original destroy method
			this.$super.destroy.apply(this, arguments);
		};
		return Controller;

	});

/*
	 * ----------------------------------------------------------------
	 * Internal class for the construction of Indicators
	 * ----------------------------------------------------------------
	 */
	var Indicator = function (Scene, options) {
		var
		Indicator = this,
			_elemBounds = TPL.bounds(),
			_elemStart = TPL.start(options.colorStart),
			_elemEnd = TPL.end(options.colorEnd),
			_boundsContainer = options.parent && _util.get.elements(options.parent)[0],
			_vertical, _ctrl;

		var log = function () {
			if (Scene._log) { // not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		options.name = options.name || _autoindex;

		// prepare bounds elements
		_elemStart.firstChild.textContent += " " + options.name;
		_elemEnd.textContent += " " + options.name;
		_elemBounds.appendChild(_elemStart);
		_elemBounds.appendChild(_elemEnd);

		// set public variables
		Indicator.options = options;
		Indicator.bounds = _elemBounds;
		// will be set later
		Indicator.triggerGroup = undefined;

		// add indicators to DOM
		this.add = function () {
			_ctrl = Scene.controller();
			_vertical = _ctrl.info("vertical");

			var isDocument = _ctrl.info("isDocument");

			if (!_boundsContainer) {
				// no parent supplied or doesnt exist
				_boundsContainer = isDocument ? document.body : _ctrl.info("container"); // check if window/document (then use body)
			}
			if (!isDocument && _util.css(_boundsContainer, "position") === 'static') {
				// position mode needed for correct positioning of indicators
				_util.css(_boundsContainer, {
					position: "relative"
				});
			}

			// add listeners for updates
			Scene.on("change.plugin_addIndicators", handleTriggerParamsChange);
			Scene.on("shift.plugin_addIndicators", handleBoundsParamsChange);

			// updates trigger & bounds (will add elements if needed)
			updateTriggerGroup();
			updateBounds();

			setTimeout(function () { // do after all execution is finished otherwise sometimes size calculations are off
				_ctrl._indicators.updateBoundsPositions(Indicator);
			}, 0);

			log(3, "added indicators");
		};

		// remove indicators from DOM
		this.remove = function () {
			if (Indicator.triggerGroup) { // if not set there's nothing to remove
				Scene.off("change.plugin_addIndicators", handleTriggerParamsChange);
				Scene.off("shift.plugin_addIndicators", handleBoundsParamsChange);

				if (Indicator.triggerGroup.members.length > 1) {
					// just remove from memberlist of old group
					var group = Indicator.triggerGroup;
					group.members.splice(group.members.indexOf(Indicator), 1);
					_ctrl._indicators.updateTriggerGroupLabel(group);
					_ctrl._indicators.updateTriggerGroupPositions(group);
					Indicator.triggerGroup = undefined;
				} else {
					// remove complete group
					removeTriggerGroup();
				}
				removeBounds();

				log(3, "removed indicators");
			}
		};

/*
		 * ----------------------------------------------------------------
		 * internal Event Handlers
		 * ----------------------------------------------------------------
		 */

		// event handler for when bounds params change
		var handleBoundsParamsChange = function () {
			updateBounds();
		};

		// event handler for when trigger params change
		var handleTriggerParamsChange = function (e) {
			if (e.what === "triggerHook") {
				updateTriggerGroup();
			}
		};

/*
		 * ----------------------------------------------------------------
		 * Bounds (start / stop) management
		 * ----------------------------------------------------------------
		 */

		// adds an new bounds elements to the array and to the DOM
		var addBounds = function () {
			var v = _ctrl.info("vertical");
			// apply stuff we didn't know before...
			_util.css(_elemStart.firstChild, {
				"border-bottom-width": v ? 1 : 0,
				"border-right-width": v ? 0 : 1,
				"bottom": v ? -1 : options.indent,
				"right": v ? options.indent : -1,
				"padding": v ? "0 8px" : "2px 4px",
			});
			_util.css(_elemEnd, {
				"border-top-width": v ? 1 : 0,
				"border-left-width": v ? 0 : 1,
				"top": v ? "100%" : "",
				"right": v ? options.indent : "",
				"bottom": v ? "" : options.indent,
				"left": v ? "" : "100%",
				"padding": v ? "0 8px" : "2px 4px"
			});
			// append
			_boundsContainer.appendChild(_elemBounds);
		};

		// remove bounds from list and DOM
		var removeBounds = function () {
			_elemBounds.parentNode.removeChild(_elemBounds);
		};

		// update the start and end positions of the scene
		var updateBounds = function () {
			if (_elemBounds.parentNode !== _boundsContainer) {
				addBounds(); // Add Bounds elements (start/end)
			}
			var css = {};
			css[_vertical ? "top" : "left"] = Scene.triggerPosition();
			css[_vertical ? "height" : "width"] = Scene.duration();
			_util.css(_elemBounds, css);
			_util.css(_elemEnd, {
				display: Scene.duration() > 0 ? "" : "none"
			});
		};

/*
		 * ----------------------------------------------------------------
		 * trigger and trigger group management
		 * ----------------------------------------------------------------
		 */

		// adds an new trigger group to the array and to the DOM
		var addTriggerGroup = function () {
			var triggerElem = TPL.trigger(options.colorTrigger); // new trigger element
			var css = {};
			css[_vertical ? "right" : "bottom"] = 0;
			css[_vertical ? "border-top-width" : "border-left-width"] = 1;
			_util.css(triggerElem.firstChild, css);
			_util.css(triggerElem.firstChild.firstChild, {
				padding: _vertical ? "0 8px 3px 8px" : "3px 4px"
			});
			document.body.appendChild(triggerElem); // directly add to body
			var newGroup = {
				triggerHook: Scene.triggerHook(),
				element: triggerElem,
				members: [Indicator]
			};
			_ctrl._indicators.groups.push(newGroup);
			Indicator.triggerGroup = newGroup;
			// update right away
			_ctrl._indicators.updateTriggerGroupLabel(newGroup);
			_ctrl._indicators.updateTriggerGroupPositions(newGroup);
		};

		var removeTriggerGroup = function () {
			_ctrl._indicators.groups.splice(_ctrl._indicators.groups.indexOf(Indicator.triggerGroup), 1);
			Indicator.triggerGroup.element.parentNode.removeChild(Indicator.triggerGroup.element);
			Indicator.triggerGroup = undefined;
		};

		// updates the trigger group -> either join existing or add new one
/*	
		 * Logic:
		 * 1 if a trigger group exist, check if it's in sync with Scene settings – if so, nothing else needs to happen
		 * 2 try to find an existing one that matches Scene parameters
		 * 	 2.1 If a match is found check if already assigned to an existing group
		 *			 If so:
		 *       A: it was the last member of existing group -> kill whole group
		 *       B: the existing group has other members -> just remove from member list
		 *	 2.2 Assign to matching group
		 * 3 if no new match could be found, check if assigned to existing group
		 *   A: yes, and it's the only member -> just update parameters and positions and keep using this group
		 *   B: yes but there are other members -> remove from member list and create a new one
		 *   C: no, so create a new one
		 */
		var updateTriggerGroup = function () {
			var
			triggerHook = Scene.triggerHook(),
				closeEnough = 0.0001;

			// Have a group, check if it still matches
			if (Indicator.triggerGroup) {
				if (Math.abs(Indicator.triggerGroup.triggerHook - triggerHook) < closeEnough) {
					// _util.log(0, "trigger", options.name, "->", "no need to change, still in sync");
					return; // all good
				}
			}
			// Don't have a group, check if a matching one exists
			// _util.log(0, "trigger", options.name, "->", "out of sync!");
			var
			groups = _ctrl._indicators.groups,
				group, i = groups.length;
			while (i--) {
				group = groups[i];
				if (Math.abs(group.triggerHook - triggerHook) < closeEnough) {
					// found a match!
					// _util.log(0, "trigger", options.name, "->", "found match");
					if (Indicator.triggerGroup) { // do I have an old group that is out of sync?
						if (Indicator.triggerGroup.members.length === 1) { // is it the only remaining group?
							// _util.log(0, "trigger", options.name, "->", "kill");
							// was the last member, remove the whole group
							removeTriggerGroup();
						} else {
							Indicator.triggerGroup.members.splice(Indicator.triggerGroup.members.indexOf(Indicator), 1); // just remove from memberlist of old group
							_ctrl._indicators.updateTriggerGroupLabel(Indicator.triggerGroup);
							_ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);
							// _util.log(0, "trigger", options.name, "->", "removing from previous member list");
						}
					}
					// join new group
					group.members.push(Indicator);
					Indicator.triggerGroup = group;
					_ctrl._indicators.updateTriggerGroupLabel(group);
					return;
				}
			}

			// at this point I am obviously out of sync and don't match any other group
			if (Indicator.triggerGroup) {
				if (Indicator.triggerGroup.members.length === 1) {
					// _util.log(0, "trigger", options.name, "->", "updating existing");
					// out of sync but i'm the only member => just change and update
					Indicator.triggerGroup.triggerHook = triggerHook;
					_ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);
					return;
				} else {
					// _util.log(0, "trigger", options.name, "->", "removing from previous member list");
					Indicator.triggerGroup.members.splice(Indicator.triggerGroup.members.indexOf(Indicator), 1); // just remove from memberlist of old group
					_ctrl._indicators.updateTriggerGroupLabel(Indicator.triggerGroup);
					_ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);
					Indicator.triggerGroup = undefined; // need a brand new group...
				}
			}
			// _util.log(0, "trigger", options.name, "->", "add a new one");
			// did not find any match, make new trigger group
			addTriggerGroup();
		};
	};

/*
	 * ----------------------------------------------------------------
	 * Templates for the indicators
	 * ----------------------------------------------------------------
	 */
	var TPL = {
		start: function (color) {
			// inner element (for bottom offset -1, while keeping top position 0)
			var inner = document.createElement("div");
			inner.textContent = "start";
			_util.css(inner, {
				position: "absolute",
				overflow: "visible",
				"border-width": 0,
				"border-style": "solid",
				color: color,
				"border-color": color
			});
			var e = document.createElement('div');
			// wrapper
			_util.css(e, {
				position: "absolute",
				overflow: "visible",
				width: 0,
				height: 0
			});
			e.appendChild(inner);
			return e;
		},
		end: function (color) {
			var e = document.createElement('div');
			e.textContent = "end";
			_util.css(e, {
				position: "absolute",
				overflow: "visible",
				"border-width": 0,
				"border-style": "solid",
				color: color,
				"border-color": color
			});
			return e;
		},
		bounds: function () {
			var e = document.createElement('div');
			_util.css(e, {
				position: "absolute",
				overflow: "visible",
				"white-space": "nowrap",
				"pointer-events": "none",
				"font-size": FONT_SIZE
			});
			e.style.zIndex = ZINDEX;
			return e;
		},
		trigger: function (color) {
			// inner to be above or below line but keep position
			var inner = document.createElement('div');
			inner.textContent = "trigger";
			_util.css(inner, {
				position: "relative",
			});
			// inner wrapper for right: 0 and main element has no size
			var w = document.createElement('div');
			_util.css(w, {
				position: "absolute",
				overflow: "visible",
				"border-width": 0,
				"border-style": "solid",
				color: color,
				"border-color": color
			});
			w.appendChild(inner);
			// wrapper
			var e = document.createElement('div');
			_util.css(e, {
				position: "fixed",
				overflow: "visible",
				"white-space": "nowrap",
				"pointer-events": "none",
				"font-size": FONT_SIZE
			});
			e.style.zIndex = ZINDEX;
			e.appendChild(w);
			return e;
		},
	};

}));
/*!
 * ScrollMagic v2.0.5 (2015-04-29)
 * The javascript library for magical scroll interactions.
 * (c) 2015 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.5
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic GSAP Animation Plugin.
 *
 * requires: GSAP ~1.14
 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
 * Greensock License info at http://www.greensock.com/licensing/
 */
/**
 * This plugin is meant to be used in conjunction with the Greensock Animation Plattform.  
 * It offers an easy API to trigger Tweens or synchronize them to the scrollbar movement.
 *
 * Both the `lite` and the `max` versions of the GSAP library are supported.  
 * The most basic requirement is `TweenLite`.
 * 
 * To have access to this extension, please include `plugins/animation.gsap.js`.
 * @requires {@link http://greensock.com/gsap|GSAP ~1.14.x}
 * @mixin animation.GSAP
 */
(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['ScrollMagic', 'TweenMax', 'TimelineMax'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		// Loads whole gsap package onto global scope.
		require('gsap');
		factory(require('scrollmagic'), TweenMax, TimelineMax);
	} else {
		// Browser globals
		factory(root.ScrollMagic || (root.jQuery && root.jQuery.ScrollMagic), root.TweenMax || root.TweenLite, root.TimelineMax || root.TimelineLite);
	}
}(this, function (ScrollMagic, Tween, Timeline) {
	"use strict";
	var NAMESPACE = "animation.gsap";

	var
	console = window.console || {},
		err = Function.prototype.bind.call(console.error || console.log ||
		function () {}, console);
	if (!ScrollMagic) {
		err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
	}
	if (!Tween) {
		err("(" + NAMESPACE + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs.");
	}

/*
	 * ----------------------------------------------------------------
	 * Extensions for Scene
	 * ----------------------------------------------------------------
	 */
	/**
	 * Every instance of ScrollMagic.Scene now accepts an additional option.  
	 * See {@link ScrollMagic.Scene} for a complete list of the standard options.
	 * @memberof! animation.GSAP#
	 * @method new ScrollMagic.Scene(options)
	 * @example
	 * var scene = new ScrollMagic.Scene({tweenChanges: true});
	 *
	 * @param {object} [options] - Options for the Scene. The options can be updated at any time.
	 * @param {boolean} [options.tweenChanges=false] - Tweens Animation to the progress target instead of setting it.  
	 Does not affect animations where duration is `0`.
	 */
	/**
	 * **Get** or **Set** the tweenChanges option value.  
	 * This only affects scenes with a duration. If `tweenChanges` is `true`, the progress update when scrolling will not be immediate, but instead the animation will smoothly animate to the target state.  
	 * For a better understanding, try enabling and disabling this option in the [Scene Manipulation Example](../examples/basic/scene_manipulation.html).
	 * @memberof! animation.GSAP#
	 * @method Scene.tweenChanges
	 * 
	 * @example
	 * // get the current tweenChanges option
	 * var tweenChanges = scene.tweenChanges();
	 *
	 * // set new tweenChanges option
	 * scene.tweenChanges(true);
	 *
	 * @fires {@link Scene.change}, when used as setter
	 * @param {boolean} [newTweenChanges] - The new tweenChanges setting of the scene.
	 * @returns {boolean} `get` -  Current tweenChanges option value.
	 * @returns {Scene} `set` -  Parent object for chaining.
	 */
	// add option (TODO: DOC (private for dev))
	ScrollMagic.Scene.addOption("tweenChanges", // name
	false, // default


	function (val) { // validation callback
		return !!val;
	});
	// extend scene
	ScrollMagic.Scene.extend(function () {
		var Scene = this,
			_tween;

		var log = function () {
			if (Scene._log) { // not available, when main source minified
				Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
				Scene._log.apply(this, arguments);
			}
		};

		// set listeners
		Scene.on("progress.plugin_gsap", function () {
			updateTweenProgress();
		});
		Scene.on("destroy.plugin_gsap", function (e) {
			Scene.removeTween(e.reset);
		});

		/**
		 * Update the tween progress to current position.
		 * @private
		 */
		var updateTweenProgress = function () {
			if (_tween) {
				var
				progress = Scene.progress(),
					state = Scene.state();
				if (_tween.repeat && _tween.repeat() === -1) {
					// infinite loop, so not in relation to progress
					if (state === 'DURING' && _tween.paused()) {
						_tween.play();
					} else if (state !== 'DURING' && !_tween.paused()) {
						_tween.pause();
					}
				} else if (progress != _tween.progress()) { // do we even need to update the progress?
					// no infinite loop - so should we just play or go to a specific point in time?
					if (Scene.duration() === 0) {
						// play the animation
						if (progress > 0) { // play from 0 to 1
							_tween.play();
						} else { // play from 1 to 0
							_tween.reverse();
						}
					} else {
						// go to a specific point in time
						if (Scene.tweenChanges() && _tween.tweenTo) {
							// go smooth
							_tween.tweenTo(progress * _tween.duration());
						} else {
							// just hard set it
							_tween.progress(progress).pause();
						}
					}
				}
			}
		};

		/**
		 * Add a tween to the scene.  
		 * If you want to add multiple tweens, add them into a GSAP Timeline object and supply it instead (see example below).  
		 * 
		 * If the scene has a duration, the tween's duration will be projected to the scroll distance of the scene, meaning its progress will be synced to scrollbar movement.  
		 * For a scene with a duration of `0`, the tween will be triggered when scrolling forward past the scene's trigger position and reversed, when scrolling back.  
		 * To gain better understanding, check out the [Simple Tweening example](../examples/basic/simple_tweening.html).
		 *
		 * Instead of supplying a tween this method can also be used as a shorthand for `TweenMax.to()` (see example below).
		 * @memberof! animation.GSAP#
		 *
		 * @example
		 * // add a single tween directly
		 * scene.setTween(TweenMax.to("obj"), 1, {x: 100});
		 *
		 * // add a single tween via variable
		 * var tween = TweenMax.to("obj"), 1, {x: 100};
		 * scene.setTween(tween);
		 *
		 * // add multiple tweens, wrapped in a timeline.
		 * var timeline = new TimelineMax();
		 * var tween1 = TweenMax.from("obj1", 1, {x: 100});
		 * var tween2 = TweenMax.to("obj2", 1, {y: 100});
		 * timeline
		 *		.add(tween1)
		 *		.add(tween2);
		 * scene.addTween(timeline);
		 *
		 * // short hand to add a TweenMax.to() tween
		 * scene.setTween("obj3", 0.5, {y: 100});
		 *
		 * // short hand to add a TweenMax.to() tween for 1 second
		 * // this is useful, when the scene has a duration and the tween duration isn't important anyway
		 * scene.setTween("obj3", {y: 100});
		 *
		 * @param {(object|string)} TweenObject - A TweenMax, TweenLite, TimelineMax or TimelineLite object that should be animated in the scene. Can also be a Dom Element or Selector, when using direct tween definition (see examples).
		 * @param {(number|object)} duration - A duration for the tween, or tween parameters. If an object containing parameters are supplied, a default duration of 1 will be used.
		 * @param {object} params - The parameters for the tween
		 * @returns {Scene} Parent object for chaining.
		 */
		Scene.setTween = function (TweenObject, duration, params) {
			var newTween;
			if (arguments.length > 1) {
				if (arguments.length < 3) {
					params = duration;
					duration = 1;
				}
				TweenObject = Tween.to(TweenObject, duration, params);
			}
			try {
				// wrap Tween into a Timeline Object if available to include delay and repeats in the duration and standardize methods.
				if (Timeline) {
					newTween = new Timeline({
						smoothChildTiming: true
					}).add(TweenObject);
				} else {
					newTween = TweenObject;
				}
				newTween.pause();
			} catch (e) {
				log(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject");
				return Scene;
			}
			if (_tween) { // kill old tween?
				Scene.removeTween();
			}
			_tween = newTween;

			// some properties need to be transferred it to the wrapper, otherwise they would get lost.
			if (TweenObject.repeat && TweenObject.repeat() === -1) { // TweenMax or TimelineMax Object?
				_tween.repeat(-1);
				_tween.yoyo(TweenObject.yoyo());
			}
			// Some tween validations and debugging helpers
			if (Scene.tweenChanges() && !_tween.tweenTo) {
				log(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic.");
			}

			// check if there are position tweens defined for the trigger and warn about it :)
			if (_tween && Scene.controller() && Scene.triggerElement() && Scene.loglevel() >= 2) { // controller is needed to know scroll direction.
				var
				triggerTweens = Tween.getTweensOf(Scene.triggerElement()),
					vertical = Scene.controller().info("vertical");
				triggerTweens.forEach(function (value, index) {
					var
					tweenvars = value.vars.css || value.vars,
						condition = vertical ? (tweenvars.top !== undefined || tweenvars.bottom !== undefined) : (tweenvars.left !== undefined || tweenvars.right !== undefined);
					if (condition) {
						log(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!");
						return false;
					}
				});
			}

			// warn about tween overwrites, when an element is tweened multiple times
			if (parseFloat(TweenLite.version) >= 1.14) { // onOverwrite only present since GSAP v1.14.0
				var
				list = _tween.getChildren ? _tween.getChildren(true, true, false) : [_tween],
					// get all nested tween objects
					newCallback = function () {
						log(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another");
					};
				for (var i = 0, thisTween, oldCallback; i < list.length; i++) { /*jshint loopfunc: true */
					thisTween = list[i];
					if (oldCallback !== newCallback) { // if tweens is added more than once
						oldCallback = thisTween.vars.onOverwrite;
						thisTween.vars.onOverwrite = function () {
							if (oldCallback) {
								oldCallback.apply(this, arguments);
							}
							newCallback.apply(this, arguments);
						};
					}
				}
			}
			log(3, "added tween");

			updateTweenProgress();
			return Scene;
		};

		/**
		 * Remove the tween from the scene.  
		 * This will terminate the control of the Scene over the tween.
		 *
		 * Using the reset option you can decide if the tween should remain in the current state or be rewound to set the target elements back to the state they were in before the tween was added to the scene.
		 * @memberof! animation.GSAP#
		 *
		 * @example
		 * // remove the tween from the scene without resetting it
		 * scene.removeTween();
		 *
		 * // remove the tween from the scene and reset it to initial position
		 * scene.removeTween(true);
		 *
		 * @param {boolean} [reset=false] - If `true` the tween will be reset to its initial values.
		 * @returns {Scene} Parent object for chaining.
		 */
		Scene.removeTween = function (reset) {
			if (_tween) {
				if (reset) {
					_tween.progress(0).pause();
				}
				_tween.kill();
				_tween = undefined;
				log(3, "removed tween (reset: " + (reset ? "true" : "false") + ")");
			}
			return Scene;
		};

	});
}));
/**
* jquery.matchHeight.js master
* http://brm.io/jquery-match-height/
* License: MIT
*/

;(function($) {
    /*
    *  internal
    */

    var _previousResizeWidth = -1,
        _updateTimeout = -1;

    /*
    *  _parse
    *  value parse utility function
    */

    var _parse = function(value) {
        // parse value and convert NaN to 0
        return parseFloat(value) || 0;
    };

    /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

    var _rows = function(elements) {
        var tolerance = 1,
            $elements = $(elements),
            lastTop = null,
            rows = [];

        // group elements by their top position
        $elements.each(function(){
            var $that = $(this),
                top = $that.offset().top - _parse($that.css('margin-top')),
                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

            if (lastRow === null) {
                // first item on the row, so just push it
                rows.push($that);
            } else {
                // if the row top is the same, add to the row group
                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
                    rows[rows.length - 1] = lastRow.add($that);
                } else {
                    // otherwise start a new row group
                    rows.push($that);
                }
            }

            // keep track of the last row top
            lastTop = top;
        });

        return rows;
    };

    /*
    *  _parseOptions
    *  handle plugin options
    */

    var _parseOptions = function(options) {
        var opts = {
            byRow: true,
            property: 'height',
            target: null,
            remove: false
        };

        if (typeof options === 'object') {
            return $.extend(opts, options);
        }

        if (typeof options === 'boolean') {
            opts.byRow = options;
        } else if (options === 'remove') {
            opts.remove = true;
        }

        return opts;
    };

    /*
    *  matchHeight
    *  plugin definition
    */

    var matchHeight = $.fn.matchHeight = function(options) {
        var opts = _parseOptions(options);

        // handle remove
        if (opts.remove) {
            var that = this;

            // remove fixed height from all selected elements
            this.css(opts.property, '');

            // remove selected elements from all groups
            $.each(matchHeight._groups, function(key, group) {
                group.elements = group.elements.not(that);
            });

            // TODO: cleanup empty groups

            return this;
        }

        if (this.length <= 1 && !opts.target) {
            return this;
        }

        // keep track of this group so we can re-apply later on load and resize events
        matchHeight._groups.push({
            elements: this,
            options: opts
        });

        // match each element's height to the tallest element in the selection
        matchHeight._apply(this, opts);

        return this;
    };

    /*
    *  plugin global options
    */

    matchHeight._groups = [];
    matchHeight._throttle = 80;
    matchHeight._maintainScroll = false;
    matchHeight._beforeUpdate = null;
    matchHeight._afterUpdate = null;

    /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

    matchHeight._apply = function(elements, options) {
        var opts = _parseOptions(options),
            $elements = $(elements),
            rows = [$elements];

        // take note of scroll position
        var scrollTop = $(window).scrollTop(),
            htmlHeight = $('html').outerHeight(true);

        // get hidden parents
        var $hiddenParents = $elements.parents().filter(':hidden');

        // cache the original inline style
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.data('style-cache', $that.attr('style'));
        });

        // temporarily must force hidden parents visible
        $hiddenParents.css('display', 'block');

        // get rows if using byRow, otherwise assume one row
        if (opts.byRow && !opts.target) {

            // must first force an arbitrary equal height so floating elements break evenly
            $elements.each(function() {
                var $that = $(this),
                    display = $that.css('display') === 'inline-block' ? 'inline-block' : 'block';

                // cache the original inline style
                $that.data('style-cache', $that.attr('style'));

                $that.css({
                    'display': display,
                    'padding-top': '0',
                    'padding-bottom': '0',
                    'margin-top': '0',
                    'margin-bottom': '0',
                    'border-top-width': '0',
                    'border-bottom-width': '0',
                    'height': '100px'
                });
            });

            // get the array of rows (based on element top position)
            rows = _rows($elements);

            // revert original inline styles
            $elements.each(function() {
                var $that = $(this);
                $that.attr('style', $that.data('style-cache') || '');
            });
        }

        $.each(rows, function(key, row) {
            var $row = $(row),
                targetHeight = 0;

            if (!opts.target) {
                // skip apply to rows with only one item
                if (opts.byRow && $row.length <= 1) {
                    $row.css(opts.property, '');
                    return;
                }

                // iterate the row and find the max height
                $row.each(function(){
                    var $that = $(this),
                        display = $that.css('display') === 'inline-block' ? 'inline-block' : 'block';

                    // ensure we get the correct actual height (and not a previously set height value)
                    var css = { 'display': display };
                    css[opts.property] = '';
                    $that.css(css);

                    // find the max height (including padding, but not margin)
                    if ($that.outerHeight(false) > targetHeight) {
                        targetHeight = $that.outerHeight(false);
                    }

                    // revert display block
                    $that.css('display', '');
                });
            } else {
                // if target set, use the height of the target element
                targetHeight = opts.target.outerHeight(false);
            }

            // iterate the row and apply the height to all elements
            $row.each(function(){
                var $that = $(this),
                    verticalPadding = 0;

                // don't apply to a target
                if (opts.target && $that.is(opts.target)) {
                    return;
                }

                // handle padding and border correctly (required when not using border-box)
                if ($that.css('box-sizing') !== 'border-box') {
                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
                }

                // set the height (accounting for padding and border)
                $that.css(opts.property, targetHeight - verticalPadding);
            });
        });

        // revert hidden parents
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.attr('style', $that.data('style-cache') || null);
        });

        // restore scroll position if enabled
        if (matchHeight._maintainScroll) {
            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));
        }

        return this;
    };

    /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

    matchHeight._applyDataApi = function() {
        var groups = {};

        // generate groups by their groupId set by elements using data-match-height
        $('[data-match-height], [data-mh]').each(function() {
            var $this = $(this),
                groupId = $this.attr('data-mh') || $this.attr('data-match-height');

            if (groupId in groups) {
                groups[groupId] = groups[groupId].add($this);
            } else {
                groups[groupId] = $this;
            }
        });

        // apply matchHeight to each group
        $.each(groups, function() {
            this.matchHeight(true);
        });
    };

    /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

    var _update = function(event) {
        if (matchHeight._beforeUpdate) {
            matchHeight._beforeUpdate(event, matchHeight._groups);
        }

        $.each(matchHeight._groups, function() {
            matchHeight._apply(this.elements, this.options);
        });

        if (matchHeight._afterUpdate) {
            matchHeight._afterUpdate(event, matchHeight._groups);
        }
    };

    matchHeight._update = function(throttle, event) {
        // prevent update if fired from a resize event
        // where the viewport width hasn't actually changed
        // fixes an event looping bug in IE8
        if (event && event.type === 'resize') {
            var windowWidth = $(window).width();
            if (windowWidth === _previousResizeWidth) {
                return;
            }
            _previousResizeWidth = windowWidth;
        }

        // throttle updates
        if (!throttle) {
            _update(event);
        } else if (_updateTimeout === -1) {
            _updateTimeout = setTimeout(function() {
                _update(event);
                _updateTimeout = -1;
            }, matchHeight._throttle);
        }
    };

    /*
    *  bind events
    */

    // apply on DOM ready event
    $(matchHeight._applyDataApi);

    // update heights on load and resize events
    $(window).bind('load', function(event) {
        matchHeight._update(false, event);
    });

    // throttled update heights on resize events
    $(window).bind('resize orientationchange', function(event) {
        matchHeight._update(true, event);
    });

})(jQuery);

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

/*!
 * jQuery UI Effects 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */
(function($, undefined) {

var dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );


/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.10.4",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of "olddisplay" works.
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery);

/*!
 * jQuery UI Effects Blind 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/blind-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

/*!
 * jQuery UI Effects Bounce 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/bounce-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

/*!
 * jQuery UI Effects Clip 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/clip-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

/*!
 * jQuery UI Effects Drop 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/drop-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

/*!
 * jQuery UI Effects Explode 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/explode-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);

/*!
 * jQuery UI Effects Fade 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fade-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );

/*!
 * jQuery UI Effects Fold 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fold-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);

/*!
 * jQuery UI Effects Highlight 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/highlight-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);

/*!
 * jQuery UI Effects Pulsate 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/pulsate-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);

/*!
 * jQuery UI Effects Scale 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/scale-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

/*!
 * jQuery UI Effects Shake 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/shake-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

/*!
 * jQuery UI Effects Slide 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slide-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

/*!
 * jQuery UI Effects Transfer 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/transfer-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( "<div class='ui-effects-transfer'></div>" )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);

/*!
 * The Final Countdown for jQuery v2.1.0 (http://hilios.github.io/jQuery.countdown/)
 * Copyright (c) 2015 Edson Hilios
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
(function(factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    "use strict";
    var instances = [], matchers = [], defaultOptions = {
        precision: 100,
        elapse: false
    };
    matchers.push(/^[0-9]*$/.source);
    matchers.push(/([0-9]{1,2}\/){2}[0-9]{4}( [0-9]{1,2}(:[0-9]{2}){2})?/.source);
    matchers.push(/[0-9]{4}([\/\-][0-9]{1,2}){2}( [0-9]{1,2}(:[0-9]{2}){2})?/.source);
    matchers = new RegExp(matchers.join("|"));
    function parseDateString(dateString) {
        if (dateString instanceof Date) {
            return dateString;
        }
        if (String(dateString).match(matchers)) {
            if (String(dateString).match(/^[0-9]*$/)) {
                dateString = Number(dateString);
            }
            if (String(dateString).match(/\-/)) {
                dateString = String(dateString).replace(/\-/g, "/");
            }
            return new Date(dateString);
        } else {
            throw new Error("Couldn't cast `" + dateString + "` to a date object.");
        }
    }
    var DIRECTIVE_KEY_MAP = {
        Y: "years",
        m: "months",
        n: "daysToMonth",
        w: "weeks",
        d: "daysToWeek",
        D: "totalDays",
        H: "hours",
        M: "minutes",
        S: "seconds"
    };
    function escapedRegExp(str) {
        var sanitize = str.toString().replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        return new RegExp(sanitize);
    }
    function strftime(offsetObject) {
        return function(format) {
            var directives = format.match(/%(-|!)?[A-Z]{1}(:[^;]+;)?/gi);
            if (directives) {
                for (var i = 0, len = directives.length; i < len; ++i) {
                    var directive = directives[i].match(/%(-|!)?([a-zA-Z]{1})(:[^;]+;)?/), regexp = escapedRegExp(directive[0]), modifier = directive[1] || "", plural = directive[3] || "", value = null;
                    directive = directive[2];
                    if (DIRECTIVE_KEY_MAP.hasOwnProperty(directive)) {
                        value = DIRECTIVE_KEY_MAP[directive];
                        value = Number(offsetObject[value]);
                    }
                    if (value !== null) {
                        if (modifier === "!") {
                            value = pluralize(plural, value);
                        }
                        if (modifier === "") {
                            if (value < 10) {
                                value = "0" + value.toString();
                            }
                        }
                        format = format.replace(regexp, value.toString());
                    }
                }
            }
            format = format.replace(/%%/, "%");
            return format;
        };
    }
    function pluralize(format, count) {
        var plural = "s", singular = "";
        if (format) {
            format = format.replace(/(:|;|\s)/gi, "").split(/\,/);
            if (format.length === 1) {
                plural = format[0];
            } else {
                singular = format[0];
                plural = format[1];
            }
        }
        if (Math.abs(count) === 1) {
            return singular;
        } else {
            return plural;
        }
    }
    var Countdown = function(el, finalDate, options) {
        this.el = el;
        this.$el = $(el);
        this.interval = null;
        this.offset = {};
        this.options = $.extend({}, defaultOptions);
        this.instanceNumber = instances.length;
        instances.push(this);
        this.$el.data("countdown-instance", this.instanceNumber);
        if (options) {
            if (typeof options === "function") {
                this.$el.on("update.countdown", options);
                this.$el.on("stoped.countdown", options);
                this.$el.on("finish.countdown", options);
            } else {
                this.options = $.extend({}, defaultOptions, options);
            }
        }
        this.setFinalDate(finalDate);
        this.start();
    };
    $.extend(Countdown.prototype, {
        start: function() {
            if (this.interval !== null) {
                clearInterval(this.interval);
            }
            var self = this;
            this.update();
            this.interval = setInterval(function() {
                self.update.call(self);
            }, this.options.precision);
        },
        stop: function() {
            clearInterval(this.interval);
            this.interval = null;
            this.dispatchEvent("stoped");
        },
        toggle: function() {
            if (this.interval) {
                this.stop();
            } else {
                this.start();
            }
        },
        pause: function() {
            this.stop();
        },
        resume: function() {
            this.start();
        },
        remove: function() {
            this.stop.call(this);
            instances[this.instanceNumber] = null;
            delete this.$el.data().countdownInstance;
        },
        setFinalDate: function(value) {
            this.finalDate = parseDateString(value);
        },
        update: function() {
            if (this.$el.closest("html").length === 0) {
                this.remove();
                return;
            }
            var hasEventsAttached = $._data(this.el, "events") !== undefined, now = new Date(), newTotalSecsLeft;
            newTotalSecsLeft = this.finalDate.getTime() - now.getTime();
            newTotalSecsLeft = Math.ceil(newTotalSecsLeft / 1e3);
            newTotalSecsLeft = !this.options.elapse && newTotalSecsLeft < 0 ? 0 : Math.abs(newTotalSecsLeft);
            if (this.totalSecsLeft === newTotalSecsLeft || !hasEventsAttached) {
                return;
            } else {
                this.totalSecsLeft = newTotalSecsLeft;
            }
            this.elapsed = now >= this.finalDate;
            this.offset = {
                seconds: this.totalSecsLeft % 60,
                minutes: Math.floor(this.totalSecsLeft / 60) % 60,
                hours: Math.floor(this.totalSecsLeft / 60 / 60) % 24,
                days: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
                daysToWeek: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
                daysToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 % 30.4368),
                totalDays: Math.floor(this.totalSecsLeft / 60 / 60 / 24),
                weeks: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7),
                months: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 30.4368),
                years: Math.abs(this.finalDate.getFullYear() - now.getFullYear())
            };
            if (!this.options.elapse && this.totalSecsLeft === 0) {
                this.stop();
                this.dispatchEvent("finish");
            } else {
                this.dispatchEvent("update");
            }
        },
        dispatchEvent: function(eventName) {
            var event = $.Event(eventName + ".countdown");
            event.finalDate = this.finalDate;
            event.elapsed = this.elapsed;
            event.offset = $.extend({}, this.offset);
            event.strftime = strftime(this.offset);
            this.$el.trigger(event);
        }
    });
    $.fn.countdown = function() {
        var argumentsArray = Array.prototype.slice.call(arguments, 0);
        return this.each(function() {
            var instanceNumber = $(this).data("countdown-instance");
            if (instanceNumber !== undefined) {
                var instance = instances[instanceNumber], method = argumentsArray[0];
                if (Countdown.prototype.hasOwnProperty(method)) {
                    instance[method].apply(instance, argumentsArray.slice(1));
                } else if (String(method).match(/^[$A-Z_][0-9A-Z_$]*$/i) === null) {
                    instance.setFinalDate.call(instance, method);
                    instance.start();
                } else {
                    $.error("Method %s does not exist on jQuery.countdown".replace(/\%s/gi, method));
                }
            } else {
                new Countdown(this, argumentsArray[0], argumentsArray[1]);
            }
        });
    };
});
/* jQuery.qrcode 0.12.0 - http://larsjung.de/jquery-qrcode/ - uses //github.com/kazuhikoarase/qrcode-generator (MIT) */
(function (qrcode) {
    'use strict';

    var $ = jQuery;

    // Wrapper for the original QR code generator.
    function QRCode(text, level, version, quiet) {

        var qr = qrcode(version, level);
        qr.addData(text);
        qr.make();

        quiet = quiet || 0;

        var qrModuleCount = qr.getModuleCount();
        var quietModuleCount = qr.getModuleCount() + 2 * quiet;

        function isDark(row, col) {

            row -= quiet;
            col -= quiet;

            if (row < 0 || row >= qrModuleCount || col < 0 || col >= qrModuleCount) {
                return false;
            }

            return qr.isDark(row, col);
        }

        var addBlank = function (l, t, r, b) {

            var prevIsDark = this.isDark;
            var moduleSize = 1 / quietModuleCount;

            this.isDark = function (row, col) {

                var ml = col * moduleSize;
                var mt = row * moduleSize;
                var mr = ml + moduleSize;
                var mb = mt + moduleSize;

                return prevIsDark(row, col) && (l > mr || ml > r || t > mb || mt > b);
            };
        };

        this.text = text;
        this.level = level;
        this.version = version;
        this.moduleCount = quietModuleCount;
        this.isDark = isDark;
        this.addBlank = addBlank;
    }

    // Check if canvas is available in the browser (as Modernizr does)
    var hasCanvas = (function () {

        var elem = document.createElement('canvas');
        return Boolean(elem.getContext && elem.getContext('2d'));
    }());
    var hasArcTo = Object.prototype.toString.call(window.opera) !== '[object Opera]';

    // Returns a minimal QR code for the given text starting with version `minVersion`.
    // Returns `undefined` if `text` is too long to be encoded in `maxVersion`.
    function createQRCode(text, level, minVersion, maxVersion, quiet) {

        minVersion = Math.max(1, minVersion || 1);
        maxVersion = Math.min(40, maxVersion || 40);
        for (var version = minVersion; version <= maxVersion; version += 1) {
            try {
                return new QRCode(text, level, version, quiet);
            } catch (err) {}
        }
    }

    function drawBackgroundLabel(qr, context, settings) {

        var size = settings.size;
        var font = 'bold ' + (settings.mSize * size) + 'px ' + settings.fontname;
        var ctx = $('<canvas/>')[0].getContext('2d');

        ctx.font = font;

        var w = ctx.measureText(settings.label).width;
        var sh = settings.mSize;
        var sw = w / size;
        var sl = (1 - sw) * settings.mPosX;
        var st = (1 - sh) * settings.mPosY;
        var sr = sl + sw;
        var sb = st + sh;
        var pad = 0.01;

        if (settings.mode === 1) {
            // Strip
            qr.addBlank(0, st - pad, size, sb + pad);
        } else {
            // Box
            qr.addBlank(sl - pad, st - pad, sr + pad, sb + pad);
        }

        context.fillStyle = settings.fontcolor;
        context.font = font;
        context.fillText(settings.label, sl * size, st * size + 0.75 * settings.mSize * size);
    }

    function drawBackgroundImage(qr, context, settings) {

        var size = settings.size;
        var w = settings.image.naturalWidth || 1;
        var h = settings.image.naturalHeight || 1;
        var sh = settings.mSize;
        var sw = sh * w / h;
        var sl = (1 - sw) * settings.mPosX;
        var st = (1 - sh) * settings.mPosY;
        var sr = sl + sw;
        var sb = st + sh;
        var pad = 0.01;

        if (settings.mode === 3) {
            // Strip
            qr.addBlank(0, st - pad, size, sb + pad);
        } else {
            // Box
            qr.addBlank(sl - pad, st - pad, sr + pad, sb + pad);
        }

        context.drawImage(settings.image, sl * size, st * size, sw * size, sh * size);
    }

    function drawBackground(qr, context, settings) {

        if ($(settings.background).is('img')) {
            context.drawImage(settings.background, 0, 0, settings.size, settings.size);
        } else if (settings.background) {
            context.fillStyle = settings.background;
            context.fillRect(settings.left, settings.top, settings.size, settings.size);
        }

        var mode = settings.mode;
        if (mode === 1 || mode === 2) {
            drawBackgroundLabel(qr, context, settings);
        } else if (mode === 3 || mode === 4) {
            drawBackgroundImage(qr, context, settings);
        }
    }

    function drawModuleDefault(qr, context, settings, left, top, width, row, col) {

        if (qr.isDark(row, col)) {
            context.rect(left, top, width, width);
        }
    }

    function drawModuleRoundedDark(ctx, l, t, r, b, rad, nw, ne, se, sw) {

        if (nw) {
            ctx.moveTo(l + rad, t);
        } else {
            ctx.moveTo(l, t);
        }

        if (ne) {
            ctx.lineTo(r - rad, t);
            ctx.arcTo(r, t, r, b, rad);
        } else {
            ctx.lineTo(r, t);
        }

        if (se) {
            ctx.lineTo(r, b - rad);
            ctx.arcTo(r, b, l, b, rad);
        } else {
            ctx.lineTo(r, b);
        }

        if (sw) {
            ctx.lineTo(l + rad, b);
            ctx.arcTo(l, b, l, t, rad);
        } else {
            ctx.lineTo(l, b);
        }

        if (nw) {
            ctx.lineTo(l, t + rad);
            ctx.arcTo(l, t, r, t, rad);
        } else {
            ctx.lineTo(l, t);
        }
    }

    function drawModuleRoundendLight(ctx, l, t, r, b, rad, nw, ne, se, sw) {

        if (nw) {
            ctx.moveTo(l + rad, t);
            ctx.lineTo(l, t);
            ctx.lineTo(l, t + rad);
            ctx.arcTo(l, t, l + rad, t, rad);
        }

        if (ne) {
            ctx.moveTo(r - rad, t);
            ctx.lineTo(r, t);
            ctx.lineTo(r, t + rad);
            ctx.arcTo(r, t, r - rad, t, rad);
        }

        if (se) {
            ctx.moveTo(r - rad, b);
            ctx.lineTo(r, b);
            ctx.lineTo(r, b - rad);
            ctx.arcTo(r, b, r - rad, b, rad);
        }

        if (sw) {
            ctx.moveTo(l + rad, b);
            ctx.lineTo(l, b);
            ctx.lineTo(l, b - rad);
            ctx.arcTo(l, b, l + rad, b, rad);
        }
    }

    function drawModuleRounded(qr, context, settings, left, top, width, row, col) {

        var isDark = qr.isDark;
        var right = left + width;
        var bottom = top + width;
        var radius = settings.radius * width;
        var rowT = row - 1;
        var rowB = row + 1;
        var colL = col - 1;
        var colR = col + 1;
        var center = isDark(row, col);
        var northwest = isDark(rowT, colL);
        var north = isDark(rowT, col);
        var northeast = isDark(rowT, colR);
        var east = isDark(row, colR);
        var southeast = isDark(rowB, colR);
        var south = isDark(rowB, col);
        var southwest = isDark(rowB, colL);
        var west = isDark(row, colL);

        if (center) {
            drawModuleRoundedDark(context, left, top, right, bottom, radius, !north && !west, !north && !east, !south && !east, !south && !west);
        } else {
            drawModuleRoundendLight(context, left, top, right, bottom, radius, north && west && northwest, north && east && northeast, south && east && southeast, south && west && southwest);
        }
    }

    function drawModules(qr, context, settings) {

        var moduleCount = qr.moduleCount;
        var moduleSize = settings.size / moduleCount;
        var fn = drawModuleDefault;
        var row;
        var col;

        if (hasArcTo && settings.radius > 0 && settings.radius <= 0.5) {
            fn = drawModuleRounded;
        }

        context.beginPath();
        for (row = 0; row < moduleCount; row += 1) {
            for (col = 0; col < moduleCount; col += 1) {

                var l = settings.left + col * moduleSize;
                var t = settings.top + row * moduleSize;
                var w = moduleSize;

                fn(qr, context, settings, l, t, w, row, col);
            }
        }
        if ($(settings.fill).is('img')) {
            context.strokeStyle = 'rgba(0,0,0,0.5)';
            context.lineWidth = 2;
            context.stroke();
            var prev = context.globalCompositeOperation;
            context.globalCompositeOperation = 'destination-out';
            context.fill();
            context.globalCompositeOperation = prev;

            context.clip();
            context.drawImage(settings.fill, 0, 0, settings.size, settings.size);
            context.restore();
        } else {
            context.fillStyle = settings.fill;
            context.fill();
        }
    }

    // Draws QR code to the given `canvas` and returns it.
    function drawOnCanvas(canvas, settings) {

        var qr = createQRCode(settings.text, settings.ecLevel, settings.minVersion, settings.maxVersion, settings.quiet);
        if (!qr) {
            return null;
        }

        var $canvas = $(canvas).data('qrcode', qr);
        var context = $canvas[0].getContext('2d');

        drawBackground(qr, context, settings);
        drawModules(qr, context, settings);

        return $canvas;
    }

    // Returns a `canvas` element representing the QR code for the given settings.
    function createCanvas(settings) {

        var $canvas = $('<canvas/>').attr('width', settings.size).attr('height', settings.size);
        return drawOnCanvas($canvas, settings);
    }

    // Returns an `image` element representing the QR code for the given settings.
    function createImage(settings) {

        return $('<img/>').attr('src', createCanvas(settings)[0].toDataURL('image/png'));
    }

    // Returns a `div` element representing the QR code for the given settings.
    function createDiv(settings) {

        var qr = createQRCode(settings.text, settings.ecLevel, settings.minVersion, settings.maxVersion, settings.quiet);
        if (!qr) {
            return null;
        }

        // some shortcuts to improve compression
        var settings_size = settings.size;
        var settings_bgColor = settings.background;
        var math_floor = Math.floor;

        var moduleCount = qr.moduleCount;
        var moduleSize = math_floor(settings_size / moduleCount);
        var offset = math_floor(0.5 * (settings_size - moduleSize * moduleCount));

        var row;
        var col;

        var containerCSS = {
                position: 'relative',
                left: 0,
                top: 0,
                padding: 0,
                margin: 0,
                width: settings_size,
                height: settings_size
            };
        var darkCSS = {
                position: 'absolute',
                padding: 0,
                margin: 0,
                width: moduleSize,
                height: moduleSize,
                'background-color': settings.fill
            };

        var $div = $('<div/>').data('qrcode', qr).css(containerCSS);

        if (settings_bgColor) {
            $div.css('background-color', settings_bgColor);
        }

        for (row = 0; row < moduleCount; row += 1) {
            for (col = 0; col < moduleCount; col += 1) {
                if (qr.isDark(row, col)) {
                    $('<div/>')
                        .css(darkCSS)
                        .css({
                            left: offset + col * moduleSize,
                            top: offset + row * moduleSize
                        })
                        .appendTo($div);
                }
            }
        }

        return $div;
    }

    function createHTML(settings) {

        if (hasCanvas && settings.render === 'canvas') {
            return createCanvas(settings);
        } else if (hasCanvas && settings.render === 'image') {
            return createImage(settings);
        }

        return createDiv(settings);
    }

    // Plugin
    // ======

    // Default settings
    // ----------------
    var defaults = {

        // render method: `'canvas'`, `'image'` or `'div'`
        render: 'canvas',

        // version range somewhere in 1 .. 40
        minVersion: 1,
        maxVersion: 40,

        // error correction level: `'L'`, `'M'`, `'Q'` or `'H'`
        ecLevel: 'L',

        // offset in pixel if drawn onto existing canvas
        left: 0,
        top: 0,

        // size in pixel
        size: 200,

        // code color or image element
        fill: '#000',

        // background color or image element, `null` for transparent background
        background: null,

        // content
        text: 'no text',

        // corner radius relative to module width: 0.0 .. 0.5
        radius: 0,

        // quiet zone in modules
        quiet: 0,

        // modes
        // 0: normal
        // 1: label strip
        // 2: label box
        // 3: image strip
        // 4: image box
        mode: 0,

        mSize: 0.1,
        mPosX: 0.5,
        mPosY: 0.5,

        label: 'no label',
        fontname: 'sans',
        fontcolor: '#000',

        image: null
    };

    // Register the plugin
    // -------------------
    $.fn.qrcode = function (options) {

        var settings = $.extend({}, defaults, options);

        return this.each(function () {

            if (this.nodeName.toLowerCase() === 'canvas') {
                drawOnCanvas(this, settings);
            } else {
                $(this).append(createHTML(settings));
            }
        });
    };
}(function () {

    // `qrcode` is the single public function defined by the `QR Code Generator`
    //---------------------------------------------------------------------
    //
    // QR Code Generator for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //  http://www.opensource.org/licenses/mit-license.php
    //
    // The word 'QR Code' is registered trademark of
    // DENSO WAVE INCORPORATED
    //  http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------

    var qrcode = function() {

      //---------------------------------------------------------------------
      // qrcode
      //---------------------------------------------------------------------

      /**
       * qrcode
       * @param typeNumber 1 to 40
       * @param errorCorrectLevel 'L','M','Q','H'
       */
      var qrcode = function(typeNumber, errorCorrectLevel) {

        var PAD0 = 0xEC;
        var PAD1 = 0x11;

        var _typeNumber = typeNumber;
        var _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataCache = null;
        var _dataList = new Array();

        var _this = {};

        var makeImpl = function(test, maskPattern) {

          _moduleCount = _typeNumber * 4 + 17;
          _modules = function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row += 1) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col += 1) {
                modules[row][col] = null;
              }
            }
            return modules;
          }(_moduleCount);

          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);

          if (_typeNumber >= 7) {
            setupTypeNumber(test);
          }

          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList);
          }

          mapData(_dataCache, maskPattern);
        };

        var setupPositionProbePattern = function(row, col) {

          for (var r = -1; r <= 7; r += 1) {

            if (row + r <= -1 || _moduleCount <= row + r) continue;

            for (var c = -1; c <= 7; c += 1) {

              if (col + c <= -1 || _moduleCount <= col + c) continue;

              if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
                  || (0 <= c && c <= 6 && (r == 0 || r == 6) )
                  || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        };

        var getBestMaskPattern = function() {

          var minLostPoint = 0;
          var pattern = 0;

          for (var i = 0; i < 8; i += 1) {

            makeImpl(true, i);

            var lostPoint = QRUtil.getLostPoint(_this);

            if (i == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i;
            }
          }

          return pattern;
        };

        var setupTimingPattern = function() {

          for (var r = 8; r < _moduleCount - 8; r += 1) {
            if (_modules[r][6] != null) {
              continue;
            }
            _modules[r][6] = (r % 2 == 0);
          }

          for (var c = 8; c < _moduleCount - 8; c += 1) {
            if (_modules[6][c] != null) {
              continue;
            }
            _modules[6][c] = (c % 2 == 0);
          }
        };

        var setupPositionAdjustPattern = function() {

          var pos = QRUtil.getPatternPosition(_typeNumber);

          for (var i = 0; i < pos.length; i += 1) {

            for (var j = 0; j < pos.length; j += 1) {

              var row = pos[i];
              var col = pos[j];

              if (_modules[row][col] != null) {
                continue;
              }

              for (var r = -2; r <= 2; r += 1) {

                for (var c = -2; c <= 2; c += 1) {

                  if (r == -2 || r == 2 || c == -2 || c == 2
                      || (r == 0 && c == 0) ) {
                    _modules[row + r][col + c] = true;
                  } else {
                    _modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        };

        var setupTypeNumber = function(test) {

          var bits = QRUtil.getBCHTypeNumber(_typeNumber);

          for (var i = 0; i < 18; i += 1) {
            var mod = (!test && ( (bits >> i) & 1) == 1);
            _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
          }

          for (var i = 0; i < 18; i += 1) {
            var mod = (!test && ( (bits >> i) & 1) == 1);
            _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
          }
        };

        var setupTypeInfo = function(test, maskPattern) {

          var data = (_errorCorrectLevel << 3) | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);

          // vertical
          for (var i = 0; i < 15; i += 1) {

            var mod = (!test && ( (bits >> i) & 1) == 1);

            if (i < 6) {
              _modules[i][8] = mod;
            } else if (i < 8) {
              _modules[i + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i][8] = mod;
            }
          }

          // horizontal
          for (var i = 0; i < 15; i += 1) {

            var mod = (!test && ( (bits >> i) & 1) == 1);

            if (i < 8) {
              _modules[8][_moduleCount - i - 1] = mod;
            } else if (i < 9) {
              _modules[8][15 - i - 1 + 1] = mod;
            } else {
              _modules[8][15 - i - 1] = mod;
            }
          }

          // fixed module
          _modules[_moduleCount - 8][8] = (!test);
        };

        var mapData = function(data, maskPattern) {

          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          var maskFunc = QRUtil.getMaskFunction(maskPattern);

          for (var col = _moduleCount - 1; col > 0; col -= 2) {

            if (col == 6) col -= 1;

            while (true) {

              for (var c = 0; c < 2; c += 1) {

                if (_modules[row][col - c] == null) {

                  var dark = false;

                  if (byteIndex < data.length) {
                    dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
                  }

                  var mask = maskFunc(row, col - c);

                  if (mask) {
                    dark = !dark;
                  }

                  _modules[row][col - c] = dark;
                  bitIndex -= 1;

                  if (bitIndex == -1) {
                    byteIndex += 1;
                    bitIndex = 7;
                  }
                }
              }

              row += inc;

              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };

        var createBytes = function(buffer, rsBlocks) {

          var offset = 0;

          var maxDcCount = 0;
          var maxEcCount = 0;

          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);

          for (var r = 0; r < rsBlocks.length; r += 1) {

            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;

            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);

            dcdata[r] = new Array(dcCount);

            for (var i = 0; i < dcdata[r].length; i += 1) {
              dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
            }
            offset += dcCount;

            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (var i = 0; i < ecdata[r].length; i += 1) {
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
            }
          }

          var totalCodeCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalCodeCount += rsBlocks[i].totalCount;
          }

          var data = new Array(totalCodeCount);
          var index = 0;

          for (var i = 0; i < maxDcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < dcdata[r].length) {
                data[index] = dcdata[r][i];
                index += 1;
              }
            }
          }

          for (var i = 0; i < maxEcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < ecdata[r].length) {
                data[index] = ecdata[r][i];
                index += 1;
              }
            }
          }

          return data;
        };

        var createData = function(typeNumber, errorCorrectLevel, dataList) {

          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);

          var buffer = qrBitBuffer();

          for (var i = 0; i < dataList.length; i += 1) {
            var data = dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          // calc num max data.
          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error('code length overflow. ('
              + buffer.getLengthInBits()
              + '>'
              + totalDataCount * 8
              + ')');
          }

          // end code
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }

          // padding
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }

          // padding
          while (true) {

            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD0, 8);

            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD1, 8);
          }

          return createBytes(buffer, rsBlocks);
        };

        _this.addData = function(data) {
          var newData = qr8BitByte(data);
          _dataList.push(newData);
          _dataCache = null;
        };

        _this.isDark = function(row, col) {
          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
            throw new Error(row + ',' + col);
          }
          return _modules[row][col];
        };

        _this.getModuleCount = function() {
          return _moduleCount;
        };

        _this.make = function() {
          makeImpl(false, getBestMaskPattern() );
        };

        _this.createTableTag = function(cellSize, margin) {

          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

          var qrHtml = '';

          qrHtml += '<table style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
          qrHtml += '">';
          qrHtml += '<tbody>';

          for (var r = 0; r < _this.getModuleCount(); r += 1) {

            qrHtml += '<tr>';

            for (var c = 0; c < _this.getModuleCount(); c += 1) {
              qrHtml += '<td style="';
              qrHtml += ' border-width: 0px; border-style: none;';
              qrHtml += ' border-collapse: collapse;';
              qrHtml += ' padding: 0px; margin: 0px;';
              qrHtml += ' width: ' + cellSize + 'px;';
              qrHtml += ' height: ' + cellSize + 'px;';
              qrHtml += ' background-color: ';
              qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
              qrHtml += ';';
              qrHtml += '"/>';
            }

            qrHtml += '</tr>';
          }

          qrHtml += '</tbody>';
          qrHtml += '</table>';

          return qrHtml;
        };

        _this.createImgTag = function(cellSize, margin) {

          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;

          return createImgTag(size, size, function(x, y) {
            if (min <= x && x < max && min <= y && y < max) {
              var c = Math.floor( (x - min) / cellSize);
              var r = Math.floor( (y - min) / cellSize);
              return _this.isDark(r, c)? 0 : 1;
            } else {
              return 1;
            }
          } );
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // qrcode.stringToBytes
      //---------------------------------------------------------------------

      qrcode.stringToBytes = function(s) {
        var bytes = new Array();
        for (var i = 0; i < s.length; i += 1) {
          var c = s.charCodeAt(i);
          bytes.push(c & 0xff);
        }
        return bytes;
      };

      //---------------------------------------------------------------------
      // qrcode.createStringToBytes
      //---------------------------------------------------------------------

      /**
       * @param unicodeData base64 string of byte array.
       * [16bit Unicode],[16bit Bytes], ...
       * @param numChars
       */
      qrcode.createStringToBytes = function(unicodeData, numChars) {

        // create conversion map.

        var unicodeMap = function() {

          var bin = base64DecodeInputStream(unicodeData);
          var read = function() {
            var b = bin.read();
            if (b == -1) throw new Error();
            return b;
          };

          var count = 0;
          var unicodeMap = {};
          while (true) {
            var b0 = bin.read();
            if (b0 == -1) break;
            var b1 = read();
            var b2 = read();
            var b3 = read();
            var k = String.fromCharCode( (b0 << 8) | b1);
            var v = (b2 << 8) | b3;
            unicodeMap[k] = v;
            count += 1;
          }
          if (count != numChars) {
            throw new Error(count + ' != ' + numChars);
          }

          return unicodeMap;
        }();

        var unknownChar = '?'.charCodeAt(0);

        return function(s) {
          var bytes = new Array();
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            if (c < 128) {
              bytes.push(c);
            } else {
              var b = unicodeMap[s.charAt(i)];
              if (typeof b == 'number') {
                if ( (b & 0xff) == b) {
                  // 1byte
                  bytes.push(b);
                } else {
                  // 2bytes
                  bytes.push(b >>> 8);
                  bytes.push(b & 0xff);
                }
              } else {
                bytes.push(unknownChar);
              }
            }
          }
          return bytes;
        };
      };

      //---------------------------------------------------------------------
      // QRMode
      //---------------------------------------------------------------------

      var QRMode = {
        MODE_NUMBER :    1 << 0,
        MODE_ALPHA_NUM : 1 << 1,
        MODE_8BIT_BYTE : 1 << 2,
        MODE_KANJI :     1 << 3
      };

      //---------------------------------------------------------------------
      // QRErrorCorrectLevel
      //---------------------------------------------------------------------

      var QRErrorCorrectLevel = {
        L : 1,
        M : 0,
        Q : 3,
        H : 2
      };

      //---------------------------------------------------------------------
      // QRMaskPattern
      //---------------------------------------------------------------------

      var QRMaskPattern = {
        PATTERN000 : 0,
        PATTERN001 : 1,
        PATTERN010 : 2,
        PATTERN011 : 3,
        PATTERN100 : 4,
        PATTERN101 : 5,
        PATTERN110 : 6,
        PATTERN111 : 7
      };

      //---------------------------------------------------------------------
      // QRUtil
      //---------------------------------------------------------------------

      var QRUtil = function() {

        var PATTERN_POSITION_TABLE = [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ];
        var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
        var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
        var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

        var _this = {};

        var getBCHDigit = function(data) {
          var digit = 0;
          while (data != 0) {
            digit += 1;
            data >>>= 1;
          }
          return digit;
        };

        _this.getBCHTypeInfo = function(data) {
          var d = data << 10;
          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
            d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
          }
          return ( (data << 10) | d) ^ G15_MASK;
        };

        _this.getBCHTypeNumber = function(data) {
          var d = data << 12;
          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
            d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
          }
          return (data << 12) | d;
        };

        _this.getPatternPosition = function(typeNumber) {
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        };

        _this.getMaskFunction = function(maskPattern) {

          switch (maskPattern) {

          case QRMaskPattern.PATTERN000 :
            return function(i, j) { return (i + j) % 2 == 0; };
          case QRMaskPattern.PATTERN001 :
            return function(i, j) { return i % 2 == 0; };
          case QRMaskPattern.PATTERN010 :
            return function(i, j) { return j % 3 == 0; };
          case QRMaskPattern.PATTERN011 :
            return function(i, j) { return (i + j) % 3 == 0; };
          case QRMaskPattern.PATTERN100 :
            return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
          case QRMaskPattern.PATTERN101 :
            return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
          case QRMaskPattern.PATTERN110 :
            return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
          case QRMaskPattern.PATTERN111 :
            return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

          default :
            throw new Error('bad maskPattern:' + maskPattern);
          }
        };

        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
          var a = qrPolynomial([1], 0);
          for (var i = 0; i < errorCorrectLength; i += 1) {
            a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
          }
          return a;
        };

        _this.getLengthInBits = function(mode, type) {

          if (1 <= type && type < 10) {

            // 1 - 9

            switch(mode) {
            case QRMode.MODE_NUMBER    : return 10;
            case QRMode.MODE_ALPHA_NUM : return 9;
            case QRMode.MODE_8BIT_BYTE : return 8;
            case QRMode.MODE_KANJI     : return 8;
            default :
              throw new Error('mode:' + mode);
            }

          } else if (type < 27) {

            // 10 - 26

            switch(mode) {
            case QRMode.MODE_NUMBER    : return 12;
            case QRMode.MODE_ALPHA_NUM : return 11;
            case QRMode.MODE_8BIT_BYTE : return 16;
            case QRMode.MODE_KANJI     : return 10;
            default :
              throw new Error('mode:' + mode);
            }

          } else if (type < 41) {

            // 27 - 40

            switch(mode) {
            case QRMode.MODE_NUMBER    : return 14;
            case QRMode.MODE_ALPHA_NUM : return 13;
            case QRMode.MODE_8BIT_BYTE : return 16;
            case QRMode.MODE_KANJI     : return 12;
            default :
              throw new Error('mode:' + mode);
            }

          } else {
            throw new Error('type:' + type);
          }
        };

        _this.getLostPoint = function(qrcode) {

          var moduleCount = qrcode.getModuleCount();

          var lostPoint = 0;

          // LEVEL1

          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount; col += 1) {

              var sameCount = 0;
              var dark = qrcode.isDark(row, col);

              for (var r = -1; r <= 1; r += 1) {

                if (row + r < 0 || moduleCount <= row + r) {
                  continue;
                }

                for (var c = -1; c <= 1; c += 1) {

                  if (col + c < 0 || moduleCount <= col + c) {
                    continue;
                  }

                  if (r == 0 && c == 0) {
                    continue;
                  }

                  if (dark == qrcode.isDark(row + r, col + c) ) {
                    sameCount += 1;
                  }
                }
              }

              if (sameCount > 5) {
                lostPoint += (3 + sameCount - 5);
              }
            }
          };

          // LEVEL2

          for (var row = 0; row < moduleCount - 1; row += 1) {
            for (var col = 0; col < moduleCount - 1; col += 1) {
              var count = 0;
              if (qrcode.isDark(row, col) ) count += 1;
              if (qrcode.isDark(row + 1, col) ) count += 1;
              if (qrcode.isDark(row, col + 1) ) count += 1;
              if (qrcode.isDark(row + 1, col + 1) ) count += 1;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }

          // LEVEL3

          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount - 6; col += 1) {
              if (qrcode.isDark(row, col)
                  && !qrcode.isDark(row, col + 1)
                  &&  qrcode.isDark(row, col + 2)
                  &&  qrcode.isDark(row, col + 3)
                  &&  qrcode.isDark(row, col + 4)
                  && !qrcode.isDark(row, col + 5)
                  &&  qrcode.isDark(row, col + 6) ) {
                lostPoint += 40;
              }
            }
          }

          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount - 6; row += 1) {
              if (qrcode.isDark(row, col)
                  && !qrcode.isDark(row + 1, col)
                  &&  qrcode.isDark(row + 2, col)
                  &&  qrcode.isDark(row + 3, col)
                  &&  qrcode.isDark(row + 4, col)
                  && !qrcode.isDark(row + 5, col)
                  &&  qrcode.isDark(row + 6, col) ) {
                lostPoint += 40;
              }
            }
          }

          // LEVEL4

          var darkCount = 0;

          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount; row += 1) {
              if (qrcode.isDark(row, col) ) {
                darkCount += 1;
              }
            }
          }

          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;

          return lostPoint;
        };

        return _this;
      }();

      //---------------------------------------------------------------------
      // QRMath
      //---------------------------------------------------------------------

      var QRMath = function() {

        var EXP_TABLE = new Array(256);
        var LOG_TABLE = new Array(256);

        // initialize tables
        for (var i = 0; i < 8; i += 1) {
          EXP_TABLE[i] = 1 << i;
        }
        for (var i = 8; i < 256; i += 1) {
          EXP_TABLE[i] = EXP_TABLE[i - 4]
            ^ EXP_TABLE[i - 5]
            ^ EXP_TABLE[i - 6]
            ^ EXP_TABLE[i - 8];
        }
        for (var i = 0; i < 255; i += 1) {
          LOG_TABLE[EXP_TABLE[i] ] = i;
        }

        var _this = {};

        _this.glog = function(n) {

          if (n < 1) {
            throw new Error('glog(' + n + ')');
          }

          return LOG_TABLE[n];
        };

        _this.gexp = function(n) {

          while (n < 0) {
            n += 255;
          }

          while (n >= 256) {
            n -= 255;
          }

          return EXP_TABLE[n];
        };

        return _this;
      }();

      //---------------------------------------------------------------------
      // qrPolynomial
      //---------------------------------------------------------------------

      function qrPolynomial(num, shift) {

        if (typeof num.length == 'undefined') {
          throw new Error(num.length + '/' + shift);
        }

        var _num = function() {
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset += 1;
          }
          var _num = new Array(num.length - offset + shift);
          for (var i = 0; i < num.length - offset; i += 1) {
            _num[i] = num[i + offset];
          }
          return _num;
        }();

        var _this = {};

        _this.getAt = function(index) {
          return _num[index];
        };

        _this.getLength = function() {
          return _num.length;
        };

        _this.multiply = function(e) {

          var num = new Array(_this.getLength() + e.getLength() - 1);

          for (var i = 0; i < _this.getLength(); i += 1) {
            for (var j = 0; j < e.getLength(); j += 1) {
              num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
            }
          }

          return qrPolynomial(num, 0);
        };

        _this.mod = function(e) {

          if (_this.getLength() - e.getLength() < 0) {
            return _this;
          }

          var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

          var num = new Array(_this.getLength() );
          for (var i = 0; i < _this.getLength(); i += 1) {
            num[i] = _this.getAt(i);
          }

          for (var i = 0; i < e.getLength(); i += 1) {
            num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
          }

          // recursive call
          return qrPolynomial(num, 0).mod(e);
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // QRRSBlock
      //---------------------------------------------------------------------

      var QRRSBlock = function() {

        var RS_BLOCK_TABLE = [

          // L
          // M
          // Q
          // H

          // 1
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],

          // 2
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],

          // 3
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],

          // 4
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],

          // 5
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],

          // 6
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],

          // 7
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],

          // 8
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],

          // 9
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],

          // 10
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],

          // 11
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],

          // 12
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],

          // 13
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],

          // 14
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],

          // 15
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12, 7, 37, 13],

          // 16
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],

          // 17
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],

          // 18
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],

          // 19
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],

          // 20
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],

          // 21
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],

          // 22
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],

          // 23
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],

          // 24
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],

          // 25
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],

          // 26
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],

          // 27
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],

          // 28
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],

          // 29
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],

          // 30
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],

          // 31
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],

          // 32
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],

          // 33
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],

          // 34
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],

          // 35
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],

          // 36
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],

          // 37
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],

          // 38
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],

          // 39
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],

          // 40
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];

        var qrRSBlock = function(totalCount, dataCount) {
          var _this = {};
          _this.totalCount = totalCount;
          _this.dataCount = dataCount;
          return _this;
        };

        var _this = {};

        var getRsBlockTable = function(typeNumber, errorCorrectLevel) {

          switch(errorCorrectLevel) {
          case QRErrorCorrectLevel.L :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
          case QRErrorCorrectLevel.M :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
          case QRErrorCorrectLevel.Q :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
          case QRErrorCorrectLevel.H :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
          default :
            return undefined;
          }
        };

        _this.getRSBlocks = function(typeNumber, errorCorrectLevel) {

          var rsBlock = getRsBlockTable(typeNumber, errorCorrectLevel);

          if (typeof rsBlock == 'undefined') {
            throw new Error('bad rs block @ typeNumber:' + typeNumber +
                '/errorCorrectLevel:' + errorCorrectLevel);
          }

          var length = rsBlock.length / 3;

          var list = new Array();

          for (var i = 0; i < length; i += 1) {

            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];

            for (var j = 0; j < count; j += 1) {
              list.push(qrRSBlock(totalCount, dataCount) );
            }
          }

          return list;
        };

        return _this;
      }();

      //---------------------------------------------------------------------
      // qrBitBuffer
      //---------------------------------------------------------------------

      var qrBitBuffer = function() {

        var _buffer = new Array();
        var _length = 0;

        var _this = {};

        _this.getBuffer = function() {
          return _buffer;
        };

        _this.getAt = function(index) {
          var bufIndex = Math.floor(index / 8);
          return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
        };

        _this.put = function(num, length) {
          for (var i = 0; i < length; i += 1) {
            _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
          }
        };

        _this.getLengthInBits = function() {
          return _length;
        };

        _this.putBit = function(bit) {

          var bufIndex = Math.floor(_length / 8);
          if (_buffer.length <= bufIndex) {
            _buffer.push(0);
          }

          if (bit) {
            _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
          }

          _length += 1;
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // qr8BitByte
      //---------------------------------------------------------------------

      var qr8BitByte = function(data) {

        var _mode = QRMode.MODE_8BIT_BYTE;
        var _data = data;
        var _bytes = qrcode.stringToBytes(data);

        var _this = {};

        _this.getMode = function() {
          return _mode;
        };

        _this.getLength = function(buffer) {
          return _bytes.length;
        };

        _this.write = function(buffer) {
          for (var i = 0; i < _bytes.length; i += 1) {
            buffer.put(_bytes[i], 8);
          }
        };

        return _this;
      };

      //=====================================================================
      // GIF Support etc.
      //

      //---------------------------------------------------------------------
      // byteArrayOutputStream
      //---------------------------------------------------------------------

      var byteArrayOutputStream = function() {

        var _bytes = new Array();

        var _this = {};

        _this.writeByte = function(b) {
          _bytes.push(b & 0xff);
        };

        _this.writeShort = function(i) {
          _this.writeByte(i);
          _this.writeByte(i >>> 8);
        };

        _this.writeBytes = function(b, off, len) {
          off = off || 0;
          len = len || b.length;
          for (var i = 0; i < len; i += 1) {
            _this.writeByte(b[i + off]);
          }
        };

        _this.writeString = function(s) {
          for (var i = 0; i < s.length; i += 1) {
            _this.writeByte(s.charCodeAt(i) );
          }
        };

        _this.toByteArray = function() {
          return _bytes;
        };

        _this.toString = function() {
          var s = '';
          s += '[';
          for (var i = 0; i < _bytes.length; i += 1) {
            if (i > 0) {
              s += ',';
            }
            s += _bytes[i];
          }
          s += ']';
          return s;
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // base64EncodeOutputStream
      //---------------------------------------------------------------------

      var base64EncodeOutputStream = function() {

        var _buffer = 0;
        var _buflen = 0;
        var _length = 0;
        var _base64 = '';

        var _this = {};

        var writeEncoded = function(b) {
          _base64 += String.fromCharCode(encode(b & 0x3f) );
        };

        var encode = function(n) {
          if (n < 0) {
            // error.
          } else if (n < 26) {
            return 0x41 + n;
          } else if (n < 52) {
            return 0x61 + (n - 26);
          } else if (n < 62) {
            return 0x30 + (n - 52);
          } else if (n == 62) {
            return 0x2b;
          } else if (n == 63) {
            return 0x2f;
          }
          throw new Error('n:' + n);
        };

        _this.writeByte = function(n) {

          _buffer = (_buffer << 8) | (n & 0xff);
          _buflen += 8;
          _length += 1;

          while (_buflen >= 6) {
            writeEncoded(_buffer >>> (_buflen - 6) );
            _buflen -= 6;
          }
        };

        _this.flush = function() {

          if (_buflen > 0) {
            writeEncoded(_buffer << (6 - _buflen) );
            _buffer = 0;
            _buflen = 0;
          }

          if (_length % 3 != 0) {
            // padding
            var padlen = 3 - _length % 3;
            for (var i = 0; i < padlen; i += 1) {
              _base64 += '=';
            }
          }
        };

        _this.toString = function() {
          return _base64;
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // base64DecodeInputStream
      //---------------------------------------------------------------------

      var base64DecodeInputStream = function(str) {

        var _str = str;
        var _pos = 0;
        var _buffer = 0;
        var _buflen = 0;

        var _this = {};

        _this.read = function() {

          while (_buflen < 8) {

            if (_pos >= _str.length) {
              if (_buflen == 0) {
                return -1;
              }
              throw new Error('unexpected end of file./' + _buflen);
            }

            var c = _str.charAt(_pos);
            _pos += 1;

            if (c == '=') {
              _buflen = 0;
              return -1;
            } else if (c.match(/^\s$/) ) {
              // ignore if whitespace.
              continue;
            }

            _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
            _buflen += 6;
          }

          var n = (_buffer >>> (_buflen - 8) ) & 0xff;
          _buflen -= 8;
          return n;
        };

        var decode = function(c) {
          if (0x41 <= c && c <= 0x5a) {
            return c - 0x41;
          } else if (0x61 <= c && c <= 0x7a) {
            return c - 0x61 + 26;
          } else if (0x30 <= c && c <= 0x39) {
            return c - 0x30 + 52;
          } else if (c == 0x2b) {
            return 62;
          } else if (c == 0x2f) {
            return 63;
          } else {
            throw new Error('c:' + c);
          }
        };

        return _this;
      };

      //---------------------------------------------------------------------
      // gifImage (B/W)
      //---------------------------------------------------------------------

      var gifImage = function(width, height) {

        var _width = width;
        var _height = height;
        var _data = new Array(width * height);

        var _this = {};

        _this.setPixel = function(x, y, pixel) {
          _data[y * _width + x] = pixel;
        };

        _this.write = function(out) {

          //---------------------------------
          // GIF Signature

          out.writeString('GIF87a');

          //---------------------------------
          // Screen Descriptor

          out.writeShort(_width);
          out.writeShort(_height);

          out.writeByte(0x80); // 2bit
          out.writeByte(0);
          out.writeByte(0);

          //---------------------------------
          // Global Color Map

          // black
          out.writeByte(0x00);
          out.writeByte(0x00);
          out.writeByte(0x00);

          // white
          out.writeByte(0xff);
          out.writeByte(0xff);
          out.writeByte(0xff);

          //---------------------------------
          // Image Descriptor

          out.writeString(',');
          out.writeShort(0);
          out.writeShort(0);
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(0);

          //---------------------------------
          // Local Color Map

          //---------------------------------
          // Raster Data

          var lzwMinCodeSize = 2;
          var raster = getLZWRaster(lzwMinCodeSize);

          out.writeByte(lzwMinCodeSize);

          var offset = 0;

          while (raster.length - offset > 255) {
            out.writeByte(255);
            out.writeBytes(raster, offset, 255);
            offset += 255;
          }

          out.writeByte(raster.length - offset);
          out.writeBytes(raster, offset, raster.length - offset);
          out.writeByte(0x00);

          //---------------------------------
          // GIF Terminator
          out.writeString(';');
        };

        var bitOutputStream = function(out) {

          var _out = out;
          var _bitLength = 0;
          var _bitBuffer = 0;

          var _this = {};

          _this.write = function(data, length) {

            if ( (data >>> length) != 0) {
              throw new Error('length over');
            }

            while (_bitLength + length >= 8) {
              _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
              length -= (8 - _bitLength);
              data >>>= (8 - _bitLength);
              _bitBuffer = 0;
              _bitLength = 0;
            }

            _bitBuffer = (data << _bitLength) | _bitBuffer;
            _bitLength = _bitLength + length;
          };

          _this.flush = function() {
            if (_bitLength > 0) {
              _out.writeByte(_bitBuffer);
            }
          };

          return _this;
        };

        var getLZWRaster = function(lzwMinCodeSize) {

          var clearCode = 1 << lzwMinCodeSize;
          var endCode = (1 << lzwMinCodeSize) + 1;
          var bitLength = lzwMinCodeSize + 1;

          // Setup LZWTable
          var table = lzwTable();

          for (var i = 0; i < clearCode; i += 1) {
            table.add(String.fromCharCode(i) );
          }
          table.add(String.fromCharCode(clearCode) );
          table.add(String.fromCharCode(endCode) );

          var byteOut = byteArrayOutputStream();
          var bitOut = bitOutputStream(byteOut);

          // clear code
          bitOut.write(clearCode, bitLength);

          var dataIndex = 0;

          var s = String.fromCharCode(_data[dataIndex]);
          dataIndex += 1;

          while (dataIndex < _data.length) {

            var c = String.fromCharCode(_data[dataIndex]);
            dataIndex += 1;

            if (table.contains(s + c) ) {

              s = s + c;

            } else {

              bitOut.write(table.indexOf(s), bitLength);

              if (table.size() < 0xfff) {

                if (table.size() == (1 << bitLength) ) {
                  bitLength += 1;
                }

                table.add(s + c);
              }

              s = c;
            }
          }

          bitOut.write(table.indexOf(s), bitLength);

          // end code
          bitOut.write(endCode, bitLength);

          bitOut.flush();

          return byteOut.toByteArray();
        };

        var lzwTable = function() {

          var _map = {};
          var _size = 0;

          var _this = {};

          _this.add = function(key) {
            if (_this.contains(key) ) {
              throw new Error('dup key:' + key);
            }
            _map[key] = _size;
            _size += 1;
          };

          _this.size = function() {
            return _size;
          };

          _this.indexOf = function(key) {
            return _map[key];
          };

          _this.contains = function(key) {
            return typeof _map[key] != 'undefined';
          };

          return _this;
        };

        return _this;
      };

      var createImgTag = function(width, height, getPixel, alt) {

        var gif = gifImage(width, height);
        for (var y = 0; y < height; y += 1) {
          for (var x = 0; x < width; x += 1) {
            gif.setPixel(x, y, getPixel(x, y) );
          }
        }

        var b = byteArrayOutputStream();
        gif.write(b);

        var base64 = base64EncodeOutputStream();
        var bytes = b.toByteArray();
        for (var i = 0; i < bytes.length; i += 1) {
          base64.writeByte(bytes[i]);
        }
        base64.flush();

        var img = '';
        img += '<img';
        img += '\u0020src="';
        img += 'data:image/gif;base64,';
        img += base64;
        img += '"';
        img += '\u0020width="';
        img += width;
        img += '"';
        img += '\u0020height="';
        img += height;
        img += '"';
        if (alt) {
          img += '\u0020alt="';
          img += alt;
          img += '"';
        }
        img += '/>';

        return img;
      };

      //---------------------------------------------------------------------
      // returns qrcode function.

      return qrcode;
    }();

    (function (factory) {
      if (typeof define === 'function' && define.amd) {
          define([], factory);
      } else if (typeof exports === 'object') {
          module.exports = factory();
      }
    }(function () {
        return qrcode;
    }));
    //---------------------------------------------------------------------
    //
    // QR Code Generator for JavaScript UTF8 Support (optional)
    //
    // Copyright (c) 2011 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //  http://www.opensource.org/licenses/mit-license.php
    //
    // The word 'QR Code' is registered trademark of
    // DENSO WAVE INCORPORATED
    //  http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------

    !function(qrcode) {

      //---------------------------------------------------------------------
      // overwrite qrcode.stringToBytes
      //---------------------------------------------------------------------

      qrcode.stringToBytes = function(s) {
        // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
        function toUTF8Array(str) {
          var utf8 = [];
          for (var i=0; i < str.length; i++) {
            var charcode = str.charCodeAt(i);
            if (charcode < 0x80) utf8.push(charcode);
            else if (charcode < 0x800) {
              utf8.push(0xc0 | (charcode >> 6),
                  0x80 | (charcode & 0x3f));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
              utf8.push(0xe0 | (charcode >> 12),
                  0x80 | ((charcode>>6) & 0x3f),
                  0x80 | (charcode & 0x3f));
            }
            // surrogate pair
            else {
              i++;
              // UTF-16 encodes 0x10000-0x10FFFF by
              // subtracting 0x10000 and splitting the
              // 20 bits of 0x0-0xFFFFF into two halves
              charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                | (str.charCodeAt(i) & 0x3ff));
              utf8.push(0xf0 | (charcode >>18),
                  0x80 | ((charcode>>12) & 0x3f),
                  0x80 | ((charcode>>6) & 0x3f),
                  0x80 | (charcode & 0x3f));
            }
          }
          return utf8;
        }
        return toUTF8Array(s);
      };

    }(qrcode);

    return qrcode;
}()));

/*! jRespond.js v 0.10 | Author: Jeremy Fields [jeremy.fields@viget.com], 2013 | License: MIT */

// Universal Module Definition
;(function (window, name, fn) {
	// Node module pattern
    if (typeof module === "object" && module && typeof module.exports === "object") {
        module.exports = fn;
    } else {
		// browser
        window[name] = fn;

        // AMD definition
        if (typeof define === "function" && define.amd) {
            define(name, [], function (module) {
                return fn;
            });
        }
    }
}(this, 'jRespond', function(win,doc,undefined) {

	'use strict';

	return function(breakpoints) {

		// array for registered functions
		var mediaListeners = [];

		// array that corresponds to mediaListeners and holds the current on/off state
		var mediaInit = [];

		// array of media query breakpoints; adjust as needed
		var mediaBreakpoints = breakpoints;

		// store the current breakpoint
		var curr = '';

		// the previous breakpoint
		var prev = '';

		// window resize event timer stuff
		var resizeTimer;
		var resizeW = 0;
		var resizeTmrFast = 100;
		var resizeTmrSlow = 500;
		var resizeTmrSpd = resizeTmrSlow;

		// cross browser window width
		var winWidth = function() {

			var w = 0;

			// IE
			if (typeof( window.innerWidth ) != 'number') {

				if (!(document.documentElement.clientWidth === 0)) {

					// strict mode
					w = document.documentElement.clientWidth;
				} else {

					// quirks mode
					w = document.body.clientWidth;
				}
			} else {

				// w3c
				w = window.innerWidth;
			}

			return w;
		};

		// determine input type
		var addFunction = function(elm) {
			if (elm.length === undefined) {
				addToStack(elm);
			} else {
				for (var i = 0; i < elm.length; i++) {
					addToStack(elm[i]);
				}
			}
		};

		// send media to the mediaListeners array
		var addToStack = function(elm) {
			var brkpt = elm['breakpoint'];
			var entr = elm['enter'] || undefined;

			// add function to stack
			mediaListeners.push(elm);

			// add corresponding entry to mediaInit
			mediaInit.push(false);

			if (testForCurr(brkpt)) {
				if (entr !== undefined) {
					entr.call(null, {entering : curr, exiting : prev});
				}
				mediaInit[(mediaListeners.length - 1)] = true;
			}
		};

		// loops through all registered functions and determines what should be fired
		var cycleThrough = function() {

			var enterArray = [];
			var exitArray = [];

			for (var i = 0; i < mediaListeners.length; i++) {
				var brkpt = mediaListeners[i]['breakpoint'];
				var entr = mediaListeners[i]['enter'] || undefined;
				var exit = mediaListeners[i]['exit'] || undefined;

				if (brkpt === '*') {
					if (entr !== undefined) {
						enterArray.push(entr);
					}
					if (exit !== undefined) {
						exitArray.push(exit);
					}
				} else if (testForCurr(brkpt)) {
					if (entr !== undefined && !mediaInit[i]) {
						enterArray.push(entr);
					}
					mediaInit[i] = true;
				} else {
					if (exit !== undefined && mediaInit[i]) {
						exitArray.push(exit);
					}
					mediaInit[i] = false;
				}
			}

			var eventObject = {
				entering : curr,
				exiting : prev
			};

			// loop through exit functions to call
			for (var j = 0; j < exitArray.length; j++) {
				exitArray[j].call(null, eventObject);
			}

			// then loop through enter functions to call
			for (var k = 0; k < enterArray.length; k++) {
				enterArray[k].call(null, eventObject);
			}
		};

		// checks for the correct breakpoint against the mediaBreakpoints list
		var returnBreakpoint = function(width) {

			var foundBrkpt = false;

			// look for existing breakpoint based on width
			for (var i = 0; i < mediaBreakpoints.length; i++) {

				// if registered breakpoint found, break out of loop
				if (width >= mediaBreakpoints[i]['enter'] && width <= mediaBreakpoints[i]['exit']) {
					foundBrkpt = true;

					break;
				}
			}

			// if breakpoint is found and it's not the current one
			if (foundBrkpt && curr !== mediaBreakpoints[i]['label']) {
				prev = curr;
				curr = mediaBreakpoints[i]['label'];

				// run the loop
				cycleThrough();

			// or if no breakpoint applies
			} else if (!foundBrkpt && curr !== '') {
				curr = '';

				// run the loop
				cycleThrough();
			}

		};

		// takes the breakpoint/s arguement from an object and tests it against the current state
		var testForCurr = function(elm) {

			// if there's an array of breakpoints
			if (typeof elm === 'object') {
				if (elm.join().indexOf(curr) >= 0) {
					return true;
				}

			// if the string is '*' then run at every breakpoint
			} else if (elm === '*') {
				return true;

			// or if it's a single breakpoint
			} else if (typeof elm === 'string') {
				if (curr === elm) {
					return true;
				}
			}
		};

		// self-calling function that checks the browser width and delegates if it detects a change
		var checkResize = function() {

			// get current width
			var w = winWidth();

			// if there is a change speed up the timer and fire the returnBreakpoint function
			if (w !== resizeW) {
				resizeTmrSpd = resizeTmrFast;

				returnBreakpoint(w);

			// otherwise keep on keepin' on
			} else {
				resizeTmrSpd = resizeTmrSlow;
			}

			resizeW = w;

			// calls itself on a setTimeout
			setTimeout(checkResize, resizeTmrSpd);
		};
		checkResize();

		// return
		return {
			addFunc: function(elm) { addFunction(elm); },
			getBreakpoint: function() { return curr; }
		};

	};

}(this,this.document)));
/*!
 * Bootstrap v3.3.7 (http://getbootstrap.com)
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under the MIT license
 */

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}

+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.3.7
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.7'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector === '#' ? [] : selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.3.7
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.7'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d).prop(d, true)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d).prop(d, false)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target).closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
        e.preventDefault()
        // The target component still receive the focus
        if ($btn.is('input,button')) $btn.trigger('focus')
        else $btn.find('input:visible,button:visible').first().trigger('focus')
      }
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.3.7
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.7'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.7'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.7
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.7'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (document !== e.target &&
            this.$element[0] !== e.target &&
            !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.3.7
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.7'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
        that.$element
          .removeAttr('aria-describedby')
          .trigger('hidden.bs.' + that.type)
      }
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var isSvg = window.SVGElement && el instanceof window.SVGElement
    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
    // See https://github.com/twbs/bootstrap/issues/20280
    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
      that.$element = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.7
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.7'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.7
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.7'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.3.7
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.7'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.3.7
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.7'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/**
 * @license jquery.panzoom.js v3.2.2
 * Updated: Sun Aug 28 2016
 * Add pan and zoom functionality to any element
 * Copyright (c) timmy willison
 * Released under the MIT license
 * https://github.com/timmywil/jquery.panzoom/blob/master/MIT-License.txt
 */

(function(global, factory) {
	// AMD
	if (typeof define === 'function' && define.amd) {
		define([ 'jquery' ], function(jQuery) {
			return factory(global, jQuery);
		});
	// CommonJS/Browserify
	} else if (typeof exports === 'object') {
		factory(global, require('jquery'));
	// Global
	} else {
		factory(global, global.jQuery);
	}
}(typeof window !== 'undefined' ? window : this, function(window, $) {
	'use strict';

	var document = window.document;
	var datakey = '__pz__';
	var slice = Array.prototype.slice;
	var rIE11 = /trident\/7./i;
	var supportsInputEvent = (function() {
		// IE11 returns a false positive
		if (rIE11.test(navigator.userAgent)) {
			return false;
		}
		var input = document.createElement('input');
		input.setAttribute('oninput', 'return');
		return typeof input.oninput === 'function';
	})();

	// Regex
	var rupper = /([A-Z])/g;
	var rsvg = /^http:[\w\.\/]+svg$/;

	var floating = '(\\-?\\d[\\d\\.e-]*)';
	var commaSpace = '\\,?\\s*';
	var rmatrix = new RegExp(
		'^matrix\\(' +
		floating + commaSpace +
		floating + commaSpace +
		floating + commaSpace +
		floating + commaSpace +
		floating + commaSpace +
		floating + '\\)$'
	);

	/**
	 * Utility for determining transform matrix equality
	 * Checks backwards to test translation first
	 * @param {Array} first
	 * @param {Array} second
	 */
	function matrixEquals(first, second) {
		var i = first.length;
		while(--i) {
			if (Math.round(+first[i]) !== Math.round(+second[i])) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Creates the options object for reset functions
	 * @param {Boolean|Object} opts See reset methods
	 * @returns {Object} Returns the newly-created options object
	 */
	function createResetOptions(opts) {
		var options = { range: true, animate: true };
		if (typeof opts === 'boolean') {
			options.animate = opts;
		} else {
			$.extend(options, opts);
		}
		return options;
	}

	/**
	 * Represent a transformation matrix with a 3x3 matrix for calculations
	 * Matrix functions adapted from Louis Remi's jQuery.transform (https://github.com/louisremi/jquery.transform.js)
	 * @param {Array|Number} a An array of six values representing a 2d transformation matrix
	 */
	function Matrix(a, b, c, d, e, f, g, h, i) {
		if ($.type(a) === 'array') {
			this.elements = [
				+a[0], +a[2], +a[4],
				+a[1], +a[3], +a[5],
				    0,     0,     1
			];
		} else {
			this.elements = [
				a, b, c,
				d, e, f,
				g || 0, h || 0, i || 1
			];
		}
	}

	Matrix.prototype = {
		/**
		 * Multiply a 3x3 matrix by a similar matrix or a vector
		 * @param {Matrix|Vector} matrix
		 * @return {Matrix|Vector} Returns a vector if multiplying by a vector
		 */
		x: function(matrix) {
			var isVector = matrix instanceof Vector;

			var a = this.elements,
				b = matrix.elements;

			if (isVector && b.length === 3) {
				// b is actually a vector
				return new Vector(
					a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
					a[3] * b[0] + a[4] * b[1] + a[5] * b[2],
					a[6] * b[0] + a[7] * b[1] + a[8] * b[2]
				);
			} else if (b.length === a.length) {
				// b is a 3x3 matrix
				return new Matrix(
					a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
					a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
					a[0] * b[2] + a[1] * b[5] + a[2] * b[8],

					a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
					a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
					a[3] * b[2] + a[4] * b[5] + a[5] * b[8],

					a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
					a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
					a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
				);
			}
			return false; // fail
		},
		/**
		 * Generates an inverse of the current matrix
		 * @returns {Matrix}
		 */
		inverse: function() {
			var d = 1 / this.determinant(),
				a = this.elements;
			return new Matrix(
				d * ( a[8] * a[4] - a[7] * a[5]),
				d * (-(a[8] * a[1] - a[7] * a[2])),
				d * ( a[5] * a[1] - a[4] * a[2]),

				d * (-(a[8] * a[3] - a[6] * a[5])),
				d * ( a[8] * a[0] - a[6] * a[2]),
				d * (-(a[5] * a[0] - a[3] * a[2])),

				d * ( a[7] * a[3] - a[6] * a[4]),
				d * (-(a[7] * a[0] - a[6] * a[1])),
				d * ( a[4] * a[0] - a[3] * a[1])
			);
		},
		/**
		 * Calculates the determinant of the current matrix
		 * @returns {Number}
		 */
		determinant: function() {
			var a = this.elements;
			return a[0] * (a[8] * a[4] - a[7] * a[5]) - a[3] * (a[8] * a[1] - a[7] * a[2]) + a[6] * (a[5] * a[1] - a[4] * a[2]);
		}
	};

	/**
	 * Create a vector containing three values
	 */
	function Vector(x, y, z) {
		this.elements = [ x, y, z ];
	}

	/**
	 * Get the element at zero-indexed index i
	 * @param {Number} i
	 */
	Vector.prototype.e = Matrix.prototype.e = function(i) {
		return this.elements[ i ];
	};

	/**
	 * Create a Panzoom object for a given element
	 * @constructor
	 * @param {Element} elem - Element to use pan and zoom
	 * @param {Object} [options] - An object literal containing options to override default options
	 *  (See Panzoom.defaults for ones not listed below)
	 * @param {jQuery} [options.$zoomIn] - zoom in buttons/links collection (you can also bind these yourself
	 *  e.g. $button.on('click', function(e) { e.preventDefault(); $elem.panzoom('zoomIn'); });)
	 * @param {jQuery} [options.$zoomOut] - zoom out buttons/links collection on which to bind zoomOut
	 * @param {jQuery} [options.$zoomRange] - zoom in/out with this range control
	 * @param {jQuery} [options.$reset] - Reset buttons/links collection on which to bind the reset method
	 * @param {Function} [options.on[Start|Change|Zoom|Pan|End|Reset] - Optional callbacks for panzoom events
	 */
	function Panzoom(elem, options) {

		// Allow instantiation without `new` keyword
		if (!(this instanceof Panzoom)) {
			return new Panzoom(elem, options);
		}

		// Sanity checks
		if (elem.nodeType !== 1) {
			$.error('Panzoom called on non-Element node');
		}
		if (!$.contains(document, elem)) {
			$.error('Panzoom element must be attached to the document');
		}

		// Don't remake
		var d = $.data(elem, datakey);
		if (d) {
			return d;
		}

		// Extend default with given object literal
		// Each instance gets its own options
		this.options = options = $.extend({}, Panzoom.defaults, options);
		this.elem = elem;
		var $elem = this.$elem = $(elem);
		this.$set = options.$set && options.$set.length ? options.$set : $elem;
		this.$doc = $(elem.ownerDocument || document);
		this.$parent = $elem.parent();
		this.parent = this.$parent[0];

		// This is SVG if the namespace is SVG
		// However, while <svg> elements are SVG, we want to treat those like other elements
		this.isSVG = rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';

		this.panning = false;

		// Save the original transform value
		// Save the prefixed transform style key
		// Set the starting transform
		this._buildTransform();

		// Build the appropriately-prefixed transform style property name
		// De-camelcase
		this._transform = $.cssProps.transform.replace(rupper, '-$1').toLowerCase();

		// Build the transition value
		this._buildTransition();

		// Build containment dimensions
		this.resetDimensions();

		// Add zoom and reset buttons to `this`
		var $empty = $();
		var self = this;
		$.each([ '$zoomIn', '$zoomOut', '$zoomRange', '$reset' ], function(i, name) {
			self[ name ] = options[ name ] || $empty;
		});

		this.enable();

		this.scale = this.getMatrix()[0];
		this._checkPanWhenZoomed();

		// Save the instance
		$.data(elem, datakey, this);
	}

	// Attach regex for possible use (immutable)
	Panzoom.rmatrix = rmatrix;

	Panzoom.defaults = {
		// Should always be non-empty
		// Used to bind jQuery events without collisions
		// A guid is not added here as different instantiations/versions of panzoom
		// on the same element is not supported, so don't do it.
		eventNamespace: '.panzoom',

		// Whether or not to transition the scale
		transition: true,

		// Default cursor style for the element
		cursor: 'move',

		// There may be some use cases for zooming without panning or vice versa
		disablePan: false,
		disableZoom: false,

		// Pan only on the X or Y axes
		disableXAxis: false,
		disableYAxis: false,

		// Set whether you'd like to pan on left (1), middle (2), or right click (3)
		which: 1,

		// The increment at which to zoom
		// adds/subtracts to the scale each time zoomIn/Out is called
		increment: 0.3,

		// Turns on exponential zooming
		// If false, zooming will be incremented linearly
		exponential: true,

		// Pan only when the scale is greater than minScale
		panOnlyWhenZoomed: false,

		// min and max zoom scales
		minScale: 0.3,
		maxScale: 6,

		// The default step for the range input
		// Precendence: default < HTML attribute < option setting
		rangeStep: 0.05,

		// Animation duration (ms)
		duration: 200,
		// CSS easing used for scale transition
		easing: 'ease-in-out',

		// Indicate that the element should be contained within it's parent when panning
		// Note: this does not affect zooming outside of the parent
		// Set this value to 'invert' to only allow panning outside of the parent element (basically the opposite of the normal use of contain)
		// 'invert' is useful for a large panzoom element where you don't want to show anything behind it
		contain: false
	};

	Panzoom.prototype = {
		constructor: Panzoom,

		/**
		 * @returns {Panzoom} Returns the instance
		 */
		instance: function() {
			return this;
		},

		/**
		 * Enable or re-enable the panzoom instance
		 */
		enable: function() {
			// Unbind first
			this._initStyle();
			this._bind();
			this.disabled = false;
		},

		/**
		 * Disable panzoom
		 */
		disable: function() {
			this.disabled = true;
			this._resetStyle();
			this._unbind();
		},

		/**
		 * @returns {Boolean} Returns whether the current panzoom instance is disabled
		 */
		isDisabled: function() {
			return this.disabled;
		},

		/**
		 * Destroy the panzoom instance
		 */
		destroy: function() {
			this.disable();
			$.removeData(this.elem, datakey);
		},

		/**
		 * Builds the restricing dimensions from the containment element
		 * Also used with focal points
		 * Call this method whenever the dimensions of the element or parent are changed
		 */
		resetDimensions: function() {
			// Reset container properties
			this.container = this.parent.getBoundingClientRect();

			// Set element properties
			var elem = this.elem;
			// getBoundingClientRect() works with SVG, offsetWidth does not
			var dims = elem.getBoundingClientRect();
			var absScale = Math.abs(this.scale);
			this.dimensions = {
				width: dims.width,
				height: dims.height,
				left: $.css(elem, 'left', true) || 0,
				top: $.css(elem, 'top', true) || 0,
				// Borders and margins are scaled
				border: {
					top: $.css(elem, 'borderTopWidth', true) * absScale || 0,
					bottom: $.css(elem, 'borderBottomWidth', true) * absScale || 0,
					left: $.css(elem, 'borderLeftWidth', true) * absScale || 0,
					right: $.css(elem, 'borderRightWidth', true) * absScale || 0
				},
				margin: {
					top: $.css(elem, 'marginTop', true) * absScale || 0,
					left: $.css(elem, 'marginLeft', true) * absScale || 0
				}
			};
		},

		/**
		 * Return the element to it's original transform matrix
		 * @param {Boolean} [options] If a boolean is passed, animate the reset (default: true). If an options object is passed, simply pass that along to setMatrix.
		 * @param {Boolean} [options.silent] Silence the reset event
		 */
		reset: function(options) {
			options = createResetOptions(options);
			// Reset the transform to its original value
			var matrix = this.setMatrix(this._origTransform, options);
			if (!options.silent) {
				this._trigger('reset', matrix);
			}
		},

		/**
		 * Only resets zoom level
		 * @param {Boolean|Object} [options] Whether to animate the reset (default: true) or an object of options to pass to zoom()
		 */
		resetZoom: function(options) {
			options = createResetOptions(options);
			var origMatrix = this.getMatrix(this._origTransform);
			options.dValue = origMatrix[ 3 ];
			this.zoom(origMatrix[0], options);
		},

		/**
		 * Only reset panning
		 * @param {Boolean|Object} [options] Whether to animate the reset (default: true) or an object of options to pass to pan()
		 */
		resetPan: function(options) {
			var origMatrix = this.getMatrix(this._origTransform);
			this.pan(origMatrix[4], origMatrix[5], createResetOptions(options));
		},

		/**
		 * Sets a transform on the $set
		 * For SVG, the style attribute takes precedence
		 * and allows us to animate
		 * @param {String} transform
		 */
		setTransform: function(transform) {
			var $set = this.$set;
			var i = $set.length;
			while(i--) {
				$.style($set[i], 'transform', transform);

				// Support IE9-11, Edge 13-14+
				// Set attribute alongside style attribute
				// since IE and Edge do not respect style settings on SVG
				// See https://css-tricks.com/transforms-on-svg-elements/
				if (this.isSVG) {
					$set[i].setAttribute('transform', transform);
				}
			}
		},

		/**
		 * Retrieving the transform is different for SVG
		 *  (unless a style transform is already present)
		 * Uses the $set collection for retrieving the transform
		 * @param {String} [transform] Pass in an transform value (like 'scale(1.1)')
		 *  to have it formatted into matrix format for use by Panzoom
		 * @returns {String} Returns the current transform value of the element
		 */
		getTransform: function(transform) {
			var $set = this.$set;
			var transformElem = $set[0];
			if (transform) {
				this.setTransform(transform);
			} else {

				// IE and Edge still set the transform style properly
				// They just don't render it on SVG
				// So we get a correct value here
				transform = $.style(transformElem, 'transform');

				if (this.isSVG && (!transform || transform === 'none')) {
					transform = $.attr(transformElem, 'transform') || 'none';
				}
			}

			// Convert any transforms set by the user to matrix format
			// by setting to computed
			if (transform !== 'none' && !rmatrix.test(transform)) {

				// Get computed and set for next time
				this.setTransform(transform = $.css(transformElem, 'transform'));
			}

			return transform || 'none';
		},

		/**
		 * Retrieve the current transform matrix for $elem (or turn a transform into it's array values)
		 * @param {String} [transform] matrix-formatted transform value
		 * @returns {Array} Returns the current transform matrix split up into it's parts, or a default matrix
		 */
		getMatrix: function(transform) {
			var matrix = rmatrix.exec(transform || this.getTransform());
			if (matrix) {
				matrix.shift();
			}
			return matrix || [ 1, 0, 0, 1, 0, 0 ];
		},

		/**
		 * Given a matrix object, quickly set the current matrix of the element
		 * @param {Array|String} matrix
		 * @param {Object} [options]
		 * @param {Boolean|String} [options.animate] Whether to animate the transform change, or 'skip' indicating that it is unnecessary to set
		 * @param {Boolean} [options.contain] Override the global contain option
		 * @param {Boolean} [options.range] If true, $zoomRange's value will be updated.
		 * @param {Boolean} [options.silent] If true, the change event will not be triggered
		 * @returns {Array} Returns the newly-set matrix
		 */
		setMatrix: function(matrix, options) {
			if (this.disabled) { return; }
			if (!options) { options = {}; }
			// Convert to array
			if (typeof matrix === 'string') {
				matrix = this.getMatrix(matrix);
			}
			var scale = +matrix[0];
			var contain = typeof options.contain !== 'undefined' ? options.contain : this.options.contain;

			// Apply containment
			if (contain) {
				var dims = options.dims;
				if (!dims) {
					this.resetDimensions();
					dims = this.dimensions;
				}
				var spaceWLeft, spaceWRight, scaleDiff;
				var container = this.container;
				var width = dims.width;
				var height = dims.height;
				var conWidth = container.width;
				var conHeight = container.height;
				var zoomAspectW = conWidth / width;
				var zoomAspectH = conHeight / height;

				// If the element is not naturally centered,
				// assume full space right
				if (this.$parent.css('textAlign') !== 'center' || $.css(this.elem, 'display') !== 'inline') {
					// offsetWidth gets us the width without the transform
					scaleDiff = (width - this.elem.offsetWidth) / 2;
					spaceWLeft = scaleDiff - dims.border.left;
					spaceWRight = width - conWidth - scaleDiff + dims.border.right;
				} else {
					spaceWLeft = spaceWRight = ((width - conWidth) / 2);
				}
				var spaceHTop = ((height - conHeight) / 2) + dims.border.top;
				var spaceHBottom = ((height - conHeight) / 2) - dims.border.top - dims.border.bottom;

				if (contain === 'invert' || contain === 'automatic' && zoomAspectW < 1.01) {
					matrix[4] = Math.max(Math.min(matrix[4], spaceWLeft - dims.border.left), -spaceWRight);
				} else {
					matrix[4] = Math.min(Math.max(matrix[4], spaceWLeft), -spaceWRight);
				}

				if (contain === 'invert' || (contain === 'automatic' && zoomAspectH < 1.01)) {
					matrix[5] = Math.max(Math.min(matrix[5], spaceHTop - dims.border.top), -spaceHBottom);
				} else {
					matrix[5] = Math.min(Math.max(matrix[5], spaceHTop), -spaceHBottom);
				}
			}

			// Animate
			if (options.animate !== 'skip') {
				// Set transition
				this.transition(!options.animate);
			}

			// Update range element
			if (options.range) {
				this.$zoomRange.val(scale);
			}

			// Set the matrix on this.$set
			if (this.options.disableXAxis || this.options.disableYAxis) {
				var originalMatrix = this.getMatrix();
				if (this.options.disableXAxis) {
					matrix[4] = originalMatrix[4];
				}
				if (this.options.disableYAxis) {
					matrix[5] = originalMatrix[5];
				}
			}
			this.setTransform('matrix(' + matrix.join(',') + ')');

			this.scale = scale;

			// Disable/enable panning if zooming is at minimum and panOnlyWhenZoomed is true
			this._checkPanWhenZoomed(scale);

			if (!options.silent) {
				this._trigger('change', matrix);
			}

			return matrix;
		},

		/**
		 * @returns {Boolean} Returns whether the panzoom element is currently being dragged
		 */
		isPanning: function() {
			return this.panning;
		},

		/**
		 * Apply the current transition to the element, if allowed
		 * @param {Boolean} [off] Indicates that the transition should be turned off
		 */
		transition: function(off) {
			if (!this._transition) { return; }
			var transition = off || !this.options.transition ? 'none' : this._transition;
			var $set = this.$set;
			var i = $set.length;
			while(i--) {
				// Avoid reflows when zooming
				if ($.style($set[i], 'transition') !== transition) {
					$.style($set[i], 'transition', transition);
				}
			}
		},

		/**
		 * Pan the element to the specified translation X and Y
		 * Note: this is not the same as setting jQuery#offset() or jQuery#position()
		 * @param {Number} x
		 * @param {Number} y
		 * @param {Object} [options] These options are passed along to setMatrix
		 * @param {Array} [options.matrix] The matrix being manipulated (if already known so it doesn't have to be retrieved again)
		 * @param {Boolean} [options.silent] Silence the pan event. Note that this will also silence the setMatrix change event.
		 * @param {Boolean} [options.relative] Make the x and y values relative to the existing matrix
		 */
		pan: function(x, y, options) {
			if (this.options.disablePan) { return; }
			if (!options) { options = {}; }
			var matrix = options.matrix;
			if (!matrix) {
				matrix = this.getMatrix();
			}
			// Cast existing matrix values to numbers
			if (options.relative) {
				x += +matrix[4];
				y += +matrix[5];
			}
			matrix[4] = x;
			matrix[5] = y;
			this.setMatrix(matrix, options);
			if (!options.silent) {
				this._trigger('pan', matrix[4], matrix[5]);
			}
		},

		/**
		 * Zoom in/out the element using the scale properties of a transform matrix
		 * @param {Number|Boolean} [scale] The scale to which to zoom or a boolean indicating to transition a zoom out
		 * @param {Object} [opts] All global options can be overwritten by this options object. For example, override the default increment.
		 * @param {Boolean} [opts.noSetRange] Specify that the method should not set the $zoomRange value (as is the case when $zoomRange is calling zoom on change)
		 * @param {jQuery.Event|Object} [opts.focal] A focal point on the panzoom element on which to zoom.
		 *  If an object, set the clientX and clientY properties to the position relative to the parent
		 * @param {Boolean} [opts.animate] Whether to animate the zoom (defaults to true if scale is not a number, false otherwise)
		 * @param {Boolean} [opts.silent] Silence the zoom event
		 * @param {Array} [opts.matrix] Optionally pass the current matrix so it doesn't need to be retrieved
		 * @param {Number} [opts.dValue] Think of a transform matrix as four values a, b, c, d
		 *  where a/d are the horizontal/vertical scale values and b/c are the skew values
		 *  (5 and 6 of matrix array are the tx/ty transform values).
		 *  Normally, the scale is set to both the a and d values of the matrix.
		 *  This option allows you to specify a different d value for the zoom.
		 *  For instance, to flip vertically, you could set -1 as the dValue.
		 */
		zoom: function(scale, opts) {
			// Shuffle arguments
			if (typeof scale === 'object') {
				opts = scale;
				scale = null;
			} else if (!opts) {
				opts = {};
			}
			var options = $.extend({}, this.options, opts);
			// Check if disabled
			if (options.disableZoom) { return; }
			var animate = false;
			var matrix = options.matrix || this.getMatrix();
			var startScale = +matrix[0];

			// Calculate zoom based on increment
			if (typeof scale !== 'number') {
				// Just use a number a little greater than 1
				// Below 1 can use normal increments
				if (options.exponential && startScale - options.increment >= 1) {
					scale = Math[scale ? 'sqrt' : 'pow'](startScale, 2);
				} else {
					scale = startScale + (options.increment * (scale ? -1 : 1));
				}
				animate = true;
			}

			// Constrain scale
			if (scale > options.maxScale) {
				scale = options.maxScale;
			} else if (scale < options.minScale) {
				scale = options.minScale;
			}

			// Calculate focal point based on scale
			var focal = options.focal;
			if (focal && !options.disablePan) {
				// Adapted from code by Florian Günther
				// https://github.com/florianguenther/zui53
				this.resetDimensions();
				var dims = options.dims = this.dimensions;
				var clientX = focal.clientX;
				var clientY = focal.clientY;

				// Adjust the focal point for transform-origin 50% 50%
				// SVG elements have a transform origin of 0 0
				if (!this.isSVG) {
					clientX -= (dims.width / startScale) / 2;
					clientY -= (dims.height / startScale) / 2;
				}

				var clientV = new Vector(clientX, clientY, 1);
				var surfaceM = new Matrix(matrix);
				// Supply an offset manually if necessary
				var o = this.parentOffset || this.$parent.offset();
				var offsetM = new Matrix(1, 0, o.left - this.$doc.scrollLeft(), 0, 1, o.top - this.$doc.scrollTop());
				var surfaceV = surfaceM.inverse().x(offsetM.inverse().x(clientV));
				var scaleBy = scale / matrix[0];
				surfaceM = surfaceM.x(new Matrix([scaleBy, 0, 0, scaleBy, 0, 0]));
				clientV = offsetM.x(surfaceM.x(surfaceV));
				matrix[4] = +matrix[4] + (clientX - clientV.e(0));
				matrix[5] = +matrix[5] + (clientY - clientV.e(1));
			}

			// Set the scale
			matrix[0] = scale;
			matrix[3] = typeof options.dValue === 'number' ? options.dValue : scale;

			// Calling zoom may still pan the element
			this.setMatrix(matrix, {
				animate: typeof options.animate !== 'undefined' ? options.animate : animate,
				// Set the zoomRange value
				range: !options.noSetRange
			});

			// Trigger zoom event
			if (!options.silent) {
				this._trigger('zoom', matrix[0], options);
			}
		},

		/**
		 * Get/set option on an existing instance
		 * @returns {Array|undefined} If getting, returns an array of all values
		 *   on each instance for a given key. If setting, continue chaining by returning undefined.
		 */
		option: function(key, value) {
			var options;
			if (!key) {
				// Avoids returning direct reference
				return $.extend({}, this.options);
			}

			if (typeof key === 'string') {
				if (arguments.length === 1) {
					return this.options[ key ] !== undefined ?
						this.options[ key ] :
						null;
				}
				options = {};
				options[ key ] = value;
			} else {
				options = key;
			}

			this._setOptions(options);
		},

		/**
		 * Internally sets options
		 * @param {Object} options - An object literal of options to set
		 * @private
		 */
		_setOptions: function(options) {
			$.each(options, $.proxy(function(key, value) {
				switch(key) {
					case 'disablePan':
						this._resetStyle();
						/* falls through */
					case '$zoomIn':
					case '$zoomOut':
					case '$zoomRange':
					case '$reset':
					case 'disableZoom':
					case 'onStart':
					case 'onChange':
					case 'onZoom':
					case 'onPan':
					case 'onEnd':
					case 'onReset':
					case 'eventNamespace':
						this._unbind();
				}
				this.options[ key ] = value;
				switch(key) {
					case 'disablePan':
						this._initStyle();
						/* falls through */
					case '$zoomIn':
					case '$zoomOut':
					case '$zoomRange':
					case '$reset':
						// Set these on the instance
						this[ key ] = value;
						/* falls through */
					case 'disableZoom':
					case 'onStart':
					case 'onChange':
					case 'onZoom':
					case 'onPan':
					case 'onEnd':
					case 'onReset':
					case 'eventNamespace':
						this._bind();
						break;
					case 'cursor':
						$.style(this.elem, 'cursor', value);
						break;
					case 'minScale':
						this.$zoomRange.attr('min', value);
						break;
					case 'maxScale':
						this.$zoomRange.attr('max', value);
						break;
					case 'rangeStep':
						this.$zoomRange.attr('step', value);
						break;
					case 'startTransform':
						this._buildTransform();
						break;
					case 'duration':
					case 'easing':
						this._buildTransition();
						/* falls through */
					case 'transition':
						this.transition();
						break;
					case 'panOnlyWhenZoomed':
						this._checkPanWhenZoomed();
						break;
					case '$set':
						if (value instanceof $ && value.length) {
							this.$set = value;
							// Reset styles
							this._initStyle();
							this._buildTransform();
						}
				}
			}, this));
		},

		/**
		 * Disable/enable panning depending on whether the current scale
		 * matches the minimum
		 * @param {Number} [scale]
		 * @private
		 */
		_checkPanWhenZoomed: function(scale) {
			var options = this.options;
			if (options.panOnlyWhenZoomed) {
				if (!scale) {
					scale = this.getMatrix()[0];
				}
				var toDisable = scale <= options.minScale;
				if (options.disablePan !== toDisable) {
					this.option('disablePan', toDisable);
				}
			}
		},

		/**
		 * Initialize base styles for the element and its parent
		 * @private
		 */
		_initStyle: function() {
			var styles = {
				// Set the same default whether SVG or HTML
				// transform-origin cannot be changed to 50% 50% in IE9-11 or Edge 13-14+
				'transform-origin': this.isSVG ? '0 0' : '50% 50%'
			};
			// Set elem styles
			if (!this.options.disablePan) {
				styles.cursor = this.options.cursor;
			}
			this.$set.css(styles);

			// Set parent to relative if set to static
			var $parent = this.$parent;
			// No need to add styles to the body
			if ($parent.length && !$.nodeName(this.parent, 'body')) {
				styles = {
					overflow: 'hidden'
				};
				if ($parent.css('position') === 'static') {
					styles.position = 'relative';
				}
				$parent.css(styles);
			}
		},

		/**
		 * Undo any styles attached in this plugin
		 * @private
		 */
		_resetStyle: function() {
			this.$elem.css({
				'cursor': '',
				'transition': ''
			});
			this.$parent.css({
				'overflow': '',
				'position': ''
			});
		},

		/**
		 * Binds all necessary events
		 * @private
		 */
		_bind: function() {
			var self = this;
			var options = this.options;
			var ns = options.eventNamespace;
			var str_down = 'mousedown' + ns + ' pointerdown' + ns + ' MSPointerDown' + ns;
			var str_start = 'touchstart' + ns + ' ' + str_down;
			var str_click = 'touchend' + ns + ' click' + ns + ' pointerup' + ns + ' MSPointerUp' + ns;
			var events = {};
			var $reset = this.$reset;
			var $zoomRange = this.$zoomRange;

			// Bind panzoom events from options
			$.each([ 'Start', 'Change', 'Zoom', 'Pan', 'End', 'Reset' ], function() {
				var m = options[ 'on' + this ];
				if ($.isFunction(m)) {
					events[ 'panzoom' + this.toLowerCase() + ns ] = m;
				}
			});

			// Bind $elem drag and click/touchdown events
			// Bind touchstart if either panning or zooming is enabled
			if (!options.disablePan || !options.disableZoom) {
				events[ str_start ] = function(e) {
					var touches;
					if (e.type === 'touchstart' ?
						// Touch
						(touches = e.touches || e.originalEvent.touches) &&
							((touches.length === 1 && !options.disablePan) || touches.length === 2) :
						// Mouse/Pointer: Ignore unexpected click types
						// Support: IE10 only
						// IE10 does not support e.button for MSPointerDown, but does have e.which
						!options.disablePan && (e.which || e.originalEvent.which) === options.which) {

						e.preventDefault();
						e.stopPropagation();
						self._startMove(e, touches);
					}
				};
				// Prevent the contextmenu event
				// if we're binding to right-click
				if (options.which === 3) {
					events.contextmenu = false;
				}
			}
			this.$elem.on(events);

			// Bind reset
			if ($reset.length) {
				$reset.on(str_click, function(e) {
					e.preventDefault();
					self.reset();
				});
			}

			// Set default attributes for the range input
			if ($zoomRange.length) {
				$zoomRange.attr({
					// Only set the range step if explicit or
					// set the default if there is no attribute present
					step: options.rangeStep === Panzoom.defaults.rangeStep &&
						$zoomRange.attr('step') ||
						options.rangeStep,
					min: options.minScale,
					max: options.maxScale
				}).prop({
					value: this.getMatrix()[0]
				});
			}

			// No bindings if zooming is disabled
			if (options.disableZoom) {
				return;
			}

			var $zoomIn = this.$zoomIn;
			var $zoomOut = this.$zoomOut;

			// Bind zoom in/out
			// Don't bind one without the other
			if ($zoomIn.length && $zoomOut.length) {
				// preventDefault cancels future mouse events on touch events
				$zoomIn.on(str_click, function(e) {
					e.preventDefault();
					self.zoom();
				});
				$zoomOut.on(str_click, function(e) {
					e.preventDefault();
					self.zoom(true);
				});
			}

			if ($zoomRange.length) {
				events = {};
				// Cannot prevent default action here
				events[ str_down ] = function() {
					self.transition(true);
				};
				// Zoom on input events if available and change events
				// See https://github.com/timmywil/jquery.panzoom/issues/90
				events[ (supportsInputEvent ? 'input' : 'change') + ns ] = function() {
					self.zoom(+this.value, { noSetRange: true });
				};
				$zoomRange.on(events);
			}
		},

		/**
		 * Unbind all events
		 * @private
		 */
		_unbind: function() {
			this.$elem
				.add(this.$zoomIn)
				.add(this.$zoomOut)
				.add(this.$reset)
				.off(this.options.eventNamespace);
		},

		/**
		 * Builds the original transform value
		 * @private
		 */
		_buildTransform: function() {
			// Save the original transform
			// Retrieving this also adds the correct prefixed style name
			// to jQuery's internal $.cssProps
			return this._origTransform = this.getTransform(this.options.startTransform);
		},

		/**
		 * Set transition property for later use when zooming
		 * @private
		 */
		_buildTransition: function() {
			if (this._transform) {
				var options = this.options;
				this._transition = this._transform + ' ' + options.duration + 'ms ' + options.easing;
			}
		},

		/**
		 * Calculates the distance between two touch points
		 * Remember pythagorean?
		 * @param {Array} touches
		 * @returns {Number} Returns the distance
		 * @private
		 */
		_getDistance: function(touches) {
			var touch1 = touches[0];
			var touch2 = touches[1];
			return Math.sqrt(Math.pow(Math.abs(touch2.clientX - touch1.clientX), 2) + Math.pow(Math.abs(touch2.clientY - touch1.clientY), 2));
		},

		/**
		 * Constructs an approximated point in the middle of two touch points
		 * @returns {Object} Returns an object containing pageX and pageY
		 * @private
		 */
		_getMiddle: function(touches) {
			var touch1 = touches[0];
			var touch2 = touches[1];
			return {
				clientX: ((touch2.clientX - touch1.clientX) / 2) + touch1.clientX,
				clientY: ((touch2.clientY - touch1.clientY) / 2) + touch1.clientY
			};
		},

		/**
		 * Trigger a panzoom event on our element
		 * The event is passed the Panzoom instance
		 * @param {String|jQuery.Event} event
		 * @param {Mixed} arg1[, arg2, arg3, ...] Arguments to append to the trigger
		 * @private
		 */
		_trigger: function (event) {
			if (typeof event === 'string') {
				event = 'panzoom' + event;
			}
			this.$elem.triggerHandler(event, [this].concat(slice.call(arguments, 1)));
		},

		/**
		 * Starts the pan
		 * This is bound to mouse/touchmove on the element
		 * @param {jQuery.Event} event An event with pageX, pageY, and possibly the touches list
		 * @param {TouchList} [touches] The touches list if present
		 * @private
		 */
		_startMove: function(event, touches) {
			if (this.panning) {
				return;
			}
			var moveEvent, endEvent,
				startDistance, startScale, startMiddle,
				startPageX, startPageY, touch;
			var self = this;
			var options = this.options;
			var ns = options.eventNamespace;
			var matrix = this.getMatrix();
			var original = matrix.slice(0);
			var origPageX = +original[4];
			var origPageY = +original[5];
			var panOptions = { matrix: matrix, animate: 'skip' };
			var type = event.type;

			// Use proper events
			if (type === 'pointerdown') {
				moveEvent = 'pointermove';
				endEvent = 'pointerup';
			} else if (type === 'touchstart') {
				moveEvent = 'touchmove';
				endEvent = 'touchend';
			} else if (type === 'MSPointerDown') {
				moveEvent = 'MSPointerMove';
				endEvent = 'MSPointerUp';
			} else {
				moveEvent = 'mousemove';
				endEvent = 'mouseup';
			}

			// Add namespace
			moveEvent += ns;
			endEvent += ns;

			// Remove any transitions happening
			this.transition(true);

			// Indicate that we are currently panning
			this.panning = true;

			// Trigger start event
			this._trigger('start', event, touches);

			var setStart = function(event, touches) {
				if (touches) {
					if (touches.length === 2) {
						if (startDistance != null) {
							return;
						}
						startDistance = self._getDistance(touches);
						startScale = +matrix[0];
						startMiddle = self._getMiddle(touches);
						return;
					}
					if (startPageX != null) {
						return;
					}
					if ((touch = touches[0])) {
						startPageX = touch.pageX;
						startPageY = touch.pageY;
					}
				}
				if (startPageX != null) {
					return;
				}
				startPageX = event.pageX;
				startPageY = event.pageY;
			};

			setStart(event, touches);

			var move = function(e) {
				var coords;
				e.preventDefault();
				touches = e.touches || e.originalEvent.touches;
				setStart(e, touches);

				if (touches) {
					if (touches.length === 2) {

						// Calculate move on middle point
						var middle = self._getMiddle(touches);
						var diff = self._getDistance(touches) - startDistance;

						// Set zoom
						self.zoom(diff * (options.increment / 100) + startScale, {
							focal: middle,
							matrix: matrix,
							animate: 'skip'
						});

						// Set pan
						self.pan(
							+matrix[4] + middle.clientX - startMiddle.clientX,
							+matrix[5] + middle.clientY - startMiddle.clientY,
							panOptions
						);
						startMiddle = middle;
						return;
					}
					coords = touches[0] || { pageX: 0, pageY: 0 };
				}

				if (!coords) {
					coords = e;
				}

				self.pan(
					origPageX + coords.pageX - startPageX,
					origPageY + coords.pageY - startPageY,
					panOptions
				);
			};

			// Bind the handlers
			$(document)
				.off(ns)
				.on(moveEvent, move)
				.on(endEvent, function(e) {
					e.preventDefault();
					// Unbind all document events
					$(this).off(ns);
					self.panning = false;
					// Trigger our end event
					// Simply set the type to "panzoomend" to pass through all end properties
					// jQuery's `not` is used here to compare Array equality
					e.type = 'panzoomend';
					self._trigger(e, matrix, !matrixEquals(matrix, original));
				});
		}
	};

	// Add Panzoom as a static property
	$.Panzoom = Panzoom;

	/**
	 * Extend jQuery
	 * @param {Object|String} options - The name of a method to call on the prototype
	 *  or an object literal of options
	 * @returns {jQuery|Mixed} jQuery instance for regular chaining or the return value(s) of a panzoom method call
	 */
	$.fn.panzoom = function(options) {
		var instance, args, m, ret;

		// Call methods widget-style
		if (typeof options === 'string') {
			ret = [];
			args = slice.call(arguments, 1);
			this.each(function() {
				instance = $.data(this, datakey);

				if (!instance) {
					ret.push(undefined);

				// Ignore methods beginning with `_`
				} else if (options.charAt(0) !== '_' &&
					typeof (m = instance[ options ]) === 'function' &&
					// If nothing is returned, do not add to return values
					(m = m.apply(instance, args)) !== undefined) {

					ret.push(m);
				}
			});

			// Return an array of values for the jQuery instances
			// Or the value itself if there is only one
			// Or keep chaining
			return ret.length ?
				(ret.length === 1 ? ret[0] : ret) :
				this;
		}

		return this.each(function() { new Panzoom(this, options); });
	};

	return Panzoom;
}));

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js
// ==/ClosureCompiler==

/**
 * @name MarkerClusterer for Google Maps v3
 * @version version 1.0
 * @author Luke Mahe
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of
 * markers.
 * <br/>
 * This is a v3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >v2 MarkerClusterer</a>.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A Marker Clusterer that clusters markers.
 *
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
 *   the cluster.
 * @param {Object=} opt_options support the following options:
 *     'gridSize': (number) The grid size of a cluster in pixels.
 *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
 *                cluster.
 *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
 *                    cluster is to zoom into it.
 *     'averageCenter': (boolean) Wether the center of each cluster should be
 *                      the average of all markers in the cluster.
 *     'minimumClusterSize': (number) The minimum number of markers to be in a
 *                           cluster before the markers are hidden and a count
 *                           is shown.
 *     'styles': (object) An object that has style properties:
 *       'url': (string) The image url.
 *       'height': (number) The image height.
 *       'width': (number) The image width.
 *       'anchor': (Array) The anchor position of the label text.
 *       'textColor': (string) The text color.
 *       'textSize': (number) The text size.
 *       'backgroundPosition': (string) The position of the backgound x, y.
 *       'iconAnchor': (Array) The anchor position of the icon x, y.
 * @constructor
 * @extends google.maps.OverlayView
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);
  this.map_ = map;

  /**
   * @type {Array.<google.maps.Marker>}
   * @private
   */
  this.markers_ = [];

  /**
   *  @type {Array.<Cluster>}
   */
  this.clusters_ = [];

  this.sizes = [53, 56, 66, 78, 90];

  /**
   * @private
   */
  this.styles_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.ready_ = false;

  var options = opt_options || {};

  /**
   * @type {number}
   * @private
   */
  this.gridSize_ = options['gridSize'] || 60;

  /**
   * @private
   */
  this.minClusterSize_ = options['minimumClusterSize'] || 2;


  /**
   * @type {?number}
   * @private
   */
  this.maxZoom_ = options['maxZoom'] || null;

  this.styles_ = options['styles'] || [];

  /**
   * @type {string}
   * @private
   */
  this.imagePath_ = options['imagePath'] ||
      this.MARKER_CLUSTER_IMAGE_PATH_;

  /**
   * @type {string}
   * @private
   */
  this.imageExtension_ = options['imageExtension'] ||
      this.MARKER_CLUSTER_IMAGE_EXTENSION_;

  /**
   * @type {boolean}
   * @private
   */
  this.zoomOnClick_ = true;

  if (options['zoomOnClick'] != undefined) {
    this.zoomOnClick_ = options['zoomOnClick'];
  }

  /**
   * @type {boolean}
   * @private
   */
  this.averageCenter_ = false;

  if (options['averageCenter'] != undefined) {
    this.averageCenter_ = options['averageCenter'];
  }

  this.setupStyles_();

  this.setMap(map);

  /**
   * @type {number}
   * @private
   */
  this.prevZoom_ = this.map_.getZoom();

  // Add the map event listeners
  var that = this;
  google.maps.event.addListener(this.map_, 'zoom_changed', function() {
    var zoom = that.map_.getZoom();

    if (that.prevZoom_ != zoom) {
      that.prevZoom_ = zoom;
      that.resetViewport();
    }
  });

  google.maps.event.addListener(this.map_, 'idle', function() {
    that.redraw();
  });

  // Finally, add the markers
  if (opt_markers && opt_markers.length) {
    this.addMarkers(opt_markers, false);
  }
}


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ =
    'http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/' +
    'images/m';


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';


/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function(obj1, obj2) {
  return (function(object) {
    for (var property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function() {
  this.setReady_(true);
};

/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function() {};

/**
 * Sets up the styles object.
 *
 * @private
 */
MarkerClusterer.prototype.setupStyles_ = function() {
  if (this.styles_.length) {
    return;
  }

  for (var i = 0, size; size = this.sizes[i]; i++) {
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
      height: size,
      width: size
    });
  }
};

/**
 *  Fit the map to the bounds of the markers in the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function() {
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }

  this.map_.fitBounds(bounds);
};


/**
 *  Sets the styles.
 *
 *  @param {Object} styles The style to set.
 */
MarkerClusterer.prototype.setStyles = function(styles) {
  this.styles_ = styles;
};


/**
 *  Gets the styles.
 *
 *  @return {Object} The styles object.
 */
MarkerClusterer.prototype.getStyles = function() {
  return this.styles_;
};


/**
 * Whether zoom on click is set.
 *
 * @return {boolean} True if zoomOnClick_ is set.
 */
MarkerClusterer.prototype.isZoomOnClick = function() {
  return this.zoomOnClick_;
};

/**
 * Whether average center is set.
 *
 * @return {boolean} True if averageCenter_ is set.
 */
MarkerClusterer.prototype.isAverageCenter = function() {
  return this.averageCenter_;
};


/**
 *  Returns the array of markers in the clusterer.
 *
 *  @return {Array.<google.maps.Marker>} The markers.
 */
MarkerClusterer.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 *  Returns the number of markers in the clusterer
 *
 *  @return {Number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function() {
  return this.markers_.length;
};


/**
 *  Sets the max zoom for the clusterer.
 *
 *  @param {number} maxZoom The max zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Gets the max zoom for the clusterer.
 *
 *  @return {number} The max zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function() {
  return this.maxZoom_;
};


/**
 *  The function for calculating the cluster icon image.
 *
 *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
 *  @param {number} numStyles The number of styles available.
 *  @return {Object} A object properties: 'text' (string) and 'index' (number).
 *  @private
 */
MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
  var index = 0;
  var count = markers.length;
  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index
  };
};


/**
 * Set the calculator function.
 *
 * @param {function(Array, number)} calculator The function to set as the
 *     calculator. The function should return a object properties:
 *     'text' (string) and 'index' (number).
 *
 */
MarkerClusterer.prototype.setCalculator = function(calculator) {
  this.calculator_ = calculator;
};


/**
 * Get the calculator function.
 *
 * @return {function(Array, number)} the calculator function.
 */
MarkerClusterer.prototype.getCalculator = function() {
  return this.calculator_;
};


/**
 * Add an array of markers to the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
  for (var i = 0, marker; marker = markers[i]; i++) {
    this.pushMarkerTo_(marker);
  }
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
  marker.isAdded = false;
  if (marker['draggable']) {
    // If the marker is draggable add a listener so we update the clusters on
    // the drag end.
    var that = this;
    google.maps.event.addListener(marker, 'dragend', function() {
      marker.isAdded = false;
      that.repaint();
    });
  }
  this.markers_.push(marker);
};


/**
 * Adds a marker to the clusterer and redraws if needed.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Removes a marker and returns true if removed, false if not
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 * @private
 */
MarkerClusterer.prototype.removeMarker_ = function(marker) {
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        index = i;
        break;
      }
    }
  }

  if (index == -1) {
    // Marker is not in our list of markers.
    return false;
  }

  marker.setMap(null);

  this.markers_.splice(index, 1);

  return true;
};


/**
 * Remove a marker from the cluster.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 * @return {boolean} True if the marker was removed.
 */
MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  } else {
   return false;
  }
};


/**
 * Removes an array of markers from the cluster.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 */
MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
  var removed = false;

  for (var i = 0, marker; marker = markers[i]; i++) {
    var r = this.removeMarker_(marker);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  }
};


/**
 * Sets the clusterer's ready state.
 *
 * @param {boolean} ready The state.
 * @private
 */
MarkerClusterer.prototype.setReady_ = function(ready) {
  if (!this.ready_) {
    this.ready_ = ready;
    this.createClusters_();
  }
};


/**
 * Returns the number of clusters in the clusterer.
 *
 * @return {number} The number of clusters.
 */
MarkerClusterer.prototype.getTotalClusters = function() {
  return this.clusters_.length;
};


/**
 * Returns the google map that the clusterer is associated with.
 *
 * @return {google.maps.Map} The map.
 */
MarkerClusterer.prototype.getMap = function() {
  return this.map_;
};


/**
 * Sets the google map that the clusterer is associated with.
 *
 * @param {google.maps.Map} map The map.
 */
MarkerClusterer.prototype.setMap = function(map) {
  this.map_ = map;
};


/**
 * Returns the size of the grid.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function() {
  return this.gridSize_;
};


/**
 * Sets the size of the grid.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setGridSize = function(size) {
  this.gridSize_ = size;
};


/**
 * Returns the min cluster size.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getMinClusterSize = function() {
  return this.minClusterSize_;
};

/**
 * Sets the min cluster size.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setMinClusterSize = function(size) {
  this.minClusterSize_ = size;
};


/**
 * Extends a bounds object by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 */
MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Determins if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 * @private
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Clears all clusters and markers from the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function() {
  this.resetViewport(true);

  // Set the markers a empty array.
  this.markers_ = [];
};


/**
 * Clears all existing clusters and recreates them.
 * @param {boolean} opt_hide To also hide the marker.
 */
MarkerClusterer.prototype.resetViewport = function(opt_hide) {
  // Remove all the clusters
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    cluster.remove();
  }

  // Reset the markers to not be added and to be invisible.
  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }

  this.clusters_ = [];
};

/**
 *
 */
MarkerClusterer.prototype.repaint = function() {
  var oldClusters = this.clusters_.slice();
  this.clusters_.length = 0;
  this.resetViewport();
  this.redraw();

  // Remove the old clusters.
  // Do it in a timeout so the other clusters have been drawn first.
  window.setTimeout(function() {
    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
      cluster.remove();
    }
  }, 0);
};


/**
 * Redraws the clusters.
 */
MarkerClusterer.prototype.redraw = function() {
  this.createClusters_();
};


/**
 * Calculates the distance between two latlng locations in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @private
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
  if (!p1 || !p2) {
    return 0;
  }

  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Add a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  var pos = marker.getPosition();
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    var center = cluster.getCenter();
    if (center) {
      var d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    var cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters.
 *
 * @private
 */
MarkerClusterer.prototype.createClusters_ = function() {
  if (!this.ready_) {
    return;
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
      this.map_.getBounds().getNorthEast());
  var bounds = this.getExtendedBounds(mapBounds);

  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      this.addToClosestCluster_(marker);
    }
  }
};


/**
 * A cluster that contains markers.
 *
 * @param {MarkerClusterer} markerClusterer The markerclusterer that this
 *     cluster is associated with.
 * @constructor
 * @ignore
 */
function Cluster(markerClusterer) {
  this.markerClusterer_ = markerClusterer;
  this.map_ = markerClusterer.getMap();
  this.gridSize_ = markerClusterer.getGridSize();
  this.minClusterSize_ = markerClusterer.getMinClusterSize();
  this.averageCenter_ = markerClusterer.isAverageCenter();
  this.center_ = null;
  this.markers_ = [];
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
      markerClusterer.getGridSize());
}

/**
 * Determins if a marker is already added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker is already added.
 */
Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) != -1;
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        return true;
      }
    }
  }
  return false;
};


/**
 * Add a marker the cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @return {boolean} True if the marker was added.
 */
Cluster.prototype.addMarker = function(marker) {
  if (this.isMarkerAlreadyAdded(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  var len = this.markers_.length;
  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {
    // Min cluster size not reached so show the marker.
    marker.setMap(this.map_);
  }

  if (len == this.minClusterSize_) {
    // Hide the markers that were showing.
    for (var i = 0; i < len; i++) {
      this.markers_[i].setMap(null);
    }
  }

  if (len >= this.minClusterSize_) {
    marker.setMap(null);
  }

  this.updateIcon();
  return true;
};


/**
 * Returns the marker clusterer that the cluster is associated with.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 */
Cluster.prototype.getMarkerClusterer = function() {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 */
Cluster.prototype.getBounds = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster
 */
Cluster.prototype.remove = function() {
  this.clusterIcon_.remove();
  this.markers_.length = 0;
  delete this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {number} The cluster center.
 */
Cluster.prototype.getSize = function() {
  return this.markers_.length;
};


/**
 * Returns the center of the cluster.
 *
 * @return {Array.<google.maps.Marker>} The cluster center.
 */
Cluster.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {google.maps.LatLng} The cluster center.
 */
Cluster.prototype.getCenter = function() {
  return this.center_;
};


/**
 * Calculated the extended bounds of the cluster with the grid.
 *
 * @private
 */
Cluster.prototype.calculateBounds_ = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Determines if a marker lies in the clusters bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 */
Cluster.prototype.isMarkerInClusterBounds = function(marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Returns the map that the cluster is associated with.
 *
 * @return {google.maps.Map} The map.
 */
Cluster.prototype.getMap = function() {
  return this.map_;
};


/**
 * Updates the cluster icon
 */
Cluster.prototype.updateIcon = function() {
  var zoom = this.map_.getZoom();
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz && zoom > mz) {
    // The zoom is greater than our max zoom so show all the markers in cluster.
    for (var i = 0, marker; marker = this.markers_[i]; i++) {
      marker.setMap(this.map_);
    }
    return;
  }

  if (this.markers_.length < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.setSums(sums);
  this.clusterIcon_.show();
};


/**
 * A cluster icon
 *
 * @param {Cluster} cluster The cluster to be associated with.
 * @param {Object} styles An object that has style properties:
 *     'url': (string) The image url.
 *     'height': (number) The image height.
 *     'width': (number) The image width.
 *     'anchor': (Array) The anchor position of the label text.
 *     'textColor': (string) The text color.
 *     'textSize': (number) The text size.
 *     'backgroundPosition: (string) The background postition x, y.
 * @param {number=} opt_padding Optional padding to apply to the cluster icon.
 * @constructor
 * @extends google.maps.OverlayView
 * @ignore
 */
function ClusterIcon(cluster, styles, opt_padding) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.styles_ = styles;
  this.padding_ = opt_padding || 0;
  this.cluster_ = cluster;
  this.center_ = null;
  this.map_ = cluster.getMap();
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(this.map_);
}


/**
 * Triggers the clusterclick event and zoom's if the option is set.
 */
ClusterIcon.prototype.triggerClusterClick = function() {
  var markerClusterer = this.cluster_.getMarkerClusterer();

  // Trigger the clusterclick event.
  google.maps.event.trigger(markerClusterer, 'clusterclick', this.cluster_);

  if (markerClusterer.isZoomOnClick()) {
    // Zoom into the cluster.
    this.map_.fitBounds(this.cluster_.getBounds());
  }
};


/**
 * Adding the cluster icon to the dom.
 * @ignore
 */
ClusterIcon.prototype.onAdd = function() {
  this.div_ = document.createElement('DIV');
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.innerHTML = this.sums_.text;
  }

  var panes = this.getPanes();
  panes.overlayMouseTarget.appendChild(this.div_);

  var that = this;
  google.maps.event.addDomListener(this.div_, 'click', function() {
    that.triggerClusterClick();
  });
};


/**
 * Returns the position to place the div dending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 * @private
 */
ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);

  if (typeof this.iconAnchor_ === 'object' && this.iconAnchor_.length === 2) {
    pos.x -= this.iconAnchor_[0];
    pos.y -= this.iconAnchor_[1];
  } else {
    pos.x -= parseInt(this.width_ / 2, 10);
    pos.y -= parseInt(this.height_ / 2, 10);
  }
  return pos;
};


/**
 * Draw the icon.
 * @ignore
 */
ClusterIcon.prototype.draw = function() {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + 'px';
    this.div_.style.left = pos.x + 'px';
  }
};


/**
 * Hide the icon.
 */
ClusterIcon.prototype.hide = function() {
  if (this.div_) {
    this.div_.style.display = 'none';
  }
  this.visible_ = false;
};


/**
 * Position and show the icon.
 */
ClusterIcon.prototype.show = function() {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.style.display = '';
  }
  this.visible_ = true;
};


/**
 * Remove the icon from the map
 */
ClusterIcon.prototype.remove = function() {
  this.setMap(null);
};


/**
 * Implementation of the onRemove interface.
 * @ignore
 */
ClusterIcon.prototype.onRemove = function() {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Set the sums of the icon.
 *
 * @param {Object} sums The sums containing:
 *   'text': (string) The text to display in the icon.
 *   'index': (number) The style index of the icon.
 */
ClusterIcon.prototype.setSums = function(sums) {
  this.sums_ = sums;
  this.text_ = sums.text;
  this.index_ = sums.index;
  if (this.div_) {
    this.div_.innerHTML = sums.text;
  }

  this.useStyle();
};


/**
 * Sets the icon to the the styles.
 */
ClusterIcon.prototype.useStyle = function() {
  var index = Math.max(0, this.sums_.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style['url'];
  this.height_ = style['height'];
  this.width_ = style['width'];
  this.textColor_ = style['textColor'];
  this.anchor_ = style['anchor'];
  this.textSize_ = style['textSize'];
  this.backgroundPosition_ = style['backgroundPosition'];
  this.iconAnchor_ = style['iconAnchor'];
};


/**
 * Sets the center of the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function(center) {
  this.center_ = center;
};


/**
 * Create the css text based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position.
 * @return {string} The css style text.
 */
ClusterIcon.prototype.createCss = function(pos) {
  var style = [];
  style.push('background-image:url(' + this.url_ + ');');
  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
  style.push('background-position:' + backgroundPosition + ';');

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
        this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
          'px; padding-top:' + this.anchor_[0] + 'px;');
    } else if (typeof this.anchor_[0] === 'number' && this.anchor_[0] < 0 &&
        -this.anchor_[0] < this.height_) {
      style.push('height:' + this.height_ + 'px; line-height:' + (this.height_ + this.anchor_[0]) +
          'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
          'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
        this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
          'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  var txtColor = this.textColor_ ? this.textColor_ : 'black';
  var txtSize = this.textSize_ ? this.textSize_ : 11;

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');
  return style.join('');
};


// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
window['MarkerClusterer'] = MarkerClusterer;
MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;
MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;
MarkerClusterer.prototype['clearMarkers'] =
    MarkerClusterer.prototype.clearMarkers;
MarkerClusterer.prototype['fitMapToMarkers'] =
    MarkerClusterer.prototype.fitMapToMarkers;
MarkerClusterer.prototype['getCalculator'] =
    MarkerClusterer.prototype.getCalculator;
MarkerClusterer.prototype['getGridSize'] =
    MarkerClusterer.prototype.getGridSize;
MarkerClusterer.prototype['getExtendedBounds'] =
    MarkerClusterer.prototype.getExtendedBounds;
MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;
MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;
MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;
MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;
MarkerClusterer.prototype['getTotalClusters'] =
    MarkerClusterer.prototype.getTotalClusters;
MarkerClusterer.prototype['getTotalMarkers'] =
    MarkerClusterer.prototype.getTotalMarkers;
MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;
MarkerClusterer.prototype['removeMarker'] =
    MarkerClusterer.prototype.removeMarker;
MarkerClusterer.prototype['removeMarkers'] =
    MarkerClusterer.prototype.removeMarkers;
MarkerClusterer.prototype['resetViewport'] =
    MarkerClusterer.prototype.resetViewport;
MarkerClusterer.prototype['repaint'] =
    MarkerClusterer.prototype.repaint;
MarkerClusterer.prototype['setCalculator'] =
    MarkerClusterer.prototype.setCalculator;
MarkerClusterer.prototype['setGridSize'] =
    MarkerClusterer.prototype.setGridSize;
MarkerClusterer.prototype['setMaxZoom'] =
    MarkerClusterer.prototype.setMaxZoom;
MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;
MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;

Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;
Cluster.prototype['getSize'] = Cluster.prototype.getSize;
Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;

ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;
ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;
ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;

// Class loading
Cube = (typeof Cube === 'object') ? Cube : {};
Cube.Gallery = (typeof Cube.Gallery === 'object') ? Cube.Gallery : {};
Cube.Gallery.Gallery = (typeof Cube.Gallery.Gallery === 'object') ? Cube.Gallery.Gallery : {};


// Object parameters
Cube.Gallery.Gallery = function (selector) {
	this.selector = selector;
	this.mobile = false;
	this.mobileMaxWidth = decathlon.uxBreakpoints.xsMax;
	this.touchstart = {x:0, y:0};
    this.vertical = false;
	this.caller = null;
	this.imageExpand = false; // If 'true', force 'viewerImagePadding' to '0' 
	this.viewerImagePadding = 80;
	this.categoryThumbSize = 76;
	this.categoryGemSize = 20;
	this.mediaThumbSize = 100;
	this.categoryId = 'picture';
	this.imageFolder = './img/';
	this.videoLink = 'https://players.brightcove.net/$accountId/$playerId_default/index.html?videoId=$videoId&width=$width&height=$height&autoPlay=true&secureConnections=true&secureHTMLConnections=true';
	this.sizeIcon = 100;
	this.sizeSmall = 250;
	this.sizeMedium = 550;
	this.sizeLarge = 1200;
};


// Object methods
Cube.Gallery.Gallery.prototype = {

	setFolder: function(folder)
	{
		this.imageFolder = folder;
	},

	openGallery: function(callback)
	{
		callback = (typeof callback === 'function') ? callback : function() {};
		var that = this;
		var mediaMaxLevel = this.maxLevel();

		// Hide panels and tools before animation
		this.bodyOverflow = jQuery('body').css('overflow-x');
		jQuery('body').css('overflow', 'hidden');
		that.getPanel('category').hide();
		that.getPanel('media').hide();
		that.getPanel('viewer').hide();
		that.getPanel('viewer').find('.gallery-viewer').hide();
		that.getPanel('viewer').find('.gallery-viewer.' + that.categoryId).show();
		that.getTools().hide();

		// Open gallery and animate
		var direction = this.vertical ? 'down' : 'left';
		that.getGallery().show();
		
		that.openPanel('viewer', null, {type:'scale', duration:500, easing:'swing'}, function() {
			that.openPanel('category', null, {type:'slide', direction:direction, duration:300, easing:'easeOutQuint'}, function() {
				that.openPanel('media', null, {type:'slide', direction:direction, duration:(mediaMaxLevel * 300), easing:'easeOutQuint'}, function() {
					// Only create video iframe if required
						if (that.getPanel('media').find('ul.video li').length > 0) {
						that.createVideoIframe();
					}
					that.showTools();
				});
			});
		});
	},

	createVideoIframe: function()
	{
		var media = this.getPanel('media').find('ul.video li.active').first();
		if (this.getPanel('media').find('ul.video li.active').length < 1) {
			media = this.getPanel('media').find('ul.video li').first();
		}
		var iframe = '<iframe src="" frameborder="0" allowfullscreen></iframe>';
		this.getPanel('viewer').find('.gallery-viewer.video .viewer-box').html(iframe);
		this.loadVideoIframe(media.data('media'), media.data('player'), media.data('account'));
	},

	removeVideoIframe: function()
	{
		this.getPanel('viewer').find('.gallery-viewer.video .viewer-box').html('');
	},

	loadVideoIframe: function(videoId, playerId, accountId) {
		var width = jQuery(window).width();
		var height = jQuery(window).height();

		// Reduce viewer depending on Menu panel
		if (!this.vertical) {
			width -= this.categoryThumbSize;
			if (this.hasLevel(1)) {
				width -= this.mediaThumbSize;
			}
		} else {
			height -= this.categoryThumbSize;
			if (this.hasLevel(1)) {
				height -= this.mediaThumbSize;
			}
		}

		// Add border if required
		if (!this.imageExpand && !this.mobile) {
			width = width - (2 * this.viewerImagePadding);
			height = height - (2 * this.viewerImagePadding);
		}

		// Generate iframe src
		var src = this.videoLink.replace('$videoId', videoId);
		src = src.replace('$playerId', playerId);
		src = src.replace('$accountId', accountId);
		src = src.replace('$width', width);
		src = src.replace('$height', height);

		// Update iframe src
		if (this.categoryId === 'video') {
			this.getPanel('viewer').find('.gallery-viewer.video .viewer-box iframe').attr('src', src);
		}
	},
	
	unloadVideoIframe: function(videoId, playerId) {
		this.getPanel('viewer').find('.gallery-viewer.video .viewer-box iframe').attr('src', '');
	},

	closeGallery: function(callback)
	{
		var that = this;
		callback = (typeof callback === 'function') ? callback : function() {};
		that.removeVideoIframe();
		jQuery('body').css('overflow-x', this.bodyOverflow);
		this.getGallery().hide('scale', 500, function() {callback();});
		this.removeNavigation();
	},

	openPanel: function(panel, params, animation, callback)
	{
		panel = (panel !== null) ? panel : 'viewer';
		params = (typeof params === 'object' && params !== null) ? params : {};
		animation = (typeof animation === 'object' && animation !== null) ? animation : {};
		animation.type = (typeof animation.type !== 'undefined') ? animation.type : 'fade';
		animation.direction = (typeof animation.direction !== 'undefined') ? animation.direction : 'right';
        animation.duration = (typeof animation.duration !== 'undefined') ? animation.duration : 500;
		animation.easing = (typeof animation.easing !== 'undefined') ? animation.easing : 'swing';
		callback = (typeof callback === 'function') ? callback : function() {};

		// Animation options
		animation.options = {};
		animation.options.easing = animation.easing;
        animation.options.direction = animation.direction;

		// Scale from caller center
		if ((animation.type == 'scale') && (this.caller !== null)) {
			var offset = jQuery(this.caller).offset();
			var width = jQuery(this.caller).width();
			var height = jQuery(this.caller).height();

			var x = Math.round(offset.left + width / 2);
            if (!this.vertical) {
                x = x - this.categoryThumbSize;
                if (this.hasLevel(1)) {
                    x = x - this.mediaThumbSize;
                }
                if (this.hasLevel(2)) {
                    x = x - this.mediaThumbSize;
                }
            }
			var y = Math.round(offset.top + height / 2);
			y = y - jQuery(window).scrollTop();

			animation.options.origin = [y, x];
		}

		this.getPanel(panel).show(animation.type, animation.options, animation.duration, function() {callback();});
	},



  replaceimageSizeInURL: function(url, size){
    var newUrl = url;
    var sizeRegex = /f=[0-9]*x[0-9]*/;
    var sizeReplace = 'f='+size+'x'+size;

    if (newUrl.indexOf('?') === -1) {
      newUrl += '?' + sizeReplace;
    } else if (sizeRegex.test(newUrl)) {
      newUrl = newUrl.replace(sizeRegex, sizeReplace);
    } else {
      newUrl += '&' + sizeReplace;
    }

    return newUrl;

  },

  renewImageSources : function(s){

    var that = this;
    
    var size = s ? s : this.sizeMedium;
    // Apply the same size to all srset to give zooming capabilities on mobile.
    that.getGallery().find('.gallery-viewer.picture source, .gallery-viewer.picture img').each(function() {
      
      if(jQuery(this).attr('src')){
        jQuery(this).attr('src', that.replaceimageSizeInURL(that.newImageUrl, size));
      }

      if(jQuery(this).attr('srcset')){
        jQuery(this).attr('srcset', that.replaceimageSizeInURL(that.newImageUrl, size));
      }

      if(jQuery(this).attr('data-srcset')) {
        jQuery(this).attr('data-srcset', that.replaceimageSizeInURL(that.newImageUrl, size));
      }
      
    });
  },

	load: function(category, index, caller)
	{
		category = (typeof category !== 'undefined') ? category : 'picture';
		index = (typeof index !== 'undefined') ? index : 0;
		caller = (typeof caller !== 'undefined') ? caller : null;
		var that = this;

    that.$galleryContainer = that.getGallery();

    that.$galleryContainer.find('img').attr('width', '1200').attr('height', '1200');

		// Save parameters
		this.caller = caller;

        // Test vertical and mobile
		this.testVertical();

		// Level 2 unused: Put level 2 item in level 1 menu if exist for legacy compatibility
		this.getPanel('media').find('ul.lvl2.picture li').each(function () {
			jQuery(this).clone().removeClass('active').appendTo(that.getPanel('media').find('ul.lvl1.picture'));
		});
		this.getPanel('media').find('ul.lvl2.picture').remove();

		// Load category
		this.loadCategory(category, index);

		this.alignMediaPanel();
		this.alignMediaList();
		this.updateLegendPagination();

		// Add zoom tool
		var $panzoom = $('.gallery-viewer.picture .viewer-box').panzoom({
			disablePan: true,
			increment: 0.2,
			minScale: 0.2,
			maxScale: 4,
			contain: false
		});

    var gestureScale;
    that.zoomed = false;

		$panzoom.on("panzoomzoom", function(event, panzoom, scale, opts) {
			if(scale <= this.scaleInitial) {
				$panzoom.panzoom("option", "disablePan", true);
				that.alignViewerBox();
        that.zoomed = false;
			} else {
				$panzoom.panzoom("option", "disablePan", false);
        if(that.zoomed === false){
          that.renewImageSources(that.sizeLarge);
          that.zoomed = true;
        }
			}
		});
    

		jQuery('.gallery-panel-viewer').on('mousewheel.focal', function( e ) {
			e.preventDefault();
			delta = e.delta || e.originalEvent.wheelDelta;
			zoom = delta ? delta < 0 : e.originalEvent.deltaY > 0;
      
			$panzoom.panzoom('zoom', zoom, {
				animate: false,
				focal: e
			});

		});

		// Add navigation events
		this.addNavigation();

		// Animate gallery opening
		this.openGallery();
	},

	loadCategory: function(category, index)
	{
		// Save active category
		this.categoryId = category;

		// Switch category and move gem
		this.getPanel('category').find('li.active').removeClass('active');
		this.getPanel('category').find('li.' + category).addClass('active');
		this.alignCategoryGem();

		// Switch media panel and select first item
		this.getPanel('media').find('ul li.active').removeClass('active');
		this.getPanel('media').find('ul').hide();
        var mediaWidth = this.mediaThumbSize;
        if (!this.vertical) {
            if (this.getPanel('media').find('ul.' + category + '.lvl2 li').length > 0) {
                mediaWidth += this.mediaThumbSize;
            }
            this.getPanel('media').width(mediaWidth);
			this.getPanel('media').height('100%');
        } else {
			this.getPanel('media').width('100%');
            this.getPanel('media').height(this.mediaThumbSize);
        }
		this.getPanel('media').find('ul.' + category).show();
		var media = this.getPanel('media').find('ul.' + category + ' li').slice(index, index + 1);
		media.addClass('active');
		this.go(media, 'left', 0);
		
		// Switch viewer panel
		this.getPanel('viewer').find('.gallery-viewer').hide();
		this.getPanel('viewer').find('.gallery-viewer.' + category).show();
		
		// Start/Stop player
		if (category === 'video') {
			this.loadVideoIframe(media.data('media'), media.data('player'), media.data('account'));
		} else {
			this.unloadVideoIframe();
		}

		// Translate viewer panel and align
        if (!this.vertical) {
            var viewerLeft = this.categoryThumbSize + mediaWidth;
            jQuery('.gallery-panel-viewer')
                .css('left', viewerLeft)
                .width(jQuery(window).width() - viewerLeft);
        } else {
            jQuery('.gallery-panel-viewer')
                .height(jQuery(window).height() - this.categoryThumbSize - this.mediaThumbSize);
        }

		// Align elements
		this.alignAll();
		
		// Show tools
		this.hideTools();
		this.showTools();

		// Update legend
        this.updateLegendPagination();
	},

	hasLevel: function(level)
	{
		var toReturn = false;

		if (this.getPanel('media').find('ul.' + this.categoryId + '.lvl' + level + ' li').length > 0) {
			toReturn = true;
		}

		return toReturn;
	},

	maxLevel: function()
	{
		var maxLevel = 0;

		while (this.hasLevel(maxLevel + 1)) {
			maxLevel++;
		}

		return maxLevel;
	},

	testVertical: function()
	{
		// Add/Remove class to replace css media queries
		if (jQuery(window).width() < jQuery(window).height()) {
			this.vertical = true;
			this.getGallery().addClass('vertical');
		} else {
			this.vertical = false;
			this.getGallery().removeClass('vertical');
		}

		if (jQuery(window).width() < this.mobileMaxWidth) {
			this.mobile = true;
		} else {
			this.mobile = false;
		}
	},

	getGallery: function()
	{
		return jQuery(this.selector);
	},

	getPanel: function(panel)
	{
		return this.getGallery().find('.gallery-panel-' + panel);
	},

	getTools: function(tool)
	{
		return this.getGallery().find('.gallery-tool');
	},
	
	hideTools: function()
	{
    	var getter = this.getTools();
    	getter.hide('fade', 500);
	},
	
	showTools: function()
	{
    	var getter = this.getTools();
    	
    	// Do not display arrows on mobile
        if (this.mobile) {
        	getter = getter.not('.gallery-tool-previous, .gallery-tool-next');
        }
        
        // Do not display arrows if only one media is in the category
        if (this.getPanel('media').find('.' + this.categoryId + ' li').length < 2) {
        	getter = getter.not('.gallery-tool-previous, .gallery-tool-next');
        }
		
    	getter.show('fade', 500);
	},

	getTool: function(tool)
	{
		return this.getGallery().find('.gallery-tool-' + tool);
	},

	addNavigation: function()
	{
		var that = this;

		// Category
		this.getPanel('category').find('li').on('click', function() {
			that.loadCategory(jQuery(this).data('category'), 0);
			that.alignAll();
		});

		// Close
		this.getTool('close').on('click', function() {
			that.closeGallery();
		});

		// Previous
		this.getTool('previous').on('click', function() {
			that.goPrevious();
		});

		// Next
		this.getTool('next').on('click', function() {
			that.goNext();
		});

		// GoTo
		this.getPanel('media').find('li').on('click', function() {
			var index = that.getPanel('media').find('li').index(this);
			that.goTo(index);
		});

		// Keyboard escape => Close gallery
		jQuery(window).on('keydown.key27', function(e) {
			var keycode = (e.keyCode ? e.keyCode : e.which);
			if (keycode === 27) {
				that.closeGallery();
			}
		});
		
		// Keyboard left arrow => Previous media
		jQuery(window).on('keydown.key37', function(e) {
			var keycode = (e.keyCode ? e.keyCode : e.which);
			if (keycode === 37) {
				that.goPrevious();
			}
		});
		
		// Keyboard right arrow => Next media
		jQuery(window).on('keydown.key39', function(e) {
			var keycode = (e.keyCode ? e.keyCode : e.which);
			if (keycode === 39) {
				that.goNext();
			}
		});
		
		this.getPanel('media').find('ul').each(function() {
			// On mouse scroll
			jQuery(this).on('mousewheel.focal', function(event) {
				event.preventDefault();
				var delta = 0;
				
				if (event.wheelDelta) {
					delta = event.wheelDelta;
			    }
				else if (event.originalEvent.detail) {
			    	delta = event.originalEvent.detail * -40;
			    }
				// Chrome
				else if (event.originalEvent && event.originalEvent.wheelDelta) {
			    	delta = event.originalEvent.wheelDelta;
			    }
				// Firefox & Edge
				else if (event.originalEvent && event.originalEvent.deltaY) {
			    	delta = - event.originalEvent.deltaY;
			    }
				
				// If delta is specified in lines, convert it in pixel
				if (-10 < delta && delta < 10)  {
					delta = 40 * delta;
				}
				
				that.scrollMediaList(jQuery(this), delta);
			});

			jQuery(this).on('touchstart', function(event) {
				// Register position on touch start
				that.touchstart.x = event.originalEvent.touches[0].pageX;
				that.touchstart.y = event.originalEvent.touches[0].pageY;
			});

			jQuery(this).on('touchmove', function(event) {
				// Calculate delta and slide
				var delta = !that.vertical ? (event.originalEvent.touches[0].pageY - that.touchstart.y) : (event.originalEvent.touches[0].pageX - that.touchstart.x);
				that.scrollMediaList(jQuery(this), delta * 2);

				// Register actual position
				that.touchstart.x = event.originalEvent.touches[0].pageX;
				that.touchstart.y = event.originalEvent.touches[0].pageY;
			});
		});

		// Gallery and window events
		that.getGallery().on('touchmove', function(event) {
			event.preventDefault();
		});
		jQuery(window).on('resize', _.debounce(function() {
			that.alignAll();
		},100));
	},

	removeNavigation: function()
	{
		var that = this;
		
		// Category
		this.getPanel('category').find('li').off('click');

		// Close
		this.getTool('close').off('click');

		// Previous
		this.getTool('previous').off('click');

		// Next
		this.getTool('next').off('click');

		// GoTo
		this.getPanel('media').find('li').off('click');

		// Keyboard escape => Close gallery
		jQuery(window).off('keydown.key27');
		
		// Keyboard left arrow => Previous media
		jQuery(window).off('keydown.key37');
		
		// Keyboard right arrow => Next media
		jQuery(window).off('keydown.key39');
	},

	go: function(media, direction, animationDuration)
	{
		var that = this;

		var animationDirectionHide = 'left';
		var animationDirectionShow = 'right';
		animationDuration = (typeof animationDuration !== 'undefined') ? animationDuration : 400;
		if (direction === 'previous') {
			animationDirectionHide = 'right';
			animationDirectionShow = 'left';
		}
        var animationType = 'slide';
        var animationTimeout = 0;
		if (that.categoryId === 'video') {
			animationType = 'fade';
			animationTimeout = 500;
		}

		that.getPanel('viewer').find('.gallery-viewer.' + that.categoryId + ' .viewer-parent').hide(animationType, {direction:animationDirectionHide}, animationDuration, function() {

			// Switch media panel
			that.getPanel('media').find('li.active').removeClass('active');
			media.addClass('active');
      that.updateLegendPagination();

			// Switch viewer panel & align
			if (that.categoryId === 'picture') {

        that.newImageUrl = that.imageFolder + media.data('media');
				// Get image URL

        // // Apply the same size to all srset to give zooming capabilities on mobile.
        that.renewImageSources(that.sizeMedium);

				that.getPanel('viewer').find('.gallery-viewer.picture .viewer-box img').one('load', function() {

					that.alignViewerPanel();
					that.alignViewerBox();
					
					// Display viewer back
					that.getPanel('viewer').find('.gallery-viewer.picture .viewer-parent').show(animationType, {direction:animationDirectionShow}, animationDuration);
				}).attr('src', that.replaceimageSizeInURL(that.newImageUrl, that.sizeMedium));

        that.zoomed = false;
			}
			
			else if (that.categoryId === 'video') {
				that.loadVideoIframe(media.data('media'), media.data('player'), media.data('account'));
				that.alignViewerPanel();
				that.alignViewerBox();
				
				// Display viewer back
				setTimeout(function() {
					that.getPanel('viewer').find('.gallery-viewer.video .viewer-parent').show(animationType, {direction:animationDirectionShow}, animationDuration);
				}, animationTimeout);
			}
		});
	},

	goTo: function(id)
	{
		var goMedia = this.getPanel('media').find('li').slice(id, id + 1);
		this.go(goMedia);
	},

	goNext: function()
	{
		var activeMedia = this.getPanel('media').find('li.active').first();
		var nextMedia = activeMedia.next();

		if(nextMedia.length > 0 ) {
			// Loop media on panel/list end
			if (!nextMedia.is('li')) {
				var activePanel = activeMedia.parents('ul').first();
				var lvl1Panel = this.getPanel('media').find('ul.' + this.categoryId + '.lvl1 li');
				var lvl2Panel = this.getPanel('media').find('ul.' + this.categoryId + '.lvl2 li');

				if (activePanel.hasClass('lvl1') && (lvl2Panel.length > 0)) {
					nextMedia = lvl2Panel.first();
				}
				else {
					nextMedia = lvl1Panel.first();
				}
			}

			this.go(nextMedia, 'next');
		}
		
	},

	goPrevious: function()
	{
		var activeMedia = this.getPanel('media').find('li.active').first();
		var previousMedia = activeMedia.prev();

		if(previousMedia.length > 0){
			// Loop media on panel/list begin
			if (!previousMedia.is('li')) {
				var activePanel = activeMedia.parents('ul').first();
				var lvl1Panel = this.getPanel('media').find('ul.' + this.categoryId + '.lvl1 li');
				var lvl2Panel = this.getPanel('media').find('ul.' + this.categoryId + '.lvl2 li');

				if (activePanel.hasClass('lvl1') && (lvl2Panel.length > 0)) {
					previousMedia = lvl2Panel.last();
				}
				else {
					previousMedia = lvl1Panel.last();
				}
			}

			this.go(previousMedia, 'previous');
		}
		
	},

  updateLegendPagination: function() {
      var elementList = this.getPanel('media').find('ul.' + this.categoryId + ' li');
      var total = elementList.length;
      var index = 1 + elementList.index(this.getPanel('media').find('ul.' + this.categoryId + ' li.active'));

      this.getTool('legend').find('.index').html(index);
      this.getTool('legend').find('.total').html(total);
  },

	alignAll: function () {
		this.testVertical();
		this.alignCategoryPanel();
		this.alignCategoryGem();
		this.alignMediaPanel();
		this.alignMediaList();
		this.alignViewerPanel();
		this.alignViewerBox();
		this.alignTools();
	},

	alignCategoryPanel: function()
	{
		var width = '100%';
		var height = '100%';

		if (!this.vertical) {
			width = this.categoryThumbSize;
		} else {
			height = this.categoryThumbSize;
		}

		this.getPanel('category')
			.width(width)
			.height(height);
	},

	alignCategoryGem: function()
	{
		var windowWidth = jQuery(window).width();
		var windowHeight = jQuery(window).height();
		var categoryCount = this.getPanel('category').find('li').length;
		var categoryIndex = this.getPanel('category').find('li').index(this.getPanel('category').find('li.active').first());

		var left = this.categoryThumbSize - (this.categoryGemSize / 2);
		var top = - (this.categoryGemSize / 2);
		if (!this.vertical) {
			// Window middle
			top = ((windowHeight - this.categoryGemSize) / 2);
			// First category element
			top = top - ((categoryCount - 1) / 2 * this.categoryThumbSize);
			// Active category element
			top = top + (categoryIndex * this.categoryThumbSize);
		} else {
			// Window middle
			left= ((windowWidth - this.categoryGemSize) / 2);
			// First category element
			left = left - ((categoryCount - 1) / 2 * this.categoryThumbSize);
			// Active category element
			left = left + (categoryIndex * this.categoryThumbSize);
		}

		this.getPanel('category').find('.gem').css({
			display: 'block',
			top: top,
			left: left
		});
	},

	alignMediaPanel: function()
	{
		var width = '100%';
		var height = '100%';
		var top = 0;
		var bottom = 'auto';
		var left = 0;

		if (!this.vertical) {
			left = this.categoryThumbSize;
			width = this.maxLevel() * this.mediaThumbSize;
		} else {
			top = 'auto';
			bottom = this.categoryThumbSize;
			height = this.maxLevel() * this.mediaThumbSize;
		}

		this.getPanel('media')
			.css('top', top)
			.css('bottom', bottom)
			.css('left', left)
			.width(width)
			.height(height);
	},

	alignMediaList: function() {
		var that = this;
		var windowWidth = jQuery(window).width();
		var windowHeight = jQuery(window).height();

		this.getPanel('media').find('ul').each(function() {
			var level = jQuery(this).hasClass('lvl2') ? 2 : 1;
			var size = jQuery(this).find('li').length;
			var top = 0;
			var left = 0;

			if (!that.vertical) {
				top = (windowHeight - (size * that.mediaThumbSize)) / 2;
				left = (level - 1) * that.mediaThumbSize;
			} else {
				top = (level - 1) * that.mediaThumbSize;
				left = (windowWidth - (size * that.mediaThumbSize)) / 2;
			}

			// Do not get negative position
			top = top < 0 ? 0 : top;
			left = left < 0 ? 0 : left;

			jQuery(this).css({
				top: top,
				left: left
			});
		});
	},

	scrollMediaList: function(list, delta) {
		// Only scroll while having a too long list. Keep small list centered
		if (
			(!this.vertical && jQuery(window).height() < list.height()) ||
			(this.vertical && jQuery(window).width() < list.width())
		) {
			var position = list.position();
			var top = position.top;
			var left = position.left;
			var maxTop = jQuery(window).height() - list.height();
			var maxLeft = jQuery(window).width() - list.width();

			if (!this.vertical) {
				top += delta / 2;
				top = top > 0 ? 0 : top;
				top = top < maxTop ? maxTop : top;
			} else {
				left += delta / 2;
				left = left > 0 ? 0 : left;
				left = left < maxLeft ? maxLeft : left;
			}

			list
				.css('top', top)
				.css('left', left);
		}
	},

	alignViewerPanel: function()
	{
		var windowWidth = jQuery(window).width();
		var windowHeight = jQuery(window).height();
		var panelTop = 0;
		var panelLeft = 0;
		var panelWidth = windowWidth;
		var panelHeight = windowHeight;

		if (!this.vertical) {
			panelLeft += this.categoryThumbSize;
			panelLeft += this.maxLevel() * this.mediaThumbSize;
			panelWidth = windowWidth - panelLeft;
		} else {
			panelHeight -= this.categoryThumbSize;
			panelHeight -= this.maxLevel() * this.mediaThumbSize;
		}

		this.getPanel('viewer').css({
			top: panelTop,
			left: panelLeft,
			width: panelWidth,
			height: panelHeight
		});
	},

	alignViewerBox: function()
	{
		var that = this;
		var windowWidth = jQuery(window).width();
		var windowHeight = jQuery(window).height();

		that.getPanel('viewer').find('.viewer-box').each(function() {
			var boxTop = 0;
			var boxLeft = 0;
			var boxWidth = windowWidth;
			var boxHeight = windowHeight;

			if (!that.vertical) {
				boxWidth -= that.categoryThumbSize;
				boxWidth -= that.maxLevel() * that.mediaThumbSize;
			} else {
				boxHeight -= that.categoryThumbSize;
				boxHeight -= that.maxLevel() * that.mediaThumbSize;
			}

			// Add border if required
			if (!that.imageExpand && !that.mobile) {
				boxWidth -= 2 * that.viewerImagePadding;
				boxHeight -= 2 * that.viewerImagePadding;
				boxTop += that.viewerImagePadding;
				boxLeft += that.viewerImagePadding;
			}

			if (jQuery(this).parents('.gallery-viewer').first().hasClass('picture')) {
				var imgSelector = jQuery(this).find('img').first();
				var imgWidth = imgSelector.attr('width') ? imgSelector.attr('width') : imgSelector.prop('width');
				var imgHeight = imgSelector.attr('height') ? imgSelector.attr('height') : imgSelector.prop('height');

				// Improve calculation by using image natural width if available
				if (typeof imgSelector.prop('naturalWidth') !== 'undefined') {
					imgWidth = imgSelector.attr('width') ? imgSelector.attr('width') : imgSelector.prop('naturalWidth');
					imgHeight = imgSelector.attr('height') ? imgSelector.attr('height') : imgSelector.prop('naturalHeight');
				}

				// Calculate scale
				var viewRatio = boxWidth / boxHeight;
				var scale = boxWidth / imgWidth;
				if ( (viewRatio < 1 && that.imageExpand) || (viewRatio >= 1 && !that.imageExpand) ) {
					scale = boxHeight / imgHeight;
				}
				scale = Math.round(scale * 100) / 100;
				this.scaleInitial = scale;

				// Calculate alignment
				var translateX = boxLeft + (boxWidth - imgWidth) / 2;
				var translateY = boxTop + (boxHeight - imgHeight) / 2;

				// Do changes
				jQuery(this).css('transform', 'matrix(' + scale + ', 0, 0, ' + scale + ', ' + translateX + ', ' + translateY + ')');
			} else {
				jQuery(this).css({
					top: boxTop,
					left: boxLeft,
					width: boxWidth,
					height: boxHeight
				});
			}
		});
	},

	alignTools: function () {
		var windowWidth = jQuery(window).width();
		var windowHeight = jQuery(window).height();
		var panelLeft = 0;
		var panelWidth = windowWidth;
		var panelHeight = windowHeight;

		if (!this.vertical) {
			panelWidth -= this.categoryThumbSize;
			panelWidth -= this.maxLevel() * this.mediaThumbSize;
			panelLeft = windowWidth - panelWidth;
		} else {
			panelHeight -= this.categoryThumbSize;
			panelHeight -= this.maxLevel() * this.mediaThumbSize;
		}

		this.getTool('previous')
			.css('top', (panelHeight / 2))
			.css('left', (panelLeft + 20));

		this.getTool('next')
			.css('top', (panelHeight / 2))
			.css('right', 20);

		this.getTool('brand')
			.css('top', 10)
			.css('left', (panelLeft + 10));

		this.getTool('legend')
			.css('bottom', (windowHeight - panelHeight + 10))
			.css('left', (panelLeft + panelWidth / 2  - 50))
			.css('margin-left', 0);
	}

};

;(function(window, $){

	var galleryTarget,
	galleryType,
	mouseDownInitialXPos = 0,
	mouseUpXPos = 0,
	mouseDownInitialScrollYpos = 0;
	imageInitialXpos = 0;
	imageXpos = 0;

	$(document).on('click', 'a[data-toggle="gallery"]', function(e){
		e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = false;
	});

	$(document).on('mousedown touchstart', 'a[data-toggle="gallery"]', function(e){
		
		if(e.type === 'mousedown'){
			e.preventDefault();
			e.stopPropagation();
			e.cancelBubble = false;
    }

		mouseDownInitialXPos = e.pageX || e.originalEvent.touches[0].pageX;
		mouseDownInitialScrollYpos = $(window).scrollTop();
		imageInitialXpos = $(this)[0].getBoundingClientRect().left;

	});

	$(document).on('touchmove', 'a[data-toggle="gallery"]', function(e){
		mouseUpXPos = e.originalEvent.touches[0].pageX;
	});


	var isAnchorAtTheSamePlace = function(){
		if(Math.abs(imageXpos - imageInitialXpos) < 10) {
			return true;
		}
	};

	var isPointerAtTheSamePlace = function(){
		if(Math.abs(mouseUpXPos - mouseDownInitialXPos) < 10) {
			return true;
		}
	};

	$(document).on('mouseup touchend', 'a[data-toggle="gallery"]', function(e){

		e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = false;

    mouseUpXPos = mouseUpXPos === 0 ? mouseDownInitialXPos : mouseUpXPos;

    imageXpos = $(this)[0].getBoundingClientRect().left;

    if(e.type === 'mouseup'){
			mouseUpXPos = e.pageX;
    }

		galleryTarget = $(this).data('galleryTarget') ? $(this).data('galleryTarget') : 0;
		galleryType = $(this).data('galleryType') ? $(this).data('galleryType') : 'picture';

		if(isPointerAtTheSamePlace() && isAnchorAtTheSamePlace() && Math.abs(mouseDownInitialScrollYpos - $(window).scrollTop()) < 10){
			myGallery.load(galleryType, galleryTarget = 0, this);
		}

		mouseUpXPos = 0;

	});

})(window, jQuery);

/*!
 * VERSION: 0.9.9
 * DATE: 2015-04-28
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * ThrowPropsPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
 * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
 * This work is subject to the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("plugins.ThrowPropsPlugin", ["plugins.TweenPlugin", "TweenLite", "easing.Ease", "utils.VelocityTracker"], function(TweenPlugin, TweenLite, Ease, VelocityTracker) {
		
		var ThrowPropsPlugin = function(props, priority) {
				TweenPlugin.call(this, "throwProps");
				this._overwriteProps.length = 0;
			},
			_max = 999999999999999,
			_min = 0.0000000001,
			_globals = _gsScope._gsDefine.globals,
			_recordEndMode = false,//in a typical throwProps css tween that has an "end" defined as a function, it grabs that value initially when the tween is rendered, then again when we calculate the necessary duration, and then a 3rd time after we invalidate() the tween, so we toggle _recordEndMode to true when we're about to begin such a tween which tells the engine to grab the end value(s) once and record them as "max" and "min" on the throwProps object, thus we can skip those extra calls. Then we set it back to false when we're done with our fancy initialization routine.
			_transforms = {x:1,y:1,z:2,scale:1,scaleX:1,scaleY:1,rotation:1,rotationZ:1,rotationX:2,rotationY:2,skewX:1,skewY:1,xPercent:1,yPercent:1},
			_getClosest = function(n, values, max, min) {
				var i = values.length,
					closest = 0,
					absDif = _max,
					val, dif;
				while (--i > -1) {
					val = values[i];
					dif = val - n;
					if (dif < 0) {
						dif = -dif;
					}
					if (dif < absDif && val >= min && val <= max) {
						closest = i;
						absDif = dif;
					}
				}
				return values[closest];
			},
			_parseEnd = function(curProp, end, max, min) {
				if (curProp.end === "auto") {
					return curProp;
				}
				max = isNaN(max) ? _max : max;
				min = isNaN(min) ? -_max : min;
				var adjustedEnd = (typeof(curProp.end) === "function") ? curProp.end(end) : (curProp.end instanceof Array) ? _getClosest(end, curProp.end, max, min) : Number(curProp.end);
				if (adjustedEnd > max) {
					adjustedEnd = max;
				} else if (adjustedEnd < min) {
					adjustedEnd = min;
				}
				return {max:adjustedEnd, min:adjustedEnd, unitFactor:curProp.unitFactor};
			},
			_extend = function(decoratee, extras, exclude) {
				for (var p in extras) {
					if (decoratee[p] === undefined && p !== exclude) {
						decoratee[p] = extras[p];
					}
				}
				return decoratee;
			},
			_calculateChange = ThrowPropsPlugin.calculateChange = function(velocity, ease, duration, checkpoint) {
				if (checkpoint == null) {
					checkpoint = 0.05;
				}
				var e = (ease instanceof Ease) ? ease : (!ease) ? TweenLite.defaultEase : new Ease(ease);
				return (duration * checkpoint * velocity) / e.getRatio(checkpoint);
			},
			_calculateDuration = ThrowPropsPlugin.calculateDuration = function(start, end, velocity, ease, checkpoint) {
				checkpoint = checkpoint || 0.05;
				var e = (ease instanceof Ease) ? ease : (!ease) ? TweenLite.defaultEase : new Ease(ease);
				return Math.abs( (end - start) * e.getRatio(checkpoint) / velocity / checkpoint );
			},
			_calculateTweenDuration = ThrowPropsPlugin.calculateTweenDuration = function(target, vars, maxDuration, minDuration, overshootTolerance, recordEnd) {
				if (typeof(target) === "string") {
					target = TweenLite.selector(target);
				}
				if (!target) {
					return 0;
				}
				if (maxDuration == null) {
					maxDuration = 10;
				}
				if (minDuration == null) {
					minDuration = 0.2;
				}
				if (overshootTolerance == null) {
					overshootTolerance = 1;
				}
				if (target.length) {
					target = target[0] || target;
				}
				var duration = 0,
					clippedDuration = 9999999999,
					throwPropsVars = vars.throwProps || vars,
					ease = (vars.ease instanceof Ease) ? vars.ease : (!vars.ease) ? TweenLite.defaultEase : new Ease(vars.ease),
					checkpoint = isNaN(throwPropsVars.checkpoint) ? 0.05 : Number(throwPropsVars.checkpoint),
					resistance = isNaN(throwPropsVars.resistance) ? ThrowPropsPlugin.defaultResistance : Number(throwPropsVars.resistance),
					p, curProp, curDuration, curVelocity, curResistance, curVal, end, curClippedDuration, tracker, unitFactor;

				for (p in throwPropsVars) {

					if (p !== "resistance" && p !== "checkpoint" && p !== "preventOvershoot") {
						curProp = throwPropsVars[p];
						if (typeof(curProp) !== "object") {
							tracker = tracker || VelocityTracker.getByTarget(target);
							if (tracker && tracker.isTrackingProp(p)) {
								curProp = (typeof(curProp) === "number") ? {velocity:curProp} : {velocity:tracker.getVelocity(p)}; //if we're tracking this property, we should use the tracking velocity and then use the numeric value that was passed in as the min and max so that it tweens exactly there.
							} else {
								curVelocity = Number(curProp) || 0;
								curDuration = (curVelocity * resistance > 0) ? curVelocity / resistance : curVelocity / -resistance;
							}
						}
						if (typeof(curProp) === "object") {
							if (curProp.velocity !== undefined && typeof(curProp.velocity) === "number") {
								curVelocity = Number(curProp.velocity) || 0;
							} else {
								tracker = tracker || VelocityTracker.getByTarget(target);
								curVelocity =  (tracker && tracker.isTrackingProp(p)) ? tracker.getVelocity(p) : 0;
							}
							curResistance = isNaN(curProp.resistance) ? resistance : Number(curProp.resistance);
							curDuration = (curVelocity * curResistance > 0) ? curVelocity / curResistance : curVelocity / -curResistance;
							curVal = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() : target[p] || 0;
							end = curVal + _calculateChange(curVelocity, ease, curDuration, checkpoint);
							if (curProp.end !== undefined) {
								curProp = _parseEnd(curProp, end, curProp.max, curProp.min);
								if (recordEnd || _recordEndMode) {
									throwPropsVars[p] = _extend(curProp, throwPropsVars[p], "end");
								}
							}
							if (curProp.max !== undefined && end > Number(curProp.max) + _min) {
								unitFactor = curProp.unitFactor || ThrowPropsPlugin.defaultUnitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.
								//if the value is already exceeding the max or the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive. If the max and min match, it means we're animating to a particular value and we don't want to shorten the time unless the velocity is really slow. Example: a rotation where the start and natural end value are less than the snapping spot, but the natural end is pretty close to the snap.
								curClippedDuration = ((curVal > curProp.max && curProp.min !== curProp.max) || (curVelocity * unitFactor > -15 && curVelocity * unitFactor < 45)) ? (minDuration + (maxDuration - minDuration) * 0.1) : _calculateDuration(curVal, curProp.max, curVelocity, ease, checkpoint);
								if (curClippedDuration + overshootTolerance < clippedDuration) {
									clippedDuration = curClippedDuration + overshootTolerance;
								}

							} else if (curProp.min !== undefined && end < Number(curProp.min) - _min) {
								unitFactor = curProp.unitFactor || ThrowPropsPlugin.defaultUnitFactors[p] || 1; //some values are measured in special units like radians in which case our thresholds need to be adjusted accordingly.
								//if the value is already exceeding the min or if the velocity is too low, the duration can end up being uncomfortably long but in most situations, users want the snapping to occur relatively quickly (0.75 seconds), so we implement a cap here to make things more intuitive.
								curClippedDuration = ((curVal < curProp.min && curProp.min !== curProp.max) || (curVelocity * unitFactor > -45 && curVelocity * unitFactor < 15)) ? (minDuration + (maxDuration - minDuration) * 0.1) : _calculateDuration(curVal, curProp.min, curVelocity, ease, checkpoint);
								if (curClippedDuration + overshootTolerance < clippedDuration) {
									clippedDuration = curClippedDuration + overshootTolerance;
								}
							}

							if (curClippedDuration > duration) {
								duration = curClippedDuration;
							}
						}

						if (curDuration > duration) {
							duration = curDuration;
						}

					}
				}
				if (duration > clippedDuration) {
					duration = clippedDuration;
				}
				if (duration > maxDuration) {
					return maxDuration;
				} else if (duration < minDuration) {
					return minDuration;
				}
				return duration;
			},
			p = ThrowPropsPlugin.prototype = new TweenPlugin("throwProps"),
			_cssProxy, _cssVars, _last, _lastValue; //these serve as a cache of sorts, recording the last css-related proxy and the throwProps vars that get calculated in the _cssRegister() method. This allows us to grab them in the ThrowPropsPlugin.to() function and calculate the duration. Of course we could have structured things in a more "clean" fashion, but performance is of paramount importance.
			


		p.constructor = ThrowPropsPlugin;
		ThrowPropsPlugin.version = "0.9.9";
		ThrowPropsPlugin.API = 2;
		ThrowPropsPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		ThrowPropsPlugin.defaultResistance = 100;
		ThrowPropsPlugin.defaultUnitFactors = {time:1000, totalTime:1000}; //setting the unitFactor to a higher value (default is 1) reduces the chance of the auto-accelerating behavior kicking in when determining durations when the initial velocity is adequately low - imagine dragging something past a boundary and then letting go - snapping back relatively quickly should be prioritized over matching the initial velocity (at least that's the behavior most people consider intuitive). But in some situations when the units are very low (like "time" of a timeline or rotation when using radians), it can kick in too frequently so this allows tweaking.

		ThrowPropsPlugin.track = function(target, props, types) {
			return VelocityTracker.track(target, props, types);
		};

		ThrowPropsPlugin.untrack = function(target, props) {
			VelocityTracker.untrack(target, props);
		};

		ThrowPropsPlugin.isTracking = function(target, prop) {
			return VelocityTracker.isTracking(target, prop);
		};

		ThrowPropsPlugin.getVelocity = function(target, prop) {
			var vt = VelocityTracker.getByTarget(target);
			return vt ? vt.getVelocity(prop) : NaN;
		};

		ThrowPropsPlugin._cssRegister = function() {
			var CSSPlugin = _globals.com.greensock.plugins.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("throwProps", {parser:function(t, e, prop, cssp, pt, plugin) {
				plugin = new ThrowPropsPlugin();
				var velocities = {},
					min = {},
					max = {},
					end = {},
					res = {},
					preventOvershoot = {},
					hasResistance, val, p, data, tracker;
				_cssVars = {};
				for (p in e) {
					if (p !== "resistance" && p !== "preventOvershoot") {
						val = e[p];
						if (typeof(val) === "object") {
							if (val.velocity !== undefined && typeof(val.velocity) === "number") {
								velocities[p] = Number(val.velocity) || 0;
							} else {
								tracker = tracker || VelocityTracker.getByTarget(t);
								velocities[p] = (tracker && tracker.isTrackingProp(p)) ? tracker.getVelocity(p) : 0; //rotational values are actually converted to radians in CSSPlugin, but our tracking velocity is in radians already, so make it into degrees to avoid a funky conversion
							}
							if (val.end !== undefined) {
								end[p] = val.end;
							}
							if (val.min !== undefined) {
								min[p] = val.min;
							}
							if (val.max !== undefined) {
								max[p] = val.max;
							}
							if (val.preventOvershoot) {
								preventOvershoot[p] = true;
							}
							if (val.resistance !== undefined) {
								hasResistance = true;
								res[p] = val.resistance;
							}
						} else if (typeof(val) === "number") {
							velocities[p] = val;
						} else {
							tracker = tracker || VelocityTracker.getByTarget(t);
							if (tracker && tracker.isTrackingProp(p)) {
								velocities[p] = tracker.getVelocity(p);
							} else {
								velocities[p] = val || 0;
							}
						}
						if (_transforms[p]) {
							cssp._enableTransforms((_transforms[p] === 2));
						}
					}
				}
				data = _parseToProxy(t, velocities, cssp, pt, plugin);
				_cssProxy = data.proxy;
				velocities = data.end;
				for (p in _cssProxy) {
					_cssVars[p] = {velocity:velocities[p], min:min[p], max:max[p], end:end[p], resistance:res[p], preventOvershoot:preventOvershoot[p]};
				}
				if (e.resistance != null) {
					_cssVars.resistance = e.resistance;
				}
				if (e.preventOvershoot) {
					_cssVars.preventOvershoot = true;
				}
				pt = new CSSPropTween(t, "throwProps", 0, 0, data.pt, 2);
				cssp._overwriteProps.pop(); //don't overwrite all other throwProps tweens. In the CSSPropTween constructor, we add the property to the _overwriteProps, so remove it here.
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				pt.data = data;
				plugin._onInitTween(_cssProxy, _cssVars, cssp._tween);
				return pt;
			}});
		};

		
		ThrowPropsPlugin.to = function(target, vars, maxDuration, minDuration, overshootTolerance) {
			if (!vars.throwProps) {
				vars = {throwProps:vars};
			}
			if (overshootTolerance === 0) {
				vars.throwProps.preventOvershoot = true;
			}
			_recordEndMode = true; //if we encounter a function-based "end" value, ThrowPropsPlugin will record it as "max" and "min" properties, replacing "end" (this is an optimization so that the function only gets called once)
			var tween = new TweenLite(target, minDuration || 1, vars);
			tween.render(0, true, true); //we force a render so that the CSSPlugin instantiates and populates the _cssProxy and _cssVars which we need in order to calculate the tween duration. Remember, we can't use the regular target for calculating the duration because the current values wouldn't be able to be grabbed like target["propertyName"], as css properties can be complex like boxShadow:"10px 10px 20px 30px red" or backgroundPosition:"25px 50px". The proxy is the result of breaking all that complex data down and finding just the numeric values and assigning them to a generic proxy object with unique names. THAT is what the _calculateTweenDuration() can look at. We also needed to do the same break down of any min or max or velocity data
			if (tween.vars.css) {
				tween.duration(_calculateTweenDuration(_cssProxy, {throwProps:_cssVars, ease:vars.ease}, maxDuration, minDuration, overshootTolerance));
				if (tween._delay && !tween.vars.immediateRender) {
					tween.invalidate(); //if there's a delay, the starting values could be off, so invalidate() to force reinstantiation when the tween actually starts.
				} else {
					_last._onInitTween(_cssProxy, _lastValue, tween);
				}
				_recordEndMode = false;
				return tween;
			} else {
				tween.kill();
				tween = new TweenLite(target, _calculateTweenDuration(target, vars, maxDuration, minDuration, overshootTolerance), vars);
				_recordEndMode = false;
				return tween;
			}
		};
		
		p._onInitTween = function(target, value, tween) {
			this.target = target;
			this._props = [];
			_last = this;
			_lastValue = value;
			var ease = tween._ease,
				checkpoint = isNaN(value.checkpoint) ? 0.05 : Number(value.checkpoint),
				duration = tween._duration,
				preventOvershoot = value.preventOvershoot,
				cnt = 0,
				p, curProp, curVal, isFunc, velocity, change1, end, change2, tracker;
			for (p in value) {
				if (p !== "resistance" && p !== "checkpoint" && p !== "preventOvershoot") {
					curProp = value[p];
					if (typeof(curProp) === "number") {
						velocity = Number(curProp) || 0;
					} else if (typeof(curProp) === "object" && !isNaN(curProp.velocity)) {
						velocity = Number(curProp.velocity);
					} else {
						tracker = tracker || VelocityTracker.getByTarget(target);
						if (tracker && tracker.isTrackingProp(p)) {
							velocity = tracker.getVelocity(p);
						} else {
							throw("ERROR: No velocity was defined in the throwProps tween of " + target + " property: " + p);
						}
					}
					change1 = _calculateChange(velocity, ease, duration, checkpoint);
					change2 = 0;
					isFunc = (typeof(target[p]) === "function");
					curVal = (isFunc) ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() : target[p];
					if (typeof(curProp) === "object") {
						end = curVal + change1;
						if (curProp.end !== undefined) {
							curProp = _parseEnd(curProp, end, curProp.max, curProp.min);
							if (_recordEndMode) {
								value[p] = _extend(curProp, value[p], "end");
							}
						}
						if (curProp.max !== undefined && Number(curProp.max) < end) {
							if (preventOvershoot || curProp.preventOvershoot) {
								change1 = curProp.max - curVal;
							} else {
								change2 = (curProp.max - curVal) - change1;
							}
						} else if (curProp.min !== undefined && Number(curProp.min) > end) {
							if (preventOvershoot || curProp.preventOvershoot) {
								change1 = curProp.min - curVal;
							} else {
								change2 = (curProp.min - curVal) - change1;
							}
						}
					}
					this._overwriteProps[cnt] = p;
					this._props[cnt++] = {p:p, s:curVal, c1:change1, c2:change2, f:isFunc, r:false};
				}
			}
			return true;
		};
		
		p._kill = function(lookup) {
			var i = this._props.length;
			while (--i > -1) {
				if (lookup[this._props[i].p] != null) {
					this._props.splice(i, 1);
				}
			}
			return TweenPlugin.prototype._kill.call(this, lookup);
		};
		
		p._roundProps = function(lookup, value) {
			var p = this._props,
				i = p.length;
			while (--i > -1) {
				if (lookup[p[i].p] || lookup.throwProps) {
					p[i].r = value;
				}
			}
		};
		
		p.setRatio = function(v) {
			var i = this._props.length, 
				cp, val;
			while (--i > -1) {
				cp = this._props[i];
				val = cp.s + cp.c1 * v + cp.c2 * v * v;
				if (cp.r) {
					val = Math.round(val);
				}
				if (cp.f) {
					this.target[cp.p](val);
				} else {
					this.target[cp.p] = val;
				}
			}	
		};
		
		TweenPlugin.activate([ThrowPropsPlugin]);
		
		return ThrowPropsPlugin;
		
	}, true);



/*
 * ----------------------------------------------------------------
 * VelocityTracker
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("utils.VelocityTracker", ["TweenLite"], function(TweenLite) {

		var _first,	_initted, _time1, _time2,
			_capsExp = /([A-Z])/g,
			_empty = {},
			_transforms = {x:1,y:1,z:2,scale:1,scaleX:1,scaleY:1,rotation:1,rotationZ:1,rotationX:2,rotationY:2,skewX:1,skewY:1,xPercent:1,yPercent:1},
			_getComputedStyle = document.defaultView ? document.defaultView.getComputedStyle : function() {},
			_getStyle = function(t, p, cs) {
				var rv = (t._gsTransform || _empty)[p];
				if (rv || rv === 0) {
					return rv;
				} else if (t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t, null))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return parseFloat(rv) || 0;
			},
			_ticker = TweenLite.ticker,
			VelocityProp = function(p, isFunc, next) {
				this.p = p;
				this.f = isFunc;
				this.v1 = this.v2 = 0;
				this.t1 = this.t2 = _ticker.time;
				this.css = false;
				this.type = "";
				this._prev = null;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},
			_update = function() {
				var vt = _first,
					t = _ticker.time,
					val, vp;
				//if the frame rate is too high, we won't be able to track the velocity as well, so only update the values about 33 times per second
				if (t - _time1 >= 0.03) {
					_time2 = _time1;
					_time1 = t;
					while (vt) {
						vp = vt._firstVP;
						while (vp) {
							val = vp.css ? _getStyle(vt.target, vp.p) : vp.f ? vt.target[vp.p]() : vt.target[vp.p];
							if (val !== vp.v1 || t - vp.t1 > 0.15) { //use a threshold of 0.15 seconds for zeroing-out velocity. If we only use 0.03 and things update slightly slower, like some Android devices dispatch "touchmove" events sluggishly so 2 or 3 ticks of the TweenLite.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it's not updating as frequently. A threshold of 0.15 seconds seems to be a good balance. We want to update things frequently (0.03 seconds) when they're moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.
								vp.v2 = vp.v1;
								vp.v1 = val;
								vp.t2 = vp.t1;
								vp.t1 = t;
							}
							vp = vp._next;
						}
						vt = vt._next;
					}
				}
			},
			VelocityTracker = function(target) {
				this._lookup = {};
				this.target = target;
				this.elem = (target.style && target.nodeType) ? true : false;
				if (!_initted) {
					_ticker.addEventListener("tick", _update, null, false, -100);
					_time1 = _time2 = _ticker.time;
					_initted = true;
				}
				if (_first) {
					this._next = _first;
					_first._prev = this;
				}
				_first = this;
			},
			getByTarget = VelocityTracker.getByTarget = function(target) {
				var vt = _first;
				while (vt) {
					if (vt.target === target) {
						return vt;
					}
					vt = vt._next;
				}
			},
			p = VelocityTracker.prototype;

		p.addProp = function(prop, type) {
			if (!this._lookup[prop]) {
				var t = this.target,
					isFunc = (typeof(t[prop]) === "function"),
					alt = isFunc ? this._altProp(prop) : prop,
					vp = this._firstVP;
				this._firstVP = this._lookup[prop] = this._lookup[alt] = vp = new VelocityProp((alt !== prop && prop.indexOf("set") === 0) ? alt : prop, isFunc, vp);
				vp.css = (this.elem && (this.target.style[vp.p] !== undefined || _transforms[vp.p]));
				if (vp.css && _transforms[vp.p] && !t._gsTransform) {
					TweenLite.set(t, {x:"+=0", overwrite:false}); //just forces CSSPlugin to create a _gsTransform for the element if it doesn't exist
				}
				vp.type = type || (vp.css && prop.indexOf("rotation") === 0) ? "deg" : "";
				vp.v1 = vp.v2 = vp.css ? _getStyle(t, vp.p) : isFunc ? t[vp.p]() : t[vp.p];
			}
		};

		p.removeProp = function(prop) {
			var vp = this._lookup[prop];
			if (vp) {
				if (vp._prev) {
					vp._prev._next = vp._next;
				} else if (vp === this._firstVP) {
					this._firstVP = vp._next;
				}
				if (vp._next) {
					vp._next._prev = vp._prev;
				}
				this._lookup[prop] = 0;
				if (vp.f) {
					this._lookup[this._altProp(prop)] = 0; //if it's a getter/setter, we should remove the matching counterpart (if one exists)
				}
			}
		};

		p.isTrackingProp = function(prop) {
			return (this._lookup[prop] instanceof VelocityProp);
		};

		p.getVelocity = function(prop) {
			var vp = this._lookup[prop],
				target = this.target,
				val, dif, rotationCap;
			if (!vp) {
				throw "The velocity of " + prop + " is not being tracked.";
			}
			val = vp.css ? _getStyle(target, vp.p) : vp.f ? target[vp.p]() : target[vp.p];
			dif = (val - vp.v2);
			if (vp.type === "rad" || vp.type === "deg") { //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.
				rotationCap = (vp.type === "rad") ? Math.PI * 2 : 360;
				dif = dif % rotationCap;
				if (dif !== dif % (rotationCap / 2)) {
					dif = (dif < 0) ? dif + rotationCap : dif - rotationCap;
				}
			}
			return dif / (_ticker.time - vp.t2);
		};

		p._altProp = function(p) { //for getters/setters like getCustomProp() and setCustomProp() - we should accommodate both
			var pre = p.substr(0, 3),
				alt = ((pre === "get") ? "set" : (pre === "set") ? "get" : pre) + p.substr(3);
			return (typeof(this.target[alt]) === "function") ? alt : p;
		};

		VelocityTracker.getByTarget = function(target) {
			var vt = _first;
			if (typeof(target) === "string") {
				target = TweenLite.selector(target);
			}
			if (target.length && target !== window && target[0] && target[0].style && !target.nodeType) {
				target = target[0];
			}
			while (vt) {
				if (vt.target === target) {
					return vt;
				}
				vt = vt._next;
			}
		};

		VelocityTracker.track = function(target, props, types) {
			var vt = getByTarget(target),
				a = props.split(","),
				i = a.length;
			types = (types || "").split(",");
			if (!vt) {
				vt = new VelocityTracker(target);
			}
			while (--i > -1) {
				vt.addProp(a[i], types[i] || types[0]);
			}
			return vt;
		};

		VelocityTracker.untrack = function(target, props) {
			var vt = getByTarget(target),
				a = (props || "").split(","),
				i = a.length;
			if (!vt) {
				return;
			}
			while (--i > -1) {
				vt.removeProp(a[i]);
			}
			if (!vt._firstVP || !props) {
				if (vt._prev) {
					vt._prev._next = vt._next;
				} else if (vt === _first) {
					_first = vt._next;
				}
				if (vt._next) {
					vt._next._prev = vt._prev;
				}
			}
		};

		VelocityTracker.isTracking = function(target, prop) {
			var vt = getByTarget(target);
			return (!vt) ? false : (!prop && vt._firstVP) ? true : vt.isTrackingProp(prop);
		};

		return VelocityTracker;

	}, true);


}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }

//export to AMD/RequireJS and CommonJS/Node (precursor to full modular build system coming at a later date)
(function(name) {
	"use strict";
	var getGlobal = function() {
		return (_gsScope.GreenSockGlobals || _gsScope)[name];
	};
	if (typeof(define) === "function" && define.amd) { //AMD
		define(["TweenLite"], getGlobal);
	} else if (typeof(module) !== "undefined" && module.exports) { //node
		require("../TweenLite.js");
		module.exports = getGlobal();
	}
}("ThrowPropsPlugin"));
/*!
 * VERSION: 1.7.5
 * DATE: 2015-02-26
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	var _doc = document.documentElement,
		_window = window,
		_max = function(element, axis) {
			var dim = (axis === "x") ? "Width" : "Height",
				scroll = "scroll" + dim,
				client = "client" + dim,
				body = document.body;
			return (element === _window || element === _doc || element === body) ? Math.max(_doc[scroll], body[scroll]) - (_window["inner" + dim] || _doc[client] || body[client]) : element[scroll] - element["offset" + dim];
		},

		ScrollToPlugin = _gsScope._gsDefine.plugin({
			propName: "scrollTo",
			API: 2,
			version:"1.7.5",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function(target, value, tween) {
				this._wdw = (target === _window);
				this._target = target;
				this._tween = tween;
				if (typeof(value) !== "object") {
					value = {y:value}; //if we don't receive an object as the parameter, assume the user intends "y".
				}
				this.vars = value;
				this._autoKill = (value.autoKill !== false);
				this.x = this.xPrev = this.getX();
				this.y = this.yPrev = this.getY();
				if (value.x != null) {
					this._addTween(this, "x", this.x, (value.x === "max") ? _max(target, "x") : value.x, "scrollTo_x", true);
					this._overwriteProps.push("scrollTo_x");
				} else {
					this.skipX = true;
				}
				if (value.y != null) {
					this._addTween(this, "y", this.y, (value.y === "max") ? _max(target, "y") : value.y, "scrollTo_y", true);
					this._overwriteProps.push("scrollTo_y");
				} else {
					this.skipY = true;
				}
				return true;
			},

			//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
			set: function(v) {
				this._super.setRatio.call(this, v);

				var x = (this._wdw || !this.skipX) ? this.getX() : this.xPrev,
					y = (this._wdw || !this.skipY) ? this.getY() : this.yPrev,
					yDif = y - this.yPrev,
					xDif = x - this.xPrev;

				if (this._autoKill) {
					//note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
					if (!this.skipX && (xDif > 7 || xDif < -7) && x < _max(this._target, "x")) {
						this.skipX = true; //if the user scrolls separately, we should stop tweening!
					}
					if (!this.skipY && (yDif > 7 || yDif < -7) && y < _max(this._target, "y")) {
						this.skipY = true; //if the user scrolls separately, we should stop tweening!
					}
					if (this.skipX && this.skipY) {
						this._tween.kill();
						if (this.vars.onAutoKill) {
							this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);
						}
					}
				}
				if (this._wdw) {
					_window.scrollTo((!this.skipX) ? this.x : x, (!this.skipY) ? this.y : y);
				} else {
					if (!this.skipY) {
						this._target.scrollTop = this.y;
					}
					if (!this.skipX) {
						this._target.scrollLeft = this.x;
					}
				}
				this.xPrev = this.x;
				this.yPrev = this.y;
			}

		}),
		p = ScrollToPlugin.prototype;

	ScrollToPlugin.max = _max;

	p.getX = function() {
		return (!this._wdw) ? this._target.scrollLeft : (_window.pageXOffset != null) ? _window.pageXOffset : (_doc.scrollLeft != null) ? _doc.scrollLeft : document.body.scrollLeft;
	};

	p.getY = function() {
		return (!this._wdw) ? this._target.scrollTop : (_window.pageYOffset != null) ? _window.pageYOffset : (_doc.scrollTop != null) ? _doc.scrollTop : document.body.scrollTop;
	};

	p._kill = function(lookup) {
		if (lookup.scrollTo_x) {
			this.skipX = true;
		}
		if (lookup.scrollTo_y) {
			this.skipY = true;
		}
		return this._super._kill.call(this, lookup);
	};

}); if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); }
/* FIXED WITH THE SOLUTION FOUND IN https://github.com/kenwheeler/slick/pull/1660/commits */
/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" data-role="none" role="button" tabindex="0" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                activateRows: false,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.getNavTarget = function() {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.getNavTarget();

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if ( _.slideCount > _.options.slidesToShow ) {
            _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this,
            slideTo = _.currentSlide + _.options.slidesToScroll;

        if ( !_.paused && !_.interrupted && !_.focussed ) {

            if ( _.options.infinite === false ) {

                if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                    _.direction = 0;
                }

                else if ( _.direction === 0 ) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if ( _.currentSlide - 1 === 0 ) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler( slideTo );

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 1 || (_.options.rows === 1 && _.options.activateRows === true)) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.currentTarget),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots)
                .off('click.slick', _.changeSlide)
                .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 1 || (_.options.rows === 1 && _.options.activateRows === true)) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }


        if ( _.$prevArrow && _.$prevArrow.length ) {

            _.$prevArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.prevArrow )) {
                _.$prevArrow.remove();
            }
        }

        if ( _.$nextArrow && _.$nextArrow.length ) {

            _.$nextArrow
                .removeClass('slick-disabled slick-arrow slick-hidden')
                .removeAttr('aria-hidden aria-disabled tabindex')
                .css('display','');

            if ( _.htmlExpr.test( _.options.nextArrow )) {
                _.$nextArrow.remove();
            }

        }


        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider
            .off('focus.slick blur.slick')
            .on('focus.slick blur.slick',
                '*:not(.slick-arrow)', function(event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function() {

                if( _.options.pauseOnFocus ) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }

            }, 0);

        });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if(!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        }else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft =  0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft =  0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if ( _.options.autoplay ) {

            _.paused = false;
            _.autoPlay();

        }

    };

    Slick.prototype.initADA = function() {
        var _ = this;
        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        _.$slideTrack.attr('role', 'listbox');

        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
            $(this).attr({
                'role': 'option',
                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''
            });
        });

        if (_.$dots !== null) {
            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                $(this).attr({
                    'role': 'presentation',
                    'aria-selected': 'false',
                    'aria-controls': 'navigation' + _.instanceUid + i + '',
                    'id': 'slick-slide' + _.instanceUid + i + ''
                });
            })
                .first().attr('aria-selected', 'true').end()
                .find('button').attr('role', 'button').end()
                .closest('div').attr('role', 'toolbar');
        }
        _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'previous'
               }, _.changeSlide);
            _.$nextArrow
               .off('click.slick')
               .on('click.slick', {
                    message: 'next'
               }, _.changeSlide);
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

        if ( _.options.dots === true && _.options.pauseOnDotsHover === true ) {

            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
                .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if ( _.options.pauseOnHover ) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
         //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' :  'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image
                        .animate({ opacity: 0 }, 100, function() {
                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy')
                                        .removeClass('slick-loading');
                                });
                            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                        });

                };

                imageToLoad.onerror = function() {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                };

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if( !_.unslicked ) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            _.setPosition();

            _.swipeLeft = null;

            if ( _.options.autoplay ) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();
            }

        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function( tryCount ) {

        tryCount = tryCount || 1;

        var _ = this,
            $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
            image,
            imageSource,
            imageToLoad;

        if ( $imgsToLoad.length ) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                image
                    .attr( 'src', imageSource )
                    .removeAttr('data-lazy')
                    .removeClass('slick-loading');

                if ( _.options.adaptiveHeight === true ) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
                _.progressiveLazyLoad();

            };

            imageToLoad.onerror = function() {

                if ( tryCount < 3 ) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout( function() {
                        _.progressiveLazyLoad( tryCount + 1 );
                    }, 500 );

                } else {

                    image
                        .removeAttr( 'data-lazy' )
                        .removeClass( 'slick-loading' )
                        .addClass( 'slick-lazyload-error' );

                    _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                    _.progressiveLazyLoad();

                }

            };

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [ _ ]);

        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if ( _.slideCount <= _.options.slidesToShow ) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;
                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption =
    Slick.prototype.slickSetOption = function() {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this, l, item, option, value, refresh = false, type;

        if( $.type( arguments[0] ) === 'object' ) {

            option =  arguments[0];
            refresh = arguments[1];
            type = 'multiple';

        } else if ( $.type( arguments[0] ) === 'string' ) {

            option =  arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

                type = 'responsive';

            } else if ( typeof arguments[1] !== 'undefined' ) {

                type = 'single';

            }

        }

        if ( type === 'single' ) {

            _.options[option] = value;


        } else if ( type === 'multiple' ) {

            $.each( option , function( opt, val ) {

                _.options[opt] = val;

            });


        } else if ( type === 'responsive' ) {

            for ( item in value ) {

                if( $.type( _.options.responsive ) !== 'array' ) {

                    _.options.responsive = [ value[item] ];

                } else {

                    l = _.options.responsive.length-1;

                    // loop through the responsive object and splice out duplicates.
                    while( l >= 0 ) {

                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                            _.options.responsive.splice(l,1);

                        }

                        l--;

                    }

                    _.options.responsive.push( value[item] );

                }

            }

        }

        if ( refresh ) {

            _.unload();
            _.reinit();

        }

    };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {

                    _.$slides
                        .slice(index - centerOffset, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }

    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                        infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.interrupt = function( toggle ) {

        var _ = this;

        if( !toggle ) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));
        
        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.setSlideClasses(index);
            _.asNavFor(index); 
            return;
        }

        _.slideHandler(index);

    };          

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if ( _.options.autoplay ) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if ( _.options.asNavFor ) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');
            if ( navTarget.slideCount <= navTarget.slidesToShow ) {
                 navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount,
            direction;

        _.dragging = false;
        _.interrupted = false;
        _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

        if ( _.touchObject.curX === undefined ) {
            return false;
        }

        if ( _.touchObject.edgeHit === true ) {
            _.$slider.trigger('edge', [_, _.swipeDirection() ]);
        }

        if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

            direction = _.swipeDirection();

            switch ( direction ) {

                case 'left':
                case 'down':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                            _.currentSlide + _.getSlideCount();

                    _.currentDirection = 0;

                    break;

                case 'right':
                case 'up':

                    slideCount =
                        _.options.swipeToSlide ?
                            _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                            _.currentSlide - _.getSlideCount();

                    _.currentDirection = 1;

                    break;

                default:


            }

            if( direction != 'vertical' ) {

                _.slideHandler( slideCount );
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction ]);

            }

        } else {

            if ( _.touchObject.startX !== _.touchObject.curX ) {

                _.slideHandler( _.currentSlide );
                _.touchObject = {};

            }

        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
            .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = Math.round(Math.sqrt(
                Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
        }

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                .removeClass('slick-active')
                .attr('aria-hidden', 'true');

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active')
                .attr('aria-hidden', 'false');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if ( _.options.autoplay ) {

            if ( document[_.hidden] ) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i,
            ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));
/**
 * Swiper 3.3.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2016, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: February 7, 2016
 */
(function () {
    'use strict';
    var $;
    /*===========================
    Swiper
    ===========================*/
    var Swiper = function (container, params) {
        if (!(this instanceof Swiper)) return new Swiper(container, params);

        var defaults = {
            direction: 'horizontal',
            touchEventsTarget: 'container',
            initialSlide: 0,
            speed: 300,
            // autoplay
            autoplay: false,
            autoplayDisableOnInteraction: true,
            autoplayStopOnLast: false,
            // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
            iOSEdgeSwipeDetection: false,
            iOSEdgeSwipeThreshold: 20,
            // Free mode
            freeMode: false,
            freeModeMomentum: true,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: true,
            freeModeMomentumBounceRatio: 1,
            freeModeSticky: false,
            freeModeMinimumVelocity: 0.02,
            // Autoheight
            autoHeight: false,
            // Set wrapper width
            setWrapperSize: false,
            // Virtual Translate
            virtualTranslate: false,
            // Effects
            effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
            coverflow: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows : true
            },
            flip: {
                slideShadows : true,
                limitRotation: true
            },
            cube: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            },
            fade: {
                crossFade: false
            },
            // Parallax
            parallax: false,
            // Scrollbar
            scrollbar: null,
            scrollbarHide: true,
            scrollbarDraggable: false,
            scrollbarSnapOnRelease: false,
            // Keyboard Mousewheel
            keyboardControl: false,
            mousewheelControl: false,
            mousewheelReleaseOnEdges: false,
            mousewheelInvert: false,
            mousewheelForceToAxis: false,
            mousewheelSensitivity: 1,
            // Hash Navigation
            hashnav: false,
            // Breakpoints
            breakpoints: undefined,
            // Slides grid
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerColumnFill: 'column',
            slidesPerGroup: 1,
            centeredSlides: false,
            slidesOffsetBefore: 0, // in px
            slidesOffsetAfter: 0, // in px
            // Round length
            roundLengths: false,
            // Touches
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: true,
            onlyExternal: false,
            threshold: 0,
            touchMoveStopPropagation: true,
            // Unique Navigation Elements
            uniqueNavElements: true,
            // Pagination
            pagination: null,
            paginationElement: 'span',
            paginationClickable: false,
            paginationHide: false,
            paginationBulletRender: null,
            paginationProgressRender: null,
            paginationFractionRender: null,
            paginationCustomRender: null,
            paginationType: 'bullets', // 'bullets' or 'progress' or 'fraction' or 'custom'
            // Resistance
            resistance: true,
            resistanceRatio: 0.85,
            // Next/prev buttons
            nextButton: null,
            prevButton: null,
            // Progress
            watchSlidesProgress: false,
            watchSlidesVisibility: false,
            // Cursor
            grabCursor: false,
            // Clicks
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            // Lazy Loading
            lazyLoading: false,
            lazyLoadingInPrevNext: false,
            lazyLoadingInPrevNextAmount: 1,
            lazyLoadingOnTransitionStart: false,
            // Images
            preloadImages: true,
            updateOnImagesReady: true,
            // loop
            loop: false,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            // Control
            control: undefined,
            controlInverse: false,
            controlBy: 'slide', //or 'container'
            // Swiping/no swiping
            allowSwipeToPrev: true,
            allowSwipeToNext: true,
            swipeHandler: null, //'.swipe-handler',
            noSwiping: true,
            noSwipingClass: 'swiper-no-swiping',
            // NS
            slideClass: 'swiper-slide',
            slideActiveClass: 'swiper-slide-active',
            slideVisibleClass: 'swiper-slide-visible',
            slideDuplicateClass: 'swiper-slide-duplicate',
            slideNextClass: 'swiper-slide-next',
            slidePrevClass: 'swiper-slide-prev',
            wrapperClass: 'swiper-wrapper',
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            buttonDisabledClass: 'swiper-button-disabled',
            paginationCurrentClass: 'swiper-pagination-current',
            paginationTotalClass: 'swiper-pagination-total',
            paginationHiddenClass: 'swiper-pagination-hidden',
            paginationProgressbarClass: 'swiper-pagination-progressbar',
            // Observer
            observer: false,
            observeParents: false,
            // Accessibility
            a11y: false,
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
            paginationBulletMessage: 'Go to slide {{index}}',
            // Callbacks
            runCallbacksOnInit: true
            /*
            Callbacks:
            onInit: function (swiper)
            onDestroy: function (swiper)
            onClick: function (swiper, e)
            onTap: function (swiper, e)
            onDoubleTap: function (swiper, e)
            onSliderMove: function (swiper, e)
            onSlideChangeStart: function (swiper)
            onSlideChangeEnd: function (swiper)
            onTransitionStart: function (swiper)
            onTransitionEnd: function (swiper)
            onImagesReady: function (swiper)
            onProgress: function (swiper, progress)
            onTouchStart: function (swiper, e)
            onTouchMove: function (swiper, e)
            onTouchMoveOpposite: function (swiper, e)
            onTouchEnd: function (swiper, e)
            onReachBeginning: function (swiper)
            onReachEnd: function (swiper)
            onSetTransition: function (swiper, duration)
            onSetTranslate: function (swiper, translate)
            onAutoplayStart: function (swiper)
            onAutoplayStop: function (swiper),
            onLazyImageLoad: function (swiper, slide, image)
            onLazyImageReady: function (swiper, slide, image)
            */
        
        };
        var initialVirtualTranslate = params && params.virtualTranslate;
        
        params = params || {};
        var originalParams = {};
        for (var param in params) {
            if (typeof params[param] === 'object' && params[param] !== null && !(params[param].nodeType || params[param] === window || params[param] === document || (typeof Dom7 !== 'undefined' && params[param] instanceof Dom7) || (typeof jQuery !== 'undefined' && params[param] instanceof jQuery))) {
                originalParams[param] = {};
                for (var deepParam in params[param]) {
                    originalParams[param][deepParam] = params[param][deepParam];
                }
            }
            else {
                originalParams[param] = params[param];
            }
        }
        for (var def in defaults) {
            if (typeof params[def] === 'undefined') {
                params[def] = defaults[def];
            }
            else if (typeof params[def] === 'object') {
                for (var deepDef in defaults[def]) {
                    if (typeof params[def][deepDef] === 'undefined') {
                        params[def][deepDef] = defaults[def][deepDef];
                    }
                }
            }
        }
        
        // Swiper
        var s = this;
        
        // Params
        s.params = params;
        s.originalParams = originalParams;
        
        // Classname
        s.classNames = [];
        /*=========================
          Dom Library and plugins
          ===========================*/
        if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){
            $ = Dom7;
        }
        if (typeof $ === 'undefined') {
            if (typeof Dom7 === 'undefined') {
                $ = window.Dom7 || window.Zepto || window.jQuery;
            }
            else {
                $ = Dom7;
            }
            if (!$) return;
        }
        // Export it to Swiper instance
        s.$ = $;
        
        /*=========================
          Breakpoints
          ===========================*/
        s.currentBreakpoint = undefined;
        s.getActiveBreakpoint = function () {
            //Get breakpoint for window width
            if (!s.params.breakpoints) return false;
            var breakpoint = false;
            var points = [], point;
            for ( point in s.params.breakpoints ) {
                if (s.params.breakpoints.hasOwnProperty(point)) {
                    points.push(point);
                }
            }
            points.sort(function (a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                if (point >= window.innerWidth && !breakpoint) {
                    breakpoint = point;
                }
            }
            return breakpoint || 'max';
        };
        s.setBreakpoint = function () {
            //Set breakpoint for window width and update parameters
            var breakpoint = s.getActiveBreakpoint();
            if (breakpoint && s.currentBreakpoint !== breakpoint) {
                var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
                var needsReLoop = s.params.loop && (breakPointsParams.slidesPerView !== s.params.slidesPerView);
                for ( var param in breakPointsParams ) {
                    s.params[param] = breakPointsParams[param];
                }
                s.currentBreakpoint = breakpoint;
                if(needsReLoop && s.destroyLoop) {
                    s.reLoop(true);
                }
            }
        };
        // Set breakpoint on load
        if (s.params.breakpoints) {
            s.setBreakpoint();
        }
        
        /*=========================
          Preparation - Define Container, Wrapper and Pagination
          ===========================*/
        s.container = $(container);
        if (s.container.length === 0) return;
        if (s.container.length > 1) {
            var swipers = [];
            s.container.each(function () {
                var container = this;
                swipers.push(new Swiper(this, params));
            });
            return swipers;
        }
        
        // Save instance in container HTML Element and in data
        s.container[0].swiper = s;
        s.container.data('swiper', s);
        
        s.classNames.push('swiper-container-' + s.params.direction);
        
        if (s.params.freeMode) {
            s.classNames.push('swiper-container-free-mode');
        }
        if (!s.support.flexbox) {
            s.classNames.push('swiper-container-no-flexbox');
            s.params.slidesPerColumn = 1;
        }
        if (s.params.autoHeight) {
            s.classNames.push('swiper-container-autoheight');
        }
        // Enable slides progress when required
        if (s.params.parallax || s.params.watchSlidesVisibility) {
            s.params.watchSlidesProgress = true;
        }
        // Coverflow / 3D
        if (['cube', 'coverflow', 'flip'].indexOf(s.params.effect) >= 0) {
            if (s.support.transforms3d) {
                s.params.watchSlidesProgress = true;
                s.classNames.push('swiper-container-3d');
            }
            else {
                s.params.effect = 'slide';
            }
        }
        if (s.params.effect !== 'slide') {
            s.classNames.push('swiper-container-' + s.params.effect);
        }
        if (s.params.effect === 'cube') {
            s.params.resistanceRatio = 0;
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.centeredSlides = false;
            s.params.spaceBetween = 0;
            s.params.virtualTranslate = true;
            s.params.setWrapperSize = false;
        }
        if (s.params.effect === 'fade' || s.params.effect === 'flip') {
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.watchSlidesProgress = true;
            s.params.spaceBetween = 0;
            s.params.setWrapperSize = false;
            if (typeof initialVirtualTranslate === 'undefined') {
                s.params.virtualTranslate = true;
            }
        }
        
        // Grab Cursor
        if (s.params.grabCursor && s.support.touch) {
            s.params.grabCursor = false;
        }
        
        // Wrapper
        s.wrapper = s.container.children('.' + s.params.wrapperClass);
        
        // Pagination
        if (s.params.pagination) {
            s.paginationContainer = $(s.params.pagination);
            if (s.params.uniqueNavElements && typeof s.params.pagination === 'string' && s.paginationContainer.length > 1 && s.container.find(s.params.pagination).length === 1) {
                s.paginationContainer = s.container.find(s.params.pagination);
            }
        
            if (s.params.paginationType === 'bullets' && s.params.paginationClickable) {
                s.paginationContainer.addClass('swiper-pagination-clickable');
            }
            else {
                s.params.paginationClickable = false;
            }
            s.paginationContainer.addClass('swiper-pagination-' + s.params.paginationType);
        }
        // Next/Prev Buttons
        if (s.params.nextButton || s.params.prevButton) {
            if (s.params.nextButton) {
                s.nextButton = $(s.params.nextButton);
                if (s.params.uniqueNavElements && typeof s.params.nextButton === 'string' && s.nextButton.length > 1 && s.container.find(s.params.nextButton).length === 1) {
                    s.nextButton = s.container.find(s.params.nextButton);
                }
            }
            if (s.params.prevButton) {
                s.prevButton = $(s.params.prevButton);
                if (s.params.uniqueNavElements && typeof s.params.prevButton === 'string' && s.prevButton.length > 1 && s.container.find(s.params.prevButton).length === 1) {
                    s.prevButton = s.container.find(s.params.prevButton);
                }
            }
        }
        
        // Is Horizontal
        s.isHorizontal = function () {
            return s.params.direction === 'horizontal';
        };
        // s.isH = isH;
        
        // RTL
        s.rtl = s.isHorizontal() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
        if (s.rtl) {
            s.classNames.push('swiper-container-rtl');
        }
        
        // Wrong RTL support
        if (s.rtl) {
            s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
        }
        
        // Columns
        if (s.params.slidesPerColumn > 1) {
            s.classNames.push('swiper-container-multirow');
        }
        
        // Check for Android
        if (s.device.android) {
            s.classNames.push('swiper-container-android');
        }
        
        // Add classes
        s.container.addClass(s.classNames.join(' '));
        
        // Translate
        s.translate = 0;
        
        // Progress
        s.progress = 0;
        
        // Velocity
        s.velocity = 0;
        
        /*=========================
          Locks, unlocks
          ===========================*/
        s.lockSwipeToNext = function () {
            s.params.allowSwipeToNext = false;
        };
        s.lockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = false;
        };
        s.lockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
        };
        s.unlockSwipeToNext = function () {
            s.params.allowSwipeToNext = true;
        };
        s.unlockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = true;
        };
        s.unlockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
        };
        
        /*=========================
          Round helper
          ===========================*/
        function round(a) {
            return Math.floor(a);
        }
        /*=========================
          Set grab cursor
          ===========================*/
        if (s.params.grabCursor) {
            s.container[0].style.cursor = 'move';
            s.container[0].style.cursor = '-webkit-grab';
            s.container[0].style.cursor = '-moz-grab';
            s.container[0].style.cursor = 'grab';
        }
        /*=========================
          Update on Images Ready
          ===========================*/
        s.imagesToLoad = [];
        s.imagesLoaded = 0;
        
        s.loadImage = function (imgElement, src, srcset, checkForComplete, callback) {
            var image;
            function onReady () {
                if (callback) callback();
            }
            if (!imgElement.complete || !checkForComplete) {
                if (src) {
                    image = new window.Image();
                    image.onload = onReady;
                    image.onerror = onReady;
                    if (srcset) {
                        image.srcset = srcset;
                    }
                    if (src) {
                        image.src = src;
                    }
                } else {
                    onReady();
                }
        
            } else {//image already loaded...
                onReady();
            }
        };
        s.preloadImages = function () {
            s.imagesToLoad = s.container.find('img');
            function _onReady() {
                if (typeof s === 'undefined' || s === null) return;
                if (s.imagesLoaded !== undefined) s.imagesLoaded++;
                if (s.imagesLoaded === s.imagesToLoad.length) {
                    if (s.params.updateOnImagesReady) s.update();
                    s.emit('onImagesReady', s);
                }
            }
            for (var i = 0; i < s.imagesToLoad.length; i++) {
                s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), (s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset')), true, _onReady);
            }
        };
        
        /*=========================
          Autoplay
          ===========================*/
        s.autoplayTimeoutId = undefined;
        s.autoplaying = false;
        s.autoplayPaused = false;
        function autoplay() {
            s.autoplayTimeoutId = setTimeout(function () {
                if (s.params.loop) {
                    s.fixLoop();
                    s._slideNext();
                    s.emit('onAutoplay', s);
                }
                else {
                    if (!s.isEnd) {
                        s._slideNext();
                        s.emit('onAutoplay', s);
                    }
                    else {
                        if (!params.autoplayStopOnLast) {
                            s._slideTo(0);
                            s.emit('onAutoplay', s);
                        }
                        else {
                            s.stopAutoplay();
                        }
                    }
                }
            }, s.params.autoplay);
        }
        s.startAutoplay = function () {
            if (typeof s.autoplayTimeoutId !== 'undefined') return false;
            if (!s.params.autoplay) return false;
            if (s.autoplaying) return false;
            s.autoplaying = true;
            s.emit('onAutoplayStart', s);
            autoplay();
        };
        s.stopAutoplay = function (internal) {
            if (!s.autoplayTimeoutId) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplaying = false;
            s.autoplayTimeoutId = undefined;
            s.emit('onAutoplayStop', s);
        };
        s.pauseAutoplay = function (speed) {
            if (s.autoplayPaused) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplayPaused = true;
            if (speed === 0) {
                s.autoplayPaused = false;
                autoplay();
            }
            else {
                s.wrapper.transitionEnd(function () {
                    if (!s) return;
                    s.autoplayPaused = false;
                    if (!s.autoplaying) {
                        s.stopAutoplay();
                    }
                    else {
                        autoplay();
                    }
                });
            }
        };
        /*=========================
          Min/Max Translate
          ===========================*/
        s.minTranslate = function () {
            return (-s.snapGrid[0]);
        };
        s.maxTranslate = function () {
            return (-s.snapGrid[s.snapGrid.length - 1]);
        };
        /*=========================
          Slider/slides sizes
          ===========================*/
        s.updateAutoHeight = function () {
            // Update Height
            var slide = s.slides.eq(s.activeIndex)[0];
            if (typeof slide !== 'undefined') {
                var newHeight = slide.offsetHeight;
                if (newHeight) s.wrapper.css('height', newHeight + 'px');
            }
        };
        s.updateContainerSize = function () {
            var width, height;
            if (typeof s.params.width !== 'undefined') {
                width = s.params.width;
            }
            else {
                width = s.container[0].clientWidth;
            }
            if (typeof s.params.height !== 'undefined') {
                height = s.params.height;
            }
            else {
                height = s.container[0].clientHeight;
            }
            if (width === 0 && s.isHorizontal() || height === 0 && !s.isHorizontal()) {
                return;
            }
        
            //Subtract paddings
            width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
            height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
        
            // Store values
            s.width = width;
            s.height = height;
            s.size = s.isHorizontal() ? s.width : s.height;
        };
        
        s.updateSlidesSize = function () {
            s.slides = s.wrapper.children('.' + s.params.slideClass);
            s.snapGrid = [];
            s.slidesGrid = [];
            s.slidesSizesGrid = [];
        
            var spaceBetween = s.params.spaceBetween,
                slidePosition = -s.params.slidesOffsetBefore,
                i,
                prevSlideSize = 0,
                index = 0;
            if (typeof s.size === 'undefined') return;
            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
            }
        
            s.virtualSize = -spaceBetween;
            // reset margins
            if (s.rtl) s.slides.css({marginLeft: '', marginTop: ''});
            else s.slides.css({marginRight: '', marginBottom: ''});
        
            var slidesNumberEvenToRows;
            if (s.params.slidesPerColumn > 1) {
                if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
                    slidesNumberEvenToRows = s.slides.length;
                }
                else {
                    slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
                }
                if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
                    slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
                }
            }
        
            // Calc slides
            var slideSize;
            var slidesPerColumn = s.params.slidesPerColumn;
            var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
            var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
            for (i = 0; i < s.slides.length; i++) {
                slideSize = 0;
                var slide = s.slides.eq(i);
                if (s.params.slidesPerColumn > 1) {
                    // Set slides order
                    var newSlideOrderIndex;
                    var column, row;
                    if (s.params.slidesPerColumnFill === 'column') {
                        column = Math.floor(i / slidesPerColumn);
                        row = i - column * slidesPerColumn;
                        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn-1)) {
                            if (++row >= slidesPerColumn) {
                                row = 0;
                                column++;
                            }
                        }
                        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                        slide
                            .css({
                                '-webkit-box-ordinal-group': newSlideOrderIndex,
                                '-moz-box-ordinal-group': newSlideOrderIndex,
                                '-ms-flex-order': newSlideOrderIndex,
                                '-webkit-order': newSlideOrderIndex,
                                'order': newSlideOrderIndex
                            });
                    }
                    else {
                        row = Math.floor(i / slidesPerRow);
                        column = i - row * slidesPerRow;
                    }
                    slide
                        .css({
                            'margin-top': (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')
                        })
                        .attr('data-swiper-column', column)
                        .attr('data-swiper-row', row);
        
                }
                if (slide.css('display') === 'none') continue;
                if (s.params.slidesPerView === 'auto') {
                    slideSize = s.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                    if (s.params.roundLengths) slideSize = round(slideSize);
                }
                else {
                    slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
                    if (s.params.roundLengths) slideSize = round(slideSize);
        
                    if (s.isHorizontal()) {
                        s.slides[i].style.width = slideSize + 'px';
                    }
                    else {
                        s.slides[i].style.height = slideSize + 'px';
                    }
                }
                s.slides[i].swiperSlideSize = slideSize;
                s.slidesSizesGrid.push(slideSize);
        
        
                if (s.params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                    if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                }
                else {
                    if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
        
                s.virtualSize += slideSize + spaceBetween;
        
                prevSlideSize = slideSize;
        
                index ++;
            }
            s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
            var newSlidesGrid;
        
            if (
                s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
                s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
            }
            if (!s.support.flexbox || s.params.setWrapperSize) {
                if (s.isHorizontal()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
                else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
            }
        
            if (s.params.slidesPerColumn > 1) {
                s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
                s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
                s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
                if (s.params.centeredSlides) {
                    newSlidesGrid = [];
                    for (i = 0; i < s.snapGrid.length; i++) {
                        if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
                    }
                    s.snapGrid = newSlidesGrid;
                }
            }
        
            // Remove last grid elements depending on width
            if (!s.params.centeredSlides) {
                newSlidesGrid = [];
                for (i = 0; i < s.snapGrid.length; i++) {
                    if (s.snapGrid[i] <= s.virtualSize - s.size) {
                        newSlidesGrid.push(s.snapGrid[i]);
                    }
                }
                s.snapGrid = newSlidesGrid;
                if (Math.floor(s.virtualSize - s.size) - Math.floor(s.snapGrid[s.snapGrid.length - 1]) > 1) {
                    s.snapGrid.push(s.virtualSize - s.size);
                }
            }
            if (s.snapGrid.length === 0) s.snapGrid = [0];
        
            if (s.params.spaceBetween !== 0) {
                if (s.isHorizontal()) {
                    if (s.rtl) s.slides.css({marginLeft: spaceBetween + 'px'});
                    else s.slides.css({marginRight: spaceBetween + 'px'});
                }
                else s.slides.css({marginBottom: spaceBetween + 'px'});
            }
            if (s.params.watchSlidesProgress) {
                s.updateSlidesOffset();
            }
        };
        s.updateSlidesOffset = function () {
            for (var i = 0; i < s.slides.length; i++) {
                s.slides[i].swiperSlideOffset = s.isHorizontal() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
            }
        };
        
        /*=========================
          Slider/slides progress
          ===========================*/
        s.updateSlidesProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            if (s.slides.length === 0) return;
            if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();
        
            var offsetCenter = -translate;
            if (s.rtl) offsetCenter = translate;
        
            // Visible Slides
            s.slides.removeClass(s.params.slideVisibleClass);
            for (var i = 0; i < s.slides.length; i++) {
                var slide = s.slides[i];
                var slideProgress = (offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
                if (s.params.watchSlidesVisibility) {
                    var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                    var slideAfter = slideBefore + s.slidesSizesGrid[i];
                    var isVisible =
                        (slideBefore >= 0 && slideBefore < s.size) ||
                        (slideAfter > 0 && slideAfter <= s.size) ||
                        (slideBefore <= 0 && slideAfter >= s.size);
                    if (isVisible) {
                        s.slides.eq(i).addClass(s.params.slideVisibleClass);
                    }
                }
                slide.progress = s.rtl ? -slideProgress : slideProgress;
            }
        };
        s.updateProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            var wasBeginning = s.isBeginning;
            var wasEnd = s.isEnd;
            if (translatesDiff === 0) {
                s.progress = 0;
                s.isBeginning = s.isEnd = true;
            }
            else {
                s.progress = (translate - s.minTranslate()) / (translatesDiff);
                s.isBeginning = s.progress <= 0;
                s.isEnd = s.progress >= 1;
            }
            if (s.isBeginning && !wasBeginning) s.emit('onReachBeginning', s);
            if (s.isEnd && !wasEnd) s.emit('onReachEnd', s);
        
            if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
            s.emit('onProgress', s, s.progress);
        };
        s.updateActiveIndex = function () {
            var translate = s.rtl ? s.translate : -s.translate;
            var newActiveIndex, i, snapIndex;
            for (i = 0; i < s.slidesGrid.length; i ++) {
                if (typeof s.slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
                        newActiveIndex = i;
                    }
                    else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
                        newActiveIndex = i + 1;
                    }
                }
                else {
                    if (translate >= s.slidesGrid[i]) {
                        newActiveIndex = i;
                    }
                }
            }
            // Normalize slideIndex
            if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
            // for (i = 0; i < s.slidesGrid.length; i++) {
                // if (- translate >= s.slidesGrid[i]) {
                    // newActiveIndex = i;
                // }
            // }
            snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
            if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;
        
            if (newActiveIndex === s.activeIndex) {
                return;
            }
            s.snapIndex = snapIndex;
            s.previousIndex = s.activeIndex;
            s.activeIndex = newActiveIndex;
            s.updateClasses();
        };
        
        /*=========================
          Classes
          ===========================*/
        s.updateClasses = function () {
            s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);
            var activeSlide = s.slides.eq(s.activeIndex);
            // Active classes
            activeSlide.addClass(s.params.slideActiveClass);
            // Next Slide
            var nextSlide = activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
            if (s.params.loop && nextSlide.length === 0) {
                s.slides.eq(0).addClass(s.params.slideNextClass);
            }
            // Prev Slide
            var prevSlide = activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
            if (s.params.loop && prevSlide.length === 0) {
                s.slides.eq(-1).addClass(s.params.slidePrevClass);
            }
        
            // Pagination
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                // Current/Total
                var current,
                    total = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                if (s.params.loop) {
                    current = Math.ceil((s.activeIndex - s.loopedSlides)/s.params.slidesPerGroup);
                    if (current > s.slides.length - 1 - s.loopedSlides * 2) {
                        current = current - (s.slides.length - s.loopedSlides * 2);
                    }
                    if (current > total - 1) current = current - total;
                    if (current < 0 && s.params.paginationType !== 'bullets') current = total + current;
                }
                else {
                    if (typeof s.snapIndex !== 'undefined') {
                        current = s.snapIndex;
                    }
                    else {
                        current = s.activeIndex || 0;
                    }
                }
                // Types
                if (s.params.paginationType === 'bullets' && s.bullets && s.bullets.length > 0) {
                    s.bullets.removeClass(s.params.bulletActiveClass);
                    if (s.paginationContainer.length > 1) {
                        s.bullets.each(function () {
                            if ($(this).index() === current) $(this).addClass(s.params.bulletActiveClass);
                        });
                    }
                    else {
                        s.bullets.eq(current).addClass(s.params.bulletActiveClass);
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    s.paginationContainer.find('.' + s.params.paginationCurrentClass).text(current + 1);
                    s.paginationContainer.find('.' + s.params.paginationTotalClass).text(total);
                }
                if (s.params.paginationType === 'progress') {
                    var scale = (current + 1) / total,
                        scaleX = scale,
                        scaleY = 1;
                    if (!s.isHorizontal()) {
                        scaleY = scale;
                        scaleX = 1;
                    }
                    s.paginationContainer.find('.' + s.params.paginationProgressbarClass).transform('translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')').transition(s.params.speed);
                }
                if (s.params.paginationType === 'custom' && s.params.paginationCustomRender) {
                    s.paginationContainer.html(s.params.paginationCustomRender(s, current + 1, total));
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        
            // Next/active buttons
            if (!s.params.loop) {
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    if (s.isBeginning) {
                        s.prevButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.prevButton);
                    }
                    else {
                        s.prevButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.prevButton);
                    }
                }
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    if (s.isEnd) {
                        s.nextButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.nextButton);
                    }
                    else {
                        s.nextButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.nextButton);
                    }
                }
            }
        };
        
        /*=========================
          Pagination
          ===========================*/
        s.updatePagination = function () {
            if (!s.params.pagination) return;
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                var paginationHTML = '';
                if (s.params.paginationType === 'bullets') {
                    var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                    for (var i = 0; i < numberOfBullets; i++) {
                        if (s.params.paginationBulletRender) {
                            paginationHTML += s.params.paginationBulletRender(i, s.params.bulletClass);
                        }
                        else {
                            paginationHTML += '<' + s.params.paginationElement+' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
                        }
                    }
                    s.paginationContainer.html(paginationHTML);
                    s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
                    if (s.params.paginationClickable && s.params.a11y && s.a11y) {
                        s.a11y.initPagination();
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    if (s.params.paginationFractionRender) {
                        paginationHTML = s.params.paginationFractionRender(s, s.params.paginationCurrentClass, s.params.paginationTotalClass);
                    }
                    else {
                        paginationHTML =
                            '<span class="' + s.params.paginationCurrentClass + '"></span>' +
                            ' / ' +
                            '<span class="' + s.params.paginationTotalClass+'"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType === 'progress') {
                    if (s.params.paginationProgressRender) {
                        paginationHTML = s.params.paginationProgressRender(s, s.params.paginationProgressbarClass);
                    }
                    else {
                        paginationHTML = '<span class="' + s.params.paginationProgressbarClass + '"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType !== 'custom') {
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        };
        /*=========================
          Common update method
          ===========================*/
        s.update = function (updateTranslate) {
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updateProgress();
            s.updatePagination();
            s.updateClasses();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            function forceSetTranslate() {
                newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
            }
            if (updateTranslate) {
                var translated, newTranslate;
                if (s.controller && s.controller.spline) {
                    s.controller.spline = undefined;
                }
                if (s.params.freeMode) {
                    forceSetTranslate();
                    if (s.params.autoHeight) {
                        s.updateAutoHeight();
                    }
                }
                else {
                    if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                        translated = s.slideTo(s.slides.length - 1, 0, false, true);
                    }
                    else {
                        translated = s.slideTo(s.activeIndex, 0, false, true);
                    }
                    if (!translated) {
                        forceSetTranslate();
                    }
                }
            }
            else if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
        };
        
        /*=========================
          Resize Handler
          ===========================*/
        s.onResize = function (forceUpdatePagination) {
            //Breakpoints
            if (s.params.breakpoints) {
                s.setBreakpoint();
            }
        
            // Disable locks on resize
            var allowSwipeToPrev = s.params.allowSwipeToPrev;
            var allowSwipeToNext = s.params.allowSwipeToNext;
            s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
        
            s.updateContainerSize();
            s.updateSlidesSize();
            if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            if (s.controller && s.controller.spline) {
                s.controller.spline = undefined;
            }
            var slideChangedBySlideTo = false;
            if (s.params.freeMode) {
                var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
        
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
            }
            else {
                s.updateClasses();
                if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                    slideChangedBySlideTo = s.slideTo(s.slides.length - 1, 0, false, true);
                }
                else {
                    slideChangedBySlideTo = s.slideTo(s.activeIndex, 0, false, true);
                }
            }
            if (s.params.lazyLoading && !slideChangedBySlideTo && s.lazy) {
                s.lazy.load();
            }
            // Return locks after resize
            s.params.allowSwipeToPrev = allowSwipeToPrev;
            s.params.allowSwipeToNext = allowSwipeToNext;
        };
        
        /*=========================
          Events
          ===========================*/
        
        //Define Touch Events
        var desktopEvents = ['mousedown', 'mousemove', 'mouseup'];
        if (window.navigator.pointerEnabled) desktopEvents = ['pointerdown', 'pointermove', 'pointerup'];
        else if (window.navigator.msPointerEnabled) desktopEvents = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
        s.touchEvents = {
            start : s.support.touch || !s.params.simulateTouch  ? 'touchstart' : desktopEvents[0],
            move : s.support.touch || !s.params.simulateTouch ? 'touchmove' : desktopEvents[1],
            end : s.support.touch || !s.params.simulateTouch ? 'touchend' : desktopEvents[2]
        };
        
        
        // WP8 Touch Events Fix
        if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
            (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
        }
        
        // Attach/detach events
        s.initEvents = function (detach) {
            var actionDom = detach ? 'off' : 'on';
            var action = detach ? 'removeEventListener' : 'addEventListener';
            var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
            var target = s.support.touch ? touchEventsTarget : document;
        
            var moveCapture = s.params.nested ? true : false;
        
            //Touch Events
            if (s.browser.ie) {
                touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
                target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                target[action](s.touchEvents.end, s.onTouchEnd, false);
            }
            else {
                if (s.support.touch) {
                    touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
                    touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                    touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, false);
                }
                if (params.simulateTouch && !s.device.ios && !s.device.android) {
                    touchEventsTarget[action]('mousedown', s.onTouchStart, false);
                    document[action]('mousemove', s.onTouchMove, moveCapture);
                    document[action]('mouseup', s.onTouchEnd, false);
                }
            }
            window[action]('resize', s.onResize);
        
            // Next, Prev, Index
            if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                s.nextButton[actionDom]('click', s.onClickNext);
                if (s.params.a11y && s.a11y) s.nextButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                s.prevButton[actionDom]('click', s.onClickPrev);
                if (s.params.a11y && s.a11y) s.prevButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.pagination && s.params.paginationClickable) {
                s.paginationContainer[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
                if (s.params.a11y && s.a11y) s.paginationContainer[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
            }
        
            // Prevent Links Clicks
            if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
        };
        s.attachEvents = function () {
            s.initEvents();
        };
        s.detachEvents = function () {
            s.initEvents(true);
        };
        
        /*=========================
          Handle Clicks
          ===========================*/
        // Prevent Clicks
        s.allowClick = true;
        s.preventClicks = function (e) {
            if (!s.allowClick) {
                if (s.params.preventClicks) e.preventDefault();
                if (s.params.preventClicksPropagation && s.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        };
        // Clicks
        s.onClickNext = function (e) {
            e.preventDefault();
            if (s.isEnd && !s.params.loop) return;
            s.slideNext();
        };
        s.onClickPrev = function (e) {
            e.preventDefault();
            if (s.isBeginning && !s.params.loop) return;
            s.slidePrev();
        };
        s.onClickIndex = function (e) {
            e.preventDefault();
            var index = $(this).index() * s.params.slidesPerGroup;
            if (s.params.loop) index = index + s.loopedSlides;
            s.slideTo(index);
        };
        
        /*=========================
          Handle Touches
          ===========================*/
        function findElementInEvent(e, selector) {
            var el = $(e.target);
            if (!el.is(selector)) {
                if (typeof selector === 'string') {
                    el = el.parents(selector);
                }
                else if (selector.nodeType) {
                    var found;
                    el.parents().each(function (index, _el) {
                        if (_el === selector) found = selector;
                    });
                    if (!found) return undefined;
                    else return selector;
                }
            }
            if (el.length === 0) {
                return undefined;
            }
            return el[0];
        }
        s.updateClickedSlide = function (e) {
            var slide = findElementInEvent(e, '.' + s.params.slideClass);
            var slideFound = false;
            if (slide) {
                for (var i = 0; i < s.slides.length; i++) {
                    if (s.slides[i] === slide) slideFound = true;
                }
            }
        
            if (slide && slideFound) {
                s.clickedSlide = slide;
                s.clickedIndex = $(slide).index();
            }
            else {
                s.clickedSlide = undefined;
                s.clickedIndex = undefined;
                return;
            }
            if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
                var slideToIndex = s.clickedIndex,
                    realIndex,
                    duplicatedSlides;
                if (s.params.loop) {
                    if (s.animating) return;
                    realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');
                    if (s.params.centeredSlides) {
                        if ((slideToIndex < s.loopedSlides - s.params.slidesPerView/2) || (slideToIndex > s.slides.length - s.loopedSlides + s.params.slidesPerView/2)) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        }
                        else {
                            s.slideTo(slideToIndex);
                        }
                    }
                    else {
                        if (slideToIndex > s.slides.length - s.params.slidesPerView) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        }
                        else {
                            s.slideTo(slideToIndex);
                        }
                    }
                }
                else {
                    s.slideTo(slideToIndex);
                }
            }
        };
        
        var isTouched,
            isMoved,
            allowTouchCallbacks,
            touchStartTime,
            isScrolling,
            currentTranslate,
            startTranslate,
            allowThresholdMove,
            // Form elements to match
            formElements = 'input, select, textarea, button',
            // Last click time
            lastClickTime = Date.now(), clickTimeout,
            //Velocities
            velocities = [],
            allowMomentumBounce;
        
        // Animating Flag
        s.animating = false;
        
        // Touches information
        s.touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
        };
        
        // Touch handlers
        var isTouchEvent, startMoving;
        s.onTouchStart = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            isTouchEvent = e.type === 'touchstart';
            if (!isTouchEvent && 'which' in e && e.which === 3) return;
            if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
                s.allowClick = true;
                return;
            }
            if (s.params.swipeHandler) {
                if (!findElementInEvent(e, s.params.swipeHandler)) return;
            }
        
            var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        
            // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
            if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
                return;
            }
        
            isTouched = true;
            isMoved = false;
            allowTouchCallbacks = true;
            isScrolling = undefined;
            startMoving = undefined;
            s.touches.startX = startX;
            s.touches.startY = startY;
            touchStartTime = Date.now();
            s.allowClick = true;
            s.updateContainerSize();
            s.swipeDirection = undefined;
            if (s.params.threshold > 0) allowThresholdMove = false;
            if (e.type !== 'touchstart') {
                var preventDefault = true;
                if ($(e.target).is(formElements)) preventDefault = false;
                if (document.activeElement && $(document.activeElement).is(formElements)) {
                    document.activeElement.blur();
                }
                if (preventDefault) {
                    e.preventDefault();
                }
            }
            s.emit('onTouchStart', s, e);
        };
        
        s.onTouchMove = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (isTouchEvent && e.type === 'mousemove') return;
            if (e.preventedByNestedSwiper) {
                s.touches.startX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                s.touches.startY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                return;
            }
            if (s.params.onlyExternal) {
                // isMoved = true;
                s.allowClick = false;
                if (isTouched) {
                    s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                    s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                    touchStartTime = Date.now();
                }
                return;
            }
            if (isTouchEvent && document.activeElement) {
                if (e.target === document.activeElement && $(e.target).is(formElements)) {
                    isMoved = true;
                    s.allowClick = false;
                    return;
                }
            }
            if (allowTouchCallbacks) {
                s.emit('onTouchMove', s, e);
            }
            if (e.targetTouches && e.targetTouches.length > 1) return;
        
            s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        
            if (typeof isScrolling === 'undefined') {
                var touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
                isScrolling = s.isHorizontal() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
            }
            if (isScrolling) {
                s.emit('onTouchMoveOpposite', s, e);
            }
            if (typeof startMoving === 'undefined' && s.browser.ieTouch) {
                if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
                    startMoving = true;
                }
            }
            if (!isTouched) return;
            if (isScrolling)  {
                isTouched = false;
                return;
            }
            if (!startMoving && s.browser.ieTouch) {
                return;
            }
            s.allowClick = false;
            s.emit('onSliderMove', s, e);
            e.preventDefault();
            if (s.params.touchMoveStopPropagation && !s.params.nested) {
                e.stopPropagation();
            }
        
            if (!isMoved) {
                if (params.loop) {
                    s.fixLoop();
                }
                startTranslate = s.getWrapperTranslate();
                s.setWrapperTransition(0);
                if (s.animating) {
                    s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
                }
                if (s.params.autoplay && s.autoplaying) {
                    if (s.params.autoplayDisableOnInteraction) {
                        s.stopAutoplay();
                    }
                    else {
                        s.pauseAutoplay();
                    }
                }
                allowMomentumBounce = false;
                //Grab Cursor
                if (s.params.grabCursor) {
                    s.container[0].style.cursor = 'move';
                    s.container[0].style.cursor = '-webkit-grabbing';
                    s.container[0].style.cursor = '-moz-grabbin';
                    s.container[0].style.cursor = 'grabbing';
                }
            }
            isMoved = true;
        
            var diff = s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
        
            diff = diff * s.params.touchRatio;
            if (s.rtl) diff = -diff;
        
            s.swipeDirection = diff > 0 ? 'prev' : 'next';
            currentTranslate = diff + startTranslate;
        
            var disableParentSwiper = true;
            if ((diff > 0 && currentTranslate > s.minTranslate())) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
            }
            else if (diff < 0 && currentTranslate < s.maxTranslate()) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
            }
        
            if (disableParentSwiper) {
                e.preventedByNestedSwiper = true;
            }
        
            // Directions locks
            if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
                currentTranslate = startTranslate;
            }
            if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
                currentTranslate = startTranslate;
            }
        
            if (!s.params.followFinger) return;
        
            // Threshold
            if (s.params.threshold > 0) {
                if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
                    if (!allowThresholdMove) {
                        allowThresholdMove = true;
                        s.touches.startX = s.touches.currentX;
                        s.touches.startY = s.touches.currentY;
                        currentTranslate = startTranslate;
                        s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                        return;
                    }
                }
                else {
                    currentTranslate = startTranslate;
                    return;
                }
            }
            // Update active index in free mode
            if (s.params.freeMode || s.params.watchSlidesProgress) {
                s.updateActiveIndex();
            }
            if (s.params.freeMode) {
                //Velocity
                if (velocities.length === 0) {
                    velocities.push({
                        position: s.touches[s.isHorizontal() ? 'startX' : 'startY'],
                        time: touchStartTime
                    });
                }
                velocities.push({
                    position: s.touches[s.isHorizontal() ? 'currentX' : 'currentY'],
                    time: (new window.Date()).getTime()
                });
            }
            // Update progress
            s.updateProgress(currentTranslate);
            // Update translate
            s.setWrapperTranslate(currentTranslate);
        };
        s.onTouchEnd = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (allowTouchCallbacks) {
                s.emit('onTouchEnd', s, e);
            }
            allowTouchCallbacks = false;
            if (!isTouched) return;
            //Return Grab Cursor
            if (s.params.grabCursor && isMoved && isTouched) {
                s.container[0].style.cursor = 'move';
                s.container[0].style.cursor = '-webkit-grab';
                s.container[0].style.cursor = '-moz-grab';
                s.container[0].style.cursor = 'grab';
            }
        
            // Time diff
            var touchEndTime = Date.now();
            var timeDiff = touchEndTime - touchStartTime;
        
            // Tap, doubleTap, Click
            if (s.allowClick) {
                s.updateClickedSlide(e);
                s.emit('onTap', s, e);
                if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    clickTimeout = setTimeout(function () {
                        if (!s) return;
                        if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
                            s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
                        }
                        s.emit('onClick', s, e);
                    }, 300);
        
                }
                if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    s.emit('onDoubleTap', s, e);
                }
            }
        
            lastClickTime = Date.now();
            setTimeout(function () {
                if (s) s.allowClick = true;
            }, 0);
        
            if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
                isTouched = isMoved = false;
                return;
            }
            isTouched = isMoved = false;
        
            var currentPos;
            if (s.params.followFinger) {
                currentPos = s.rtl ? s.translate : -s.translate;
            }
            else {
                currentPos = -currentTranslate;
            }
            if (s.params.freeMode) {
                if (currentPos < -s.minTranslate()) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                else if (currentPos > -s.maxTranslate()) {
                    if (s.slides.length < s.snapGrid.length) {
                        s.slideTo(s.snapGrid.length - 1);
                    }
                    else {
                        s.slideTo(s.slides.length - 1);
                    }
                    return;
                }
        
                if (s.params.freeModeMomentum) {
                    if (velocities.length > 1) {
                        var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop();
        
                        var distance = lastMoveEvent.position - velocityEvent.position;
                        var time = lastMoveEvent.time - velocityEvent.time;
                        s.velocity = distance / time;
                        s.velocity = s.velocity / 2;
                        if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
                            s.velocity = 0;
                        }
                        // this implies that the user stopped moving a finger then released.
                        // There would be no events with distance zero, so the last event is stale.
                        if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
                            s.velocity = 0;
                        }
                    } else {
                        s.velocity = 0;
                    }
        
                    velocities.length = 0;
                    var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
                    var momentumDistance = s.velocity * momentumDuration;
        
                    var newPosition = s.translate + momentumDistance;
                    if (s.rtl) newPosition = - newPosition;
                    var doBounce = false;
                    var afterBouncePosition;
                    var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
                    if (newPosition < s.maxTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition + s.maxTranslate() < -bounceAmount) {
                                newPosition = s.maxTranslate() - bounceAmount;
                            }
                            afterBouncePosition = s.maxTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        }
                        else {
                            newPosition = s.maxTranslate();
                        }
                    }
                    else if (newPosition > s.minTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition - s.minTranslate() > bounceAmount) {
                                newPosition = s.minTranslate() + bounceAmount;
                            }
                            afterBouncePosition = s.minTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        }
                        else {
                            newPosition = s.minTranslate();
                        }
                    }
                    else if (s.params.freeModeSticky) {
                        var j = 0,
                            nextSlide;
                        for (j = 0; j < s.snapGrid.length; j += 1) {
                            if (s.snapGrid[j] > -newPosition) {
                                nextSlide = j;
                                break;
                            }
        
                        }
                        if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                            newPosition = s.snapGrid[nextSlide];
                        } else {
                            newPosition = s.snapGrid[nextSlide - 1];
                        }
                        if (!s.rtl) newPosition = - newPosition;
                    }
                    //Fix duration
                    if (s.velocity !== 0) {
                        if (s.rtl) {
                            momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
                        }
                        else {
                            momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
                        }
                    }
                    else if (s.params.freeModeSticky) {
                        s.slideReset();
                        return;
                    }
        
                    if (s.params.freeModeMomentumBounce && doBounce) {
                        s.updateProgress(afterBouncePosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        s.animating = true;
                        s.wrapper.transitionEnd(function () {
                            if (!s || !allowMomentumBounce) return;
                            s.emit('onMomentumBounce', s);
        
                            s.setWrapperTransition(s.params.speed);
                            s.setWrapperTranslate(afterBouncePosition);
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        });
                    } else if (s.velocity) {
                        s.updateProgress(newPosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        if (!s.animating) {
                            s.animating = true;
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        }
        
                    } else {
                        s.updateProgress(newPosition);
                    }
        
                    s.updateActiveIndex();
                }
                if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
                    s.updateProgress();
                    s.updateActiveIndex();
                }
                return;
            }
        
            // Find current slide
            var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
            for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
                if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
                    if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
                    }
                }
                else {
                    if (currentPos >= s.slidesGrid[i]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
                    }
                }
            }
        
            // Find current slide size
            var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
        
            if (timeDiff > s.params.longSwipesMs) {
                // Long touches
                if (!s.params.longSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);
                    else s.slideTo(stopIndex);
        
                }
                if (s.swipeDirection === 'prev') {
                    if (ratio > (1 - s.params.longSwipesRatio)) s.slideTo(stopIndex + s.params.slidesPerGroup);
                    else s.slideTo(stopIndex);
                }
            }
            else {
                // Short swipes
                if (!s.params.shortSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    s.slideTo(stopIndex + s.params.slidesPerGroup);
        
                }
                if (s.swipeDirection === 'prev') {
                    s.slideTo(stopIndex);
                }
            }
        };
        /*=========================
          Transitions
          ===========================*/
        s._slideTo = function (slideIndex, speed) {
            return s.slideTo(slideIndex, speed, true, true);
        };
        s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (typeof slideIndex === 'undefined') slideIndex = 0;
            if (slideIndex < 0) slideIndex = 0;
            s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
            if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;
        
            var translate = - s.snapGrid[s.snapIndex];
            // Stop autoplay
            if (s.params.autoplay && s.autoplaying) {
                if (internal || !s.params.autoplayDisableOnInteraction) {
                    s.pauseAutoplay(speed);
                }
                else {
                    s.stopAutoplay();
                }
            }
            // Update progress
            s.updateProgress(translate);
        
            // Normalize slideIndex
            for (var i = 0; i < s.slidesGrid.length; i++) {
                if (- Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
                    slideIndex = i;
                }
            }
        
            // Directions locks
            if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
                if ((s.activeIndex || 0) !== slideIndex ) return false;
            }
        
            // Update Index
            if (typeof speed === 'undefined') speed = s.params.speed;
            s.previousIndex = s.activeIndex || 0;
            s.activeIndex = slideIndex;
        
            if ((s.rtl && -translate === s.translate) || (!s.rtl && translate === s.translate)) {
                // Update Height
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
                s.updateClasses();
                if (s.params.effect !== 'slide') {
                    s.setWrapperTranslate(translate);
                }
                return false;
            }
            s.updateClasses();
            s.onTransitionStart(runCallbacks);
        
            if (speed === 0) {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(0);
                s.onTransitionEnd(runCallbacks);
            }
            else {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(speed);
                if (!s.animating) {
                    s.animating = true;
                    s.wrapper.transitionEnd(function () {
                        if (!s) return;
                        s.onTransitionEnd(runCallbacks);
                    });
                }
        
            }
        
            return true;
        };
        
        s.onTransitionStart = function (runCallbacks) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
            if (s.lazy) s.lazy.onTransitionStart();
            if (runCallbacks) {
                s.emit('onTransitionStart', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeStart', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextStart', s);
                    }
                    else {
                        s.emit('onSlidePrevStart', s);
                    }
                }
        
            }
        };
        s.onTransitionEnd = function (runCallbacks) {
            s.animating = false;
            s.setWrapperTransition(0);
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.lazy) s.lazy.onTransitionEnd();
            if (runCallbacks) {
                s.emit('onTransitionEnd', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeEnd', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextEnd', s);
                    }
                    else {
                        s.emit('onSlidePrevEnd', s);
                    }
                }
            }
            if (s.params.hashnav && s.hashnav) {
                s.hashnav.setHash();
            }
        
        };
        s.slideNext = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
            }
            else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
        };
        s._slideNext = function (speed) {
            return s.slideNext(true, speed, true);
        };
        s.slidePrev = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
            }
            else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
        };
        s._slidePrev = function (speed) {
            return s.slidePrev(true, speed, true);
        };
        s.slideReset = function (runCallbacks, speed, internal) {
            return s.slideTo(s.activeIndex, speed, runCallbacks);
        };
        
        /*=========================
          Translate/transition helpers
          ===========================*/
        s.setWrapperTransition = function (duration, byController) {
            s.wrapper.transition(duration);
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTransition(duration);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTransition(duration);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTransition(duration);
            }
            if (s.params.control && s.controller) {
                s.controller.setTransition(duration, byController);
            }
            s.emit('onSetTransition', s, duration);
        };
        s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
            var x = 0, y = 0, z = 0;
            if (s.isHorizontal()) {
                x = s.rtl ? -translate : translate;
            }
            else {
                y = translate;
            }
        
            if (s.params.roundLengths) {
                x = round(x);
                y = round(y);
            }
        
            if (!s.params.virtualTranslate) {
                if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
                else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
            }
        
            s.translate = s.isHorizontal() ? x : y;
        
            // Check if we need to update progress
            var progress;
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            if (translatesDiff === 0) {
                progress = 0;
            }
            else {
                progress = (translate - s.minTranslate()) / (translatesDiff);
            }
            if (progress !== s.progress) {
                s.updateProgress(translate);
            }
        
            if (updateActiveIndex) s.updateActiveIndex();
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTranslate(s.translate);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTranslate(s.translate);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTranslate(s.translate);
            }
            if (s.params.control && s.controller) {
                s.controller.setTranslate(s.translate, byController);
            }
            s.emit('onSetTranslate', s, s.translate);
        };
        
        s.getTranslate = function (el, axis) {
            var matrix, curTransform, curStyle, transformMatrix;
        
            // automatic axis detection
            if (typeof axis === 'undefined') {
                axis = 'x';
            }
        
            if (s.params.virtualTranslate) {
                return s.rtl ? -s.translate : s.translate;
            }
        
            curStyle = window.getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(',').length > 6) {
                    curTransform = curTransform.split(', ').map(function(a){
                        return a.replace(',','.');
                    }).join(', ');
                }
                // Some old versions of Webkit choke when 'none' is passed; pass
                // empty string instead in this case
                transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            }
            else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform  || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }
        
            if (axis === 'x') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m41;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[12]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m42;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[13]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[5]);
            }
            if (s.rtl && curTransform) curTransform = -curTransform;
            return curTransform || 0;
        };
        s.getWrapperTranslate = function (axis) {
            if (typeof axis === 'undefined') {
                axis = s.isHorizontal() ? 'x' : 'y';
            }
            return s.getTranslate(s.wrapper[0], axis);
        };
        
        /*=========================
          Observer
          ===========================*/
        s.observers = [];
        function initObserver(target, options) {
            options = options || {};
            // create an observer instance
            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            var observer = new ObserverFunc(function (mutations) {
                mutations.forEach(function (mutation) {
                    s.onResize(true);
                    s.emit('onObserverUpdate', s, mutation);
                });
            });
        
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
        
            s.observers.push(observer);
        }
        s.initObservers = function () {
            if (s.params.observeParents) {
                var containerParents = s.container.parents();
                for (var i = 0; i < containerParents.length; i++) {
                    initObserver(containerParents[i]);
                }
            }
        
            // Observe container
            initObserver(s.container[0], {childList: false});
        
            // Observe wrapper
            initObserver(s.wrapper[0], {attributes: false});
        };
        s.disconnectObservers = function () {
            for (var i = 0; i < s.observers.length; i++) {
                s.observers[i].disconnect();
            }
            s.observers = [];
        };
        /*=========================
          Loop
          ===========================*/
        // Create looped slides
        s.createLoop = function () {
            // Remove duplicated slides
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
        
            var slides = s.wrapper.children('.' + s.params.slideClass);
        
            if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;
        
            s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
            s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
            if (s.loopedSlides > slides.length) {
                s.loopedSlides = slides.length;
            }
        
            var prependSlides = [], appendSlides = [], i;
            slides.each(function (index, el) {
                var slide = $(this);
                if (index < s.loopedSlides) appendSlides.push(el);
                if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
                slide.attr('data-swiper-slide-index', index);
            });
            for (i = 0; i < appendSlides.length; i++) {
                s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
            for (i = prependSlides.length - 1; i >= 0; i--) {
                s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
        };
        s.destroyLoop = function () {
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
            s.slides.removeAttr('data-swiper-slide-index');
        };
        s.reLoop = function (updatePosition) {
            var oldIndex = s.activeIndex - s.loopedSlides;
            s.destroyLoop();
            s.createLoop();
            s.updateSlidesSize();
            if (updatePosition) {
                s.slideTo(oldIndex + s.loopedSlides, 0, false);
            }
        
        };
        s.fixLoop = function () {
            var newIndex;
            //Fix For Negative Oversliding
            if (s.activeIndex < s.loopedSlides) {
                newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
            //Fix For Positive Oversliding
            else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
                newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
        };
        /*=========================
          Append/Prepend/Remove Slides
          ===========================*/
        s.appendSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.append(slides[i]);
                }
            }
            else {
                s.wrapper.append(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
        };
        s.prependSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            var newActiveIndex = s.activeIndex + 1;
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.prepend(slides[i]);
                }
                newActiveIndex = s.activeIndex + slides.length;
            }
            else {
                s.wrapper.prepend(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            s.slideTo(newActiveIndex, 0, false);
        };
        s.removeSlide = function (slidesIndexes) {
            if (s.params.loop) {
                s.destroyLoop();
                s.slides = s.wrapper.children('.' + s.params.slideClass);
            }
            var newActiveIndex = s.activeIndex,
                indexToRemove;
            if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
                for (var i = 0; i < slidesIndexes.length; i++) {
                    indexToRemove = slidesIndexes[i];
                    if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                    if (indexToRemove < newActiveIndex) newActiveIndex--;
                }
                newActiveIndex = Math.max(newActiveIndex, 0);
            }
            else {
                indexToRemove = slidesIndexes;
                if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex--;
                newActiveIndex = Math.max(newActiveIndex, 0);
            }
        
            if (s.params.loop) {
                s.createLoop();
            }
        
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            if (s.params.loop) {
                s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
            }
            else {
                s.slideTo(newActiveIndex, 0, false);
            }
        
        };
        s.removeAllSlides = function () {
            var slidesIndexes = [];
            for (var i = 0; i < s.slides.length; i++) {
                slidesIndexes.push(i);
            }
            s.removeSlide(slidesIndexes);
        };
        

        /*=========================
          Effects
          ===========================*/
        s.effects = {
            fade: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var offset = slide[0].swiperSlideOffset;
                        var tx = -offset;
                        if (!s.params.virtualTranslate) tx = tx - s.translate;
                        var ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
                        var slideOpacity = s.params.fade.crossFade ?
                                Math.max(1 - Math.abs(slide[0].progress), 0) :
                                1 + Math.min(Math.max(slide[0].progress, -1), 0);
                        slide
                            .css({
                                opacity: slideOpacity
                            })
                            .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
        
                    }
        
                },
                setTransition: function (duration) {
                    s.slides.transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            flip: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var progress = slide[0].progress;
                        if (s.params.flip.limitRotation) {
                            progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        }
                        var offset = slide[0].swiperSlideOffset;
                        var rotate = -180 * progress,
                            rotateY = rotate,
                            rotateX = 0,
                            tx = -offset,
                            ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                            rotateX = -rotateY;
                            rotateY = 0;
                        }
                        else if (s.rtl) {
                            rotateY = -rotateY;
                        }
        
                        slide[0].style.zIndex = -Math.abs(Math.round(progress)) + s.slides.length;
        
                        if (s.params.flip.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
        
                        slide
                            .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px) rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)');
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.eq(s.activeIndex).transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            if (!$(this).hasClass(s.params.slideActiveClass)) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            cube: {
                setTranslate: function () {
                    var wrapperRotate = 0, cubeShadow;
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow = s.wrapper.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.wrapper.append(cubeShadow);
                            }
                            cubeShadow.css({height: s.width + 'px'});
                        }
                        else {
                            cubeShadow = s.container.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.container.append(cubeShadow);
                            }
                        }
                    }
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var slideAngle = i * 90;
                        var round = Math.floor(slideAngle / 360);
                        if (s.rtl) {
                            slideAngle = -slideAngle;
                            round = Math.floor(-slideAngle / 360);
                        }
                        var progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        var tx = 0, ty = 0, tz = 0;
                        if (i % 4 === 0) {
                            tx = - round * 4 * s.size;
                            tz = 0;
                        }
                        else if ((i - 1) % 4 === 0) {
                            tx = 0;
                            tz = - round * 4 * s.size;
                        }
                        else if ((i - 2) % 4 === 0) {
                            tx = s.size + round * 4 * s.size;
                            tz = s.size;
                        }
                        else if ((i - 3) % 4 === 0) {
                            tx = - s.size;
                            tz = 3 * s.size + s.size * 4 * round;
                        }
                        if (s.rtl) {
                            tx = -tx;
                        }
        
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
        
                        var transform = 'rotateX(' + (s.isHorizontal() ? 0 : -slideAngle) + 'deg) rotateY(' + (s.isHorizontal() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                        if (progress <= 1 && progress > -1) {
                            wrapperRotate = i * 90 + progress * 90;
                            if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
                        }
                        slide.transform(transform);
                        if (s.params.cube.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
                    }
                    s.wrapper.css({
                        '-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        '-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        '-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
                    });
        
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
                        }
                        else {
                            var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                            var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                            var scale1 = s.params.cube.shadowScale,
                                scale2 = s.params.cube.shadowScale / multiplier,
                                offset = s.params.cube.shadowOffset;
                            cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
                        }
                    }
                    var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
                    s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (s.isHorizontal() ? 0 : wrapperRotate) + 'deg) rotateY(' + (s.isHorizontal() ? -wrapperRotate : 0) + 'deg)');
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.cube.shadow && !s.isHorizontal()) {
                        s.container.find('.swiper-cube-shadow').transition(duration);
                    }
                }
            },
            coverflow: {
                setTranslate: function () {
                    var transform = s.translate;
                    var center = s.isHorizontal() ? -transform + s.width / 2 : -transform + s.height / 2;
                    var rotate = s.isHorizontal() ? s.params.coverflow.rotate: -s.params.coverflow.rotate;
                    var translate = s.params.coverflow.depth;
                    //Each slide offset from center
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideSize = s.slidesSizesGrid[i];
                        var slideOffset = slide[0].swiperSlideOffset;
                        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
        
                        var rotateY = s.isHorizontal() ? rotate * offsetMultiplier : 0;
                        var rotateX = s.isHorizontal() ? 0 : rotate * offsetMultiplier;
                        // var rotateZ = 0
                        var translateZ = -translate * Math.abs(offsetMultiplier);
        
                        var translateY = s.isHorizontal() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
                        var translateX = s.isHorizontal() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;
        
                        //Fix for ultra small values
                        if (Math.abs(translateX) < 0.001) translateX = 0;
                        if (Math.abs(translateY) < 0.001) translateY = 0;
                        if (Math.abs(translateZ) < 0.001) translateZ = 0;
                        if (Math.abs(rotateY) < 0.001) rotateY = 0;
                        if (Math.abs(rotateX) < 0.001) rotateX = 0;
        
                        var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
        
                        slide.transform(slideTransform);
                        slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                        if (s.params.coverflow.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                            if (shadowAfter.length) shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                        }
                    }
        
                    //Set correct perspective for IE10
                    if (s.browser.ie) {
                        var ws = s.wrapper[0].style;
                        ws.perspectiveOrigin = center + 'px 50%';
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                }
            }
        };

        /*=========================
          Images Lazy Loading
          ===========================*/
        s.lazy = {
            initialImageLoaded: false,
            loadImageInSlide: function (index, loadInDuplicate) {
                if (typeof index === 'undefined') return;
                if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
                if (s.slides.length === 0) return;
        
                var slide = s.slides.eq(index);
                var img = slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');
                if (slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')) {
                    img = img.add(slide[0]);
                }
                if (img.length === 0) return;
        
                img.each(function () {
                    var _img = $(this);
                    _img.addClass('swiper-lazy-loading');
                    var background = _img.attr('data-background');
                    var src = _img.attr('data-src'),
                        srcset = _img.attr('data-srcset');
                    s.loadImage(_img[0], (src || background), srcset, false, function () {
                        if (background) {
                            _img.css('background-image', 'url("' + background + '")');
                            _img.removeAttr('data-background');
                        }
                        else {
                            if (srcset) {
                                _img.attr('srcset', srcset);
                                _img.removeAttr('data-srcset');
                            }
                            if (src) {
                                _img.attr('src', src);
                                _img.removeAttr('data-src');
                            }
        
                        }
        
                        _img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');
                        slide.find('.swiper-lazy-preloader, .preloader').remove();
                        if (s.params.loop && loadInDuplicate) {
                            var slideOriginalIndex = slide.attr('data-swiper-slide-index');
                            if (slide.hasClass(s.params.slideDuplicateClass)) {
                                var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
                                s.lazy.loadImageInSlide(originalSlide.index(), false);
                            }
                            else {
                                var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                                s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
                            }
                        }
                        s.emit('onLazyImageReady', s, slide[0], _img[0]);
                    });
        
                    s.emit('onLazyImageLoad', s, slide[0], _img[0]);
                });
        
            },
            load: function () {
                var i;
                if (s.params.watchSlidesVisibility) {
                    s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
                        s.lazy.loadImageInSlide($(this).index());
                    });
                }
                else {
                    if (s.params.slidesPerView > 1) {
                        for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView ; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    }
                    else {
                        s.lazy.loadImageInSlide(s.activeIndex);
                    }
                }
                if (s.params.lazyLoadingInPrevNext) {
                    if (s.params.slidesPerView > 1 || (s.params.lazyLoadingInPrevNextAmount && s.params.lazyLoadingInPrevNextAmount > 1)) {
                        var amount = s.params.lazyLoadingInPrevNextAmount;
                        var spv = s.params.slidesPerView;
                        var maxIndex = Math.min(s.activeIndex + spv + Math.max(amount, spv), s.slides.length);
                        var minIndex = Math.max(s.activeIndex - Math.max(spv, amount), 0);
                        // Next Slides
                        for (i = s.activeIndex + s.params.slidesPerView; i < maxIndex; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                        // Prev Slides
                        for (i = minIndex; i < s.activeIndex ; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    }
                    else {
                        var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
                        if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());
        
                        var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
                        if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
                    }
                }
            },
            onTransitionStart: function () {
                if (s.params.lazyLoading) {
                    if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
                        s.lazy.load();
                    }
                }
            },
            onTransitionEnd: function () {
                if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
                    s.lazy.load();
                }
            }
        };
        

        /*=========================
          Scrollbar
          ===========================*/
        s.scrollbar = {
            isTouched: false,
            setDragPosition: function (e) {
                var sb = s.scrollbar;
                var x = 0, y = 0;
                var translate;
                var pointerPosition = s.isHorizontal() ?
                    ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX) :
                    ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY) ;
                var position = (pointerPosition) - sb.track.offset()[s.isHorizontal() ? 'left' : 'top'] - sb.dragSize / 2;
                var positionMin = -s.minTranslate() * sb.moveDivider;
                var positionMax = -s.maxTranslate() * sb.moveDivider;
                if (position < positionMin) {
                    position = positionMin;
                }
                else if (position > positionMax) {
                    position = positionMax;
                }
                position = -position / sb.moveDivider;
                s.updateProgress(position);
                s.setWrapperTranslate(position, true);
            },
            dragStart: function (e) {
                var sb = s.scrollbar;
                sb.isTouched = true;
                e.preventDefault();
                e.stopPropagation();
        
                sb.setDragPosition(e);
                clearTimeout(sb.dragTimeout);
        
                sb.track.transition(0);
                if (s.params.scrollbarHide) {
                    sb.track.css('opacity', 1);
                }
                s.wrapper.transition(100);
                sb.drag.transition(100);
                s.emit('onScrollbarDragStart', s);
            },
            dragMove: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
                sb.setDragPosition(e);
                s.wrapper.transition(0);
                sb.track.transition(0);
                sb.drag.transition(0);
                s.emit('onScrollbarDragMove', s);
            },
            dragEnd: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                sb.isTouched = false;
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.dragTimeout);
                    sb.dragTimeout = setTimeout(function () {
                        sb.track.css('opacity', 0);
                        sb.track.transition(400);
                    }, 1000);
        
                }
                s.emit('onScrollbarDragEnd', s);
                if (s.params.scrollbarSnapOnRelease) {
                    s.slideReset();
                }
            },
            enableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).on(s.touchEvents.start, sb.dragStart);
                $(target).on(s.touchEvents.move, sb.dragMove);
                $(target).on(s.touchEvents.end, sb.dragEnd);
            },
            disableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).off(s.touchEvents.start, sb.dragStart);
                $(target).off(s.touchEvents.move, sb.dragMove);
                $(target).off(s.touchEvents.end, sb.dragEnd);
            },
            set: function () {
                if (!s.params.scrollbar) return;
                var sb = s.scrollbar;
                sb.track = $(s.params.scrollbar);
                if (s.params.uniqueNavElements && typeof s.params.scrollbar === 'string' && sb.track.length > 1 && s.container.find(s.params.scrollbar).length === 1) {
                    sb.track = s.container.find(s.params.scrollbar);
                }
                sb.drag = sb.track.find('.swiper-scrollbar-drag');
                if (sb.drag.length === 0) {
                    sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
                    sb.track.append(sb.drag);
                }
                sb.drag[0].style.width = '';
                sb.drag[0].style.height = '';
                sb.trackSize = s.isHorizontal() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
        
                sb.divider = s.size / s.virtualSize;
                sb.moveDivider = sb.divider * (sb.trackSize / s.size);
                sb.dragSize = sb.trackSize * sb.divider;
        
                if (s.isHorizontal()) {
                    sb.drag[0].style.width = sb.dragSize + 'px';
                }
                else {
                    sb.drag[0].style.height = sb.dragSize + 'px';
                }
        
                if (sb.divider >= 1) {
                    sb.track[0].style.display = 'none';
                }
                else {
                    sb.track[0].style.display = '';
                }
                if (s.params.scrollbarHide) {
                    sb.track[0].style.opacity = 0;
                }
            },
            setTranslate: function () {
                if (!s.params.scrollbar) return;
                var diff;
                var sb = s.scrollbar;
                var translate = s.translate || 0;
                var newPos;
        
                var newSize = sb.dragSize;
                newPos = (sb.trackSize - sb.dragSize) * s.progress;
                if (s.rtl && s.isHorizontal()) {
                    newPos = -newPos;
                    if (newPos > 0) {
                        newSize = sb.dragSize - newPos;
                        newPos = 0;
                    }
                    else if (-newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize + newPos;
                    }
                }
                else {
                    if (newPos < 0) {
                        newSize = sb.dragSize + newPos;
                        newPos = 0;
                    }
                    else if (newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize - newPos;
                    }
                }
                if (s.isHorizontal()) {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
                    }
                    else {
                        sb.drag.transform('translateX(' + (newPos) + 'px)');
                    }
                    sb.drag[0].style.width = newSize + 'px';
                }
                else {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
                    }
                    else {
                        sb.drag.transform('translateY(' + (newPos) + 'px)');
                    }
                    sb.drag[0].style.height = newSize + 'px';
                }
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.timeout);
                    sb.track[0].style.opacity = 1;
                    sb.timeout = setTimeout(function () {
                        sb.track[0].style.opacity = 0;
                        sb.track.transition(400);
                    }, 1000);
                }
            },
            setTransition: function (duration) {
                if (!s.params.scrollbar) return;
                s.scrollbar.drag.transition(duration);
            }
        };

        /*=========================
          Controller
          ===========================*/
        s.controller = {
            LinearSpline: function (x, y) {
                this.x = x;
                this.y = y;
                this.lastIndex = x.length - 1;
                // Given an x value (x2), return the expected y2 value:
                // (x1,y1) is the known point before given value,
                // (x3,y3) is the known point after given value.
                var i1, i3;
                var l = this.x.length;
        
                this.interpolate = function (x2) {
                    if (!x2) return 0;
        
                    // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                    i3 = binarySearch(this.x, x2);
                    i1 = i3 - 1;
        
                    // We have our indexes i1 & i3, so we can calculate already:
                    // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
                    return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
                };
        
                var binarySearch = (function() {
                    var maxIndex, minIndex, guess;
                    return function(array, val) {
                        minIndex = -1;
                        maxIndex = array.length;
                        while (maxIndex - minIndex > 1)
                            if (array[guess = maxIndex + minIndex >> 1] <= val) {
                                minIndex = guess;
                            } else {
                                maxIndex = guess;
                            }
                        return maxIndex;
                    };
                })();
            },
            //xxx: for now i will just save one spline function to to
            getInterpolateFunction: function(c){
                if(!s.controller.spline) s.controller.spline = s.params.loop ?
                    new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) :
                    new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
            },
            setTranslate: function (translate, byController) {
               var controlled = s.params.control;
               var multiplier, controlledTranslate;
               function setControlledTranslate(c) {
                    // this will create an Interpolate function based on the snapGrids
                    // x is the Grid of the scrolled scroller and y will be the controlled scroller
                    // it makes sense to create this only once and recall it for the interpolation
                    // the function does a lot of value caching for performance
                    translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
                    if (s.params.controlBy === 'slide') {
                        s.controller.getInterpolateFunction(c);
                        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                        // but it did not work out
                        controlledTranslate = -s.controller.spline.interpolate(-translate);
                    }
        
                    if(!controlledTranslate || s.params.controlBy === 'container'){
                        multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
                        controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
                    }
        
                    if (s.params.controlInverse) {
                        controlledTranslate = c.maxTranslate() - controlledTranslate;
                    }
                    c.updateProgress(controlledTranslate);
                    c.setWrapperTranslate(controlledTranslate, false, s);
                    c.updateActiveIndex();
               }
               if (s.isArray(controlled)) {
                   for (var i = 0; i < controlled.length; i++) {
                       if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                           setControlledTranslate(controlled[i]);
                       }
                   }
               }
               else if (controlled instanceof Swiper && byController !== controlled) {
        
                   setControlledTranslate(controlled);
               }
            },
            setTransition: function (duration, byController) {
                var controlled = s.params.control;
                var i;
                function setControlledTransition(c) {
                    c.setWrapperTransition(duration, s);
                    if (duration !== 0) {
                        c.onTransitionStart();
                        c.wrapper.transitionEnd(function(){
                            if (!controlled) return;
                            if (c.params.loop && s.params.controlBy === 'slide') {
                                c.fixLoop();
                            }
                            c.onTransitionEnd();
        
                        });
                    }
                }
                if (s.isArray(controlled)) {
                    for (i = 0; i < controlled.length; i++) {
                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                            setControlledTransition(controlled[i]);
                        }
                    }
                }
                else if (controlled instanceof Swiper && byController !== controlled) {
                    setControlledTransition(controlled);
                }
            }
        };

        /*=========================
          Hash Navigation
          ===========================*/
        s.hashnav = {
            init: function () {
                if (!s.params.hashnav) return;
                s.hashnav.initialized = true;
                var hash = document.location.hash.replace('#', '');
                if (!hash) return;
                var speed = 0;
                for (var i = 0, length = s.slides.length; i < length; i++) {
                    var slide = s.slides.eq(i);
                    var slideHash = slide.attr('data-hash');
                    if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                        var index = slide.index();
                        s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
                    }
                }
            },
            setHash: function () {
                if (!s.hashnav.initialized || !s.params.hashnav) return;
                document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';
            }
        };

        /*=========================
          Keyboard Control
          ===========================*/
        function handleKeyboard(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var kc = e.keyCode || e.charCode;
            // Directions locks
            if (!s.params.allowSwipeToNext && (s.isHorizontal() && kc === 39 || !s.isHorizontal() && kc === 40)) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && (s.isHorizontal() && kc === 37 || !s.isHorizontal() && kc === 38)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return;
            }
            if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
                var inView = false;
                //Check that swiper should be inside of visible area of window
                if (s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0) {
                    return;
                }
                var windowScroll = {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                };
                var windowWidth = window.innerWidth;
                var windowHeight = window.innerHeight;
                var swiperOffset = s.container.offset();
                if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
                var swiperCoord = [
                    [swiperOffset.left, swiperOffset.top],
                    [swiperOffset.left + s.width, swiperOffset.top],
                    [swiperOffset.left, swiperOffset.top + s.height],
                    [swiperOffset.left + s.width, swiperOffset.top + s.height]
                ];
                for (var i = 0; i < swiperCoord.length; i++) {
                    var point = swiperCoord[i];
                    if (
                        point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
                        point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight
                    ) {
                        inView = true;
                    }
        
                }
                if (!inView) return;
            }
            if (s.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl)) s.slideNext();
                if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl)) s.slidePrev();
            }
            else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if (kc === 40) s.slideNext();
                if (kc === 38) s.slidePrev();
            }
        }
        s.disableKeyboardControl = function () {
            s.params.keyboardControl = false;
            $(document).off('keydown', handleKeyboard);
        };
        s.enableKeyboardControl = function () {
            s.params.keyboardControl = true;
            $(document).on('keydown', handleKeyboard);
        };
        

        /*=========================
          Mousewheel Control
          ===========================*/
        s.mousewheel = {
            event: false,
            lastScrollTime: (new window.Date()).getTime()
        };
        if (s.params.mousewheelControl) {
            try {
                new window.WheelEvent('wheel');
                s.mousewheel.event = 'wheel';
            } catch (e) {
                if (window.WheelEvent || (s.container[0] && 'wheel' in s.container[0])) {
                    s.mousewheel.event = 'wheel';
                }
            }
            if (!s.mousewheel.event && window.WheelEvent) {
        
            }
            if (!s.mousewheel.event && document.onmousewheel !== undefined) {
                s.mousewheel.event = 'mousewheel';
            }
            if (!s.mousewheel.event) {
                s.mousewheel.event = 'DOMMouseScroll';
            }
        }
        function handleMousewheel(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var we = s.mousewheel.event;
            var delta = 0;
            var rtlFactor = s.rtl ? -1 : 1;
        
            //WebKits
            if (we === 'mousewheel') {
                if (s.params.mousewheelForceToAxis) {
                    if (s.isHorizontal()) {
                        if (Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY)) delta = e.wheelDeltaX * rtlFactor;
                        else return;
                    }
                    else {
                        if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)) delta = e.wheelDeltaY;
                        else return;
                    }
                }
                else {
                    delta = Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY) ? - e.wheelDeltaX * rtlFactor : - e.wheelDeltaY;
                }
            }
            //Old FireFox
            else if (we === 'DOMMouseScroll') delta = -e.detail;
            //New FireFox
            else if (we === 'wheel') {
                if (s.params.mousewheelForceToAxis) {
                    if (s.isHorizontal()) {
                        if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) delta = -e.deltaX * rtlFactor;
                        else return;
                    }
                    else {
                        if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) delta = -e.deltaY;
                        else return;
                    }
                }
                else {
                    delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? - e.deltaX * rtlFactor : - e.deltaY;
                }
            }
            if (delta === 0) return;
        
            if (s.params.mousewheelInvert) delta = -delta;
        
            if (!s.params.freeMode) {
                if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!s.isEnd || s.params.loop) && !s.animating) s.slideNext();
                        else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                    else {
                        if ((!s.isBeginning || s.params.loop) && !s.animating) s.slidePrev();
                        else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                }
                s.mousewheel.lastScrollTime = (new window.Date()).getTime();
        
            }
            else {
                //Freemode or scrollContainer:
                var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
                var wasBeginning = s.isBeginning,
                    wasEnd = s.isEnd;
        
                if (position >= s.minTranslate()) position = s.minTranslate();
                if (position <= s.maxTranslate()) position = s.maxTranslate();
        
                s.setWrapperTransition(0);
                s.setWrapperTranslate(position);
                s.updateProgress();
                s.updateActiveIndex();
        
                if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
                    s.updateClasses();
                }
        
                if (s.params.freeModeSticky) {
                    clearTimeout(s.mousewheel.timeout);
                    s.mousewheel.timeout = setTimeout(function () {
                        s.slideReset();
                    }, 300);
                }
                else {
                    if (s.params.lazyLoading && s.lazy) {
                        s.lazy.load();
                    }
                }
        
                // Return page scroll on edge positions
                if (position === 0 || position === s.maxTranslate()) return;
            }
            if (s.params.autoplay) s.stopAutoplay();
        
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            return false;
        }
        s.disableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            s.container.off(s.mousewheel.event, handleMousewheel);
            return true;
        };
        
        s.enableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            s.container.on(s.mousewheel.event, handleMousewheel);
            return true;
        };
        

        /*=========================
          Parallax
          ===========================*/
        function setParallaxTransform(el, progress) {
            el = $(el);
            var p, pX, pY;
            var rtlFactor = s.rtl ? -1 : 1;
        
            p = el.attr('data-swiper-parallax') || '0';
            pX = el.attr('data-swiper-parallax-x');
            pY = el.attr('data-swiper-parallax-y');
            if (pX || pY) {
                pX = pX || '0';
                pY = pY || '0';
            }
            else {
                if (s.isHorizontal()) {
                    pX = p;
                    pY = '0';
                }
                else {
                    pY = p;
                    pX = '0';
                }
            }
        
            if ((pX).indexOf('%') >= 0) {
                pX = parseInt(pX, 10) * progress * rtlFactor + '%';
            }
            else {
                pX = pX * progress * rtlFactor + 'px' ;
            }
            if ((pY).indexOf('%') >= 0) {
                pY = parseInt(pY, 10) * progress + '%';
            }
            else {
                pY = pY * progress + 'px' ;
            }
        
            el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
        }
        s.parallax = {
            setTranslate: function () {
                s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
                    setParallaxTransform(this, s.progress);
        
                });
                s.slides.each(function () {
                    var slide = $(this);
                    slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
                        var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                        setParallaxTransform(this, progress);
                    });
                });
            },
            setTransition: function (duration) {
                if (typeof duration === 'undefined') duration = s.params.speed;
                s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
                    var el = $(this);
                    var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
                    if (duration === 0) parallaxDuration = 0;
                    el.transition(parallaxDuration);
                });
            }
        };
        

        /*=========================
          Plugins API. Collect all and init all plugins
          ===========================*/
        s._plugins = [];
        for (var plugin in s.plugins) {
            var p = s.plugins[plugin](s, s.params[plugin]);
            if (p) s._plugins.push(p);
        }
        // Method to call all plugins event/method
        s.callPlugins = function (eventName) {
            for (var i = 0; i < s._plugins.length; i++) {
                if (eventName in s._plugins[i]) {
                    s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
        };

        /*=========================
          Events/Callbacks/Plugins Emitter
          ===========================*/
        function normalizeEventName (eventName) {
            if (eventName.indexOf('on') !== 0) {
                if (eventName[0] !== eventName[0].toUpperCase()) {
                    eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
                }
                else {
                    eventName = 'on' + eventName;
                }
            }
            return eventName;
        }
        s.emitterEventListeners = {
        
        };
        s.emit = function (eventName) {
            // Trigger callbacks
            if (s.params[eventName]) {
                s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
            var i;
            // Trigger events
            if (s.emitterEventListeners[eventName]) {
                for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                    s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
            // Trigger plugins
            if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        };
        s.on = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
            s.emitterEventListeners[eventName].push(handler);
            return s;
        };
        s.off = function (eventName, handler) {
            var i;
            eventName = normalizeEventName(eventName);
            if (typeof handler === 'undefined') {
                // Remove all handlers for such event
                s.emitterEventListeners[eventName] = [];
                return s;
            }
            if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                if(s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
            }
            return s;
        };
        s.once = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            var _handler = function () {
                handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                s.off(eventName, _handler);
            };
            s.on(eventName, _handler);
            return s;
        };

        // Accessibility tools
        s.a11y = {
            makeFocusable: function ($el) {
                $el.attr('tabIndex', '0');
                return $el;
            },
            addRole: function ($el, role) {
                $el.attr('role', role);
                return $el;
            },
        
            addLabel: function ($el, label) {
                $el.attr('aria-label', label);
                return $el;
            },
        
            disable: function ($el) {
                $el.attr('aria-disabled', true);
                return $el;
            },
        
            enable: function ($el) {
                $el.attr('aria-disabled', false);
                return $el;
            },
        
            onEnterKey: function (event) {
                if (event.keyCode !== 13) return;
                if ($(event.target).is(s.params.nextButton)) {
                    s.onClickNext(event);
                    if (s.isEnd) {
                        s.a11y.notify(s.params.lastSlideMessage);
                    }
                    else {
                        s.a11y.notify(s.params.nextSlideMessage);
                    }
                }
                else if ($(event.target).is(s.params.prevButton)) {
                    s.onClickPrev(event);
                    if (s.isBeginning) {
                        s.a11y.notify(s.params.firstSlideMessage);
                    }
                    else {
                        s.a11y.notify(s.params.prevSlideMessage);
                    }
                }
                if ($(event.target).is('.' + s.params.bulletClass)) {
                    $(event.target)[0].click();
                }
            },
        
            liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),
        
            notify: function (message) {
                var notification = s.a11y.liveRegion;
                if (notification.length === 0) return;
                notification.html('');
                notification.html(message);
            },
            init: function () {
                // Setup accessibility
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    s.a11y.makeFocusable(s.nextButton);
                    s.a11y.addRole(s.nextButton, 'button');
                    s.a11y.addLabel(s.nextButton, s.params.nextSlideMessage);
                }
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    s.a11y.makeFocusable(s.prevButton);
                    s.a11y.addRole(s.prevButton, 'button');
                    s.a11y.addLabel(s.prevButton, s.params.prevSlideMessage);
                }
        
                $(s.container).append(s.a11y.liveRegion);
            },
            initPagination: function () {
                if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
                    s.bullets.each(function () {
                        var bullet = $(this);
                        s.a11y.makeFocusable(bullet);
                        s.a11y.addRole(bullet, 'button');
                        s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
                    });
                }
            },
            destroy: function () {
                if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
            }
        };
        

        /*=========================
          Init/Destroy
          ===========================*/
        s.init = function () {
            if (s.params.loop) s.createLoop();
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.enableDraggable();
                }
            }
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                if (!s.params.loop) s.updateProgress();
                s.effects[s.params.effect].setTranslate();
            }
            if (s.params.loop) {
                s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
            }
            else {
                s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
                if (s.params.initialSlide === 0) {
                    if (s.parallax && s.params.parallax) s.parallax.setTranslate();
                    if (s.lazy && s.params.lazyLoading) {
                        s.lazy.load();
                        s.lazy.initialImageLoaded = true;
                    }
                }
            }
            s.attachEvents();
            if (s.params.observer && s.support.observer) {
                s.initObservers();
            }
            if (s.params.preloadImages && !s.params.lazyLoading) {
                s.preloadImages();
            }
            if (s.params.autoplay) {
                s.startAutoplay();
            }
            if (s.params.keyboardControl) {
                if (s.enableKeyboardControl) s.enableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.enableMousewheelControl) s.enableMousewheelControl();
            }
            if (s.params.hashnav) {
                if (s.hashnav) s.hashnav.init();
            }
            if (s.params.a11y && s.a11y) s.a11y.init();
            s.emit('onInit', s);
        };
        
        // Cleanup dynamic styles
        s.cleanupStyles = function () {
            // Container
            s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
        
            // Wrapper
            s.wrapper.removeAttr('style');
        
            // Slides
            if (s.slides && s.slides.length) {
                s.slides
                    .removeClass([
                      s.params.slideVisibleClass,
                      s.params.slideActiveClass,
                      s.params.slideNextClass,
                      s.params.slidePrevClass
                    ].join(' '))
                    .removeAttr('style')
                    .removeAttr('data-swiper-column')
                    .removeAttr('data-swiper-row');
            }
        
            // Pagination/Bullets
            if (s.paginationContainer && s.paginationContainer.length) {
                s.paginationContainer.removeClass(s.params.paginationHiddenClass);
            }
            if (s.bullets && s.bullets.length) {
                s.bullets.removeClass(s.params.bulletActiveClass);
            }
        
            // Buttons
            if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
            if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
        
            // Scrollbar
            if (s.params.scrollbar && s.scrollbar) {
                if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
                if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
            }
        };
        
        // Destroy
        s.destroy = function (deleteInstance, cleanupStyles) {
            // Detach evebts
            s.detachEvents();
            // Stop autoplay
            s.stopAutoplay();
            // Disable draggable
            if (s.params.scrollbar && s.scrollbar) {
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.disableDraggable();
                }
            }
            // Destroy loop
            if (s.params.loop) {
                s.destroyLoop();
            }
            // Cleanup styles
            if (cleanupStyles) {
                s.cleanupStyles();
            }
            // Disconnect observer
            s.disconnectObservers();
            // Disable keyboard/mousewheel
            if (s.params.keyboardControl) {
                if (s.disableKeyboardControl) s.disableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.disableMousewheelControl) s.disableMousewheelControl();
            }
            // Disable a11y
            if (s.params.a11y && s.a11y) s.a11y.destroy();
            // Destroy callback
            s.emit('onDestroy');
            // Delete instance
            if (deleteInstance !== false) s = null;
        };
        
        s.init();
        

    
        // Return swiper instance
        return s;
    };
    

    /*==================================================
        Prototype
    ====================================================*/
    Swiper.prototype = {
        isSafari: (function () {
            var ua = navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
        })(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
        isArray: function (arr) {
            return Object.prototype.toString.apply(arr) === '[object Array]';
        },
        /*==================================================
        Browser
        ====================================================*/
        browser: {
            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1)
        },
        /*==================================================
        Devices
        ====================================================*/
        device: (function () {
            var ua = navigator.userAgent;
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
            return {
                ios: ipad || iphone || ipod,
                android: android
            };
        })(),
        /*==================================================
        Feature Detection
        ====================================================*/
        support: {
            touch : (window.Modernizr && Modernizr.touch === true) || (function () {
                return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
            })(),
    
            transforms3d : (window.Modernizr && Modernizr.csstransforms3d === true) || (function () {
                var div = document.createElement('div').style;
                return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
            })(),
    
            flexbox: (function () {
                var div = document.createElement('div').style;
                var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
                for (var i = 0; i < styles.length; i++) {
                    if (styles[i] in div) return true;
                }
            })(),
    
            observer: (function () {
                return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
            })()
        },
        /*==================================================
        Plugins
        ====================================================*/
        plugins: {}
    };
    

    /*===========================
     Get Dom libraries
     ===========================*/
    var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
    for (var i = 0; i < swiperDomPlugins.length; i++) {
    	if (window[swiperDomPlugins[i]]) {
    		addLibraryPlugin(window[swiperDomPlugins[i]]);
    	}
    }
    // Required DOM Plugins
    var domLib;
    if (typeof Dom7 === 'undefined') {
    	domLib = window.Dom7 || window.Zepto || window.jQuery;
    }
    else {
    	domLib = Dom7;
    }

    /*===========================
    Add .swiper plugin from Dom libraries
    ===========================*/
    function addLibraryPlugin(lib) {
        lib.fn.swiper = function (params) {
            var firstInstance;
            lib(this).each(function () {
                var s = new Swiper(this, params);
                if (!firstInstance) firstInstance = s;
            });
            return firstInstance;
        };
    }
    
    if (domLib) {
        if (!('transitionEnd' in domLib.fn)) {
            domLib.fn.transitionEnd = function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i, j, dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            };
        }
        if (!('transform' in domLib.fn)) {
            domLib.fn.transform = function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            };
        }
        if (!('transition' in domLib.fn)) {
            domLib.fn.transition = function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            };
        }
    }

    window.Swiper = Swiper;
})();
/*===========================
Swiper AMD Export
===========================*/
if (typeof(module) !== 'undefined')
{
    module.exports = window.Swiper;
}
else if (typeof define === 'function' && define.amd) {
    define([], function () {
        'use strict';
        return window.Swiper;
    });
}
//# sourceMappingURL=maps/swiper.jquery.js.map

/*
 * smartscroll: debounced scroll event for jQuery *
 * https://github.com/lukeshumard/smartscroll
 * Based on smartresize by @louis_remi: https://github.com/lrbabe/jquery.smartresize.js *
 * Copyright 2011 Louis-Remi & Luke Shumard * Licensed under the MIT license. *
 */

var event = $.event,
scrollTimeout;

event.special.smartscroll = {
    setup: function () {
        $(this).bind('scroll', event.special.smartscroll.handler);
    },
    teardown: function () {
        $(this).unbind('scroll', event.special.smartscroll.handler);
    },
    handler: function (event, execAsap) {
        // Save the context
        var context = this,
        args = arguments;

        // set correct event type
        event.type = 'smartscroll';

        if (scrollTimeout) { clearTimeout(scrollTimeout); }
        scrollTimeout = setTimeout(function () {
            $(context).trigger('smartscroll', args);
        }, execAsap === 'execAsap' ? 0 : 100);
    }
};

$.fn.smartscroll = function (fn) {
    return fn ? this.bind('smartscroll', fn) : this.trigger('smartscroll', ['execAsap']);
};

// Ion.RangeSlider
// version 2.1.4 Build: 355
// © Denis Ineshin, 2016
// https://github.com/IonDen
//
// Project page:    http://ionden.com/a/plugins/ion.rangeSlider/en.html
// GitHub page:     https://github.com/IonDen/ion.rangeSlider
//
// Released under MIT licence:
// http://ionden.com/a/plugins/licence-en.html
// =====================================================================================================================

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], function ($) {
            factory($, document, window, navigator);
        });
    } else {
        factory(jQuery, document, window, navigator);
    }
} (function ($, document, window, navigator, undefined) {
    "use strict";

    // =================================================================================================================
    // Service

    var plugin_count = 0;

    // IE8 fix
    var is_old_ie = (function () {
        var n = navigator.userAgent,
            r = /msie\s\d+/i,
            v;
        if (n.search(r) > 0) {
            v = r.exec(n).toString();
            v = v.split(" ")[1];
            if (v < 9) {
                $("html").addClass("lt-ie9");
                return true;
            }
        }
        return false;
    } ());
    if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {

            var target = this;
            var slice = [].slice;

            if (typeof target != "function") {
                throw new TypeError();
            }

            var args = slice.call(arguments, 1),
                bound = function () {

                    if (this instanceof bound) {

                        var F = function(){};
                        F.prototype = target.prototype;
                        var self = new F();

                        var result = target.apply(
                            self,
                            args.concat(slice.call(arguments))
                        );
                        if (Object(result) === result) {
                            return result;
                        }
                        return self;

                    } else {

                        return target.apply(
                            that,
                            args.concat(slice.call(arguments))
                        );

                    }

                };

            return bound;
        };
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(searchElement, fromIndex) {
            var k;
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var O = Object(this);
            var len = O.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = +fromIndex || 0;
            if (Math.abs(n) === Infinity) {
                n = 0;
            }
            if (n >= len) {
                return -1;
            }
            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
            while (k < len) {
                if (k in O && O[k] === searchElement) {
                    return k;
                }
                k++;
            }
            return -1;
        };
    }



    // =================================================================================================================
    // Template

    var base_html =
        '<span class="irs">' +
        '<span class="irs-line" tabindex="-1"><span class="irs-line-left"></span><span class="irs-line-mid"></span><span class="irs-line-right"></span></span>' +
        '<span class="irs-min">0</span><span class="irs-max">1</span>' +
        '<span class="irs-from">0</span><span class="irs-to">0</span><span class="irs-single">0</span>' +
        '</span>' +
        '<span class="irs-grid"></span>' +
        '<span class="irs-bar"></span>';

    var single_html =
        '<span class="irs-bar-edge"></span>' +
        '<span class="irs-shadow shadow-single"></span>' +
        '<span class="irs-slider single"></span>';

    var double_html =
        '<span class="irs-shadow shadow-from"></span>' +
        '<span class="irs-shadow shadow-to"></span>' +
        '<span class="irs-slider from"></span>' +
        '<span class="irs-slider to"></span>';

    var disable_html =
        '<span class="irs-disable-mask"></span>';



    // =================================================================================================================
    // Core

    /**
     * Main plugin constructor
     *
     * @param input {Object} link to base input element
     * @param options {Object} slider config
     * @param plugin_count {Number}
     * @constructor
     */
    var IonRangeSlider = function (input, options, plugin_count) {
        this.VERSION = "2.1.4";
        this.input = input;
        this.plugin_count = plugin_count;
        this.current_plugin = 0;
        this.calc_count = 0;
        this.update_tm = 0;
        this.old_from = 0;
        this.old_to = 0;
        this.old_min_interval = null;
        this.raf_id = null;
        this.dragging = false;
        this.force_redraw = false;
        this.no_diapason = false;
        this.is_key = false;
        this.is_update = false;
        this.is_start = true;
        this.is_finish = false;
        this.is_active = false;
        this.is_resize = false;
        this.is_click = false;

        // cache for links to all DOM elements
        this.$cache = {
            win: $(window),
            body: $(document.body),
            input: $(input),
            cont: null,
            rs: null,
            min: null,
            max: null,
            from: null,
            to: null,
            single: null,
            bar: null,
            line: null,
            s_single: null,
            s_from: null,
            s_to: null,
            shad_single: null,
            shad_from: null,
            shad_to: null,
            edge: null,
            grid: null,
            grid_labels: []
        };

        // storage for measure variables
        this.coords = {
            // left
            x_gap: 0,
            x_pointer: 0,

            // width
            w_rs: 0,
            w_rs_old: 0,
            w_handle: 0,

            // percents
            p_gap: 0,
            p_gap_left: 0,
            p_gap_right: 0,
            p_step: 0,
            p_pointer: 0,
            p_handle: 0,
            p_single_fake: 0,
            p_single_real: 0,
            p_from_fake: 0,
            p_from_real: 0,
            p_to_fake: 0,
            p_to_real: 0,
            p_bar_x: 0,
            p_bar_w: 0,

            // grid
            grid_gap: 0,
            big_num: 0,
            big: [],
            big_w: [],
            big_p: [],
            big_x: []
        };

        // storage for labels measure variables
        this.labels = {
            // width
            w_min: 0,
            w_max: 0,
            w_from: 0,
            w_to: 0,
            w_single: 0,

            // percents
            p_min: 0,
            p_max: 0,
            p_from_fake: 0,
            p_from_left: 0,
            p_to_fake: 0,
            p_to_left: 0,
            p_single_fake: 0,
            p_single_left: 0
        };



        /**
         * get and validate config
         */
        var $inp = this.$cache.input,
            val = $inp.prop("value"),
            config, config_from_data, prop;

        // default config
        config = {
            type: "single",

            min: 10,
            max: 100,
            from: null,
            to: null,
            step: 1,

            min_interval: 0,
            max_interval: 0,
            drag_interval: false,

            values: [],
            p_values: [],

            from_fixed: false,
            from_min: null,
            from_max: null,
            from_shadow: false,

            to_fixed: false,
            to_min: null,
            to_max: null,
            to_shadow: false,

            prettify_enabled: true,
            prettify_separator: " ",
            prettify: null,

            force_edges: false,

            keyboard: false,
            keyboard_step: 5,

            grid: false,
            grid_margin: true,
            grid_num: 4,
            grid_snap: false,

            hide_min_max: false,
            hide_from_to: false,

            prefix: "",
            postfix: "",
            max_postfix: "",
            decorate_both: true,
            values_separator: " — ",

            input_values_separator: ";",

            disable: false,

            onStart: null,
            onChange: null,
            onFinish: null,
            onUpdate: null
        };



        // config from data-attributes extends js config
        config_from_data = {
            type: $inp.data("type"),

            min: $inp.data("min"),
            max: $inp.data("max"),
            from: $inp.data("from"),
            to: $inp.data("to"),
            step: $inp.data("step"),

            min_interval: $inp.data("minInterval"),
            max_interval: $inp.data("maxInterval"),
            drag_interval: $inp.data("dragInterval"),

            values: $inp.data("values"),

            from_fixed: $inp.data("fromFixed"),
            from_min: $inp.data("fromMin"),
            from_max: $inp.data("fromMax"),
            from_shadow: $inp.data("fromShadow"),

            to_fixed: $inp.data("toFixed"),
            to_min: $inp.data("toMin"),
            to_max: $inp.data("toMax"),
            to_shadow: $inp.data("toShadow"),

            prettify_enabled: $inp.data("prettifyEnabled"),
            prettify_separator: $inp.data("prettifySeparator"),

            force_edges: $inp.data("forceEdges"),

            keyboard: $inp.data("keyboard"),
            keyboard_step: $inp.data("keyboardStep"),

            grid: $inp.data("grid"),
            grid_margin: $inp.data("gridMargin"),
            grid_num: $inp.data("gridNum"),
            grid_snap: $inp.data("gridSnap"),

            hide_min_max: $inp.data("hideMinMax"),
            hide_from_to: $inp.data("hideFromTo"),

            prefix: $inp.data("prefix"),
            postfix: $inp.data("postfix"),
            max_postfix: $inp.data("maxPostfix"),
            decorate_both: $inp.data("decorateBoth"),
            values_separator: $inp.data("valuesSeparator"),

            input_values_separator: $inp.data("inputValuesSeparator"),

            disable: $inp.data("disable")
        };
        config_from_data.values = config_from_data.values && config_from_data.values.split(",");

        for (prop in config_from_data) {
            if (config_from_data.hasOwnProperty(prop)) {
                if (!config_from_data[prop] && config_from_data[prop] !== 0) {
                    delete config_from_data[prop];
                }
            }
        }



        // input value extends default config
        if (val) {
            val = val.split(config_from_data.input_values_separator || options.input_values_separator || ";");

            if (val[0] && val[0] == +val[0]) {
                val[0] = +val[0];
            }
            if (val[1] && val[1] == +val[1]) {
                val[1] = +val[1];
            }

            if (options && options.values && options.values.length) {
                config.from = val[0] && options.values.indexOf(val[0]);
                config.to = val[1] && options.values.indexOf(val[1]);
            } else {
                config.from = val[0] && +val[0];
                config.to = val[1] && +val[1];
            }
        }



        // js config extends default config
        $.extend(config, options);


        // data config extends config
        $.extend(config, config_from_data);
        this.options = config;



        // validate config, to be sure that all data types are correct
        this.validate();



        // default result object, returned to callbacks
        this.result = {
            input: this.$cache.input,
            slider: null,

            min: this.options.min,
            max: this.options.max,

            from: this.options.from,
            from_percent: 0,
            from_value: null,

            to: this.options.to,
            to_percent: 0,
            to_value: null
        };



        this.init();
    };

    IonRangeSlider.prototype = {

        /**
         * Starts or updates the plugin instance
         *
         * @param is_update {boolean}
         */
        init: function (is_update) {
            this.no_diapason = false;
            this.coords.p_step = this.convertToPercent(this.options.step, true);

            this.target = "base";

            this.toggleInput();
            this.append();
            this.setMinMax();

            if (is_update) {
                this.force_redraw = true;
                this.calc(true);

                // callbacks called
                this.callOnUpdate();
            } else {
                this.force_redraw = true;
                this.calc(true);

                // callbacks called
                this.callOnStart();
            }

            this.updateScene();
        },

        /**
         * Appends slider template to a DOM
         */
        append: function () {
            var container_html = '<span class="irs js-irs-' + this.plugin_count + '"></span>';
            this.$cache.input.before(container_html);
            this.$cache.input.prop("readonly", true);
            this.$cache.cont = this.$cache.input.prev();
            this.result.slider = this.$cache.cont;

            this.$cache.cont.html(base_html);
            this.$cache.rs = this.$cache.cont.find(".irs");
            this.$cache.min = this.$cache.cont.find(".irs-min");
            this.$cache.max = this.$cache.cont.find(".irs-max");
            this.$cache.from = this.$cache.cont.find(".irs-from");
            this.$cache.to = this.$cache.cont.find(".irs-to");
            this.$cache.single = this.$cache.cont.find(".irs-single");
            this.$cache.bar = this.$cache.cont.find(".irs-bar");
            this.$cache.line = this.$cache.cont.find(".irs-line");
            this.$cache.grid = this.$cache.cont.find(".irs-grid");

            if (this.options.type === "single") {
                this.$cache.cont.append(single_html);
                this.$cache.edge = this.$cache.cont.find(".irs-bar-edge");
                this.$cache.s_single = this.$cache.cont.find(".single");
                this.$cache.from[0].style.visibility = "hidden";
                this.$cache.to[0].style.visibility = "hidden";
                this.$cache.shad_single = this.$cache.cont.find(".shadow-single");
            } else {
                this.$cache.cont.append(double_html);
                this.$cache.s_from = this.$cache.cont.find(".from");
                this.$cache.s_to = this.$cache.cont.find(".to");
                this.$cache.shad_from = this.$cache.cont.find(".shadow-from");
                this.$cache.shad_to = this.$cache.cont.find(".shadow-to");

                this.setTopHandler();
            }

            if (this.options.hide_from_to) {
                this.$cache.from[0].style.display = "none";
                this.$cache.to[0].style.display = "none";
                this.$cache.single[0].style.display = "none";
            }

            this.appendGrid();

            if (this.options.disable) {
                this.appendDisableMask();
                this.$cache.input[0].disabled = true;
            } else {
                this.$cache.cont.removeClass("irs-disabled");
                this.$cache.input[0].disabled = false;
                this.bindEvents();
            }

            if (this.options.drag_interval) {
                this.$cache.bar[0].style.cursor = "ew-resize";
            }
        },

        /**
         * Determine which handler has a priority
         * works only for double slider type
         */
        setTopHandler: function () {
            var min = this.options.min,
                max = this.options.max,
                from = this.options.from,
                to = this.options.to;

            if (from > min && to === max) {
                this.$cache.s_from.addClass("type_last");
            } else if (to < max) {
                this.$cache.s_to.addClass("type_last");
            }
        },

        /**
         * Determine which handles was clicked last
         * and which handler should have hover effect
         *
         * @param target {String}
         */
        changeLevel: function (target) {
            switch (target) {
                case "single":
                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake);
                    break;
                case "from":
                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
                    this.$cache.s_from.addClass("state_hover");
                    this.$cache.s_from.addClass("type_last");
                    this.$cache.s_to.removeClass("type_last");
                    break;
                case "to":
                    this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake);
                    this.$cache.s_to.addClass("state_hover");
                    this.$cache.s_to.addClass("type_last");
                    this.$cache.s_from.removeClass("type_last");
                    break;
                case "both":
                    this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
                    this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer);
                    this.$cache.s_to.removeClass("type_last");
                    this.$cache.s_from.removeClass("type_last");
                    break;
            }
        },

        /**
         * Then slider is disabled
         * appends extra layer with opacity
         */
        appendDisableMask: function () {
            this.$cache.cont.append(disable_html);
            this.$cache.cont.addClass("irs-disabled");
        },

        /**
         * Remove slider instance
         * and ubind all events
         */
        remove: function () {
            this.$cache.cont.remove();
            this.$cache.cont = null;

            this.$cache.line.off("keydown.irs_" + this.plugin_count);

            this.$cache.body.off("touchmove.irs_" + this.plugin_count);
            this.$cache.body.off("mousemove.irs_" + this.plugin_count);

            this.$cache.win.off("touchend.irs_" + this.plugin_count);
            this.$cache.win.off("mouseup.irs_" + this.plugin_count);

            if (is_old_ie) {
                this.$cache.body.off("mouseup.irs_" + this.plugin_count);
                this.$cache.body.off("mouseleave.irs_" + this.plugin_count);
            }

            this.$cache.grid_labels = [];
            this.coords.big = [];
            this.coords.big_w = [];
            this.coords.big_p = [];
            this.coords.big_x = [];

            cancelAnimationFrame(this.raf_id);
        },

        /**
         * bind all slider events
         */
        bindEvents: function () {
            if (this.no_diapason) {
                return;
            }

            this.$cache.body.on("touchmove.irs_" + this.plugin_count, this.pointerMove.bind(this));
            this.$cache.body.on("mousemove.irs_" + this.plugin_count, this.pointerMove.bind(this));

            this.$cache.win.on("touchend.irs_" + this.plugin_count, this.pointerUp.bind(this));
            this.$cache.win.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));

            this.$cache.line.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
            this.$cache.line.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

            if (this.options.drag_interval && this.options.type === "double") {
                this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
                this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
            } else {
                this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
            }

            if (this.options.type === "single") {
                this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                this.$cache.s_single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                this.$cache.shad_single.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

                this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                this.$cache.s_single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
                this.$cache.edge.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                this.$cache.shad_single.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
            } else {
                this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, null));
                this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, null));

                this.$cache.from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                this.$cache.s_from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                this.$cache.to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                this.$cache.s_to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                this.$cache.shad_from.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                this.$cache.shad_to.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));

                this.$cache.from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                this.$cache.s_from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
                this.$cache.to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                this.$cache.s_to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
                this.$cache.shad_from.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
                this.$cache.shad_to.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
            }

            if (this.options.keyboard) {
                this.$cache.line.on("keydown.irs_" + this.plugin_count, this.key.bind(this, "keyboard"));
            }

            if (is_old_ie) {
                this.$cache.body.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));
                this.$cache.body.on("mouseleave.irs_" + this.plugin_count, this.pointerUp.bind(this));
            }
        },

        /**
         * Mousemove or touchmove
         * only for handlers
         *
         * @param e {Object} event object
         */
        pointerMove: function (e) {
            if (!this.dragging) {
                return;
            }

            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
            this.coords.x_pointer = x - this.coords.x_gap;

            this.calc();
        },

        /**
         * Mouseup or touchend
         * only for handlers
         *
         * @param e {Object} event object
         */
        pointerUp: function (e) {
            if (this.current_plugin !== this.plugin_count) {
                return;
            }

            if (this.is_active) {
                this.is_active = false;
            } else {
                return;
            }

            this.$cache.cont.find(".state_hover").removeClass("state_hover");

            this.force_redraw = true;

            if (is_old_ie) {
                $("*").prop("unselectable", false);
            }

            this.updateScene();
            this.restoreOriginalMinInterval();

            // callbacks call
            if ($.contains(this.$cache.cont[0], e.target) || this.dragging) {
                this.is_finish = true;
                this.callOnFinish();
            }
            
            this.dragging = false;
        },

        /**
         * Mousedown or touchstart
         * only for handlers
         *
         * @param target {String|null}
         * @param e {Object} event object
         */
        pointerDown: function (target, e) {
            e.preventDefault();
            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
            if (e.button === 2) {
                return;
            }

            if (target === "both") {
                this.setTempMinInterval();
            }

            if (!target) {
                target = this.target;
            }

            this.current_plugin = this.plugin_count;
            this.target = target;

            this.is_active = true;
            this.dragging = true;

            this.coords.x_gap = this.$cache.rs.offset().left;
            this.coords.x_pointer = x - this.coords.x_gap;

            this.calcPointerPercent();
            this.changeLevel(target);

            if (is_old_ie) {
                $("*").prop("unselectable", true);
            }

            this.$cache.line.trigger("focus");

            this.updateScene();
        },

        /**
         * Mousedown or touchstart
         * for other slider elements, like diapason line
         *
         * @param target {String}
         * @param e {Object} event object
         */
        pointerClick: function (target, e) {
            e.preventDefault();
            var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
            if (e.button === 2) {
                return;
            }

            this.current_plugin = this.plugin_count;
            this.target = target;

            this.is_click = true;
            this.coords.x_gap = this.$cache.rs.offset().left;
            this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();

            this.force_redraw = true;
            this.calc();

            this.$cache.line.trigger("focus");
        },

        /**
         * Keyborard controls for focused slider
         *
         * @param target {String}
         * @param e {Object} event object
         * @returns {boolean|undefined}
         */
        key: function (target, e) {
            if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
                return;
            }

            switch (e.which) {
                case 83: // W
                case 65: // A
                case 40: // DOWN
                case 37: // LEFT
                    e.preventDefault();
                    this.moveByKey(false);
                    break;

                case 87: // S
                case 68: // D
                case 38: // UP
                case 39: // RIGHT
                    e.preventDefault();
                    this.moveByKey(true);
                    break;
            }

            return true;
        },

        /**
         * Move by key. Beta
         * @todo refactor than have plenty of time
         *
         * @param right {boolean} direction to move
         */
        moveByKey: function (right) {
            var p = this.coords.p_pointer;

            if (right) {
                p += this.options.keyboard_step;
            } else {
                p -= this.options.keyboard_step;
            }

            this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);
            this.is_key = true;
            this.calc();
        },

        /**
         * Set visibility and content
         * of Min and Max labels
         */
        setMinMax: function () {
            if (!this.options) {
                return;
            }

            if (this.options.hide_min_max) {
                this.$cache.min[0].style.display = "none";
                this.$cache.max[0].style.display = "none";
                return;
            }

            if (this.options.values.length) {
                this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));
                this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));
            } else {
                this.$cache.min.html(this.decorate(this._prettify(this.options.min), this.options.min));
                this.$cache.max.html(this.decorate(this._prettify(this.options.max), this.options.max));
            }

            this.labels.w_min = this.$cache.min.outerWidth(false);
            this.labels.w_max = this.$cache.max.outerWidth(false);
        },

        /**
         * Then dragging interval, prevent interval collapsing
         * using min_interval option
         */
        setTempMinInterval: function () {
            var interval = this.result.to - this.result.from;

            if (this.old_min_interval === null) {
                this.old_min_interval = this.options.min_interval;
            }

            this.options.min_interval = interval;
        },

        /**
         * Restore min_interval option to original
         */
        restoreOriginalMinInterval: function () {
            if (this.old_min_interval !== null) {
                this.options.min_interval = this.old_min_interval;
                this.old_min_interval = null;
            }
        },



        // =============================================================================================================
        // Calculations

        /**
         * All calculations and measures start here
         *
         * @param update {boolean=}
         */
        calc: function (update) {
            if (!this.options) {
                return;
            }

            this.calc_count++;

            if (this.calc_count === 10 || update) {
                this.calc_count = 0;
                this.coords.w_rs = this.$cache.rs.outerWidth(false);

                this.calcHandlePercent();
            }

            if (!this.coords.w_rs) {
                return;
            }

            this.calcPointerPercent();
            var handle_x = this.getHandleX();

            if (this.target === "click") {
                this.coords.p_gap = this.coords.p_handle / 2;
                handle_x = this.getHandleX();

                if (this.options.drag_interval) {
                    this.target = "both_one";
                } else {
                    this.target = this.chooseHandle(handle_x);
                }
            }

            switch (this.target) {
                case "base":
                    var w = (this.options.max - this.options.min) / 100,
                        f = (this.result.from - this.options.min) / w,
                        t = (this.result.to - this.options.min) / w;

                    this.coords.p_single_real = this.toFixed(f);
                    this.coords.p_from_real = this.toFixed(f);
                    this.coords.p_to_real = this.toFixed(t);

                    this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);

                    this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);
                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                    this.target = null;

                    break;

                case "single":
                    if (this.options.from_fixed) {
                        break;
                    }

                    this.coords.p_single_real = this.convertToRealPercent(handle_x);
                    this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real);
                    this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);

                    this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);

                    break;

                case "from":
                    if (this.options.from_fixed) {
                        break;
                    }

                    this.coords.p_from_real = this.convertToRealPercent(handle_x);
                    this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
                    if (this.coords.p_from_real > this.coords.p_to_real) {
                        this.coords.p_from_real = this.coords.p_to_real;
                    }
                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                    this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
                    this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, "from");

                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

                    break;

                case "to":
                    if (this.options.to_fixed) {
                        break;
                    }

                    this.coords.p_to_real = this.convertToRealPercent(handle_x);
                    this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
                    if (this.coords.p_to_real < this.coords.p_from_real) {
                        this.coords.p_to_real = this.coords.p_from_real;
                    }
                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
                    this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
                    this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, "to");

                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                    break;

                case "both":
                    if (this.options.from_fixed || this.options.to_fixed) {
                        break;
                    }

                    handle_x = this.toFixed(handle_x + (this.coords.p_handle * 0.1));

                    this.coords.p_from_real = this.convertToRealPercent(handle_x) - this.coords.p_gap_left;
                    this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                    this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

                    this.coords.p_to_real = this.convertToRealPercent(handle_x) + this.coords.p_gap_right;
                    this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
                    this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                    break;

                case "both_one":
                    if (this.options.from_fixed || this.options.to_fixed) {
                        break;
                    }

                    var real_x = this.convertToRealPercent(handle_x),
                        from = this.result.from_percent,
                        to = this.result.to_percent,
                        full = to - from,
                        half = full / 2,
                        new_from = real_x - half,
                        new_to = real_x + half;

                    if (new_from < 0) {
                        new_from = 0;
                        new_to = new_from + full;
                    }

                    if (new_to > 100) {
                        new_to = 100;
                        new_from = new_to - full;
                    }

                    this.coords.p_from_real = this.calcWithStep(new_from);
                    this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
                    this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);

                    this.coords.p_to_real = this.calcWithStep(new_to);
                    this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
                    this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);

                    break;
            }

            if (this.options.type === "single") {
                this.coords.p_bar_x = (this.coords.p_handle / 2);
                this.coords.p_bar_w = this.coords.p_single_fake;

                this.result.from_percent = this.coords.p_single_real;
                this.result.from = this.convertToValue(this.coords.p_single_real);

                if (this.options.values.length) {
                    this.result.from_value = this.options.values[this.result.from];
                }
            } else {
                this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + (this.coords.p_handle / 2));
                this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake);

                this.result.from_percent = this.coords.p_from_real;
                this.result.from = this.convertToValue(this.coords.p_from_real);
                this.result.to_percent = this.coords.p_to_real;
                this.result.to = this.convertToValue(this.coords.p_to_real);

                if (this.options.values.length) {
                    this.result.from_value = this.options.values[this.result.from];
                    this.result.to_value = this.options.values[this.result.to];
                }
            }

            this.calcMinMax();
            this.calcLabels();
        },


        /**
         * calculates pointer X in percent
         */
        calcPointerPercent: function () {
            if (!this.coords.w_rs) {
                this.coords.p_pointer = 0;
                return;
            }

            if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)  ) {
                this.coords.x_pointer = 0;
            } else if (this.coords.x_pointer > this.coords.w_rs) {
                this.coords.x_pointer = this.coords.w_rs;
            }

            this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);
        },

        convertToRealPercent: function (fake) {
            var full = 100 - this.coords.p_handle;
            return fake / full * 100;
        },

        convertToFakePercent: function (real) {
            var full = 100 - this.coords.p_handle;
            return real / 100 * full;
        },

        getHandleX: function () {
            var max = 100 - this.coords.p_handle,
                x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);

            if (x < 0) {
                x = 0;
            } else if (x > max) {
                x = max;
            }

            return x;
        },

        calcHandlePercent: function () {
            if (this.options.type === "single") {
                this.coords.w_handle = this.$cache.s_single.outerWidth(false);
            } else {
                this.coords.w_handle = this.$cache.s_from.outerWidth(false);
            }

            this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);
        },

        /**
         * Find closest handle to pointer click
         *
         * @param real_x {Number}
         * @returns {String}
         */
        chooseHandle: function (real_x) {
            if (this.options.type === "single") {
                return "single";
            } else {
                var m_point = this.coords.p_from_real + ((this.coords.p_to_real - this.coords.p_from_real) / 2);
                if (real_x >= m_point) {
                    return this.options.to_fixed ? "from" : "to";
                } else {
                    return this.options.from_fixed ? "to" : "from";
                }
            }
        },

        /**
         * Measure Min and Max labels width in percent
         */
        calcMinMax: function () {
            if (!this.coords.w_rs) {
                return;
            }

            this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;
            this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;
        },

        /**
         * Measure labels width and X in percent
         */
        calcLabels: function () {
            if (!this.coords.w_rs || this.options.hide_from_to) {
                return;
            }

            if (this.options.type === "single") {

                this.labels.w_single = this.$cache.single.outerWidth(false);
                this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
                this.labels.p_single_left = this.coords.p_single_fake + (this.coords.p_handle / 2) - (this.labels.p_single_fake / 2);
                this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);

            } else {

                this.labels.w_from = this.$cache.from.outerWidth(false);
                this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100;
                this.labels.p_from_left = this.coords.p_from_fake + (this.coords.p_handle / 2) - (this.labels.p_from_fake / 2);
                this.labels.p_from_left = this.toFixed(this.labels.p_from_left);
                this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake);

                this.labels.w_to = this.$cache.to.outerWidth(false);
                this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100;
                this.labels.p_to_left = this.coords.p_to_fake + (this.coords.p_handle / 2) - (this.labels.p_to_fake / 2);
                this.labels.p_to_left = this.toFixed(this.labels.p_to_left);
                this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake);

                this.labels.w_single = this.$cache.single.outerWidth(false);
                this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
                this.labels.p_single_left = ((this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2) - (this.labels.p_single_fake / 2);
                this.labels.p_single_left = this.toFixed(this.labels.p_single_left);
                this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);

            }
        },



        // =============================================================================================================
        // Drawings

        /**
         * Main function called in request animation frame
         * to update everything
         */
        updateScene: function () {
            if (this.raf_id) {
                cancelAnimationFrame(this.raf_id);
                this.raf_id = null;
            }

            clearTimeout(this.update_tm);
            this.update_tm = null;

            if (!this.options) {
                return;
            }

            this.drawHandles();

            if (this.is_active) {
                this.raf_id = requestAnimationFrame(this.updateScene.bind(this));
            } else {
                this.update_tm = setTimeout(this.updateScene.bind(this), 300);
            }
        },

        /**
         * Draw handles
         */
        drawHandles: function () {
            this.coords.w_rs = this.$cache.rs.outerWidth(false);

            if (!this.coords.w_rs) {
                return;
            }

            if (this.coords.w_rs !== this.coords.w_rs_old) {
                this.target = "base";
                this.is_resize = true;
            }

            if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {
                this.setMinMax();
                this.calc(true);
                this.drawLabels();
                if (this.options.grid) {
                    this.calcGridMargin();
                    this.calcGridLabels();
                }
                this.force_redraw = true;
                this.coords.w_rs_old = this.coords.w_rs;
                this.drawShadow();
            }

            if (!this.coords.w_rs) {
                return;
            }

            if (!this.dragging && !this.force_redraw && !this.is_key) {
                return;
            }

            if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {

                this.drawLabels();

                this.$cache.bar[0].style.left = this.coords.p_bar_x + "%";
                this.$cache.bar[0].style.width = this.coords.p_bar_w + "%";

                if (this.options.type === "single") {
                    this.$cache.s_single[0].style.left = this.coords.p_single_fake + "%";

                    this.$cache.single[0].style.left = this.labels.p_single_left + "%";

                    if (this.options.values.length) {
                        this.$cache.input.prop("value", this.result.from_value);
                    } else {
                        this.$cache.input.prop("value", this.result.from);
                    }
                    this.$cache.input.data("from", this.result.from);
                } else {
                    this.$cache.s_from[0].style.left = this.coords.p_from_fake + "%";
                    this.$cache.s_to[0].style.left = this.coords.p_to_fake + "%";

                    if (this.old_from !== this.result.from || this.force_redraw) {
                        this.$cache.from[0].style.left = this.labels.p_from_left + "%";
                    }
                    if (this.old_to !== this.result.to || this.force_redraw) {
                        this.$cache.to[0].style.left = this.labels.p_to_left + "%";
                    }

                    this.$cache.single[0].style.left = this.labels.p_single_left + "%";

                    if (this.options.values.length) {
                        this.$cache.input.prop("value", this.result.from_value + this.options.input_values_separator + this.result.to_value);
                    } else {
                        this.$cache.input.prop("value", this.result.from + this.options.input_values_separator + this.result.to);
                    }
                    this.$cache.input.data("from", this.result.from);
                    this.$cache.input.data("to", this.result.to);
                }

                if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {
                    this.$cache.input.trigger("change");
                }

                this.old_from = this.result.from;
                this.old_to = this.result.to;

                // callbacks call
                if (!this.is_resize && !this.is_update && !this.is_start && !this.is_finish) {
                    this.callOnChange();
                }
                if (this.is_key || this.is_click) {
                    this.is_key = false;
                    this.is_click = false;
                    this.callOnFinish();
                }

                this.is_update = false;
                this.is_resize = false;
                this.is_finish = false;
            }

            this.is_start = false;
            this.is_key = false;
            this.is_click = false;
            this.force_redraw = false;
        },

        /**
         * Draw labels
         * measure labels collisions
         * collapse close labels
         */
        drawLabels: function () {
            if (!this.options) {
                return;
            }

            var values_num = this.options.values.length,
                p_values = this.options.p_values,
                text_single,
                text_from,
                text_to;

            if (this.options.hide_from_to) {
                return;
            }

            if (this.options.type === "single") {

                if (values_num) {
                    text_single = this.decorate(p_values[this.result.from]);
                    this.$cache.single.html(text_single);
                } else {
                    text_single = this.decorate(this._prettify(this.result.from), this.result.from);
                    this.$cache.single.html(text_single);
                }

                this.calcLabels();

                if (this.labels.p_single_left < this.labels.p_min + 1) {
                    this.$cache.min[0].style.visibility = "hidden";
                } else {
                    this.$cache.min[0].style.visibility = "visible";
                }

                if (this.labels.p_single_left + this.labels.p_single_fake > 100 - this.labels.p_max - 1) {
                    this.$cache.max[0].style.visibility = "hidden";
                } else {
                    this.$cache.max[0].style.visibility = "visible";
                }

            } else {

                if (values_num) {

                    if (this.options.decorate_both) {
                        text_single = this.decorate(p_values[this.result.from]);
                        text_single += this.options.values_separator;
                        text_single += this.decorate(p_values[this.result.to]);
                    } else {
                        text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);
                    }
                    text_from = this.decorate(p_values[this.result.from]);
                    text_to = this.decorate(p_values[this.result.to]);

                    this.$cache.single.html(text_single);
                    this.$cache.from.html(text_from);
                    this.$cache.to.html(text_to);

                } else {

                    if (this.options.decorate_both) {
                        text_single = this.decorate(this._prettify(this.result.from), this.result.from);
                        text_single += this.options.values_separator;
                        text_single += this.decorate(this._prettify(this.result.to), this.result.to);
                    } else {
                        text_single = this.decorate(this._prettify(this.result.from) + this.options.values_separator + this._prettify(this.result.to), this.result.to);
                    }
                    text_from = this.decorate(this._prettify(this.result.from), this.result.from);
                    text_to = this.decorate(this._prettify(this.result.to), this.result.to);

                    this.$cache.single.html(text_single);
                    this.$cache.from.html(text_from);
                    this.$cache.to.html(text_to);

                }

                this.calcLabels();

                var min = Math.min(this.labels.p_single_left, this.labels.p_from_left),
                    single_left = this.labels.p_single_left + this.labels.p_single_fake,
                    to_left = this.labels.p_to_left + this.labels.p_to_fake,
                    max = Math.max(single_left, to_left);

                if (this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left) {
                    this.$cache.from[0].style.visibility = "hidden";
                    this.$cache.to[0].style.visibility = "hidden";
                    this.$cache.single[0].style.visibility = "visible";

                    if (this.result.from === this.result.to) {
                        if (this.target === "from") {
                            this.$cache.from[0].style.visibility = "visible";
                        } else if (this.target === "to") {
                            this.$cache.to[0].style.visibility = "visible";
                        } else if (!this.target) {
                            this.$cache.from[0].style.visibility = "visible";
                        }
                        this.$cache.single[0].style.visibility = "hidden";
                        max = to_left;
                    } else {
                        this.$cache.from[0].style.visibility = "hidden";
                        this.$cache.to[0].style.visibility = "hidden";
                        this.$cache.single[0].style.visibility = "visible";
                        max = Math.max(single_left, to_left);
                    }
                } else {
                    this.$cache.from[0].style.visibility = "visible";
                    this.$cache.to[0].style.visibility = "visible";
                    this.$cache.single[0].style.visibility = "hidden";
                }

                if (min < this.labels.p_min + 1) {
                    this.$cache.min[0].style.visibility = "hidden";
                } else {
                    this.$cache.min[0].style.visibility = "visible";
                }

                if (max > 100 - this.labels.p_max - 1) {
                    this.$cache.max[0].style.visibility = "hidden";
                } else {
                    this.$cache.max[0].style.visibility = "visible";
                }

            }
        },

        /**
         * Draw shadow intervals
         */
        drawShadow: function () {
            var o = this.options,
                c = this.$cache,

                is_from_min = typeof o.from_min === "number" && !isNaN(o.from_min),
                is_from_max = typeof o.from_max === "number" && !isNaN(o.from_max),
                is_to_min = typeof o.to_min === "number" && !isNaN(o.to_min),
                is_to_max = typeof o.to_max === "number" && !isNaN(o.to_max),

                from_min,
                from_max,
                to_min,
                to_max;

            if (o.type === "single") {
                if (o.from_shadow && (is_from_min || is_from_max)) {
                    from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
                    from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
                    from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
                    from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (this.coords.p_handle / 2);

                    c.shad_single[0].style.display = "block";
                    c.shad_single[0].style.left = from_min + "%";
                    c.shad_single[0].style.width = from_max + "%";
                } else {
                    c.shad_single[0].style.display = "none";
                }
            } else {
                if (o.from_shadow && (is_from_min || is_from_max)) {
                    from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
                    from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
                    from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
                    from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
                    from_min = from_min + (this.coords.p_handle / 2);

                    c.shad_from[0].style.display = "block";
                    c.shad_from[0].style.left = from_min + "%";
                    c.shad_from[0].style.width = from_max + "%";
                } else {
                    c.shad_from[0].style.display = "none";
                }

                if (o.to_shadow && (is_to_min || is_to_max)) {
                    to_min = this.convertToPercent(is_to_min ? o.to_min : o.min);
                    to_max = this.convertToPercent(is_to_max ? o.to_max : o.max) - to_min;
                    to_min = this.toFixed(to_min - (this.coords.p_handle / 100 * to_min));
                    to_max = this.toFixed(to_max - (this.coords.p_handle / 100 * to_max));
                    to_min = to_min + (this.coords.p_handle / 2);

                    c.shad_to[0].style.display = "block";
                    c.shad_to[0].style.left = to_min + "%";
                    c.shad_to[0].style.width = to_max + "%";
                } else {
                    c.shad_to[0].style.display = "none";
                }
            }
        },



        // =============================================================================================================
        // Callbacks

        callOnStart: function () {
            if (this.options.onStart && typeof this.options.onStart === "function") {
                this.options.onStart(this.result);
            }
        },
        callOnChange: function () {
            if (this.options.onChange && typeof this.options.onChange === "function") {
                this.options.onChange(this.result);
            }
        },
        callOnFinish: function () {
            if (this.options.onFinish && typeof this.options.onFinish === "function") {
                this.options.onFinish(this.result);
            }
        },
        callOnUpdate: function () {
            if (this.options.onUpdate && typeof this.options.onUpdate === "function") {
                this.options.onUpdate(this.result);
            }
        },



        // =============================================================================================================
        // Service methods

        toggleInput: function () {
            this.$cache.input.toggleClass("irs-hidden-input");
        },

        /**
         * Convert real value to percent
         *
         * @param value {Number} X in real
         * @param no_min {boolean=} don't use min value
         * @returns {Number} X in percent
         */
        convertToPercent: function (value, no_min) {
            var diapason = this.options.max - this.options.min,
                one_percent = diapason / 100,
                val, percent;

            if (!diapason) {
                this.no_diapason = true;
                return 0;
            }

            if (no_min) {
                val = value;
            } else {
                val = value - this.options.min;
            }

            percent = val / one_percent;

            return this.toFixed(percent);
        },

        /**
         * Convert percent to real values
         *
         * @param percent {Number} X in percent
         * @returns {Number} X in real
         */
        convertToValue: function (percent) {
            var min = this.options.min,
                max = this.options.max,
                min_decimals = min.toString().split(".")[1],
                max_decimals = max.toString().split(".")[1],
                min_length, max_length,
                avg_decimals = 0,
                abs = 0;

            if (percent === 0) {
                return this.options.min;
            }
            if (percent === 100) {
                return this.options.max;
            }


            if (min_decimals) {
                min_length = min_decimals.length;
                avg_decimals = min_length;
            }
            if (max_decimals) {
                max_length = max_decimals.length;
                avg_decimals = max_length;
            }
            if (min_length && max_length) {
                avg_decimals = (min_length >= max_length) ? min_length : max_length;
            }

            if (min < 0) {
                abs = Math.abs(min);
                min = +(min + abs).toFixed(avg_decimals);
                max = +(max + abs).toFixed(avg_decimals);
            }

            var number = ((max - min) / 100 * percent) + min,
                string = this.options.step.toString().split(".")[1],
                result;

            if (string) {
                number = +number.toFixed(string.length);
            } else {
                number = number / this.options.step;
                number = number * this.options.step;

                number = +number.toFixed(0);
            }

            if (abs) {
                number -= abs;
            }

            if (string) {
                result = +number.toFixed(string.length);
            } else {
                result = this.toFixed(number);
            }

            if (result < this.options.min) {
                result = this.options.min;
            } else if (result > this.options.max) {
                result = this.options.max;
            }

            return result;
        },

        /**
         * Round percent value with step
         *
         * @param percent {Number}
         * @returns percent {Number} rounded
         */
        calcWithStep: function (percent) {
            var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;

            if (rounded > 100) {
                rounded = 100;
            }
            if (percent === 100) {
                rounded = 100;
            }

            return this.toFixed(rounded);
        },

        checkMinInterval: function (p_current, p_next, type) {
            var o = this.options,
                current,
                next;

            if (!o.min_interval) {
                return p_current;
            }

            current = this.convertToValue(p_current);
            next = this.convertToValue(p_next);

            if (type === "from") {

                if (next - current < o.min_interval) {
                    current = next - o.min_interval;
                }

            } else {

                if (current - next < o.min_interval) {
                    current = next + o.min_interval;
                }

            }

            return this.convertToPercent(current);
        },

        checkMaxInterval: function (p_current, p_next, type) {
            var o = this.options,
                current,
                next;

            if (!o.max_interval) {
                return p_current;
            }

            current = this.convertToValue(p_current);
            next = this.convertToValue(p_next);

            if (type === "from") {

                if (next - current > o.max_interval) {
                    current = next - o.max_interval;
                }

            } else {

                if (current - next > o.max_interval) {
                    current = next + o.max_interval;
                }

            }

            return this.convertToPercent(current);
        },

        checkDiapason: function (p_num, min, max) {
            var num = this.convertToValue(p_num),
                o = this.options;

            if (typeof min !== "number") {
                min = o.min;
            }

            if (typeof max !== "number") {
                max = o.max;
            }

            if (num < min) {
                num = min;
            }

            if (num > max) {
                num = max;
            }

            return this.convertToPercent(num);
        },

        toFixed: function (num) {
            num = num.toFixed(9);
            return +num;
        },

        _prettify: function (num) {
            if (!this.options.prettify_enabled) {
                return num;
            }

            if (this.options.prettify && typeof this.options.prettify === "function") {
                return this.options.prettify(num);
            } else {
                return this.prettify(num);
            }
        },

        prettify: function (num) {
            var n = num.toString();
            return n.replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + this.options.prettify_separator);
        },

        checkEdges: function (left, width) {
            if (!this.options.force_edges) {
                return this.toFixed(left);
            }

            if (left < 0) {
                left = 0;
            } else if (left > 100 - width) {
                left = 100 - width;
            }

            return this.toFixed(left);
        },

        validate: function () {
            var o = this.options,
                r = this.result,
                v = o.values,
                vl = v.length,
                value,
                i;

            if (typeof o.min === "string") o.min = +o.min;
            if (typeof o.max === "string") o.max = +o.max;
            if (typeof o.from === "string") o.from = +o.from;
            if (typeof o.to === "string") o.to = +o.to;
            if (typeof o.step === "string") o.step = +o.step;

            if (typeof o.from_min === "string") o.from_min = +o.from_min;
            if (typeof o.from_max === "string") o.from_max = +o.from_max;
            if (typeof o.to_min === "string") o.to_min = +o.to_min;
            if (typeof o.to_max === "string") o.to_max = +o.to_max;

            if (typeof o.keyboard_step === "string") o.keyboard_step = +o.keyboard_step;
            if (typeof o.grid_num === "string") o.grid_num = +o.grid_num;

            if (o.max < o.min) {
                o.max = o.min;
            }

            if (vl) {
                o.p_values = [];
                o.min = 0;
                o.max = vl - 1;
                o.step = 1;
                o.grid_num = o.max;
                o.grid_snap = true;


                for (i = 0; i < vl; i++) {
                    value = +v[i];

                    if (!isNaN(value)) {
                        v[i] = value;
                        value = this._prettify(value);
                    } else {
                        value = v[i];
                    }

                    o.p_values.push(value);
                }
            }

            if (typeof o.from !== "number" || isNaN(o.from)) {
                o.from = o.min;
            }

            if (typeof o.to !== "number" || isNaN(o.from)) {
                o.to = o.max;
            }

            if (o.type === "single") {

                if (o.from < o.min) {
                    o.from = o.min;
                }

                if (o.from > o.max) {
                    o.from = o.max;
                }

            } else {

                if (o.from < o.min || o.from > o.max) {
                    o.from = o.min;
                }
                if (o.to > o.max || o.to < o.min) {
                    o.to = o.max;
                }
                if (o.from > o.to) {
                    o.from = o.to;
                }

            }

            if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
                o.step = 1;
            }

            if (typeof o.keyboard_step !== "number" || isNaN(o.keyboard_step) || !o.keyboard_step || o.keyboard_step < 0) {
                o.keyboard_step = 5;
            }

            if (typeof o.from_min === "number" && o.from < o.from_min) {
                o.from = o.from_min;
            }

            if (typeof o.from_max === "number" && o.from > o.from_max) {
                o.from = o.from_max;
            }

            if (typeof o.to_min === "number" && o.to < o.to_min) {
                o.to = o.to_min;
            }

            if (typeof o.to_max === "number" && o.from > o.to_max) {
                o.to = o.to_max;
            }

            if (r) {
                if (r.min !== o.min) {
                    r.min = o.min;
                }

                if (r.max !== o.max) {
                    r.max = o.max;
                }

                if (r.from < r.min || r.from > r.max) {
                    r.from = o.from;
                }

                if (r.to < r.min || r.to > r.max) {
                    r.to = o.to;
                }
            }

            if (typeof o.min_interval !== "number" || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {
                o.min_interval = 0;
            }

            if (typeof o.max_interval !== "number" || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {
                o.max_interval = 0;
            }

            if (o.min_interval && o.min_interval > o.max - o.min) {
                o.min_interval = o.max - o.min;
            }

            if (o.max_interval && o.max_interval > o.max - o.min) {
                o.max_interval = o.max - o.min;
            }
        },

        decorate: function (num, original) {
            var decorated = "",
                o = this.options;

            if (o.prefix) {
                decorated += o.prefix;
            }

            decorated += num;

            if (o.max_postfix) {
                if (o.values.length && num === o.p_values[o.max]) {
                    decorated += o.max_postfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                } else if (original === o.max) {
                    decorated += o.max_postfix;
                    if (o.postfix) {
                        decorated += " ";
                    }
                }
            }

            if (o.postfix) {
                decorated += o.postfix;
            }

            return decorated;
        },

        updateFrom: function () {
            this.result.from = this.options.from;
            this.result.from_percent = this.convertToPercent(this.result.from);
            if (this.options.values) {
                this.result.from_value = this.options.values[this.result.from];
            }
        },

        updateTo: function () {
            this.result.to = this.options.to;
            this.result.to_percent = this.convertToPercent(this.result.to);
            if (this.options.values) {
                this.result.to_value = this.options.values[this.result.to];
            }
        },

        updateResult: function () {
            this.result.min = this.options.min;
            this.result.max = this.options.max;
            this.updateFrom();
            this.updateTo();
        },


        // =============================================================================================================
        // Grid

        appendGrid: function () {
            if (!this.options.grid) {
                return;
            }

            var o = this.options,
                i, z,

                total = o.max - o.min,
                big_num = o.grid_num,
                big_p = 0,
                big_w = 0,

                small_max = 4,
                local_small_max,
                small_p,
                small_w = 0,

                result,
                html = '';



            this.calcGridMargin();

            if (o.grid_snap) {
                big_num = total / o.step;
                big_p = this.toFixed(o.step / (total / 100));
            } else {
                big_p = this.toFixed(100 / big_num);
            }

            if (big_num > 4) {
                small_max = 3;
            }
            if (big_num > 7) {
                small_max = 2;
            }
            if (big_num > 14) {
                small_max = 1;
            }
            if (big_num > 28) {
                small_max = 0;
            }

            for (i = 0; i < big_num + 1; i++) {
                local_small_max = small_max;

                big_w = this.toFixed(big_p * i);

                if (big_w > 100) {
                    big_w = 100;

                    local_small_max -= 2;
                    if (local_small_max < 0) {
                        local_small_max = 0;
                    }
                }
                this.coords.big[i] = big_w;

                small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);

                for (z = 1; z <= local_small_max; z++) {
                    if (big_w === 0) {
                        break;
                    }

                    small_w = this.toFixed(big_w - (small_p * z));

                    html += '<span class="irs-grid-pol small" style="left: ' + small_w + '%"></span>';
                }

                html += '<span class="irs-grid-pol" style="left: ' + big_w + '%"></span>';

                result = this.convertToValue(big_w);
                if (o.values.length) {
                    result = o.p_values[result];
                } else {
                    result = this._prettify(result);
                }

                html += '<span class="irs-grid-text js-grid-text-' + i + '" style="left: ' + big_w + '%">' + result + '</span>';
            }
            this.coords.big_num = Math.ceil(big_num + 1);



            this.$cache.cont.addClass("irs-with-grid");
            this.$cache.grid.html(html);
            this.cacheGridLabels();
        },

        cacheGridLabels: function () {
            var $label, i,
                num = this.coords.big_num;

            for (i = 0; i < num; i++) {
                $label = this.$cache.grid.find(".js-grid-text-" + i);
                this.$cache.grid_labels.push($label);
            }

            this.calcGridLabels();
        },

        calcGridLabels: function () {
            var i, label, start = [], finish = [],
                num = this.coords.big_num;

            for (i = 0; i < num; i++) {
                this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);
                this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);
                this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);

                start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);
                finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);
            }

            if (this.options.force_edges) {
                if (start[0] < -this.coords.grid_gap) {
                    start[0] = -this.coords.grid_gap;
                    finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);

                    this.coords.big_x[0] = this.coords.grid_gap;
                }

                if (finish[num - 1] > 100 + this.coords.grid_gap) {
                    finish[num - 1] = 100 + this.coords.grid_gap;
                    start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);

                    this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);
                }
            }

            this.calcGridCollision(2, start, finish);
            this.calcGridCollision(4, start, finish);

            for (i = 0; i < num; i++) {
                label = this.$cache.grid_labels[i][0];
                label.style.marginLeft = -this.coords.big_x[i] + "%";
            }
        },

        // Collisions Calc Beta
        // TODO: Refactor then have plenty of time
        calcGridCollision: function (step, start, finish) {
            var i, next_i, label,
                num = this.coords.big_num;

            for (i = 0; i < num; i += step) {
                next_i = i + (step / 2);
                if (next_i >= num) {
                    break;
                }

                label = this.$cache.grid_labels[next_i][0];

                if (finish[i] <= start[next_i]) {
                    label.style.visibility = "visible";
                } else {
                    label.style.visibility = "hidden";
                }
            }
        },

        calcGridMargin: function () {
            if (!this.options.grid_margin) {
                return;
            }

            this.coords.w_rs = this.$cache.rs.outerWidth(false);
            if (!this.coords.w_rs) {
                return;
            }

            if (this.options.type === "single") {
                this.coords.w_handle = this.$cache.s_single.outerWidth(false);
            } else {
                this.coords.w_handle = this.$cache.s_from.outerWidth(false);
            }
            this.coords.p_handle = this.toFixed(this.coords.w_handle  / this.coords.w_rs * 100);
            this.coords.grid_gap = this.toFixed((this.coords.p_handle / 2) - 0.1);

            this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + "%";
            this.$cache.grid[0].style.left = this.coords.grid_gap + "%";
        },



        // =============================================================================================================
        // Public methods

        update: function (options) {
            if (!this.input) {
                return;
            }

            this.is_update = true;

            this.options.from = this.result.from;
            this.options.to = this.result.to;

            this.options = $.extend(this.options, options);
            this.validate();
            this.updateResult(options);

            this.toggleInput();
            this.remove();
            this.init(true);
        },

        reset: function () {
            if (!this.input) {
                return;
            }

            this.updateResult();
            this.update();
        },

        destroy: function () {
            if (!this.input) {
                return;
            }

            this.toggleInput();
            this.$cache.input.prop("readonly", false);
            $.data(this.input, "ionRangeSlider", null);

            this.remove();
            this.input = null;
            this.options = null;
        }
    };

    $.fn.ionRangeSlider = function (options) {
        return this.each(function() {
            if (!$.data(this, "ionRangeSlider")) {
                $.data(this, "ionRangeSlider", new IonRangeSlider(this, options, plugin_count++));
            }
        });
    };



    // =================================================================================================================
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

    // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

    // MIT license

    (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
                || window[vendors[x]+'CancelRequestAnimationFrame'];
        }

        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); },
                    timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };

        if (!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
    }());

}));

/**
 * jquery.mask.js
 * @version: v1.13.4
 * @author: Igor Escobar
 *
 * Created by Igor Escobar on 2012-03-10. Please report any bug at http://blog.igorescobar.com
 *
 * Copyright (c) 2012 Igor Escobar http://blog.igorescobar.com
 *
 * The MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* jshint laxbreak: true */
/* global define, jQuery, Zepto */

'use strict';

// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.
// https://github.com/umdjs/umd/blob/master/jqueryPluginCommonjs.js
(function (factory) {

    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery || Zepto);
    }

}(function ($) {

    var Mask = function (el, mask, options) {
        el = $(el);

        var jMask = this, oldValue = el.val(), regexMask;

        mask = typeof mask === 'function' ? mask(el.val(), undefined, el,  options) : mask;

        var p = {
            invalid: [],
            getCaret: function () {
                try {
                    var sel,
                        pos = 0,
                        ctrl = el.get(0),
                        dSel = document.selection,
                        cSelStart = ctrl.selectionStart;

                    // IE Support
                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {
                        sel = dSel.createRange();
                        sel.moveStart('character', el.is('input') ? -el.val().length : -el.text().length);
                        pos = sel.text.length;
                    }
                    // Firefox support
                    else if (cSelStart || cSelStart === '0') {
                        pos = cSelStart;
                    }

                    return pos;
                } catch (e) {}
            },
            setCaret: function(pos) {
                try {
                    if (el.is(':focus')) {
                        var range, ctrl = el.get(0);
                        range = ctrl.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', pos);
                        range.moveStart('character', pos);
                        range.select();
                    }
                } catch (e) {}
            },
            events: function() {
                el
                .on('input.mask keyup.mask', p.behaviour)
                .on('paste.mask drop.mask', function() {
                    setTimeout(function() {
                        el.keydown().keyup();
                    }, 100);
                })
                .on('change.mask', function(){
                    el.data('changed', true);
                })
                .on('blur.mask', function(){
                    if (oldValue !== el.val() && !el.data('changed')) {
                        el.triggerHandler('change');
                    }
                    el.data('changed', false);
                })
                // it's very important that this callback remains in this position
                // otherwhise oldValue it's going to work buggy
                .on('blur.mask', function() {
                    oldValue = el.val();
                })
                // select all text on focus
                .on('focus.mask', function (e) {
                    if (options.selectOnFocus === true) {
                        $(e.target).select();
                    }
                })
                // clear the value if it not complete the mask
                .on('focusout.mask', function() {
                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {
                       p.val('');
                   }
                });
            },
            getRegexMask: function() {
                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;

                for (var i = 0; i < mask.length; i++) {
                    translation = jMask.translation[mask.charAt(i)];

                    if (translation) {

                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');
                        optional = translation.optional;
                        recursive = translation.recursive;

                        if (recursive) {
                            maskChunks.push(mask.charAt(i));
                            oRecursive = {digit: mask.charAt(i), pattern: pattern};
                        } else {
                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));
                        }

                    } else {
                        maskChunks.push(mask.charAt(i).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    }
                }

                r = maskChunks.join('');

                if (oRecursive) {
                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')
                         .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);
                }

                return new RegExp(r);
            },
            destroyEvents: function() {
                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));
            },
            val: function(v) {
                var isInput = el.is('input'),
                    method = isInput ? 'val' : 'text',
                    r;

                if (arguments.length > 0) {
                    if (el[method]() !== v) {
                        el[method](v);
                    }
                    r = el;
                } else {
                    r = el[method]();
                }

                return r;
            },
            getMCharsBeforeCount: function(index, onCleanVal) {
                for (var count = 0, i = 0, maskL = mask.length; i < maskL && i < index; i++) {
                    if (!jMask.translation[mask.charAt(i)]) {
                        index = onCleanVal ? index + 1 : index;
                        count++;
                    }
                }
                return count;
            },
            caretPos: function (originalCaretPos, oldLength, newLength, maskDif) {
                var translation = jMask.translation[mask.charAt(Math.min(originalCaretPos - 1, mask.length - 1))];

                return !translation ? p.caretPos(originalCaretPos + 1, oldLength, newLength, maskDif)
                                    : Math.min(originalCaretPos + newLength - oldLength - maskDif, newLength);
            },
            behaviour: function(e) {
                e = e || window.event;
                p.invalid = [];
                var keyCode = e.keyCode || e.which;
                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {

                    var caretPos = p.getCaret(),
                        currVal = p.val(),
                        currValL = currVal.length,
                        changeCaret = caretPos < currValL,
                        newVal = p.getMasked(),
                        newValL = newVal.length,
                        maskDif = p.getMCharsBeforeCount(newValL - 1) - p.getMCharsBeforeCount(currValL - 1);

                    p.val(newVal);

                    // change caret but avoid CTRL+A
                    if (changeCaret && !(keyCode === 65 && e.ctrlKey)) {
                        // Avoid adjusting caret on backspace or delete
                        if (!(keyCode === 8 || keyCode === 46)) {
                            caretPos = p.caretPos(caretPos, currValL, newValL, maskDif);
                        }
                        p.setCaret(caretPos);
                    }

                    return p.callbacks(e);
                }
            },
            getMasked: function(skipMaskChars) {
                var buf = [],
                    value = p.val(),
                    m = 0, maskLen = mask.length,
                    v = 0, valLen = value.length,
                    offset = 1, addMethod = 'push',
                    resetPos = -1,
                    lastMaskChar,
                    check;

                if (options.reverse) {
                    addMethod = 'unshift';
                    offset = -1;
                    lastMaskChar = 0;
                    m = maskLen - 1;
                    v = valLen - 1;
                    check = function () {
                        return m > -1 && v > -1;
                    };
                } else {
                    lastMaskChar = maskLen - 1;
                    check = function () {
                        return m < maskLen && v < valLen;
                    };
                }

                while (check()) {
                    var maskDigit = mask.charAt(m),
                        valDigit = value.charAt(v),
                        translation = jMask.translation[maskDigit];

                    if (translation) {
                        if (valDigit.match(translation.pattern)) {
                            buf[addMethod](valDigit);
                             if (translation.recursive) {
                                if (resetPos === -1) {
                                    resetPos = m;
                                } else if (m === lastMaskChar) {
                                    m = resetPos - offset;
                                }

                                if (lastMaskChar === resetPos) {
                                    m -= offset;
                                }
                            }
                            m += offset;
                        } else if (translation.optional) {
                            m += offset;
                            v -= offset;
                        } else if (translation.fallback) {
                            buf[addMethod](translation.fallback);
                            m += offset;
                            v -= offset;
                        } else {
                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});
                        }
                        v += offset;
                    } else {
                        if (!skipMaskChars) {
                            buf[addMethod](maskDigit);
                        }

                        if (valDigit === maskDigit) {
                            v += offset;
                        }

                        m += offset;
                    }
                }

                var lastMaskCharDigit = mask.charAt(lastMaskChar);
                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
                    buf.push(lastMaskCharDigit);
                }

                return buf.join('');
            },
            callbacks: function (e) {
                var val = p.val(),
                    changed = val !== oldValue,
                    defaultArgs = [val, e, el, options],
                    callback = function(name, criteria, args) {
                        if (typeof options[name] === 'function' && criteria) {
                            options[name].apply(this, args);
                        }
                    };

                callback('onChange', changed === true, defaultArgs);
                callback('onKeyPress', changed === true, defaultArgs);
                callback('onComplete', val.length === mask.length, defaultArgs);
                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);
            }
        };


        // public methods
        jMask.mask = mask;
        jMask.options = options;
        jMask.remove = function() {
            var caret = p.getCaret();
            p.destroyEvents();
            p.val(jMask.getCleanVal());
            p.setCaret(caret - p.getMCharsBeforeCount(caret));
            return el;
        };

        // get value without mask
        jMask.getCleanVal = function() {
           return p.getMasked(true);
        };

       jMask.init = function(onlyMask) {
            onlyMask = onlyMask || false;
            options = options || {};

            jMask.byPassKeys = $.jMaskGlobals.byPassKeys;
            jMask.translation = $.jMaskGlobals.translation;

            jMask.translation = $.extend({}, jMask.translation, options.translation);
            jMask = $.extend(true, {}, jMask, options);

            regexMask = p.getRegexMask();

            if (onlyMask === false) {

                if (options.placeholder) {
                    el.attr('placeholder' , options.placeholder);
                }

                // this is necessary, otherwise if the user submit the form
                // and then press the "back" button, the autocomplete will erase
                // the data. Works fine on IE9+, FF, Opera, Safari.
                if ($('input').length && 'oninput' in $('input')[0] === false && el.attr('autocomplete') === 'on') {
                  el.attr('autocomplete', 'off');
                }

                p.destroyEvents();
                p.events();

                var caret = p.getCaret();
                p.val(p.getMasked());
                p.setCaret(caret + p.getMCharsBeforeCount(caret, true));

            } else {
                p.events();
                p.val(p.getMasked());
            }
        };

        jMask.init(!el.is('input'));
    };

    $.maskWatchers = {};
    var HTMLAttributes = function () {
            var input = $(this),
                options = {},
                prefix = 'data-mask-',
                mask = input.attr('data-mask');

            if (input.attr(prefix + 'reverse')) {
                options.reverse = true;
            }

            if (input.attr(prefix + 'clearifnotmatch')) {
                options.clearIfNotMatch = true;
            }

            if (input.attr(prefix + 'selectonfocus') === 'true') {
               options.selectOnFocus = true;
            }

            if (notSameMaskObject(input, mask, options)) {
                return input.data('mask', new Mask(this, mask, options));
            }
        },
        notSameMaskObject = function(field, mask, options) {
            options = options || {};
            var maskObject = $(field).data('mask'),
                stringify = JSON.stringify,
                value = $(field).val() || $(field).text();
            try {
                if (typeof mask === 'function') {
                    mask = mask(value);
                }
                return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;
            } catch (e) {}
        };


    $.fn.mask = function(mask, options) {
        options = options || {};
        var selector = this.selector,
            globals = $.jMaskGlobals,
            interval = $.jMaskGlobals.watchInterval,
            maskFunction = function() {
                if (notSameMaskObject(this, mask, options)) {
                    return $(this).data('mask', new Mask(this, mask, options));
                }
            };

        $(this).each(maskFunction);

        if (selector && selector !== '' && globals.watchInputs) {
            clearInterval($.maskWatchers[selector]);
            $.maskWatchers[selector] = setInterval(function(){
                $(document).find(selector).each(maskFunction);
            }, interval);
        }
        return this;
    };

    $.fn.unmask = function() {
        clearInterval($.maskWatchers[this.selector]);
        delete $.maskWatchers[this.selector];
        return this.each(function() {
            var dataMask = $(this).data('mask');
            if (dataMask) {
                dataMask.remove().removeData('mask');
            }
        });
    };

    $.fn.cleanVal = function() {
        return this.data('mask').getCleanVal();
    };

    $.applyDataMask = function(selector) {
        selector = selector || $.jMaskGlobals.maskElements;
        var $selector = (selector instanceof $) ? selector : $(selector);
        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);
    };

    var globals = {
        maskElements: 'input,td,span,div',
        dataMaskAttr: '*[data-mask]',
        dataMask: true,
        watchInterval: 300,
        watchInputs: true,
        watchDataMask: false,
        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
        translation: {
            '0': {pattern: /\d/},
            '9': {pattern: /\d/, optional: true},
            '#': {pattern: /\d/, recursive: true},
            'A': {pattern: /[a-zA-Z0-9]/},
            'S': {pattern: /[a-zA-Z]/}
        }
    };

    $.jMaskGlobals = $.jMaskGlobals || {};
    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);

    // looking for inputs with data-mask attribute
    if (globals.dataMask) { $.applyDataMask(); }

    setInterval(function(){
        if ($.jMaskGlobals.watchDataMask) { $.applyDataMask(); }
    }, globals.watchInterval);
}));

/*!
 * typeahead.js 0.11.1
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
 */

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define("bloodhound", [ "jquery" ], function(a0) {
            return root["Bloodhound"] = factory(a0);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        root["Bloodhound"] = factory(jQuery);
    }
})(this, function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return typeof obj === "string";
            },
            isNumber: function(obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return typeof obj === "undefined";
            },
            isElement: function(obj) {
                return !!(obj && obj.nodeType === 1);
            },
            isJQuery: function(obj) {
                return obj instanceof $;
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                $.each(collection, reverseArgs);
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function(obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            identity: function(x) {
                return x;
            },
            clone: function(obj) {
                return $.extend(true, {}, obj);
            },
            getIdGenerator: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            },
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;
                function template() {
                    return String(obj);
                }
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later, callNow;
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function() {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            stringify: function(val) {
                return _.isString(val) ? val : JSON.stringify(val);
            },
            noop: function() {}
        };
    }();
    var VERSION = "0.11.1";
    var tokenizers = function() {
        "use strict";
        return {
            nonword: nonword,
            whitespace: whitespace,
            obj: {
                nonword: getObjTokenizer(nonword),
                whitespace: getObjTokenizer(whitespace)
            }
        };
        function whitespace(str) {
            str = _.toStr(str);
            return str ? str.split(/\s+/) : [];
        }
        function nonword(str) {
            str = _.toStr(str);
            return str ? str.split(/\W+/) : [];
        }
        function getObjTokenizer(tokenizer) {
            return function setKey(keys) {
                keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
                return function tokenize(o) {
                    var tokens = [];
                    _.each(keys, function(k) {
                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                    });
                    return tokens;
                };
            };
        }
    }();
    var LruCache = function() {
        "use strict";
        function LruCache(maxSize) {
            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
            this.reset();
            if (this.maxSize <= 0) {
                this.set = this.get = $.noop;
            }
        }
        _.mixin(LruCache.prototype, {
            set: function set(key, val) {
                var tailItem = this.list.tail, node;
                if (this.size >= this.maxSize) {
                    this.list.remove(tailItem);
                    delete this.hash[tailItem.key];
                    this.size--;
                }
                if (node = this.hash[key]) {
                    node.val = val;
                    this.list.moveToFront(node);
                } else {
                    node = new Node(key, val);
                    this.list.add(node);
                    this.hash[key] = node;
                    this.size++;
                }
            },
            get: function get(key) {
                var node = this.hash[key];
                if (node) {
                    this.list.moveToFront(node);
                    return node.val;
                }
            },
            reset: function reset() {
                this.size = 0;
                this.hash = {};
                this.list = new List();
            }
        });
        function List() {
            this.head = this.tail = null;
        }
        _.mixin(List.prototype, {
            add: function add(node) {
                if (this.head) {
                    node.next = this.head;
                    this.head.prev = node;
                }
                this.head = node;
                this.tail = this.tail || node;
            },
            remove: function remove(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next;
                node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function(node) {
                this.remove(node);
                this.add(node);
            }
        });
        function Node(key, val) {
            this.key = key;
            this.val = val;
            this.prev = this.next = null;
        }
        return LruCache;
    }();
    var PersistentStorage = function() {
        "use strict";
        var LOCAL_STORAGE;
        try {
            LOCAL_STORAGE = window.localStorage;
            LOCAL_STORAGE.setItem("~~~", "!");
            LOCAL_STORAGE.removeItem("~~~");
        } catch (err) {
            LOCAL_STORAGE = null;
        }
        function PersistentStorage(namespace, override) {
            this.prefix = [ "__", namespace, "__" ].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
            this.ls = override || LOCAL_STORAGE;
            !this.ls && this._noop();
        }
        _.mixin(PersistentStorage.prototype, {
            _prefix: function(key) {
                return this.prefix + key;
            },
            _ttlKey: function(key) {
                return this._prefix(key) + this.ttlKey;
            },
            _noop: function() {
                this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
            },
            _safeSet: function(key, val) {
                try {
                    this.ls.setItem(key, val);
                } catch (err) {
                    if (err.name === "QuotaExceededError") {
                        this.clear();
                        this._noop();
                    }
                }
            },
            get: function(key) {
                if (this.isExpired(key)) {
                    this.remove(key);
                }
                return decode(this.ls.getItem(this._prefix(key)));
            },
            set: function(key, val, ttl) {
                if (_.isNumber(ttl)) {
                    this._safeSet(this._ttlKey(key), encode(now() + ttl));
                } else {
                    this.ls.removeItem(this._ttlKey(key));
                }
                return this._safeSet(this._prefix(key), encode(val));
            },
            remove: function(key) {
                this.ls.removeItem(this._ttlKey(key));
                this.ls.removeItem(this._prefix(key));
                return this;
            },
            clear: function() {
                var i, keys = gatherMatchingKeys(this.keyMatcher);
                for (i = keys.length; i--; ) {
                    this.remove(keys[i]);
                }
                return this;
            },
            isExpired: function(key) {
                var ttl = decode(this.ls.getItem(this._ttlKey(key)));
                return _.isNumber(ttl) && now() > ttl ? true : false;
            }
        });
        return PersistentStorage;
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return $.parseJSON(val);
        }
        function gatherMatchingKeys(keyMatcher) {
            var i, key, keys = [], len = LOCAL_STORAGE.length;
            for (i = 0; i < len; i++) {
                if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
                    keys.push(key.replace(keyMatcher, ""));
                }
            }
            return keys;
        }
    }();
    var Transport = function() {
        "use strict";
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
        function Transport(o) {
            o = o || {};
            this.cancelled = false;
            this.lastReq = null;
            this._send = o.transport;
            this._get = o.limiter ? o.limiter(this._get) : this._get;
            this._cache = o.cache === false ? new LruCache(0) : sharedCache;
        }
        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
            maxPendingRequests = num;
        };
        Transport.resetCache = function resetCache() {
            sharedCache.reset();
        };
        _.mixin(Transport.prototype, {
            _fingerprint: function fingerprint(o) {
                o = o || {};
                return o.url + o.type + $.param(o.data || {});
            },
            _get: function(o, cb) {
                var that = this, fingerprint, jqXhr;
                fingerprint = this._fingerprint(o);
                if (this.cancelled || fingerprint !== this.lastReq) {
                    return;
                }
                if (jqXhr = pendingRequests[fingerprint]) {
                    jqXhr.done(done).fail(fail);
                } else if (pendingRequestsCount < maxPendingRequests) {
                    pendingRequestsCount++;
                    pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }
                function done(resp) {
                    cb(null, resp);
                    that._cache.set(fingerprint, resp);
                }
                function fail() {
                    cb(true);
                }
                function always() {
                    pendingRequestsCount--;
                    delete pendingRequests[fingerprint];
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function(o, cb) {
                var resp, fingerprint;
                cb = cb || $.noop;
                o = _.isString(o) ? {
                    url: o
                } : o || {};
                fingerprint = this._fingerprint(o);
                this.cancelled = false;
                this.lastReq = fingerprint;
                if (resp = this._cache.get(fingerprint)) {
                    cb(null, resp);
                } else {
                    this._get(o, cb);
                }
            },
            cancel: function() {
                this.cancelled = true;
            }
        });
        return Transport;
    }();
    var SearchIndex = window.SearchIndex = function() {
        "use strict";
        var CHILDREN = "c", IDS = "i";
        function SearchIndex(o) {
            o = o || {};
            if (!o.datumTokenizer || !o.queryTokenizer) {
                $.error("datumTokenizer and queryTokenizer are both required");
            }
            this.identify = o.identify || _.stringify;
            this.datumTokenizer = o.datumTokenizer;
            this.queryTokenizer = o.queryTokenizer;
            this.reset();
        }
        _.mixin(SearchIndex.prototype, {
            bootstrap: function bootstrap(o) {
                this.datums = o.datums;
                this.trie = o.trie;
            },
            add: function(data) {
                var that = this;
                data = _.isArray(data) ? data : [ data ];
                _.each(data, function(datum) {
                    var id, tokens;
                    that.datums[id = that.identify(datum)] = datum;
                    tokens = normalizeTokens(that.datumTokenizer(datum));
                    _.each(tokens, function(token) {
                        var node, chars, ch;
                        node = that.trie;
                        chars = token.split("");
                        while (ch = chars.shift()) {
                            node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
                            node[IDS].push(id);
                        }
                    });
                });
            },
            get: function get(ids) {
                var that = this;
                return _.map(ids, function(id) {
                    return that.datums[id];
                });
            },
            search: function search(query) {
                var that = this, tokens, matches;
                tokens = normalizeTokens(this.queryTokenizer(query));
                _.each(tokens, function(token) {
                    var node, chars, ch, ids;
                    if (matches && matches.length === 0) {
                        return false;
                    }
                    node = that.trie;
                    chars = token.split("");
                    while (node && (ch = chars.shift())) {
                        node = node[CHILDREN][ch];
                    }
                    if (node && chars.length === 0) {
                        ids = node[IDS].slice(0);
                        matches = matches ? getIntersection(matches, ids) : ids;
                    } else {
                        matches = [];
                        return false;
                    }
                });
                return matches ? _.map(unique(matches), function(id) {
                    return that.datums[id];
                }) : [];
            },
            all: function all() {
                var values = [];
                for (var key in this.datums) {
                    values.push(this.datums[key]);
                }
                return values;
            },
            reset: function reset() {
                this.datums = {};
                this.trie = newNode();
            },
            serialize: function serialize() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        });
        return SearchIndex;
        function normalizeTokens(tokens) {
            tokens = _.filter(tokens, function(token) {
                return !!token;
            });
            tokens = _.map(tokens, function(token) {
                return token.toLowerCase();
            });
            return tokens;
        }
        function newNode() {
            var node = {};
            node[IDS] = [];
            node[CHILDREN] = {};
            return node;
        }
        function unique(array) {
            var seen = {}, uniques = [];
            for (var i = 0, len = array.length; i < len; i++) {
                if (!seen[array[i]]) {
                    seen[array[i]] = true;
                    uniques.push(array[i]);
                }
            }
            return uniques;
        }
        function getIntersection(arrayA, arrayB) {
            var ai = 0, bi = 0, intersection = [];
            arrayA = arrayA.sort();
            arrayB = arrayB.sort();
            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
            while (ai < lenArrayA && bi < lenArrayB) {
                if (arrayA[ai] < arrayB[bi]) {
                    ai++;
                } else if (arrayA[ai] > arrayB[bi]) {
                    bi++;
                } else {
                    intersection.push(arrayA[ai]);
                    ai++;
                    bi++;
                }
            }
            return intersection;
        }
    }();
    var Prefetch = function() {
        "use strict";
        var keys;
        keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        };
        function Prefetch(o) {
            this.url = o.url;
            this.ttl = o.ttl;
            this.cache = o.cache;
            this.prepare = o.prepare;
            this.transform = o.transform;
            this.transport = o.transport;
            this.thumbprint = o.thumbprint;
            this.storage = new PersistentStorage(o.cacheKey);
        }
        _.mixin(Prefetch.prototype, {
            _settings: function settings() {
                return {
                    url: this.url,
                    type: "GET",
                    dataType: "json"
                };
            },
            store: function store(data) {
                if (!this.cache) {
                    return;
                }
                this.storage.set(keys.data, data, this.ttl);
                this.storage.set(keys.protocol, location.protocol, this.ttl);
                this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
            },
            fromCache: function fromCache() {
                var stored = {}, isExpired;
                if (!this.cache) {
                    return null;
                }
                stored.data = this.storage.get(keys.data);
                stored.protocol = this.storage.get(keys.protocol);
                stored.thumbprint = this.storage.get(keys.thumbprint);
                isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
                return stored.data && !isExpired ? stored.data : null;
            },
            fromNetwork: function(cb) {
                var that = this, settings;
                if (!cb) {
                    return;
                }
                settings = this.prepare(this._settings());
                this.transport(settings).fail(onError).done(onResponse);
                function onError() {
                    cb(true);
                }
                function onResponse(resp) {
                    cb(null, that.transform(resp));
                }
            },
            clear: function clear() {
                this.storage.clear();
                return this;
            }
        });
        return Prefetch;
    }();
    var Remote = function() {
        "use strict";
        function Remote(o) {
            this.url = o.url;
            this.prepare = o.prepare;
            this.transform = o.transform;
            this.transport = new Transport({
                cache: o.cache,
                limiter: o.limiter,
                transport: o.transport
            });
        }
        _.mixin(Remote.prototype, {
            _settings: function settings() {
                return {
                    url: this.url,
                    type: "GET",
                    dataType: "json"
                };
            },
            get: function get(query, cb) {
                var that = this, settings;
                if (!cb) {
                    return;
                }
                query = query || "";
                settings = this.prepare(query, this._settings());
                return this.transport.get(settings, onResponse);
                function onResponse(err, resp) {
                    err ? cb([]) : cb(that.transform(resp));
                }
            },
            cancelLastRequest: function cancelLastRequest() {
                this.transport.cancel();
            }
        });
        return Remote;
    }();
    var oParser = function() {
        "use strict";
        return function parse(o) {
            var defaults, sorter;
            defaults = {
                initialize: true,
                identify: _.stringify,
                datumTokenizer: null,
                queryTokenizer: null,
                sufficient: 5,
                sorter: null,
                local: [],
                prefetch: null,
                remote: null
            };
            o = _.mixin(defaults, o || {});
            !o.datumTokenizer && $.error("datumTokenizer is required");
            !o.queryTokenizer && $.error("queryTokenizer is required");
            sorter = o.sorter;
            o.sorter = sorter ? function(x) {
                return x.sort(sorter);
            } : _.identity;
            o.local = _.isFunction(o.local) ? o.local() : o.local;
            o.prefetch = parsePrefetch(o.prefetch);
            o.remote = parseRemote(o.remote);
            return o;
        };
        function parsePrefetch(o) {
            var defaults;
            if (!o) {
                return null;
            }
            defaults = {
                url: null,
                ttl: 24 * 60 * 60 * 1e3,
                cache: true,
                cacheKey: null,
                thumbprint: "",
                prepare: _.identity,
                transform: _.identity,
                transport: null
            };
            o = _.isString(o) ? {
                url: o
            } : o;
            o = _.mixin(defaults, o);
            !o.url && $.error("prefetch requires url to be set");
            o.transform = o.filter || o.transform;
            o.cacheKey = o.cacheKey || o.url;
            o.thumbprint = VERSION + o.thumbprint;
            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            return o;
        }
        function parseRemote(o) {
            var defaults;
            if (!o) {
                return;
            }
            defaults = {
                url: null,
                cache: true,
                prepare: null,
                replace: null,
                wildcard: null,
                limiter: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                transform: _.identity,
                transport: null
            };
            o = _.isString(o) ? {
                url: o
            } : o;
            o = _.mixin(defaults, o);
            !o.url && $.error("remote requires url to be set");
            o.transform = o.filter || o.transform;
            o.prepare = toRemotePrepare(o);
            o.limiter = toLimiter(o);
            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            delete o.replace;
            delete o.wildcard;
            delete o.rateLimitBy;
            delete o.rateLimitWait;
            return o;
        }
        function toRemotePrepare(o) {
            var prepare, replace, wildcard;
            prepare = o.prepare;
            replace = o.replace;
            wildcard = o.wildcard;
            if (prepare) {
                return prepare;
            }
            if (replace) {
                prepare = prepareByReplace;
            } else if (o.wildcard) {
                prepare = prepareByWildcard;
            } else {
                prepare = idenityPrepare;
            }
            return prepare;
            function prepareByReplace(query, settings) {
                settings.url = replace(settings.url, query);
                return settings;
            }
            function prepareByWildcard(query, settings) {
                settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
                return settings;
            }
            function idenityPrepare(query, settings) {
                return settings;
            }
        }
        function toLimiter(o) {
            var limiter, method, wait;
            limiter = o.limiter;
            method = o.rateLimitBy;
            wait = o.rateLimitWait;
            if (!limiter) {
                limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
            }
            return limiter;
            function debounce(wait) {
                return function debounce(fn) {
                    return _.debounce(fn, wait);
                };
            }
            function throttle(wait) {
                return function throttle(fn) {
                    return _.throttle(fn, wait);
                };
            }
        }
        function callbackToDeferred(fn) {
            return function wrapper(o) {
                var deferred = $.Deferred();
                fn(o, onSuccess, onError);
                return deferred;
                function onSuccess(resp) {
                    _.defer(function() {
                        deferred.resolve(resp);
                    });
                }
                function onError(err) {
                    _.defer(function() {
                        deferred.reject(err);
                    });
                }
            };
        }
    }();
    var Bloodhound = function() {
        "use strict";
        var old;
        old = window && window.Bloodhound;
        function Bloodhound(o) {
            o = oParser(o);
            this.sorter = o.sorter;
            this.identify = o.identify;
            this.sufficient = o.sufficient;
            this.local = o.local;
            this.remote = o.remote ? new Remote(o.remote) : null;
            this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
            this.index = new SearchIndex({
                identify: this.identify,
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            });
            o.initialize !== false && this.initialize();
        }
        Bloodhound.noConflict = function noConflict() {
            window && (window.Bloodhound = old);
            return Bloodhound;
        };
        Bloodhound.tokenizers = tokenizers;
        _.mixin(Bloodhound.prototype, {
            __ttAdapter: function ttAdapter() {
                var that = this;
                return this.remote ? withAsync : withoutAsync;
                function withAsync(query, sync, async) {
                    return that.search(query, sync, async);
                }
                function withoutAsync(query, sync) {
                    return that.search(query, sync);
                }
            },
            _loadPrefetch: function loadPrefetch() {
                var that = this, deferred, serialized;
                deferred = $.Deferred();
                if (!this.prefetch) {
                    deferred.resolve();
                } else if (serialized = this.prefetch.fromCache()) {
                    this.index.bootstrap(serialized);
                    deferred.resolve();
                } else {
                    this.prefetch.fromNetwork(done);
                }
                return deferred.promise();
                function done(err, data) {
                    if (err) {
                        return deferred.reject();
                    }
                    that.add(data);
                    that.prefetch.store(that.index.serialize());
                    deferred.resolve();
                }
            },
            _initialize: function initialize() {
                var that = this, deferred;
                this.clear();
                (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
                return this.initPromise;
                function addLocalToIndex() {
                    that.add(that.local);
                }
            },
            initialize: function initialize(force) {
                return !this.initPromise || force ? this._initialize() : this.initPromise;
            },
            add: function add(data) {
                this.index.add(data);
                return this;
            },
            get: function get(ids) {
                ids = _.isArray(ids) ? ids : [].slice.call(arguments);
                return this.index.get(ids);
            },
            search: function search(query, sync, async) {
                var that = this, local;
                local = this.sorter(this.index.search(query));
                sync(this.remote ? local.slice() : local);
                if (this.remote && local.length < this.sufficient) {
                    this.remote.get(query, processRemote);
                } else if (this.remote) {
                    this.remote.cancelLastRequest();
                }
                return this;
                function processRemote(remote) {
                    var nonDuplicates = [];
                    _.each(remote, function(r) {
                        !_.some(local, function(l) {
                            return that.identify(r) === that.identify(l);
                        }) && nonDuplicates.push(r);
                    });
                    async && async(nonDuplicates);
                }
            },
            all: function all() {
                return this.index.all();
            },
            clear: function clear() {
                this.index.reset();
                return this;
            },
            clearPrefetchCache: function clearPrefetchCache() {
                this.prefetch && this.prefetch.clear();
                return this;
            },
            clearRemoteCache: function clearRemoteCache() {
                Transport.resetCache();
                return this;
            },
            ttAdapter: function ttAdapter() {
                return this.__ttAdapter();
            }
        });
        return Bloodhound;
    }();
    return Bloodhound;
});

(function(root, factory) {
    if (typeof define === "function" && define.amd) {
        define("typeahead.js", [ "jquery" ], function(a0) {
            return factory(a0);
        });
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
})(this, function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return typeof obj === "string";
            },
            isNumber: function(obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return typeof obj === "undefined";
            },
            isElement: function(obj) {
                return !!(obj && obj.nodeType === 1);
            },
            isJQuery: function(obj) {
                return obj instanceof $;
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                $.each(collection, reverseArgs);
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function(obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            identity: function(x) {
                return x;
            },
            clone: function(obj) {
                return $.extend(true, {}, obj);
            },
            getIdGenerator: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            },
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;
                function template() {
                    return String(obj);
                }
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later, callNow;
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function() {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            stringify: function(val) {
                return _.isString(val) ? val : JSON.stringify(val);
            },
            noop: function() {}
        };
    }();
    var WWW = function() {
        "use strict";
        var defaultClassNames = {
            wrapper: "twitter-typeahead",
            input: "tt-input",
            hint: "tt-hint",
            menu: "tt-menu",
            dataset: "tt-dataset",
            suggestion: "tt-suggestion",
            selectable: "tt-selectable",
            empty: "tt-empty",
            open: "tt-open",
            cursor: "tt-cursor",
            highlight: "tt-highlight"
        };
        return build;
        function build(o) {
            var www, classes;
            classes = _.mixin({}, defaultClassNames, o);
            www = {
                css: buildCss(),
                classes: classes,
                html: buildHtml(classes),
                selectors: buildSelectors(classes)
            };
            return {
                css: www.css,
                html: www.html,
                classes: www.classes,
                selectors: www.selectors,
                mixin: function(o) {
                    _.mixin(o, www);
                }
            };
        }
        function buildHtml(c) {
            return {
                wrapper: '<span class="' + c.wrapper + '"></span>',
                menu: '<div class="' + c.menu + '"></div>'
            };
        }
        function buildSelectors(classes) {
            var selectors = {};
            _.each(classes, function(v, k) {
                selectors[k] = "." + v;
            });
            return selectors;
        }
        function buildCss() {
            var css = {
                wrapper: {
                    position: "relative",
                    display: "inline-block"
                },
                hint: {
                    position: "absolute",
                    top: "0",
                    left: "0",
                    borderColor: "transparent",
                    boxShadow: "none",
                    opacity: "1"
                },
                input: {
                    position: "relative",
                    verticalAlign: "top",
                    backgroundColor: "transparent"
                },
                inputWithNoHint: {
                    position: "relative",
                    verticalAlign: "top"
                },
                menu: {
                    position: "absolute",
                    top: "100%",
                    left: "0",
                    zIndex: "100",
                    display: "none"
                },
                ltr: {
                    left: "0",
                    right: "auto"
                },
                rtl: {
                    left: "auto",
                    right: " 0"
                }
            };
            if (_.isMsie()) {
                _.mixin(css.input, {
                    backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
                });
            }
            return css;
        }
    }();
    var EventBus = function() {
        "use strict";
        var namespace, deprecationMap;
        namespace = "typeahead:";
        deprecationMap = {
            render: "rendered",
            cursorchange: "cursorchanged",
            select: "selected",
            autocomplete: "autocompleted"
        };
        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }
        _.mixin(EventBus.prototype, {
            _trigger: function(type, args) {
                var $e;
                $e = $.Event(namespace + type);
                (args = args || []).unshift($e);
                this.$el.trigger.apply(this.$el, args);
                return $e;
            },
            before: function(type) {
                var args, $e;
                args = [].slice.call(arguments, 1);
                $e = this._trigger("before" + type, args);
                return $e.isDefaultPrevented();
            },
            trigger: function(type) {
                var deprecatedType;
                this._trigger(type, [].slice.call(arguments, 1));
                if (deprecatedType = deprecationMap[type]) {
                    this._trigger(deprecatedType, [].slice.call(arguments, 1));
                }
            }
        });
        return EventBus;
    }();
    var EventEmitter = function() {
        "use strict";
        var splitter = /\s+/, nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };
        function on(method, types, cb, context) {
            var type;
            if (!cb) {
                return this;
            }
            types = types.split(splitter);
            cb = context ? bindContext(cb, context) : cb;
            this._callbacks = this._callbacks || {};
            while (type = types.shift()) {
                this._callbacks[type] = this._callbacks[type] || {
                    sync: [],
                    async: []
                };
                this._callbacks[type][method].push(cb);
            }
            return this;
        }
        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }
        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }
        function off(types) {
            var type;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            while (type = types.shift()) {
                delete this._callbacks[type];
            }
            return this;
        }
        function trigger(types) {
            var type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            args = [].slice.call(arguments, 1);
            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
                asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
                syncFlush() && nextTick(asyncFlush);
            }
            return this;
        }
        function getFlush(callbacks, context, args) {
            return flush;
            function flush() {
                var cancelled;
                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                    cancelled = callbacks[i].apply(context, args) === false;
                }
                return !cancelled;
            }
        }
        function getNextTick() {
            var nextTickFn;
            if (window.setImmediate) {
                nextTickFn = function nextTickSetImmediate(fn) {
                    setImmediate(function() {
                        fn();
                    });
                };
            } else {
                nextTickFn = function nextTickSetTimeout(fn) {
                    setTimeout(function() {
                        fn();
                    }, 0);
                };
            }
            return nextTickFn;
        }
        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function() {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
    }();
    var highlight = function(doc) {
        "use strict";
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: false,
            caseSensitive: false
        };
        return function hightlight(o) {
            var regex;
            o = _.mixin({}, defaults, o);
            if (!o.node || !o.pattern) {
                return;
            }
            o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
            traverse(o.node, hightlightTextNode);
            function hightlightTextNode(textNode) {
                var match, patternNode, wrapperNode;
                if (match = regex.exec(textNode.data)) {
                    wrapperNode = doc.createElement(o.tagName);
                    o.className && (wrapperNode.className = o.className);
                    patternNode = textNode.splitText(match.index);
                    patternNode.splitText(match[0].length);
                    wrapperNode.appendChild(patternNode.cloneNode(true));
                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
                }
                return !!match;
            }
            function traverse(el, hightlightTextNode) {
                var childNode, TEXT_NODE_TYPE = 3;
                for (var i = 0; i < el.childNodes.length; i++) {
                    childNode = el.childNodes[i];
                    if (childNode.nodeType === TEXT_NODE_TYPE) {
                        i += hightlightTextNode(childNode) ? 1 : 0;
                    } else {
                        traverse(childNode, hightlightTextNode);
                    }
                }
            }
        };
        function getRegex(patterns, caseSensitive, wordsOnly) {
            var escapedPatterns = [], regexStr;
            for (var i = 0, len = patterns.length; i < len; i++) {
                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            }
            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
    }(window.document);
    var Input = function() {
        "use strict";
        var specialKeyCodeMap;
        specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        };
        function Input(o, www) {
            o = o || {};
            if (!o.input) {
                $.error("input is missing");
            }
            www.mixin(this);
            this.$hint = $(o.hint);
            this.$input = $(o.input);
            this.query = this.$input.val();
            this.queryWhenFocused = this.hasFocus() ? this.query : null;
            this.$overflowHelper = buildOverflowHelper(this.$input);
            this._checkLanguageDirection();
            if (this.$hint.length === 0) {
                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
            }
        }
        Input.normalizeQuery = function(str) {
            return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        };
        _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function onBlur() {
                this.resetInputValue();
                this.trigger("blurred");
            },
            _onFocus: function onFocus() {
                this.queryWhenFocused = this.query;
                this.trigger("focused");
            },
            _onKeydown: function onKeydown($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e);
                if (keyName && this._shouldTrigger(keyName, $e)) {
                    this.trigger(keyName + "Keyed", $e);
                }
            },
            _onInput: function onInput() {
                this._setQuery(this.getInputValue());
                this.clearHintIfInvalid();
                this._checkLanguageDirection();
            },
            _managePreventDefault: function managePreventDefault(keyName, $e) {
                var preventDefault;
                switch (keyName) {
                  case "up":
                  case "down":
                    preventDefault = !withModifier($e);
                    break;

                  default:
                    preventDefault = false;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function shouldTrigger(keyName, $e) {
                var trigger;
                switch (keyName) {
                  case "tab":
                    trigger = !withModifier($e);
                    break;

                  default:
                    trigger = true;
                }
                return trigger;
            },
            _checkLanguageDirection: function checkLanguageDirection() {
                var dir = (this.$input.css("direction") || "ltr").toLowerCase();
                if (this.dir !== dir) {
                    this.dir = dir;
                    this.$hint.attr("dir", dir);
                    this.trigger("langDirChanged", dir);
                }
            },
            _setQuery: function setQuery(val, silent) {
                var areEquivalent, hasDifferentWhitespace;
                areEquivalent = areQueriesEquivalent(val, this.query);
                hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
                this.query = val;
                if (!silent && !areEquivalent) {
                    this.trigger("queryChanged", this.query);
                } else if (!silent && hasDifferentWhitespace) {
                    this.trigger("whitespaceChanged", this.query);
                }
            },
            bind: function() {
                var that = this, onBlur, onFocus, onKeydown, onInput;
                onBlur = _.bind(this._onBlur, this);
                onFocus = _.bind(this._onFocus, this);
                onKeydown = _.bind(this._onKeydown, this);
                onInput = _.bind(this._onInput, this);
                this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
                if (!_.isMsie() || _.isMsie() > 9) {
                    this.$input.on("input.tt", onInput);
                } else {
                    this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                        if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                            return;
                        }
                        _.defer(_.bind(that._onInput, that, $e));
                    });
                }
                return this;
            },
            focus: function focus() {
                this.$input.focus();
            },
            blur: function blur() {
                this.$input.blur();
            },
            getLangDir: function getLangDir() {
                return this.dir;
            },
            getQuery: function getQuery() {
                return this.query || "";
            },
            setQuery: function setQuery(val, silent) {
                this.setInputValue(val);
                this._setQuery(val, silent);
            },
            hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
                return this.query !== this.queryWhenFocused;
            },
            getInputValue: function getInputValue() {
                return this.$input.val();
            },
            setInputValue: function setInputValue(value) {
                this.$input.val(value);
                this.clearHintIfInvalid();
                this._checkLanguageDirection();
            },
            resetInputValue: function resetInputValue() {
                this.setInputValue(this.query);
            },
            getHint: function getHint() {
                return this.$hint.val();
            },
            setHint: function setHint(value) {
                this.$hint.val(value);
            },
            clearHint: function clearHint() {
                this.setHint("");
            },
            clearHintIfInvalid: function clearHintIfInvalid() {
                var val, hint, valIsPrefixOfHint, isValid;
                val = this.getInputValue();
                hint = this.getHint();
                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                !isValid && this.clearHint();
            },
            hasFocus: function hasFocus() {
                return this.$input.is(":focus");
            },
            hasOverflow: function hasOverflow() {
                var constraint = this.$input.width() - 2;
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function() {
                var valueLength, selectionStart, range;
                valueLength = this.$input.val().length;
                selectionStart = this.$input[0].selectionStart;
                if (_.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            },
            destroy: function destroy() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$overflowHelper.remove();
                this.$hint = this.$input = this.$overflowHelper = $("<div>");
            }
        });
        return Input;
        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "pre",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }
        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
    }();
    var Dataset = function() {
        "use strict";
        var keys, nameGenerator;
        keys = {
            val: "tt-selectable-display",
            obj: "tt-selectable-object"
        };
        nameGenerator = _.getIdGenerator();
        function Dataset(o, www) {
            o = o || {};
            o.templates = o.templates || {};
            o.templates.notFound = o.templates.notFound || o.templates.empty;
            if (!o.source) {
                $.error("missing source");
            }
            if (!o.node) {
                $.error("missing node");
            }
            if (o.name && !isValidName(o.name)) {
                $.error("invalid dataset name: " + o.name);
            }
            www.mixin(this);
            this.highlight = !!o.highlight;
            this.name = o.name || nameGenerator();
            this.limit = o.limit || 5;
            this.displayFn = getDisplayFn(o.display || o.displayKey);
            this.templates = getTemplates(o.templates, this.displayFn);
            this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
            this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
            this._resetLastSuggestion();
            this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
        }
        Dataset.extractData = function extractData(el) {
            var $el = $(el);
            if ($el.data(keys.obj)) {
                return {
                    val: $el.data(keys.val) || "",
                    obj: $el.data(keys.obj) || null
                };
            }
            return null;
        };
        _.mixin(Dataset.prototype, EventEmitter, {
            _overwrite: function overwrite(query, suggestions) {
                suggestions = suggestions || [];
                if (suggestions.length) {
                    this._renderSuggestions(query, suggestions);
                } else if (this.async && this.templates.pending) {
                    this._renderPending(query);
                } else if (!this.async && this.templates.notFound) {
                    this._renderNotFound(query);
                } else {
                    this._empty();
                }
                this.trigger("rendered", this.name, suggestions, false);
            },
            _append: function append(query, suggestions) {
                suggestions = suggestions || [];
                if (suggestions.length && this.$lastSuggestion.length) {
                    this._appendSuggestions(query, suggestions);
                } else if (suggestions.length) {
                    this._renderSuggestions(query, suggestions);
                } else if (!this.$lastSuggestion.length && this.templates.notFound) {
                    this._renderNotFound(query);
                }
                this.trigger("rendered", this.name, suggestions, true);
            },
            _renderSuggestions: function renderSuggestions(query, suggestions) {
                var $fragment;
                $fragment = this._getSuggestionsFragment(query, suggestions);
                this.$lastSuggestion = $fragment.children().last();
                this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
            },
            _appendSuggestions: function appendSuggestions(query, suggestions) {
                var $fragment, $lastSuggestion;
                $fragment = this._getSuggestionsFragment(query, suggestions);
                $lastSuggestion = $fragment.children().last();
                this.$lastSuggestion.after($fragment);
                this.$lastSuggestion = $lastSuggestion;
            },
            _renderPending: function renderPending(query) {
                var template = this.templates.pending;
                this._resetLastSuggestion();
                template && this.$el.html(template({
                    query: query,
                    dataset: this.name
                }));
            },
            _renderNotFound: function renderNotFound(query) {
                var template = this.templates.notFound;
                this._resetLastSuggestion();
                template && this.$el.html(template({
                    query: query,
                    dataset: this.name
                }));
            },
            _empty: function empty() {
                this.$el.empty();
                this._resetLastSuggestion();
            },
            _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
                var that = this, fragment;
                fragment = document.createDocumentFragment();
                _.each(suggestions, function getSuggestionNode(suggestion) {
                    var $el, context;
                    context = that._injectQuery(query, suggestion);
                    $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
                    fragment.appendChild($el[0]);
                });
                this.highlight && highlight({
                    className: this.classes.highlight,
                    node: fragment,
                    pattern: query
                });
                return $(fragment);
            },
            _getFooter: function getFooter(query, suggestions) {
                return this.templates.footer ? this.templates.footer({
                    query: query,
                    suggestions: suggestions,
                    dataset: this.name
                }) : null;
            },
            _getHeader: function getHeader(query, suggestions) {
                return this.templates.header ? this.templates.header({
                    query: query,
                    suggestions: suggestions,
                    dataset: this.name
                }) : null;
            },
            _resetLastSuggestion: function resetLastSuggestion() {
                this.$lastSuggestion = $();
            },
            _injectQuery: function injectQuery(query, obj) {
                return _.isObject(obj) ? _.mixin({
                    _query: query
                }, obj) : obj;
            },
            update: function update(query) {
                var that = this, canceled = false, syncCalled = false, rendered = 0;
                this.cancel();
                this.cancel = function cancel() {
                    canceled = true;
                    that.cancel = $.noop;
                    that.async && that.trigger("asyncCanceled", query);
                };
                this.source(query, sync, async);
                !syncCalled && sync([]);
                function sync(suggestions) {
                    if (syncCalled) {
                        return;
                    }
                    syncCalled = true;
                    suggestions = (suggestions || []).slice(0, that.limit);
                    rendered = suggestions.length;
                    that._overwrite(query, suggestions);
                    if (rendered < that.limit && that.async) {
                        that.trigger("asyncRequested", query);
                    }
                }
                function async(suggestions) {
                    suggestions = suggestions || [];
                    if (!canceled && rendered < that.limit) {
                        that.cancel = $.noop;
                        rendered += suggestions.length;
                        that._append(query, suggestions.slice(0, that.limit - rendered));
                        that.async && that.trigger("asyncReceived", query);
                    }
                }
            },
            cancel: $.noop,
            clear: function clear() {
                this._empty();
                this.cancel();
                this.trigger("cleared");
            },
            isEmpty: function isEmpty() {
                return this.$el.is(":empty");
            },
            destroy: function destroy() {
                this.$el = $("<div>");
            }
        });
        return Dataset;
        function getDisplayFn(display) {
            display = display || _.stringify;
            return _.isFunction(display) ? display : displayFn;
            function displayFn(obj) {
                return obj[display];
            }
        }
        function getTemplates(templates, displayFn) {
            return {
                notFound: templates.notFound && _.templatify(templates.notFound),
                pending: templates.pending && _.templatify(templates.pending),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };
            function suggestionTemplate(context) {
                return $("<div>").text(displayFn(context));
            }
        }
        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
    }();
    var Menu = function() {
        "use strict";
        function Menu(o, www) {
            var that = this;
            o = o || {};
            if (!o.node) {
                $.error("node is required");
            }
            www.mixin(this);
            this.$node = $(o.node);
            this.query = null;
            this.datasets = _.map(o.datasets, initializeDataset);
            function initializeDataset(oDataset) {
                var node = that.$node.find(oDataset.node).first();
                oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
                return new Dataset(oDataset, www);
            }
        }
        _.mixin(Menu.prototype, EventEmitter, {
            _onSelectableClick: function onSelectableClick($e) {
                this.trigger("selectableClicked", $($e.currentTarget));
            },
            _onRendered: function onRendered(type, dataset, suggestions, async) {
                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                this.trigger("datasetRendered", dataset, suggestions, async);
            },
            _onCleared: function onCleared() {
                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
                this.trigger("datasetCleared");
            },
            _propagate: function propagate() {
                this.trigger.apply(this, arguments);
            },
            _allDatasetsEmpty: function allDatasetsEmpty() {
                return _.every(this.datasets, isDatasetEmpty);
                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
            },
            _getSelectables: function getSelectables() {
                return this.$node.find(this.selectors.selectable);
            },
            _removeCursor: function _removeCursor() {
                var $selectable = this.getActiveSelectable();
                $selectable && $selectable.removeClass(this.classes.cursor);
            },
            _ensureVisible: function ensureVisible($el) {
                var elTop, elBottom, nodeScrollTop, nodeHeight;
                elTop = $el.position().top;
                elBottom = elTop + $el.outerHeight(true);
                nodeScrollTop = this.$node.scrollTop();
                nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
                if (elTop < 0) {
                    this.$node.scrollTop(nodeScrollTop + elTop);
                } else if (nodeHeight < elBottom) {
                    this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
                }
            },
            bind: function() {
                var that = this, onSelectableClick;
                onSelectableClick = _.bind(this._onSelectableClick, this);
                this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
                _.each(this.datasets, function(dataset) {
                    dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
                });
                return this;
            },
            isOpen: function isOpen() {
                return this.$node.hasClass(this.classes.open);
            },
            open: function open() {
                this.$node.addClass(this.classes.open);
            },
            close: function close() {
                this.$node.removeClass(this.classes.open);
                this._removeCursor();
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$node.attr("dir", dir);
            },
            selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
                var $selectables, $oldCursor, oldIndex, newIndex;
                $oldCursor = this.getActiveSelectable();
                $selectables = this._getSelectables();
                oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
                newIndex = oldIndex + delta;
                newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
                newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
                return newIndex === -1 ? null : $selectables.eq(newIndex);
            },
            setCursor: function setCursor($selectable) {
                this._removeCursor();
                if ($selectable = $selectable && $selectable.first()) {
                    $selectable.addClass(this.classes.cursor);
                    this._ensureVisible($selectable);
                }
            },
            getSelectableData: function getSelectableData($el) {
                return $el && $el.length ? Dataset.extractData($el) : null;
            },
            getActiveSelectable: function getActiveSelectable() {
                var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
                return $selectable.length ? $selectable : null;
            },
            getTopSelectable: function getTopSelectable() {
                var $selectable = this._getSelectables().first();
                return $selectable.length ? $selectable : null;
            },
            update: function update(query) {
                var isValidUpdate = query !== this.query;
                if (isValidUpdate) {
                    this.query = query;
                    _.each(this.datasets, updateDataset);
                }
                return isValidUpdate;
                function updateDataset(dataset) {
                    dataset.update(query);
                }
            },
            empty: function empty() {
                _.each(this.datasets, clearDataset);
                this.query = null;
                this.$node.addClass(this.classes.empty);
                function clearDataset(dataset) {
                    dataset.clear();
                }
            },
            destroy: function destroy() {
                this.$node.off(".tt");
                this.$node = $("<div>");
                _.each(this.datasets, destroyDataset);
                function destroyDataset(dataset) {
                    dataset.destroy();
                }
            }
        });
        return Menu;
    }();
    var DefaultMenu = function() {
        "use strict";
        var s = Menu.prototype;
        function DefaultMenu() {
            Menu.apply(this, [].slice.call(arguments, 0));
        }
        _.mixin(DefaultMenu.prototype, Menu.prototype, {
            open: function open() {
                !this._allDatasetsEmpty() && this._show();
                return s.open.apply(this, [].slice.call(arguments, 0));
            },
            close: function close() {
                this._hide();
                return s.close.apply(this, [].slice.call(arguments, 0));
            },
            _onRendered: function onRendered() {
                if (this._allDatasetsEmpty()) {
                    this._hide();
                } else {
                    this.isOpen() && this._show();
                }
                return s._onRendered.apply(this, [].slice.call(arguments, 0));
            },
            _onCleared: function onCleared() {
                if (this._allDatasetsEmpty()) {
                    this._hide();
                } else {
                    this.isOpen() && this._show();
                }
                return s._onCleared.apply(this, [].slice.call(arguments, 0));
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
                return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
            },
            _hide: function hide() {
                this.$node.hide();
            },
            _show: function show() {
                this.$node.css("display", "block");
            }
        });
        return DefaultMenu;
    }();
    var Typeahead = function() {
        "use strict";
        function Typeahead(o, www) {
            var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
            o = o || {};
            if (!o.input) {
                $.error("missing input");
            }
            if (!o.menu) {
                $.error("missing menu");
            }
            if (!o.eventBus) {
                $.error("missing event bus");
            }
            www.mixin(this);
            this.eventBus = o.eventBus;
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
            this.input = o.input;
            this.menu = o.menu;
            this.enabled = true;
            this.active = false;
            this.input.hasFocus() && this.activate();
            this.dir = this.input.getLangDir();
            this._hacks();
            this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
            onFocused = c(this, "activate", "open", "_onFocused");
            onBlurred = c(this, "deactivate", "_onBlurred");
            onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
            onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
            onEscKeyed = c(this, "isActive", "_onEscKeyed");
            onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
            onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
            onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
            onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
            onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
            onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
            this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
        }
        _.mixin(Typeahead.prototype, {
            _hacks: function hacks() {
                var $input, $menu;
                $input = this.input.$input || $("<div>");
                $menu = this.menu.$node || $("<div>");
                $input.on("blur.tt", function($e) {
                    var active, isActive, hasActive;
                    active = document.activeElement;
                    isActive = $menu.is(active);
                    hasActive = $menu.has(active).length > 0;
                    if (_.isMsie() && (isActive || hasActive)) {
                        $e.preventDefault();
                        $e.stopImmediatePropagation();
                        _.defer(function() {
                            $input.focus();
                        });
                    }
                });
                $menu.on("mousedown.tt", function($e) {
                    $e.preventDefault();
                });
            },
            _onSelectableClicked: function onSelectableClicked(type, $el) {
                this.select($el);
            },
            _onDatasetCleared: function onDatasetCleared() {
                this._updateHint();
            },
            _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
                this._updateHint();
                this.eventBus.trigger("render", suggestions, async, dataset);
            },
            _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
                this.eventBus.trigger("asyncrequest", query, dataset);
            },
            _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
                this.eventBus.trigger("asynccancel", query, dataset);
            },
            _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
                this.eventBus.trigger("asyncreceive", query, dataset);
            },
            _onFocused: function onFocused() {
                this._minLengthMet() && this.menu.update(this.input.getQuery());
            },
            _onBlurred: function onBlurred() {
                if (this.input.hasQueryChangedSinceLastFocus()) {
                    this.eventBus.trigger("change", this.input.getQuery());
                }
            },
            _onEnterKeyed: function onEnterKeyed(type, $e) {
                var $selectable;
                if ($selectable = this.menu.getActiveSelectable()) {
                    this.select($selectable) && $e.preventDefault();
                }
            },
            _onTabKeyed: function onTabKeyed(type, $e) {
                var $selectable;
                if ($selectable = this.menu.getActiveSelectable()) {
                    this.select($selectable) && $e.preventDefault();
                } else if ($selectable = this.menu.getTopSelectable()) {
                    this.autocomplete($selectable) && $e.preventDefault();
                }
            },
            _onEscKeyed: function onEscKeyed() {
                this.close();
            },
            _onUpKeyed: function onUpKeyed() {
                this.moveCursor(-1);
            },
            _onDownKeyed: function onDownKeyed() {
                this.moveCursor(+1);
            },
            _onLeftKeyed: function onLeftKeyed() {
                if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
                    this.autocomplete(this.menu.getTopSelectable());
                }
            },
            _onRightKeyed: function onRightKeyed() {
                if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
                    this.autocomplete(this.menu.getTopSelectable());
                }
            },
            _onQueryChanged: function onQueryChanged(e, query) {
                this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
            },
            _onWhitespaceChanged: function onWhitespaceChanged() {
                this._updateHint();
            },
            _onLangDirChanged: function onLangDirChanged(e, dir) {
                if (this.dir !== dir) {
                    this.dir = dir;
                    this.menu.setLanguageDirection(dir);
                }
            },
            _openIfActive: function openIfActive() {
                this.isActive() && this.open();
            },
            _minLengthMet: function minLengthMet(query) {
                query = _.isString(query) ? query : this.input.getQuery() || "";
                return query.length >= this.minLength;
            },
            _updateHint: function updateHint() {
                var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
                $selectable = this.menu.getTopSelectable();
                data = this.menu.getSelectableData($selectable);
                val = this.input.getInputValue();
                if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
                    query = Input.normalizeQuery(val);
                    escapedQuery = _.escapeRegExChars(query);
                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                    match = frontMatchRegEx.exec(data.val);
                    match && this.input.setHint(val + match[1]);
                } else {
                    this.input.clearHint();
                }
            },
            isEnabled: function isEnabled() {
                return this.enabled;
            },
            enable: function enable() {
                this.enabled = true;
            },
            disable: function disable() {
                this.enabled = false;
            },
            isActive: function isActive() {
                return this.active;
            },
            activate: function activate() {
                if (this.isActive()) {
                    return true;
                } else if (!this.isEnabled() || this.eventBus.before("active")) {
                    return false;
                } else {
                    this.active = true;
                    this.eventBus.trigger("active");
                    return true;
                }
            },
            deactivate: function deactivate() {
                if (!this.isActive()) {
                    return true;
                } else if (this.eventBus.before("idle")) {
                    return false;
                } else {
                    this.active = false;
                    this.close();
                    this.eventBus.trigger("idle");
                    return true;
                }
            },
            isOpen: function isOpen() {
                return this.menu.isOpen();
            },
            open: function open() {
                if (!this.isOpen() && !this.eventBus.before("open")) {
                    this.menu.open();
                    this._updateHint();
                    this.eventBus.trigger("open");
                }
                return this.isOpen();
            },
            close: function close() {
                if (this.isOpen() && !this.eventBus.before("close")) {
                    this.menu.close();
                    this.input.clearHint();
                    this.input.resetInputValue();
                    this.eventBus.trigger("close");
                }
                return !this.isOpen();
            },
            setVal: function setVal(val) {
                this.input.setQuery(_.toStr(val));
            },
            getVal: function getVal() {
                return this.input.getQuery();
            },
            select: function select($selectable) {
                var data = this.menu.getSelectableData($selectable);
                if (data && !this.eventBus.before("select", data.obj)) {
                    this.input.setQuery(data.val, true);
                    this.eventBus.trigger("select", data.obj);
                    this.close();
                    return true;
                }
                return false;
            },
            autocomplete: function autocomplete($selectable) {
                var query, data, isValid;
                query = this.input.getQuery();
                data = this.menu.getSelectableData($selectable);
                isValid = data && query !== data.val;
                if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
                    this.input.setQuery(data.val);
                    this.eventBus.trigger("autocomplete", data.obj);
                    return true;
                }
                return false;
            },
            moveCursor: function moveCursor(delta) {
                var query, $candidate, data, payload, cancelMove;
                query = this.input.getQuery();
                $candidate = this.menu.selectableRelativeToCursor(delta);
                data = this.menu.getSelectableData($candidate);
                payload = data ? data.obj : null;
                cancelMove = this._minLengthMet() && this.menu.update(query);
                if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
                    this.menu.setCursor($candidate);
                    if (data) {
                        this.input.setInputValue(data.val);
                    } else {
                        this.input.resetInputValue();
                        this._updateHint();
                    }
                    this.eventBus.trigger("cursorchange", payload);
                    return true;
                }
                return false;
            },
            destroy: function destroy() {
                this.input.destroy();
                this.menu.destroy();
            }
        });
        return Typeahead;
        function c(ctx) {
            var methods = [].slice.call(arguments, 1);
            return function() {
                var args = [].slice.call(arguments);
                _.each(methods, function(method) {
                    return ctx[method].apply(ctx, args);
                });
            };
        }
    }();
    (function() {
        "use strict";
        var old, keys, methods;
        old = $.fn.typeahead;
        keys = {
            www: "tt-www",
            attrs: "tt-attrs",
            typeahead: "tt-typeahead"
        };
        methods = {
            initialize: function initialize(o, datasets) {
                var www;
                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                o = o || {};
                www = WWW(o.classNames);
                return this.each(attach);
                function attach() {
                    var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
                    _.each(datasets, function(d) {
                        d.highlight = !!o.highlight;
                    });
                    $input = $(this);
                    $wrapper = $(www.html.wrapper);
                    $hint = $elOrNull(o.hint);
                    $menu = $elOrNull(o.menu);
                    defaultHint = o.hint !== false && !$hint;
                    defaultMenu = o.menu !== false && !$menu;
                    defaultHint && ($hint = buildHintFromInput($input, www));
                    defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
                    $hint && $hint.val("");
                    $input = prepInput($input, www);
                    if (defaultHint || defaultMenu) {
                        $wrapper.css(www.css.wrapper);
                        $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
                        $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
                    }
                    MenuConstructor = defaultMenu ? DefaultMenu : Menu;
                    eventBus = new EventBus({
                        el: $input
                    });
                    input = new Input({
                        hint: $hint,
                        input: $input
                    }, www);
                    menu = new MenuConstructor({
                        node: $menu,
                        datasets: datasets
                    }, www);
                    typeahead = new Typeahead({
                        input: input,
                        menu: menu,
                        eventBus: eventBus,
                        minLength: o.minLength
                    }, www);
                    $input.data(keys.www, www);
                    $input.data(keys.typeahead, typeahead);
                }
            },
            isEnabled: function isEnabled() {
                var enabled;
                ttEach(this.first(), function(t) {
                    enabled = t.isEnabled();
                });
                return enabled;
            },
            enable: function enable() {
                ttEach(this, function(t) {
                    t.enable();
                });
                return this;
            },
            disable: function disable() {
                ttEach(this, function(t) {
                    t.disable();
                });
                return this;
            },
            isActive: function isActive() {
                var active;
                ttEach(this.first(), function(t) {
                    active = t.isActive();
                });
                return active;
            },
            activate: function activate() {
                ttEach(this, function(t) {
                    t.activate();
                });
                return this;
            },
            deactivate: function deactivate() {
                ttEach(this, function(t) {
                    t.deactivate();
                });
                return this;
            },
            isOpen: function isOpen() {
                var open;
                ttEach(this.first(), function(t) {
                    open = t.isOpen();
                });
                return open;
            },
            open: function open() {
                ttEach(this, function(t) {
                    t.open();
                });
                return this;
            },
            close: function close() {
                ttEach(this, function(t) {
                    t.close();
                });
                return this;
            },
            select: function select(el) {
                var success = false, $el = $(el);
                ttEach(this.first(), function(t) {
                    success = t.select($el);
                });
                return success;
            },
            autocomplete: function autocomplete(el) {
                var success = false, $el = $(el);
                ttEach(this.first(), function(t) {
                    success = t.autocomplete($el);
                });
                return success;
            },
            moveCursor: function moveCursoe(delta) {
                var success = false;
                ttEach(this.first(), function(t) {
                    success = t.moveCursor(delta);
                });
                return success;
            },
            val: function val(newVal) {
                var query;
                if (!arguments.length) {
                    ttEach(this.first(), function(t) {
                        query = t.getVal();
                    });
                    return query;
                } else {
                    ttEach(this, function(t) {
                        t.setVal(newVal);
                    });
                    return this;
                }
            },
            destroy: function destroy() {
                ttEach(this, function(typeahead, $input) {
                    revert($input);
                    typeahead.destroy();
                });
                return this;
            }
        };
        $.fn.typeahead = function(method) {
            if (methods[method]) {
                return methods[method].apply(this, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
        $.fn.typeahead.noConflict = function noConflict() {
            $.fn.typeahead = old;
            return this;
        };
        function ttEach($els, fn) {
            $els.each(function() {
                var $input = $(this), typeahead;
                (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
            });
        }
        function buildHintFromInput($input, www) {
            return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
                autocomplete: "off",
                spellcheck: "false",
                tabindex: -1
            });
        }
        function prepInput($input, www) {
            $input.data(keys.attrs, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass(www.classes.input).attr({
                autocomplete: "off",
                spellcheck: false
            });
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input;
        }
        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }
        function revert($input) {
            var www, $wrapper;
            www = $input.data(keys.www);
            $wrapper = $input.parent().filter(www.selectors.wrapper);
            _.each($input.data(keys.attrs), function(val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
            if ($wrapper.length) {
                $input.detach().insertAfter($wrapper);
                $wrapper.remove();
            }
        }
        function $elOrNull(obj) {
            var isValid, $el;
            isValid = _.isJQuery(obj) || _.isElement(obj);
            $el = isValid ? $(obj).first() : [];
            return $el.length ? $el : null;
        }
    })();
});
// ProgressBar.js 1.0.1
// https://kimmobrunfeldt.github.io/progressbar.js
// License: MIT

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ProgressBar = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* shifty - v1.5.2 - 2016-02-10 - http://jeremyckahn.github.io/shifty */
;(function () {
  var root = this || Function('return this')();

/**
 * Shifty Core
 * By Jeremy Kahn - jeremyckahn@gmail.com
 */

var Tweenable = (function () {

  'use strict';

  // Aliases that get defined later in this function
  var formula;

  // CONSTANTS
  var DEFAULT_SCHEDULE_FUNCTION;
  var DEFAULT_EASING = 'linear';
  var DEFAULT_DURATION = 500;
  var UPDATE_TIME = 1000 / 60;

  var _now = Date.now
       ? Date.now
       : function () {return +new Date();};

  var now = typeof SHIFTY_DEBUG_NOW !== 'undefined' ? SHIFTY_DEBUG_NOW : _now;

  if (typeof window !== 'undefined') {
    // requestAnimationFrame() shim by Paul Irish (modified for Shifty)
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame
       || window.webkitRequestAnimationFrame
       || window.oRequestAnimationFrame
       || window.msRequestAnimationFrame
       || (window.mozCancelRequestAnimationFrame
       && window.mozRequestAnimationFrame)
       || setTimeout;
  } else {
    DEFAULT_SCHEDULE_FUNCTION = setTimeout;
  }

  function noop () {
    // NOOP!
  }

  /**
   * Handy shortcut for doing a for-in loop. This is not a "normal" each
   * function, it is optimized for Shifty.  The iterator function only receives
   * the property name, not the value.
   * @param {Object} obj
   * @param {Function(string)} fn
   * @private
   */
  function each (obj, fn) {
    var key;
    for (key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        fn(key);
      }
    }
  }

  /**
   * Perform a shallow copy of Object properties.
   * @param {Object} targetObject The object to copy into
   * @param {Object} srcObject The object to copy from
   * @return {Object} A reference to the augmented `targetObj` Object
   * @private
   */
  function shallowCopy (targetObj, srcObj) {
    each(srcObj, function (prop) {
      targetObj[prop] = srcObj[prop];
    });

    return targetObj;
  }

  /**
   * Copies each property from src onto target, but only if the property to
   * copy to target is undefined.
   * @param {Object} target Missing properties in this Object are filled in
   * @param {Object} src
   * @private
   */
  function defaults (target, src) {
    each(src, function (prop) {
      if (typeof target[prop] === 'undefined') {
        target[prop] = src[prop];
      }
    });
  }

  /**
   * Calculates the interpolated tween values of an Object for a given
   * timestamp.
   * @param {Number} forPosition The position to compute the state for.
   * @param {Object} currentState Current state properties.
   * @param {Object} originalState: The original state properties the Object is
   * tweening from.
   * @param {Object} targetState: The destination state properties the Object
   * is tweening to.
   * @param {number} duration: The length of the tween in milliseconds.
   * @param {number} timestamp: The UNIX epoch time at which the tween began.
   * @param {Object} easing: This Object's keys must correspond to the keys in
   * targetState.
   * @private
   */
  function tweenProps (forPosition, currentState, originalState, targetState,
    duration, timestamp, easing) {
    var normalizedPosition =
        forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;


    var prop;
    var easingObjectProp;
    var easingFn;
    for (prop in currentState) {
      if (currentState.hasOwnProperty(prop)) {
        easingObjectProp = easing[prop];
        easingFn = typeof easingObjectProp === 'function'
          ? easingObjectProp
          : formula[easingObjectProp];

        currentState[prop] = tweenProp(
          originalState[prop],
          targetState[prop],
          easingFn,
          normalizedPosition
        );
      }
    }

    return currentState;
  }

  /**
   * Tweens a single property.
   * @param {number} start The value that the tween started from.
   * @param {number} end The value that the tween should end at.
   * @param {Function} easingFunc The easing curve to apply to the tween.
   * @param {number} position The normalized position (between 0.0 and 1.0) to
   * calculate the midpoint of 'start' and 'end' against.
   * @return {number} The tweened value.
   * @private
   */
  function tweenProp (start, end, easingFunc, position) {
    return start + (end - start) * easingFunc(position);
  }

  /**
   * Applies a filter to Tweenable instance.
   * @param {Tweenable} tweenable The `Tweenable` instance to call the filter
   * upon.
   * @param {String} filterName The name of the filter to apply.
   * @private
   */
  function applyFilter (tweenable, filterName) {
    var filters = Tweenable.prototype.filter;
    var args = tweenable._filterArgs;

    each(filters, function (name) {
      if (typeof filters[name][filterName] !== 'undefined') {
        filters[name][filterName].apply(tweenable, args);
      }
    });
  }

  var timeoutHandler_endTime;
  var timeoutHandler_currentTime;
  var timeoutHandler_isEnded;
  var timeoutHandler_offset;
  /**
   * Handles the update logic for one step of a tween.
   * @param {Tweenable} tweenable
   * @param {number} timestamp
   * @param {number} delay
   * @param {number} duration
   * @param {Object} currentState
   * @param {Object} originalState
   * @param {Object} targetState
   * @param {Object} easing
   * @param {Function(Object, *, number)} step
   * @param {Function(Function,number)}} schedule
   * @param {number=} opt_currentTimeOverride Needed for accurate timestamp in
   * Tweenable#seek.
   * @private
   */
  function timeoutHandler (tweenable, timestamp, delay, duration, currentState,
    originalState, targetState, easing, step, schedule,
    opt_currentTimeOverride) {

    timeoutHandler_endTime = timestamp + delay + duration;

    timeoutHandler_currentTime =
    Math.min(opt_currentTimeOverride || now(), timeoutHandler_endTime);

    timeoutHandler_isEnded =
      timeoutHandler_currentTime >= timeoutHandler_endTime;

    timeoutHandler_offset = duration - (
      timeoutHandler_endTime - timeoutHandler_currentTime);

    if (tweenable.isPlaying()) {
      if (timeoutHandler_isEnded) {
        step(targetState, tweenable._attachment, timeoutHandler_offset);
        tweenable.stop(true);
      } else {
        tweenable._scheduleId =
          schedule(tweenable._timeoutHandler, UPDATE_TIME);

        applyFilter(tweenable, 'beforeTween');

        // If the animation has not yet reached the start point (e.g., there was
        // delay that has not yet completed), just interpolate the starting
        // position of the tween.
        if (timeoutHandler_currentTime < (timestamp + delay)) {
          tweenProps(1, currentState, originalState, targetState, 1, 1, easing);
        } else {
          tweenProps(timeoutHandler_currentTime, currentState, originalState,
            targetState, duration, timestamp + delay, easing);
        }

        applyFilter(tweenable, 'afterTween');

        step(currentState, tweenable._attachment, timeoutHandler_offset);
      }
    }
  }


  /**
   * Creates a usable easing Object from a string, a function or another easing
   * Object.  If `easing` is an Object, then this function clones it and fills
   * in the missing properties with `"linear"`.
   * @param {Object.<string|Function>} fromTweenParams
   * @param {Object|string|Function} easing
   * @return {Object.<string|Function>}
   * @private
   */
  function composeEasingObject (fromTweenParams, easing) {
    var composedEasing = {};
    var typeofEasing = typeof easing;

    if (typeofEasing === 'string' || typeofEasing === 'function') {
      each(fromTweenParams, function (prop) {
        composedEasing[prop] = easing;
      });
    } else {
      each(fromTweenParams, function (prop) {
        if (!composedEasing[prop]) {
          composedEasing[prop] = easing[prop] || DEFAULT_EASING;
        }
      });
    }

    return composedEasing;
  }

  /**
   * Tweenable constructor.
   * @class Tweenable
   * @param {Object=} opt_initialState The values that the initial tween should
   * start at if a `from` object is not provided to `{{#crossLink
   * "Tweenable/tween:method"}}{{/crossLink}}` or `{{#crossLink
   * "Tweenable/setConfig:method"}}{{/crossLink}}`.
   * @param {Object=} opt_config Configuration object to be passed to
   * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
   * @module Tweenable
   * @constructor
   */
  function Tweenable (opt_initialState, opt_config) {
    this._currentState = opt_initialState || {};
    this._configured = false;
    this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;

    // To prevent unnecessary calls to setConfig do not set default
    // configuration here.  Only set default configuration immediately before
    // tweening if none has been set.
    if (typeof opt_config !== 'undefined') {
      this.setConfig(opt_config);
    }
  }

  /**
   * Configure and start a tween.
   * @method tween
   * @param {Object=} opt_config Configuration object to be passed to
   * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
   * @chainable
   */
  Tweenable.prototype.tween = function (opt_config) {
    if (this._isTweening) {
      return this;
    }

    // Only set default config if no configuration has been set previously and
    // none is provided now.
    if (opt_config !== undefined || !this._configured) {
      this.setConfig(opt_config);
    }

    this._timestamp = now();
    this._start(this.get(), this._attachment);
    return this.resume();
  };

  /**
   * Configure a tween that will start at some point in the future.
   *
   * @method setConfig
   * @param {Object} config The following values are valid:
   * - __from__ (_Object=_): Starting position.  If omitted, `{{#crossLink
   *   "Tweenable/get:method"}}get(){{/crossLink}}` is used.
   * - __to__ (_Object=_): Ending position.
   * - __duration__ (_number=_): How many milliseconds to animate for.
   * - __delay__ (_delay=_): How many milliseconds to wait before starting the
   *   tween.
   * - __start__ (_Function(Object, *)_): Function to execute when the tween
   *   begins.  Receives the state of the tween as the first parameter and
   *   `attachment` as the second parameter.
   * - __step__ (_Function(Object, *, number)_): Function to execute on every
   *   tick.  Receives `{{#crossLink
   *   "Tweenable/get:method"}}get(){{/crossLink}}` as the first parameter,
   *   `attachment` as the second parameter, and the time elapsed since the
   *   start of the tween as the third. This function is not called on the
   *   final step of the animation, but `finish` is.
   * - __finish__ (_Function(Object, *)_): Function to execute upon tween
   *   completion.  Receives the state of the tween as the first parameter and
   *   `attachment` as the second parameter.
   * - __easing__ (_Object.<string|Function>|string|Function=_): Easing curve
   *   name(s) or function(s) to use for the tween.
   * - __attachment__ (_*_): Cached value that is passed to the
   *   `step`/`start`/`finish` methods.
   * @chainable
   */
  Tweenable.prototype.setConfig = function (config) {
    config = config || {};
    this._configured = true;

    // Attach something to this Tweenable instance (e.g.: a DOM element, an
    // object, a string, etc.);
    this._attachment = config.attachment;

    // Init the internal state
    this._pausedAtTime = null;
    this._scheduleId = null;
    this._delay = config.delay || 0;
    this._start = config.start || noop;
    this._step = config.step || noop;
    this._finish = config.finish || noop;
    this._duration = config.duration || DEFAULT_DURATION;
    this._currentState = shallowCopy({}, config.from) || this.get();
    this._originalState = this.get();
    this._targetState = shallowCopy({}, config.to) || this.get();

    var self = this;
    this._timeoutHandler = function () {
      timeoutHandler(self,
        self._timestamp,
        self._delay,
        self._duration,
        self._currentState,
        self._originalState,
        self._targetState,
        self._easing,
        self._step,
        self._scheduleFunction
      );
    };

    // Aliases used below
    var currentState = this._currentState;
    var targetState = this._targetState;

    // Ensure that there is always something to tween to.
    defaults(targetState, currentState);

    this._easing = composeEasingObject(
      currentState, config.easing || DEFAULT_EASING);

    this._filterArgs =
      [currentState, this._originalState, targetState, this._easing];

    applyFilter(this, 'tweenCreated');
    return this;
  };

  /**
   * @method get
   * @return {Object} The current state.
   */
  Tweenable.prototype.get = function () {
    return shallowCopy({}, this._currentState);
  };

  /**
   * @method set
   * @param {Object} state The current state.
   */
  Tweenable.prototype.set = function (state) {
    this._currentState = state;
  };

  /**
   * Pause a tween.  Paused tweens can be resumed from the point at which they
   * were paused.  This is different from `{{#crossLink
   * "Tweenable/stop:method"}}{{/crossLink}}`, as that method
   * causes a tween to start over when it is resumed.
   * @method pause
   * @chainable
   */
  Tweenable.prototype.pause = function () {
    this._pausedAtTime = now();
    this._isPaused = true;
    return this;
  };

  /**
   * Resume a paused tween.
   * @method resume
   * @chainable
   */
  Tweenable.prototype.resume = function () {
    if (this._isPaused) {
      this._timestamp += now() - this._pausedAtTime;
    }

    this._isPaused = false;
    this._isTweening = true;

    this._timeoutHandler();

    return this;
  };

  /**
   * Move the state of the animation to a specific point in the tween's
   * timeline.  If the animation is not running, this will cause the `step`
   * handlers to be called.
   * @method seek
   * @param {millisecond} millisecond The millisecond of the animation to seek
   * to.  This must not be less than `0`.
   * @chainable
   */
  Tweenable.prototype.seek = function (millisecond) {
    millisecond = Math.max(millisecond, 0);
    var currentTime = now();

    if ((this._timestamp + millisecond) === 0) {
      return this;
    }

    this._timestamp = currentTime - millisecond;

    if (!this.isPlaying()) {
      this._isTweening = true;
      this._isPaused = false;

      // If the animation is not running, call timeoutHandler to make sure that
      // any step handlers are run.
      timeoutHandler(this,
        this._timestamp,
        this._delay,
        this._duration,
        this._currentState,
        this._originalState,
        this._targetState,
        this._easing,
        this._step,
        this._scheduleFunction,
        currentTime
      );

      this.pause();
    }

    return this;
  };

  /**
   * Stops and cancels a tween.
   * @param {boolean=} gotoEnd If `false` or omitted, the tween just stops at
   * its current state, and the `finish` handler is not invoked.  If `true`,
   * the tweened object's values are instantly set to the target values, and
   * `finish` is invoked.
   * @method stop
   * @chainable
   */
  Tweenable.prototype.stop = function (gotoEnd) {
    this._isTweening = false;
    this._isPaused = false;
    this._timeoutHandler = noop;

    (root.cancelAnimationFrame            ||
    root.webkitCancelAnimationFrame     ||
    root.oCancelAnimationFrame          ||
    root.msCancelAnimationFrame         ||
    root.mozCancelRequestAnimationFrame ||
    root.clearTimeout)(this._scheduleId);

    if (gotoEnd) {
      applyFilter(this, 'beforeTween');
      tweenProps(
        1,
        this._currentState,
        this._originalState,
        this._targetState,
        1,
        0,
        this._easing
      );
      applyFilter(this, 'afterTween');
      applyFilter(this, 'afterTweenEnd');
      this._finish.call(this, this._currentState, this._attachment);
    }

    return this;
  };

  /**
   * @method isPlaying
   * @return {boolean} Whether or not a tween is running.
   */
  Tweenable.prototype.isPlaying = function () {
    return this._isTweening && !this._isPaused;
  };

  /**
   * Set a custom schedule function.
   *
   * If a custom function is not set,
   * [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame)
   * is used if available, otherwise
   * [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout)
   * is used.
   * @method setScheduleFunction
   * @param {Function(Function,number)} scheduleFunction The function to be
   * used to schedule the next frame to be rendered.
   */
  Tweenable.prototype.setScheduleFunction = function (scheduleFunction) {
    this._scheduleFunction = scheduleFunction;
  };

  /**
   * `delete` all "own" properties.  Call this when the `Tweenable` instance
   * is no longer needed to free memory.
   * @method dispose
   */
  Tweenable.prototype.dispose = function () {
    var prop;
    for (prop in this) {
      if (this.hasOwnProperty(prop)) {
        delete this[prop];
      }
    }
  };

  /**
   * Filters are used for transforming the properties of a tween at various
   * points in a Tweenable's life cycle.  See the README for more info on this.
   * @private
   */
  Tweenable.prototype.filter = {};

  /**
   * This object contains all of the tweens available to Shifty.  It is
   * extensible - simply attach properties to the `Tweenable.prototype.formula`
   * Object following the same format as `linear`.
   *
   * `pos` should be a normalized `number` (between 0 and 1).
   * @property formula
   * @type {Object(function)}
   */
  Tweenable.prototype.formula = {
    linear: function (pos) {
      return pos;
    }
  };

  formula = Tweenable.prototype.formula;

  shallowCopy(Tweenable, {
    'now': now
    ,'each': each
    ,'tweenProps': tweenProps
    ,'tweenProp': tweenProp
    ,'applyFilter': applyFilter
    ,'shallowCopy': shallowCopy
    ,'defaults': defaults
    ,'composeEasingObject': composeEasingObject
  });

  // `root` is provided in the intro/outro files.

  // A hook used for unit testing.
  if (typeof SHIFTY_DEBUG_NOW === 'function') {
    root.timeoutHandler = timeoutHandler;
  }

  // Bootstrap Tweenable appropriately for the environment.
  if (typeof exports === 'object') {
    // CommonJS
    module.exports = Tweenable;
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(function () {return Tweenable;});
  } else if (typeof root.Tweenable === 'undefined') {
    // Browser: Make `Tweenable` globally accessible.
    root.Tweenable = Tweenable;
  }

  return Tweenable;

} ());

/*!
 * All equations are adapted from Thomas Fuchs'
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
 *
 * Based on Easing Equations (c) 2003 [Robert
 * Penner](http://www.robertpenner.com/), all rights reserved. This work is
 * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
 */

/*!
 *  TERMS OF USE - EASING EQUATIONS
 *  Open source under the BSD License.
 *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
 */

;(function () {

  Tweenable.shallowCopy(Tweenable.prototype.formula, {
    easeInQuad: function (pos) {
      return Math.pow(pos, 2);
    },

    easeOutQuad: function (pos) {
      return -(Math.pow((pos - 1), 2) - 1);
    },

    easeInOutQuad: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,2);}
      return -0.5 * ((pos -= 2) * pos - 2);
    },

    easeInCubic: function (pos) {
      return Math.pow(pos, 3);
    },

    easeOutCubic: function (pos) {
      return (Math.pow((pos - 1), 3) + 1);
    },

    easeInOutCubic: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,3);}
      return 0.5 * (Math.pow((pos - 2),3) + 2);
    },

    easeInQuart: function (pos) {
      return Math.pow(pos, 4);
    },

    easeOutQuart: function (pos) {
      return -(Math.pow((pos - 1), 4) - 1);
    },

    easeInOutQuart: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
      return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
    },

    easeInQuint: function (pos) {
      return Math.pow(pos, 5);
    },

    easeOutQuint: function (pos) {
      return (Math.pow((pos - 1), 5) + 1);
    },

    easeInOutQuint: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,5);}
      return 0.5 * (Math.pow((pos - 2),5) + 2);
    },

    easeInSine: function (pos) {
      return -Math.cos(pos * (Math.PI / 2)) + 1;
    },

    easeOutSine: function (pos) {
      return Math.sin(pos * (Math.PI / 2));
    },

    easeInOutSine: function (pos) {
      return (-0.5 * (Math.cos(Math.PI * pos) - 1));
    },

    easeInExpo: function (pos) {
      return (pos === 0) ? 0 : Math.pow(2, 10 * (pos - 1));
    },

    easeOutExpo: function (pos) {
      return (pos === 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
    },

    easeInOutExpo: function (pos) {
      if (pos === 0) {return 0;}
      if (pos === 1) {return 1;}
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(2,10 * (pos - 1));}
      return 0.5 * (-Math.pow(2, -10 * --pos) + 2);
    },

    easeInCirc: function (pos) {
      return -(Math.sqrt(1 - (pos * pos)) - 1);
    },

    easeOutCirc: function (pos) {
      return Math.sqrt(1 - Math.pow((pos - 1), 2));
    },

    easeInOutCirc: function (pos) {
      if ((pos /= 0.5) < 1) {return -0.5 * (Math.sqrt(1 - pos * pos) - 1);}
      return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
    },

    easeOutBounce: function (pos) {
      if ((pos) < (1 / 2.75)) {
        return (7.5625 * pos * pos);
      } else if (pos < (2 / 2.75)) {
        return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
      } else if (pos < (2.5 / 2.75)) {
        return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
      } else {
        return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
      }
    },

    easeInBack: function (pos) {
      var s = 1.70158;
      return (pos) * pos * ((s + 1) * pos - s);
    },

    easeOutBack: function (pos) {
      var s = 1.70158;
      return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
    },

    easeInOutBack: function (pos) {
      var s = 1.70158;
      if ((pos /= 0.5) < 1) {
        return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));
      }
      return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },

    elastic: function (pos) {
      // jshint maxlen:90
      return -1 * Math.pow(4,-8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
    },

    swingFromTo: function (pos) {
      var s = 1.70158;
      return ((pos /= 0.5) < 1) ?
          0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) :
          0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },

    swingFrom: function (pos) {
      var s = 1.70158;
      return pos * pos * ((s + 1) * pos - s);
    },

    swingTo: function (pos) {
      var s = 1.70158;
      return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
    },

    bounce: function (pos) {
      if (pos < (1 / 2.75)) {
        return (7.5625 * pos * pos);
      } else if (pos < (2 / 2.75)) {
        return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
      } else if (pos < (2.5 / 2.75)) {
        return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
      } else {
        return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
      }
    },

    bouncePast: function (pos) {
      if (pos < (1 / 2.75)) {
        return (7.5625 * pos * pos);
      } else if (pos < (2 / 2.75)) {
        return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
      } else if (pos < (2.5 / 2.75)) {
        return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
      } else {
        return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
      }
    },

    easeFromTo: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
      return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
    },

    easeFrom: function (pos) {
      return Math.pow(pos,4);
    },

    easeTo: function (pos) {
      return Math.pow(pos,0.25);
    }
  });

}());

// jshint maxlen:100
/**
 * The Bezier magic in this file is adapted/copied almost wholesale from
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/cubic-bezier.js),
 * which was adapted from Apple code (which probably came from
 * [here](http://opensource.apple.com/source/WebCore/WebCore-955.66/platform/graphics/UnitBezier.h)).
 * Special thanks to Apple and Thomas Fuchs for much of this code.
 */

/**
 *  Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *  this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation
 *  and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder(s) nor the names of any
 *  contributors may be used to endorse or promote products derived from
 *  this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
;(function () {
  // port of webkit cubic bezier handling by http://www.netzgesta.de/dev/
  function cubicBezierAtTime(t,p1x,p1y,p2x,p2y,duration) {
    var ax = 0,bx = 0,cx = 0,ay = 0,by = 0,cy = 0;
    function sampleCurveX(t) {
      return ((ax * t + bx) * t + cx) * t;
    }
    function sampleCurveY(t) {
      return ((ay * t + by) * t + cy) * t;
    }
    function sampleCurveDerivativeX(t) {
      return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }
    function solveEpsilon(duration) {
      return 1.0 / (200.0 * duration);
    }
    function solve(x,epsilon) {
      return sampleCurveY(solveCurveX(x, epsilon));
    }
    function fabs(n) {
      if (n >= 0) {
        return n;
      } else {
        return 0 - n;
      }
    }
    function solveCurveX(x, epsilon) {
      var t0,t1,t2,x2,d2,i;
      for (t2 = x, i = 0; i < 8; i++) {
        x2 = sampleCurveX(t2) - x;
        if (fabs(x2) < epsilon) {
          return t2;
        }
        d2 = sampleCurveDerivativeX(t2);
        if (fabs(d2) < 1e-6) {
          break;
        }
        t2 = t2 - x2 / d2;
      }
      t0 = 0.0;
      t1 = 1.0;
      t2 = x;
      if (t2 < t0) {
        return t0;
      }
      if (t2 > t1) {
        return t1;
      }
      while (t0 < t1) {
        x2 = sampleCurveX(t2);
        if (fabs(x2 - x) < epsilon) {
          return t2;
        }
        if (x > x2) {
          t0 = t2;
        }else {
          t1 = t2;
        }
        t2 = (t1 - t0) * 0.5 + t0;
      }
      return t2; // Failure.
    }
    cx = 3.0 * p1x;
    bx = 3.0 * (p2x - p1x) - cx;
    ax = 1.0 - cx - bx;
    cy = 3.0 * p1y;
    by = 3.0 * (p2y - p1y) - cy;
    ay = 1.0 - cy - by;
    return solve(t, solveEpsilon(duration));
  }
  /**
   *  getCubicBezierTransition(x1, y1, x2, y2) -> Function
   *
   *  Generates a transition easing function that is compatible
   *  with WebKit's CSS transitions `-webkit-transition-timing-function`
   *  CSS property.
   *
   *  The W3C has more information about CSS3 transition timing functions:
   *  http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
   *
   *  @param {number} x1
   *  @param {number} y1
   *  @param {number} x2
   *  @param {number} y2
   *  @return {function}
   *  @private
   */
  function getCubicBezierTransition (x1, y1, x2, y2) {
    return function (pos) {
      return cubicBezierAtTime(pos,x1,y1,x2,y2,1);
    };
  }
  // End ported code

  /**
   * Create a Bezier easing function and attach it to `{{#crossLink
   * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  This
   * function gives you total control over the easing curve.  Matthew Lein's
   * [Ceaser](http://matthewlein.com/ceaser/) is a useful tool for visualizing
   * the curves you can make with this function.
   * @method setBezierFunction
   * @param {string} name The name of the easing curve.  Overwrites the old
   * easing function on `{{#crossLink
   * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}` if it
   * exists.
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @return {function} The easing function that was attached to
   * Tweenable.prototype.formula.
   */
  Tweenable.setBezierFunction = function (name, x1, y1, x2, y2) {
    var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
    cubicBezierTransition.displayName = name;
    cubicBezierTransition.x1 = x1;
    cubicBezierTransition.y1 = y1;
    cubicBezierTransition.x2 = x2;
    cubicBezierTransition.y2 = y2;

    return Tweenable.prototype.formula[name] = cubicBezierTransition;
  };


  /**
   * `delete` an easing function from `{{#crossLink
   * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  Be
   * careful with this method, as it `delete`s whatever easing formula matches
   * `name` (which means you can delete standard Shifty easing functions).
   * @method unsetBezierFunction
   * @param {string} name The name of the easing function to delete.
   * @return {function}
   */
  Tweenable.unsetBezierFunction = function (name) {
    delete Tweenable.prototype.formula[name];
  };

})();

;(function () {

  function getInterpolatedValues (
    from, current, targetState, position, easing, delay) {
    return Tweenable.tweenProps(
      position, current, from, targetState, 1, delay, easing);
  }

  // Fake a Tweenable and patch some internals.  This approach allows us to
  // skip uneccessary processing and object recreation, cutting down on garbage
  // collection pauses.
  var mockTweenable = new Tweenable();
  mockTweenable._filterArgs = [];

  /**
   * Compute the midpoint of two Objects.  This method effectively calculates a
   * specific frame of animation that `{{#crossLink
   * "Tweenable/tween:method"}}{{/crossLink}}` does many times over the course
   * of a full tween.
   *
   *     var interpolatedValues = Tweenable.interpolate({
   *       width: '100px',
   *       opacity: 0,
   *       color: '#fff'
   *     }, {
   *       width: '200px',
   *       opacity: 1,
   *       color: '#000'
   *     }, 0.5);
   *
   *     console.log(interpolatedValues);
   *     // {opacity: 0.5, width: "150px", color: "rgb(127,127,127)"}
   *
   * @static
   * @method interpolate
   * @param {Object} from The starting values to tween from.
   * @param {Object} targetState The ending values to tween to.
   * @param {number} position The normalized position value (between `0.0` and
   * `1.0`) to interpolate the values between `from` and `to` for.  `from`
   * represents `0` and `to` represents `1`.
   * @param {Object.<string|Function>|string|Function} easing The easing
   * curve(s) to calculate the midpoint against.  You can reference any easing
   * function attached to `Tweenable.prototype.formula`, or provide the easing
   * function(s) directly.  If omitted, this defaults to "linear".
   * @param {number=} opt_delay Optional delay to pad the beginning of the
   * interpolated tween with.  This increases the range of `position` from (`0`
   * through `1`) to (`0` through `1 + opt_delay`).  So, a delay of `0.5` would
   * increase all valid values of `position` to numbers between `0` and `1.5`.
   * @return {Object}
   */
  Tweenable.interpolate = function (
    from, targetState, position, easing, opt_delay) {

    var current = Tweenable.shallowCopy({}, from);
    var delay = opt_delay || 0;
    var easingObject = Tweenable.composeEasingObject(
      from, easing || 'linear');

    mockTweenable.set({});

    // Alias and reuse the _filterArgs array instead of recreating it.
    var filterArgs = mockTweenable._filterArgs;
    filterArgs.length = 0;
    filterArgs[0] = current;
    filterArgs[1] = from;
    filterArgs[2] = targetState;
    filterArgs[3] = easingObject;

    // Any defined value transformation must be applied
    Tweenable.applyFilter(mockTweenable, 'tweenCreated');
    Tweenable.applyFilter(mockTweenable, 'beforeTween');

    var interpolatedValues = getInterpolatedValues(
      from, current, targetState, position, easingObject, delay);

    // Transform values back into their original format
    Tweenable.applyFilter(mockTweenable, 'afterTween');

    return interpolatedValues;
  };

}());

/**
 * This module adds string interpolation support to Shifty.
 *
 * The Token extension allows Shifty to tween numbers inside of strings.  Among
 * other things, this allows you to animate CSS properties.  For example, you
 * can do this:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(45px)' },
 *       to: { transform: 'translateX(90xp)' }
 *     });
 *
 * `translateX(45)` will be tweened to `translateX(90)`.  To demonstrate:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(45px)' },
 *       to: { transform: 'translateX(90px)' },
 *       step: function (state) {
 *         console.log(state.transform);
 *       }
 *     });
 *
 * The above snippet will log something like this in the console:
 *
 *     translateX(60.3px)
 *     ...
 *     translateX(76.05px)
 *     ...
 *     translateX(90px)
 *
 * Another use for this is animating colors:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { color: 'rgb(0,255,0)' },
 *       to: { color: 'rgb(255,0,255)' },
 *       step: function (state) {
 *         console.log(state.color);
 *       }
 *     });
 *
 * The above snippet will log something like this:
 *
 *     rgb(84,170,84)
 *     ...
 *     rgb(170,84,170)
 *     ...
 *     rgb(255,0,255)
 *
 * This extension also supports hexadecimal colors, in both long (`#ff00ff`)
 * and short (`#f0f`) forms.  Be aware that hexadecimal input values will be
 * converted into the equivalent RGB output values.  This is done to optimize
 * for performance.
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { color: '#0f0' },
 *       to: { color: '#f0f' },
 *       step: function (state) {
 *         console.log(state.color);
 *       }
 *     });
 *
 * This snippet will generate the same output as the one before it because
 * equivalent values were supplied (just in hexadecimal form rather than RGB):
 *
 *     rgb(84,170,84)
 *     ...
 *     rgb(170,84,170)
 *     ...
 *     rgb(255,0,255)
 *
 * ## Easing support
 *
 * Easing works somewhat differently in the Token extension.  This is because
 * some CSS properties have multiple values in them, and you might need to
 * tween each value along its own easing curve.  A basic example:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(0px) translateY(0px)' },
 *       to: { transform:   'translateX(100px) translateY(100px)' },
 *       easing: { transform: 'easeInQuad' },
 *       step: function (state) {
 *         console.log(state.transform);
 *       }
 *     });
 *
 * The above snippet will create values like this:
 *
 *     translateX(11.56px) translateY(11.56px)
 *     ...
 *     translateX(46.24px) translateY(46.24px)
 *     ...
 *     translateX(100px) translateY(100px)
 *
 * In this case, the values for `translateX` and `translateY` are always the
 * same for each step of the tween, because they have the same start and end
 * points and both use the same easing curve.  We can also tween `translateX`
 * and `translateY` along independent curves:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(0px) translateY(0px)' },
 *       to: { transform:   'translateX(100px) translateY(100px)' },
 *       easing: { transform: 'easeInQuad bounce' },
 *       step: function (state) {
 *         console.log(state.transform);
 *       }
 *     });
 *
 * The above snippet will create values like this:
 *
 *     translateX(10.89px) translateY(82.35px)
 *     ...
 *     translateX(44.89px) translateY(86.73px)
 *     ...
 *     translateX(100px) translateY(100px)
 *
 * `translateX` and `translateY` are not in sync anymore, because `easeInQuad`
 * was specified for `translateX` and `bounce` for `translateY`.  Mixing and
 * matching easing curves can make for some interesting motion in your
 * animations.
 *
 * The order of the space-separated easing curves correspond the token values
 * they apply to.  If there are more token values than easing curves listed,
 * the last easing curve listed is used.
 * @submodule Tweenable.token
 */

// token function is defined above only so that dox-foundation sees it as
// documentation and renders it.  It is never used, and is optimized away at
// build time.

;(function (Tweenable) {

  /**
   * @typedef {{
   *   formatString: string
   *   chunkNames: Array.<string>
   * }}
   * @private
   */
  var formatManifest;

  // CONSTANTS

  var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
  var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
  var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
  var R_RGB = new RegExp(
    'rgb\\(' + R_UNFORMATTED_VALUES.source +
    (/,\s*/.source) + R_UNFORMATTED_VALUES.source +
    (/,\s*/.source) + R_UNFORMATTED_VALUES.source + '\\)', 'g');
  var R_RGB_PREFIX = /^.*\(/;
  var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
  var VALUE_PLACEHOLDER = 'VAL';

  // HELPERS

  /**
   * @param {Array.number} rawValues
   * @param {string} prefix
   *
   * @return {Array.<string>}
   * @private
   */
  function getFormatChunksFrom (rawValues, prefix) {
    var accumulator = [];

    var rawValuesLength = rawValues.length;
    var i;

    for (i = 0; i < rawValuesLength; i++) {
      accumulator.push('_' + prefix + '_' + i);
    }

    return accumulator;
  }

  /**
   * @param {string} formattedString
   *
   * @return {string}
   * @private
   */
  function getFormatStringFrom (formattedString) {
    var chunks = formattedString.match(R_FORMAT_CHUNKS);

    if (!chunks) {
      // chunks will be null if there were no tokens to parse in
      // formattedString (for example, if formattedString is '2').  Coerce
      // chunks to be useful here.
      chunks = ['', ''];

      // If there is only one chunk, assume that the string is a number
      // followed by a token...
      // NOTE: This may be an unwise assumption.
    } else if (chunks.length === 1 ||
      // ...or if the string starts with a number component (".", "-", or a
      // digit)...
    formattedString[0].match(R_NUMBER_COMPONENT)) {
      // ...prepend an empty string here to make sure that the formatted number
      // is properly replaced by VALUE_PLACEHOLDER
      chunks.unshift('');
    }

    return chunks.join(VALUE_PLACEHOLDER);
  }

  /**
   * Convert all hex color values within a string to an rgb string.
   *
   * @param {Object} stateObject
   *
   * @return {Object} The modified obj
   * @private
   */
  function sanitizeObjectForHexProps (stateObject) {
    Tweenable.each(stateObject, function (prop) {
      var currentProp = stateObject[prop];

      if (typeof currentProp === 'string' && currentProp.match(R_HEX)) {
        stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
      }
    });
  }

  /**
   * @param {string} str
   *
   * @return {string}
   * @private
   */
  function  sanitizeHexChunksToRGB (str) {
    return filterStringChunks(R_HEX, str, convertHexToRGB);
  }

  /**
   * @param {string} hexString
   *
   * @return {string}
   * @private
   */
  function convertHexToRGB (hexString) {
    var rgbArr = hexToRGBArray(hexString);
    return 'rgb(' + rgbArr[0] + ',' + rgbArr[1] + ',' + rgbArr[2] + ')';
  }

  var hexToRGBArray_returnArray = [];
  /**
   * Convert a hexadecimal string to an array with three items, one each for
   * the red, blue, and green decimal values.
   *
   * @param {string} hex A hexadecimal string.
   *
   * @returns {Array.<number>} The converted Array of RGB values if `hex` is a
   * valid string, or an Array of three 0's.
   * @private
   */
  function hexToRGBArray (hex) {

    hex = hex.replace(/#/, '');

    // If the string is a shorthand three digit hex notation, normalize it to
    // the standard six digit notation
    if (hex.length === 3) {
      hex = hex.split('');
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
    hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
    hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));

    return hexToRGBArray_returnArray;
  }

  /**
   * Convert a base-16 number to base-10.
   *
   * @param {Number|String} hex The value to convert
   *
   * @returns {Number} The base-10 equivalent of `hex`.
   * @private
   */
  function hexToDec (hex) {
    return parseInt(hex, 16);
  }

  /**
   * Runs a filter operation on all chunks of a string that match a RegExp
   *
   * @param {RegExp} pattern
   * @param {string} unfilteredString
   * @param {function(string)} filter
   *
   * @return {string}
   * @private
   */
  function filterStringChunks (pattern, unfilteredString, filter) {
    var pattenMatches = unfilteredString.match(pattern);
    var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);

    if (pattenMatches) {
      var pattenMatchesLength = pattenMatches.length;
      var currentChunk;

      for (var i = 0; i < pattenMatchesLength; i++) {
        currentChunk = pattenMatches.shift();
        filteredString = filteredString.replace(
          VALUE_PLACEHOLDER, filter(currentChunk));
      }
    }

    return filteredString;
  }

  /**
   * Check for floating point values within rgb strings and rounds them.
   *
   * @param {string} formattedString
   *
   * @return {string}
   * @private
   */
  function sanitizeRGBChunks (formattedString) {
    return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
  }

  /**
   * @param {string} rgbChunk
   *
   * @return {string}
   * @private
   */
  function sanitizeRGBChunk (rgbChunk) {
    var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
    var numbersLength = numbers.length;
    var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];

    for (var i = 0; i < numbersLength; i++) {
      sanitizedString += parseInt(numbers[i], 10) + ',';
    }

    sanitizedString = sanitizedString.slice(0, -1) + ')';

    return sanitizedString;
  }

  /**
   * @param {Object} stateObject
   *
   * @return {Object} An Object of formatManifests that correspond to
   * the string properties of stateObject
   * @private
   */
  function getFormatManifests (stateObject) {
    var manifestAccumulator = {};

    Tweenable.each(stateObject, function (prop) {
      var currentProp = stateObject[prop];

      if (typeof currentProp === 'string') {
        var rawValues = getValuesFrom(currentProp);

        manifestAccumulator[prop] = {
          'formatString': getFormatStringFrom(currentProp)
          ,'chunkNames': getFormatChunksFrom(rawValues, prop)
        };
      }
    });

    return manifestAccumulator;
  }

  /**
   * @param {Object} stateObject
   * @param {Object} formatManifests
   * @private
   */
  function expandFormattedProperties (stateObject, formatManifests) {
    Tweenable.each(formatManifests, function (prop) {
      var currentProp = stateObject[prop];
      var rawValues = getValuesFrom(currentProp);
      var rawValuesLength = rawValues.length;

      for (var i = 0; i < rawValuesLength; i++) {
        stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
      }

      delete stateObject[prop];
    });
  }

  /**
   * @param {Object} stateObject
   * @param {Object} formatManifests
   * @private
   */
  function collapseFormattedProperties (stateObject, formatManifests) {
    Tweenable.each(formatManifests, function (prop) {
      var currentProp = stateObject[prop];
      var formatChunks = extractPropertyChunks(
        stateObject, formatManifests[prop].chunkNames);
      var valuesList = getValuesList(
        formatChunks, formatManifests[prop].chunkNames);
      currentProp = getFormattedValues(
        formatManifests[prop].formatString, valuesList);
      stateObject[prop] = sanitizeRGBChunks(currentProp);
    });
  }

  /**
   * @param {Object} stateObject
   * @param {Array.<string>} chunkNames
   *
   * @return {Object} The extracted value chunks.
   * @private
   */
  function extractPropertyChunks (stateObject, chunkNames) {
    var extractedValues = {};
    var currentChunkName, chunkNamesLength = chunkNames.length;

    for (var i = 0; i < chunkNamesLength; i++) {
      currentChunkName = chunkNames[i];
      extractedValues[currentChunkName] = stateObject[currentChunkName];
      delete stateObject[currentChunkName];
    }

    return extractedValues;
  }

  var getValuesList_accumulator = [];
  /**
   * @param {Object} stateObject
   * @param {Array.<string>} chunkNames
   *
   * @return {Array.<number>}
   * @private
   */
  function getValuesList (stateObject, chunkNames) {
    getValuesList_accumulator.length = 0;
    var chunkNamesLength = chunkNames.length;

    for (var i = 0; i < chunkNamesLength; i++) {
      getValuesList_accumulator.push(stateObject[chunkNames[i]]);
    }

    return getValuesList_accumulator;
  }

  /**
   * @param {string} formatString
   * @param {Array.<number>} rawValues
   *
   * @return {string}
   * @private
   */
  function getFormattedValues (formatString, rawValues) {
    var formattedValueString = formatString;
    var rawValuesLength = rawValues.length;

    for (var i = 0; i < rawValuesLength; i++) {
      formattedValueString = formattedValueString.replace(
        VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
    }

    return formattedValueString;
  }

  /**
   * Note: It's the duty of the caller to convert the Array elements of the
   * return value into numbers.  This is a performance optimization.
   *
   * @param {string} formattedString
   *
   * @return {Array.<string>|null}
   * @private
   */
  function getValuesFrom (formattedString) {
    return formattedString.match(R_UNFORMATTED_VALUES);
  }

  /**
   * @param {Object} easingObject
   * @param {Object} tokenData
   * @private
   */
  function expandEasingObject (easingObject, tokenData) {
    Tweenable.each(tokenData, function (prop) {
      var currentProp = tokenData[prop];
      var chunkNames = currentProp.chunkNames;
      var chunkLength = chunkNames.length;

      var easing = easingObject[prop];
      var i;

      if (typeof easing === 'string') {
        var easingChunks = easing.split(' ');
        var lastEasingChunk = easingChunks[easingChunks.length - 1];

        for (i = 0; i < chunkLength; i++) {
          easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
        }

      } else {
        for (i = 0; i < chunkLength; i++) {
          easingObject[chunkNames[i]] = easing;
        }
      }

      delete easingObject[prop];
    });
  }

  /**
   * @param {Object} easingObject
   * @param {Object} tokenData
   * @private
   */
  function collapseEasingObject (easingObject, tokenData) {
    Tweenable.each(tokenData, function (prop) {
      var currentProp = tokenData[prop];
      var chunkNames = currentProp.chunkNames;
      var chunkLength = chunkNames.length;

      var firstEasing = easingObject[chunkNames[0]];
      var typeofEasings = typeof firstEasing;

      if (typeofEasings === 'string') {
        var composedEasingString = '';

        for (var i = 0; i < chunkLength; i++) {
          composedEasingString += ' ' + easingObject[chunkNames[i]];
          delete easingObject[chunkNames[i]];
        }

        easingObject[prop] = composedEasingString.substr(1);
      } else {
        easingObject[prop] = firstEasing;
      }
    });
  }

  Tweenable.prototype.filter.token = {
    'tweenCreated': function (currentState, fromState, toState, easingObject) {
      sanitizeObjectForHexProps(currentState);
      sanitizeObjectForHexProps(fromState);
      sanitizeObjectForHexProps(toState);
      this._tokenData = getFormatManifests(currentState);
    },

    'beforeTween': function (currentState, fromState, toState, easingObject) {
      expandEasingObject(easingObject, this._tokenData);
      expandFormattedProperties(currentState, this._tokenData);
      expandFormattedProperties(fromState, this._tokenData);
      expandFormattedProperties(toState, this._tokenData);
    },

    'afterTween': function (currentState, fromState, toState, easingObject) {
      collapseFormattedProperties(currentState, this._tokenData);
      collapseFormattedProperties(fromState, this._tokenData);
      collapseFormattedProperties(toState, this._tokenData);
      collapseEasingObject(easingObject, this._tokenData);
    }
  };

} (Tweenable));

}).call(null);

},{}],2:[function(require,module,exports){
// Circle shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Circle = function Circle(container, options) {
    // Use two arcs to form a circle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m 0,-{radius}' +
        ' a {radius},{radius} 0 1 1 0,{2radius}' +
        ' a {radius},{radius} 0 1 1 0,-{2radius}';

    this.containerAspectRatio = 1;

    Shape.apply(this, arguments);
};

Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

Circle.prototype._pathString = function _pathString(opts) {
    var widthOfWider = opts.strokeWidth;
    if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
        widthOfWider = opts.trailWidth;
    }

    var r = 50 - widthOfWider / 2;

    return utils.render(this._pathTemplate, {
        radius: r,
        '2radius': r * 2
    });
};

Circle.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Circle;

},{"./shape":7,"./utils":8}],3:[function(require,module,exports){
// Line shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Line = function Line(container, options) {
    this._pathTemplate = 'M 0,{center} L 100,{center}';
    Shape.apply(this, arguments);
};

Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 ' + opts.strokeWidth);
    svg.setAttribute('preserveAspectRatio', 'none');
};

Line.prototype._pathString = function _pathString(opts) {
    return utils.render(this._pathTemplate, {
        center: opts.strokeWidth / 2
    });
};

Line.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Line;

},{"./shape":7,"./utils":8}],4:[function(require,module,exports){
module.exports = {
    // Higher level API, different shaped progress bars
    Line: require('./line'),
    Circle: require('./circle'),
    SemiCircle: require('./semicircle'),

    // Lower level API to use any SVG path
    Path: require('./path'),

    // Base-class for creating new custom shapes
    // to be in line with the API of built-in shapes
    // Undocumented.
    Shape: require('./shape'),

    // Internal utils, undocumented.
    utils: require('./utils')
};

},{"./circle":2,"./line":3,"./path":5,"./semicircle":6,"./shape":7,"./utils":8}],5:[function(require,module,exports){
// Lower level API to animate any kind of svg path

var Tweenable = require('shifty');
var utils = require('./utils');

var EASING_ALIASES = {
    easeIn: 'easeInCubic',
    easeOut: 'easeOutCubic',
    easeInOut: 'easeInOutCubic'
};

var Path = function Path(path, opts) {
    // Throw a better error if not initialized with `new` keyword
    if (!(this instanceof Path)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Default parameters for animation
    opts = utils.extend({
        duration: 800,
        easing: 'linear',
        from: {},
        to: {},
        step: function() {}
    }, opts);

    var element;
    if (utils.isString(path)) {
        element = document.querySelector(path);
    } else {
        element = path;
    }

    // Reveal .path as public attribute
    this.path = element;
    this._opts = opts;
    this._tweenable = null;

    // Set up the starting positions
    var length = this.path.getTotalLength();
    this.path.style.strokeDasharray = length + ' ' + length;
    this.set(0);
};

Path.prototype.value = function value() {
    var offset = this._getComputedDashOffset();
    var length = this.path.getTotalLength();

    var progress = 1 - offset / length;
    // Round number to prevent returning very small number like 1e-30, which
    // is practically 0
    return parseFloat(progress.toFixed(6), 10);
};

Path.prototype.set = function set(progress) {
    this.stop();

    this.path.style.strokeDashoffset = this._progressToOffset(progress);

    var step = this._opts.step;
    if (utils.isFunction(step)) {
        var easing = this._easing(this._opts.easing);
        var values = this._calculateTo(progress, easing);
        var reference = this._opts.shape || this;
        step(values, reference, this._opts.attachment);
    }
};

Path.prototype.stop = function stop() {
    this._stopTween();
    this.path.style.strokeDashoffset = this._getComputedDashOffset();
};

// Method introduced here:
// http://jakearchibald.com/2013/animated-line-drawing-svg/
Path.prototype.animate = function animate(progress, opts, cb) {
    opts = opts || {};

    if (utils.isFunction(opts)) {
        cb = opts;
        opts = {};
    }

    var passedOpts = utils.extend({}, opts);

    // Copy default opts to new object so defaults are not modified
    var defaultOpts = utils.extend({}, this._opts);
    opts = utils.extend(defaultOpts, opts);

    var shiftyEasing = this._easing(opts.easing);
    var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);

    this.stop();

    // Trigger a layout so styles are calculated & the browser
    // picks up the starting position before animating
    this.path.getBoundingClientRect();

    var offset = this._getComputedDashOffset();
    var newOffset = this._progressToOffset(progress);

    var self = this;
    this._tweenable = new Tweenable();
    this._tweenable.tween({
        from: utils.extend({ offset: offset }, values.from),
        to: utils.extend({ offset: newOffset }, values.to),
        duration: opts.duration,
        easing: shiftyEasing,
        step: function(state) {
            self.path.style.strokeDashoffset = state.offset;
            var reference = opts.shape || self;
            opts.step(state, reference, opts.attachment);
        },
        finish: function(state) {
            if (utils.isFunction(cb)) {
                cb();
            }
        }
    });
};

Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
    var computedStyle = window.getComputedStyle(this.path, null);
    return parseFloat(computedStyle.getPropertyValue('stroke-dashoffset'), 10);
};

Path.prototype._progressToOffset = function _progressToOffset(progress) {
    var length = this.path.getTotalLength();
    return length - progress * length;
};

// Resolves from and to values for animation.
Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
    if (opts.from && opts.to) {
        return {
            from: opts.from,
            to: opts.to
        };
    }

    return {
        from: this._calculateFrom(easing),
        to: this._calculateTo(progress, easing)
    };
};

// Calculate `from` values from options passed at initialization
Path.prototype._calculateFrom = function _calculateFrom(easing) {
    return Tweenable.interpolate(this._opts.from, this._opts.to, this.value(), easing);
};

// Calculate `to` values from options passed at initialization
Path.prototype._calculateTo = function _calculateTo(progress, easing) {
    return Tweenable.interpolate(this._opts.from, this._opts.to, progress, easing);
};

Path.prototype._stopTween = function _stopTween() {
    if (this._tweenable !== null) {
        this._tweenable.stop();
        this._tweenable = null;
    }
};

Path.prototype._easing = function _easing(easing) {
    if (EASING_ALIASES.hasOwnProperty(easing)) {
        return EASING_ALIASES[easing];
    }

    return easing;
};

module.exports = Path;

},{"./utils":8,"shifty":1}],6:[function(require,module,exports){
// Semi-SemiCircle shaped progress bar

var Shape = require('./shape');
var Circle = require('./circle');
var utils = require('./utils');

var SemiCircle = function SemiCircle(container, options) {
    // Use one arc to form a SemiCircle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m -{radius},0' +
        ' a {radius},{radius} 0 1 1 {2radius},0';

    this.containerAspectRatio = 2;

    Shape.apply(this, arguments);
};

SemiCircle.prototype = new Shape();
SemiCircle.prototype.constructor = SemiCircle;

SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 50');
};

SemiCircle.prototype._initializeTextContainer = function _initializeTextContainer(
    opts,
    container,
    textContainer
) {
    if (opts.text.style) {
        // Reset top style
        textContainer.style.top = 'auto';
        textContainer.style.bottom = '0';

        if (opts.text.alignToBottom) {
            utils.setStyle(textContainer, 'transform', 'translate(-50%, 0)');
        } else {
            utils.setStyle(textContainer, 'transform', 'translate(-50%, 50%)');
        }
    }
};

// Share functionality with Circle, just have different path
SemiCircle.prototype._pathString = Circle.prototype._pathString;
SemiCircle.prototype._trailString = Circle.prototype._trailString;

module.exports = SemiCircle;

},{"./circle":2,"./shape":7,"./utils":8}],7:[function(require,module,exports){
// Base object for different progress bar shapes

var Path = require('./path');
var utils = require('./utils');

var DESTROYED_ERROR = 'Object is destroyed';

var Shape = function Shape(container, opts) {
    // Throw a better error if progress bars are not initialized with `new`
    // keyword
    if (!(this instanceof Shape)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Prevent calling constructor without parameters so inheritance
    // works correctly. To understand, this is how Shape is inherited:
    //
    //   Line.prototype = new Shape();
    //
    // We just want to set the prototype for Line.
    if (arguments.length === 0) {
        return;
    }

    // Default parameters for progress bar creation
    this._opts = utils.extend({
        color: '#555',
        strokeWidth: 1.0,
        trailColor: null,
        trailWidth: null,
        fill: null,
        text: {
            style: {
                color: null,
                position: 'absolute',
                left: '50%',
                top: '50%',
                padding: 0,
                margin: 0,
                transform: {
                    prefix: true,
                    value: 'translate(-50%, -50%)'
                }
            },
            autoStyleContainer: true,
            alignToBottom: true,
            value: null,
            className: 'progressbar-text'
        },
        svgStyle: {
            display: 'block',
            width: '100%'
        },
        warnings: false
    }, opts, true);  // Use recursive extend

    // If user specifies e.g. svgStyle or text style, the whole object
    // should replace the defaults to make working with styles easier
    if (utils.isObject(opts) && opts.svgStyle !== undefined) {
        this._opts.svgStyle = opts.svgStyle;
    }
    if (utils.isObject(opts) && utils.isObject(opts.text) && opts.text.style !== undefined) {
        this._opts.text.style = opts.text.style;
    }

    var svgView = this._createSvgView(this._opts);

    var element;
    if (utils.isString(container)) {
        element = document.querySelector(container);
    } else {
        element = container;
    }

    if (!element) {
        throw new Error('Container does not exist: ' + container);
    }

    this._container = element;
    this._container.appendChild(svgView.svg);
    if (this._opts.warnings) {
        this._warnContainerAspectRatio(this._container);
    }

    if (this._opts.svgStyle) {
        utils.setStyles(svgView.svg, this._opts.svgStyle);
    }

    // Expose public attributes before Path initialization
    this.svg = svgView.svg;
    this.path = svgView.path;
    this.trail = svgView.trail;
    this.text = null;

    var newOpts = utils.extend({
        attachment: undefined,
        shape: this
    }, this._opts);
    this._progressPath = new Path(svgView.path, newOpts);

    if (utils.isObject(this._opts.text) && this._opts.text.value !== null) {
        this.setText(this._opts.text.value);
    }
};

Shape.prototype.animate = function animate(progress, opts, cb) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.animate(progress, opts, cb);
};

Shape.prototype.stop = function stop() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    // Don't crash if stop is called inside step function
    if (this._progressPath === undefined) {
        return;
    }

    this._progressPath.stop();
};

Shape.prototype.destroy = function destroy() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this.stop();
    this.svg.parentNode.removeChild(this.svg);
    this.svg = null;
    this.path = null;
    this.trail = null;
    this._progressPath = null;

    if (this.text !== null) {
        this.text.parentNode.removeChild(this.text);
        this.text = null;
    }
};

Shape.prototype.set = function set(progress) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.set(progress);
};

Shape.prototype.value = function value() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return 0;
    }

    return this._progressPath.value();
};

Shape.prototype.setText = function setText(newText) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this.text === null) {
        // Create new text node
        this.text = this._createTextContainer(this._opts, this._container);
        this._container.appendChild(this.text);
    }

    // Remove previous text and add new
    if (utils.isObject(newText)) {
        utils.removeChildren(this.text);
        this.text.appendChild(newText);
    } else {
        this.text.innerHTML = newText;
    }
};

Shape.prototype._createSvgView = function _createSvgView(opts) {
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this._initializeSvg(svg, opts);

    var trailPath = null;
    // Each option listed in the if condition are 'triggers' for creating
    // the trail path
    if (opts.trailColor || opts.trailWidth) {
        trailPath = this._createTrail(opts);
        svg.appendChild(trailPath);
    }

    var path = this._createPath(opts);
    svg.appendChild(path);

    return {
        svg: svg,
        path: path,
        trail: trailPath
    };
};

Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 100');
};

Shape.prototype._createPath = function _createPath(opts) {
    var pathString = this._pathString(opts);
    return this._createPathElement(pathString, opts);
};

Shape.prototype._createTrail = function _createTrail(opts) {
    // Create path string with original passed options
    var pathString = this._trailString(opts);

    // Prevent modifying original
    var newOpts = utils.extend({}, opts);

    // Defaults for parameters which modify trail path
    if (!newOpts.trailColor) {
        newOpts.trailColor = '#eee';
    }
    if (!newOpts.trailWidth) {
        newOpts.trailWidth = newOpts.strokeWidth;
    }

    newOpts.color = newOpts.trailColor;
    newOpts.strokeWidth = newOpts.trailWidth;

    // When trail path is set, fill must be set for it instead of the
    // actual path to prevent trail stroke from clipping
    newOpts.fill = null;

    return this._createPathElement(pathString, newOpts);
};

Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathString);
    path.setAttribute('stroke', opts.color);
    path.setAttribute('stroke-width', opts.strokeWidth);

    if (opts.fill) {
        path.setAttribute('fill', opts.fill);
    } else {
        path.setAttribute('fill-opacity', '0');
    }

    return path;
};

Shape.prototype._createTextContainer = function _createTextContainer(opts, container) {
    var textContainer = document.createElement('div');
    textContainer.className = opts.text.className;

    var textStyle = opts.text.style;
    if (textStyle) {
        if (opts.text.autoStyleContainer) {
            container.style.position = 'relative';
        }

        utils.setStyles(textContainer, textStyle);
        // Default text color to progress bar's color
        if (!textStyle.color) {
            textContainer.style.color = opts.color;
        }
    }

    this._initializeTextContainer(opts, container, textContainer);
    return textContainer;
};

// Give custom shapes possibility to modify text element
Shape.prototype._initializeTextContainer = function(opts, container, element) {
    // By default, no-op
    // Custom shapes should respect API options, such as text.style
};

Shape.prototype._pathString = function _pathString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._trailString = function _trailString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._warnContainerAspectRatio = function _warnContainerAspectRatio(container) {
    if (!this.containerAspectRatio) {
        return;
    }

    var computedStyle = window.getComputedStyle(container, null);
    var width = parseFloat(computedStyle.getPropertyValue('width'), 10);
    var height = parseFloat(computedStyle.getPropertyValue('height'), 10);
    if (!utils.floatEquals(this.containerAspectRatio, width / height)) {
        console.warn(
            'Incorrect aspect ratio of container',
            '#' + container.id,
            'detected:',
            computedStyle.getPropertyValue('width') + '(width)',
            '/',
            computedStyle.getPropertyValue('height') + '(height)',
            '=',
            width / height
        );

        console.warn(
            'Aspect ratio of should be',
            this.containerAspectRatio
        );
    }
};

module.exports = Shape;

},{"./path":5,"./utils":8}],8:[function(require,module,exports){
// Utility functions

var PREFIXES = 'Webkit Moz O ms'.split(' ');
var FLOAT_COMPARISON_EPSILON = 0.001;

// Copy all attributes from source object to destination object.
// destination object is mutated.
function extend(destination, source, recursive) {
    destination = destination || {};
    source = source || {};
    recursive = recursive || false;

    for (var attrName in source) {
        if (source.hasOwnProperty(attrName)) {
            var destVal = destination[attrName];
            var sourceVal = source[attrName];
            if (recursive && isObject(destVal) && isObject(sourceVal)) {
                destination[attrName] = extend(destVal, sourceVal, recursive);
            } else {
                destination[attrName] = sourceVal;
            }
        }
    }

    return destination;
}

// Renders templates with given variables. Variables must be surrounded with
// braces without any spaces, e.g. {variable}
// All instances of variable placeholders will be replaced with given content
// Example:
// render('Hello, {message}!', {message: 'world'})
function render(template, vars) {
    var rendered = template;

    for (var key in vars) {
        if (vars.hasOwnProperty(key)) {
            var val = vars[key];
            var regExpString = '\\{' + key + '\\}';
            var regExp = new RegExp(regExpString, 'g');

            rendered = rendered.replace(regExp, val);
        }
    }

    return rendered;
}

function setStyle(element, style, value) {
    var elStyle = element.style;  // cache for performance

    for (var i = 0; i < PREFIXES.length; ++i) {
        var prefix = PREFIXES[i];
        elStyle[prefix + capitalize(style)] = value;
    }

    elStyle[style] = value;
}

function setStyles(element, styles) {
    forEachObject(styles, function(styleValue, styleName) {
        // Allow disabling some individual styles by setting them
        // to null or undefined
        if (styleValue === null || styleValue === undefined) {
            return;
        }

        // If style's value is {prefix: true, value: '50%'},
        // Set also browser prefixed styles
        if (isObject(styleValue) && styleValue.prefix === true) {
            setStyle(element, styleName, styleValue.value);
        } else {
            element.style[styleName] = styleValue;
        }
    });
}

function capitalize(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}

function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}

function isFunction(obj) {
    return typeof obj === 'function';
}

function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

// Returns true if `obj` is object as in {a: 1, b: 2}, not if it's function or
// array
function isObject(obj) {
    if (isArray(obj)) {
        return false;
    }

    var type = typeof obj;
    return type === 'object' && !!obj;
}

function forEachObject(object, callback) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var val = object[key];
            callback(val, key);
        }
    }
}

function floatEquals(a, b) {
    return Math.abs(a - b) < FLOAT_COMPARISON_EPSILON;
}

// https://coderwall.com/p/nygghw/don-t-use-innerhtml-to-empty-dom-elements
function removeChildren(el) {
    while (el.firstChild) {
        el.removeChild(el.firstChild);
    }
}

module.exports = {
    extend: extend,
    render: render,
    setStyle: setStyle,
    setStyles: setStyles,
    capitalize: capitalize,
    isString: isString,
    isFunction: isFunction,
    isObject: isObject,
    forEachObject: forEachObject,
    floatEquals: floatEquals,
    removeChildren: removeChildren
};

},{}]},{},[4])(4)
});
/* ImageMapster
   Version: 1.2.10 (2/25/2013)

Copyright 2011-2012 James Treworgy

http://www.outsharked.com/imagemapster
https://github.com/jamietre/ImageMapster

A jQuery plugin to enhance image maps.

*/

;

/// LICENSE (MIT License)
///
/// Permission is hereby granted, free of charge, to any person obtaining
/// a copy of this software and associated documentation files (the
/// "Software"), to deal in the Software without restriction, including
/// without limitation the rights to use, copy, modify, merge, publish,
/// distribute, sublicense, and/or sell copies of the Software, and to
/// permit persons to whom the Software is furnished to do so, subject to
/// the following conditions:
///
/// The above copyright notice and this permission notice shall be
/// included in all copies or substantial portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
/// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
/// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
/// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///
/// January 19, 2011

/** @license MIT License (c) copyright B Cavalier & J Hann */

/**
* when
* A lightweight CommonJS Promises/A and when() implementation
*
* when is part of the cujo.js family of libraries (http://cujojs.com/)
*
* Licensed under the MIT License at:
* http://www.opensource.org/licenses/mit-license.php
*
* @version 1.2.0
*/

/*lint-ignore-start*/

(function (define) {
    define(function () {
        var freeze, reduceArray, slice, undef;

        //
        // Public API
        //

        when.defer = defer;
        when.reject = reject;
        when.isPromise = isPromise;

        when.all = all;
        when.some = some;
        when.any = any;

        when.map = map;
        when.reduce = reduce;

        when.chain = chain;

        /** Object.freeze */
        freeze = Object.freeze || function (o) { return o; };

        /**
        * Trusted Promise constructor.  A Promise created from this constructor is
        * a trusted when.js promise.  Any other duck-typed promise is considered
        * untrusted.
        *
        * @constructor
        */
        function Promise() { }

        Promise.prototype = freeze({
            always: function (alwaysback, progback) {
                return this.then(alwaysback, alwaysback, progback);
            },

            otherwise: function (errback) {
                return this.then(undef, errback);
            }
        });

        /**
        * Create an already-resolved promise for the supplied value
        * @private
        *
        * @param value anything
        * @return {Promise}
        */
        function resolved(value) {

            var p = new Promise();

            p.then = function (callback) {
                var nextValue;
                try {
                    if (callback) nextValue = callback(value);
                    return promise(nextValue === undef ? value : nextValue);
                } catch (e) {
                    return rejected(e);
                }
            };

            return freeze(p);
        }

        /**
        * Create an already-rejected {@link Promise} with the supplied
        * rejection reason.
        * @private
        *
        * @param reason rejection reason
        * @return {Promise}
        */
        function rejected(reason) {

            var p = new Promise();

            p.then = function (callback, errback) {
                var nextValue;
                try {
                    if (errback) {
                        nextValue = errback(reason);
                        return promise(nextValue === undef ? reason : nextValue)
                    }

                    return rejected(reason);

                } catch (e) {
                    return rejected(e);
                }
            };

            return freeze(p);
        }

        /**
        * Returns a rejected promise for the supplied promiseOrValue. If
        * promiseOrValue is a value, it will be the rejection value of the
        * returned promise.  If promiseOrValue is a promise, its
        * completion value will be the rejected value of the returned promise
        *
        * @param promiseOrValue {*} the rejected value of the returned {@link Promise}
        *
        * @return {Promise} rejected {@link Promise}
        */
        function reject(promiseOrValue) {
            return when(promiseOrValue, function (value) {
                return rejected(value);
            });
        }

        /**
        * Creates a new, CommonJS compliant, Deferred with fully isolated
        * resolver and promise parts, either or both of which may be given out
        * safely to consumers.
        * The Deferred itself has the full API: resolve, reject, progress, and
        * then. The resolver has resolve, reject, and progress.  The promise
        * only has then.
        *
        * @memberOf when
        * @function
        *
        * @returns {Deferred}
        */
        function defer() {
            var deferred, promise, listeners, progressHandlers, _then, _progress, complete;

            listeners = [];
            progressHandlers = [];

            /**
            * Pre-resolution then() that adds the supplied callback, errback, and progback
            * functions to the registered listeners
            *
            * @private
            *
            * @param [callback] {Function} resolution handler
            * @param [errback] {Function} rejection handler
            * @param [progback] {Function} progress handler
            *
            * @throws {Error} if any argument is not null, undefined, or a Function
            */
            _then = function unresolvedThen(callback, errback, progback) {
                var deferred = defer();

                listeners.push(function (promise) {
                    promise.then(callback, errback)
                    .then(deferred.resolve, deferred.reject, deferred.progress);
                });

                progback && progressHandlers.push(progback);

                return deferred.promise;
            };

            /**
            * Registers a handler for this {@link Deferred}'s {@link Promise}.  Even though all arguments
            * are optional, each argument that *is* supplied must be null, undefined, or a Function.
            * Any other value will cause an Error to be thrown.
            *
            * @memberOf Promise
            *
            * @param [callback] {Function} resolution handler
            * @param [errback] {Function} rejection handler
            * @param [progback] {Function} progress handler
            *
            * @throws {Error} if any argument is not null, undefined, or a Function
            */
            function then(callback, errback, progback) {
                return _then(callback, errback, progback);
            }

            /**
            * Resolves this {@link Deferred}'s {@link Promise} with val as the
            * resolution value.
            *
            * @memberOf Resolver
            *
            * @param val anything
            */
            function resolve(val) {
                complete(resolved(val));
            }

            /**
            * Rejects this {@link Deferred}'s {@link Promise} with err as the
            * reason.
            *
            * @memberOf Resolver
            *
            * @param err anything
            */
            function reject(err) {
                complete(rejected(err));
            }

            /**
            * @private
            * @param update
            */
            _progress = function (update) {
                var progress, i = 0;
                while (progress = progressHandlers[i++]) progress(update);
            };

            /**
            * Emits a progress update to all progress observers registered with
            * this {@link Deferred}'s {@link Promise}
            *
            * @memberOf Resolver
            *
            * @param update anything
            */
            function progress(update) {
                _progress(update);
            }

            /**
            * Transition from pre-resolution state to post-resolution state, notifying
            * all listeners of the resolution or rejection
            *
            * @private
            *
            * @param completed {Promise} the completed value of this deferred
            */
            complete = function (completed) {
                var listener, i = 0;

                // Replace _then with one that directly notifies with the result.
                _then = completed.then;

                // Replace complete so that this Deferred can only be completed
                // once. Also Replace _progress, so that subsequent attempts to issue
                // progress throw.
                complete = _progress = function alreadyCompleted() {
                    // TODO: Consider silently returning here so that parties who
                    // have a reference to the resolver cannot tell that the promise
                    // has been resolved using try/catch
                    throw new Error("already completed");
                };

                // Free progressHandlers array since we'll never issue progress events
                // for this promise again now that it's completed
                progressHandlers = undef;

                // Notify listeners
                // Traverse all listeners registered directly with this Deferred

                while (listener = listeners[i++]) {
                    listener(completed);
                }

                listeners = [];
            };

            /**
            * The full Deferred object, with both {@link Promise} and {@link Resolver}
            * parts
            * @class Deferred
            * @name Deferred
            */
            deferred = {};

            // Promise and Resolver parts
            // Freeze Promise and Resolver APIs

            promise = new Promise();
            promise.then = deferred.then = then;

            /**
            * The {@link Promise} for this {@link Deferred}
            * @memberOf Deferred
            * @name promise
            * @type {Promise}
            */
            deferred.promise = freeze(promise);

            /**
            * The {@link Resolver} for this {@link Deferred}
            * @memberOf Deferred
            * @name resolver
            * @class Resolver
            */
            deferred.resolver = freeze({
                resolve: (deferred.resolve = resolve),
                reject: (deferred.reject = reject),
                progress: (deferred.progress = progress)
            });

            return deferred;
        }

        /**
        * Determines if promiseOrValue is a promise or not.  Uses the feature
        * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
        * promiseOrValue is a promise.
        *
        * @param promiseOrValue anything
        *
        * @returns {Boolean} true if promiseOrValue is a {@link Promise}
        */
        function isPromise(promiseOrValue) {
            return promiseOrValue && typeof promiseOrValue.then === 'function';
        }

        /**
        * Register an observer for a promise or immediate value.
        *
        * @function
        * @name when
        * @namespace
        *
        * @param promiseOrValue anything
        * @param {Function} [callback] callback to be called when promiseOrValue is
        *   successfully resolved.  If promiseOrValue is an immediate value, callback
        *   will be invoked immediately.
        * @param {Function} [errback] callback to be called when promiseOrValue is
        *   rejected.
        * @param {Function} [progressHandler] callback to be called when progress updates
        *   are issued for promiseOrValue.
        *
        * @returns {Promise} a new {@link Promise} that will complete with the return
        *   value of callback or errback or the completion value of promiseOrValue if
        *   callback and/or errback is not supplied.
        */
        function when(promiseOrValue, callback, errback, progressHandler) {
            // Get a promise for the input promiseOrValue
            // See promise()
            var trustedPromise = promise(promiseOrValue);

            // Register promise handlers
            return trustedPromise.then(callback, errback, progressHandler);
        }

        /**
        * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
        * promiseOrValue is a foreign promise, or a new, already-resolved {@link Promise}
        * whose resolution value is promiseOrValue if promiseOrValue is an immediate value.
        *
        * Note that this function is not safe to export since it will return its
        * input when promiseOrValue is a {@link Promise}
        *
        * @private
        *
        * @param promiseOrValue anything
        *
        * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
        *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
        *   whose resolution value is:
        *   * the resolution value of promiseOrValue if it's a foreign promise, or
        *   * promiseOrValue if it's a value
        */
        function promise(promiseOrValue) {
            var promise, deferred;

            if (promiseOrValue instanceof Promise) {
                // It's a when.js promise, so we trust it
                promise = promiseOrValue;

            } else {
                // It's not a when.js promise.  Check to see if it's a foreign promise
                // or a value.

                deferred = defer();
                if (isPromise(promiseOrValue)) {
                    // It's a compliant promise, but we don't know where it came from,
                    // so we don't trust its implementation entirely.  Introduce a trusted
                    // middleman when.js promise

                    // IMPORTANT: This is the only place when.js should ever call .then() on
                    // an untrusted promise.
                    promiseOrValue.then(deferred.resolve, deferred.reject, deferred.progress);
                    promise = deferred.promise;

                } else {
                    // It's a value, not a promise.  Create an already-resolved promise
                    // for it.
                    deferred.resolve(promiseOrValue);
                    promise = deferred.promise;
                }
            }

            return promise;
        }

        /**
        * Return a promise that will resolve when howMany of the supplied promisesOrValues
        * have resolved. The resolution value of the returned promise will be an array of
        * length howMany containing the resolutions values of the triggering promisesOrValues.
        *
        * @memberOf when
        *
        * @param promisesOrValues {Array} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param howMany
        * @param [callback]
        * @param [errback]
        * @param [progressHandler]
        *
        * @returns {Promise}
        */
        function some(promisesOrValues, howMany, callback, errback, progressHandler) {

            checkCallbacks(2, arguments);

            return when(promisesOrValues, function (promisesOrValues) {

                var toResolve, results, ret, deferred, resolver, rejecter, handleProgress, len, i;

                len = promisesOrValues.length >>> 0;

                toResolve = Math.max(0, Math.min(howMany, len));
                results = [];
                deferred = defer();
                ret = when(deferred, callback, errback, progressHandler);

                // Wrapper so that resolver can be replaced
                function resolve(val) {
                    resolver(val);
                }

                // Wrapper so that rejecter can be replaced
                function reject(err) {
                    rejecter(err);
                }

                // Wrapper so that progress can be replaced
                function progress(update) {
                    handleProgress(update);
                }

                function complete() {
                    resolver = rejecter = handleProgress = noop;
                }

                // No items in the input, resolve immediately
                if (!toResolve) {
                    deferred.resolve(results);

                } else {
                    // Resolver for promises.  Captures the value and resolves
                    // the returned promise when toResolve reaches zero.
                    // Overwrites resolver var with a noop once promise has
                    // be resolved to cover case where n < promises.length
                    resolver = function (val) {
                        // This orders the values based on promise resolution order
                        // Another strategy would be to use the original position of
                        // the corresponding promise.
                        results.push(val);

                        if (! --toResolve) {
                            complete();
                            deferred.resolve(results);
                        }
                    };

                    // Rejecter for promises.  Rejects returned promise
                    // immediately, and overwrites rejecter var with a noop
                    // once promise to cover case where n < promises.length.
                    // TODO: Consider rejecting only when N (or promises.length - N?)
                    // promises have been rejected instead of only one?
                    rejecter = function (err) {
                        complete();
                        deferred.reject(err);
                    };

                    handleProgress = deferred.progress;

                    // TODO: Replace while with forEach
                    for (i = 0; i < len; ++i) {
                        if (i in promisesOrValues) {
                            when(promisesOrValues[i], resolve, reject, progress);
                        }
                    }
                }

                return ret;
            });
        }

        /**
        * Return a promise that will resolve only once all the supplied promisesOrValues
        * have resolved. The resolution value of the returned promise will be an array
        * containing the resolution values of each of the promisesOrValues.
        *
        * @memberOf when
        *
        * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param [callback] {Function}
        * @param [errback] {Function}
        * @param [progressHandler] {Function}
        *
        * @returns {Promise}
        */
        function all(promisesOrValues, callback, errback, progressHandler) {

            checkCallbacks(1, arguments);

            return when(promisesOrValues, function (promisesOrValues) {
                return _reduce(promisesOrValues, reduceIntoArray, []);
            }).then(callback, errback, progressHandler);
        }

        function reduceIntoArray(current, val, i) {
            current[i] = val;
            return current;
        }

        /**
        * Return a promise that will resolve when any one of the supplied promisesOrValues
        * has resolved. The resolution value of the returned promise will be the resolution
        * value of the triggering promiseOrValue.
        *
        * @memberOf when
        *
        * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param [callback] {Function}
        * @param [errback] {Function}
        * @param [progressHandler] {Function}
        *
        * @returns {Promise}
        */
        function any(promisesOrValues, callback, errback, progressHandler) {

            function unwrapSingleResult(val) {
                return callback ? callback(val[0]) : val[0];
            }

            return some(promisesOrValues, 1, unwrapSingleResult, errback, progressHandler);
        }

        /**
        * Traditional map function, similar to `Array.prototype.map()`, but allows
        * input to contain {@link Promise}s and/or values, and mapFunc may return
        * either a value or a {@link Promise}
        *
        * @memberOf when
        *
        * @param promise {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values
        * @param mapFunc {Function} mapping function mapFunc(value) which may return
        *      either a {@link Promise} or value
        *
        * @returns {Promise} a {@link Promise} that will resolve to an array containing
        *      the mapped output values.
        */
        function map(promise, mapFunc) {
            return when(promise, function (array) {
                return _map(array, mapFunc);
            });
        }

        /**
        * Private map helper to map an array of promises
        * @private
        *
        * @param promisesOrValues {Array}
        * @param mapFunc {Function}
        * @return {Promise}
        */
        function _map(promisesOrValues, mapFunc) {

            var results, len, i;

            // Since we know the resulting length, we can preallocate the results
            // array to avoid array expansions.
            len = promisesOrValues.length >>> 0;
            results = new Array(len);

            // Since mapFunc may be async, get all invocations of it into flight
            // asap, and then use reduce() to collect all the results
            for (i = 0; i < len; i++) {
                if (i in promisesOrValues)
                    results[i] = when(promisesOrValues[i], mapFunc);
            }

            // Could use all() here, but that would result in another array
            // being allocated, i.e. map() would end up allocating 2 arrays
            // of size len instead of just 1.  Since all() uses reduce()
            // anyway, avoid the additional allocation by calling reduce
            // directly.
            return _reduce(results, reduceIntoArray, results);
        }

        /**
        * Traditional reduce function, similar to `Array.prototype.reduce()`, but
        * input may contain {@link Promise}s and/or values, and reduceFunc
        * may return either a value or a {@link Promise}, *and* initialValue may
        * be a {@link Promise} for the starting value.
        *
        * @memberOf when
        *
        * @param promise {Array|Promise} array of anything, may contain a mix
        *      of {@link Promise}s and values.  May also be a {@link Promise} for
        *      an array.
        * @param reduceFunc {Function} reduce function reduce(currentValue, nextValue, index, total),
        *      where total is the total number of items being reduced, and will be the same
        *      in each call to reduceFunc.
        * @param initialValue starting value, or a {@link Promise} for the starting value
        *
        * @returns {Promise} that will resolve to the final reduced value
        */
        function reduce(promise, reduceFunc, initialValue) {
            var args = slice.call(arguments, 1);
            return when(promise, function (array) {
                return _reduce.apply(undef, [array].concat(args));
            });
        }

        /**
        * Private reduce to reduce an array of promises
        * @private
        *
        * @param promisesOrValues {Array}
        * @param reduceFunc {Function}
        * @param initialValue {*}
        * @return {Promise}
        */
        function _reduce(promisesOrValues, reduceFunc, initialValue) {

            var total, args;

            total = promisesOrValues.length;

            // Skip promisesOrValues, since it will be used as 'this' in the call
            // to the actual reduce engine below.

            // Wrap the supplied reduceFunc with one that handles promises and then
            // delegates to the supplied.

            args = [
            function (current, val, i) {
                return when(current, function (c) {
                    return when(val, function (value) {
                        return reduceFunc(c, value, i, total);
                    });
                });
            }
        ];

            if (arguments.length > 2) args.push(initialValue);

            return reduceArray.apply(promisesOrValues, args);
        }

        /**
        * Ensure that resolution of promiseOrValue will complete resolver with the completion
        * value of promiseOrValue, or instead with resolveValue if it is provided.
        *
        * @memberOf when
        *
        * @param promiseOrValue
        * @param resolver {Resolver}
        * @param [resolveValue] anything
        *
        * @returns {Promise}
        */
        function chain(promiseOrValue, resolver, resolveValue) {
            var useResolveValue = arguments.length > 2;

            return when(promiseOrValue,
            function (val) {
                if (useResolveValue) val = resolveValue;
                resolver.resolve(val);
                return val;
            },
            function (e) {
                resolver.reject(e);
                return rejected(e);
            },
            resolver.progress
        );
        }

        //
        // Utility functions
        //

        /**
        * Helper that checks arrayOfCallbacks to ensure that each element is either
        * a function, or null or undefined.
        *
        * @private
        *
        * @param arrayOfCallbacks {Array} array to check
        * @throws {Error} if any element of arrayOfCallbacks is something other than
        * a Functions, null, or undefined.
        */
        function checkCallbacks(start, arrayOfCallbacks) {
            var arg, i = arrayOfCallbacks.length;
            while (i > start) {
                arg = arrayOfCallbacks[--i];
                if (arg != null && typeof arg != 'function') throw new Error('callback is not a function');
            }
        }

        /**
        * No-Op function used in method replacement
        * @private
        */
        function noop() { }

        slice = [].slice;

        // ES5 reduce implementation if native not available
        // See: http://es5.github.com/#x15.4.4.21 as there are many
        // specifics and edge cases.
        reduceArray = [].reduce ||
        function (reduceFunc /*, initialValue */) {
            // ES5 dictates that reduce.length === 1

            // This implementation deviates from ES5 spec in the following ways:
            // 1. It does not check if reduceFunc is a Callable

            var arr, args, reduced, len, i;

            i = 0;
            arr = Object(this);
            len = arr.length >>> 0;
            args = arguments;

            // If no initialValue, use first item of array (we know length !== 0 here)
            // and adjust i to start at second item
            if (args.length <= 1) {
                // Skip to the first real element in the array
                for (; ; ) {
                    if (i in arr) {
                        reduced = arr[i++];
                        break;
                    }

                    // If we reached the end of the array without finding any real
                    // elements, it's a TypeError
                    if (++i >= len) {
                        throw new TypeError();
                    }
                }
            } else {
                // If initialValue provided, use it
                reduced = args[1];
            }

            // Do the actual reduce
            for (; i < len; ++i) {
                // Skip holes
                if (i in arr)
                    reduced = reduceFunc(reduced, arr[i], i, arr);
            }

            return reduced;
        };

        return when;
    });
})(typeof define == 'function'
    ? define
    : function (factory) {
        typeof module != 'undefined'
        ? (module.exports = factory())
        : (jQuery.mapster_when = factory());
    }
// Boilerplate for AMD, Node, and browser global
);
/*lint-ignore-end*/
/* ImageMapster core */

/*jslint laxbreak: true, evil: true, unparam: true */

/*global jQuery: true, Zepto: true */


(function ($) {
    // all public functions in $.mapster.impl are methods
    $.fn.mapster = function (method) {
        var m = $.mapster.impl;
        if ($.isFunction(m[method])) {
            return m[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return m.bind.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.mapster');
        }
    };

    $.mapster = {
        version: "1.2.10",
        render_defaults: {
            isSelectable: true,
            isDeselectable: true,
            fade: false,
            fadeDuration: 150,
            fill: true,
            fillColor: '000000',
            fillColorMask: 'FFFFFF',
            fillOpacity: 0.7,
            highlight: true,
            stroke: false,
            strokeColor: 'ff0000',
            strokeOpacity: 1,
            strokeWidth: 1,
            includeKeys: '',
            altImage: null,
            altImageId: null, // used internally            
            altImages: {} 
        },
        defaults: {
            clickNavigate: false,
            wrapClass: null,
            wrapCss: null,
            onGetList: null,
            sortList: false,
            listenToList: false,
            mapKey: '',
            mapValue: '',
            singleSelect: false,
            listKey: 'value',
            listSelectedAttribute: 'selected',
            listSelectedClass: null,
            onClick: null,
            onMouseover: null,
            onMouseout: null,
            mouseoutDelay: 0,
            onStateChange: null,
            boundList: null,
            onConfigured: null,
            configTimeout: 30000,
            noHrefIsMask: true,
            scaleMap: true,
            safeLoad: false,
            areas: []
        },
        shared_defaults: {
            render_highlight: { fade: true },
            render_select: { fade: false },
            staticState: null,
            selected: null
        },
        area_defaults:
        {
            includeKeys: '',
            isMask: false
        },
        canvas_style: {
            position: 'absolute',
            left: 0,
            top: 0,
            padding: 0,
            border: 0
        },
        hasCanvas: null,
        isTouch: null,
        map_cache: [],
        hooks: {},
        addHook: function(name,callback) {
            this.hooks[name]=(this.hooks[name]||[]).push(callback);
        },
        callHooks: function(name,context) {
            $.each(this.hooks[name]||[],function(i,e) {
                e.apply(context);
            });
        },
        utils: {
            when: $.mapster_when,
            defer: $.mapster_when.defer,

            // extends the constructor, returns a new object prototype. Does not refer to the
            // original constructor so is protected if the original object is altered. This way you
            // can "extend" an object by replacing it with its subclass.
            subclass: function(BaseClass, constr) {
                var Subclass=function() {
                    var me=this, 
                        args=Array.prototype.slice.call(arguments,0);
                    me.base = BaseClass.prototype;
                    me.base.init = function() {
                        BaseClass.prototype.constructor.apply(me,args);
                    };
                    constr.apply(me,args);
                };
                Subclass.prototype = new BaseClass();
                Subclass.prototype.constructor=Subclass;
                return Subclass;
            },
            asArray: function (obj) {
                return obj.constructor === Array ?
                    obj : this.split(obj);
            },
            // clean split: no padding or empty elements
            split: function (text,cb) {
                var i,el, arr = text.split(',');
                for (i = 0; i < arr.length; i++) {
                    el = $.trim(arr[i]);
                    if (el==='') {
                        arr.splice(i,1);
                    } else {
                        arr[i] = cb ? cb(el):el;
                    }
                }
                return arr;
            },
            // similar to $.extend but does not add properties (only updates), unless the
            // first argument is an empty object, then all properties will be copied
            updateProps: function (_target, _template) {
                var onlyProps,
                    target = _target || {},
                    template = $.isEmptyObject(target) ? _template : _target;

                //if (template) {
                onlyProps = [];
                $.each(template, function (prop) {
                    onlyProps.push(prop);
                });
                //}

                $.each(Array.prototype.slice.call(arguments, 1), function (i, src) {
                    $.each(src || {}, function (prop) {
                        if (!onlyProps || $.inArray(prop, onlyProps) >= 0) {
                            var p = src[prop];

                            if ($.isPlainObject(p)) {
                                // not recursive - only copies 1 level of subobjects, and always merges
                                target[prop] = $.extend(target[prop] || {}, p);
                            } else if (p && p.constructor === Array) {
                                target[prop] = p.slice(0);
                            } else if (typeof p !== 'undefined') {
                                target[prop] = src[prop];
                            }

                        }
                    });
                });
                return target;
            },
            isElement: function (o) {
                return (typeof HTMLElement === "object" ? o instanceof HTMLElement :
                        o && typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === "string");
            },
            // finds element of array or object with a property "prop" having value "val"
            // if prop is not defined, then just looks for property with value "val"
            indexOfProp: function (obj, prop, val) {
                var result = obj.constructor === Array ? -1 : null;
                $.each(obj, function (i, e) {
                    if (e && (prop ? e[prop] : e) === val) {
                        result = i;
                        return false;
                    }
                });
                return result;
            },
            // returns "obj" if true or false, or "def" if not true/false
            boolOrDefault: function (obj, def) {
                return this.isBool(obj) ?
                        obj : def || false;
            },
            isBool: function (obj) {
                return typeof obj === "boolean";
            },
            isUndef: function(obj) {
                return typeof obj === "undefined";
            },
            // evaluates "obj", if function, calls it with args
            // (todo - update this to handle variable lenght/more than one arg)
            ifFunction: function (obj, that, args) {
                if ($.isFunction(obj)) {
                    obj.call(that, args);
                }
            },
            size: function(image, raw) {
                var u=$.mapster.utils;
                return { 
                    width: raw ? (image.width || image.naturalWidth) : u.imgWidth(image,true) ,
                    height: raw ? (image.height || image.naturalHeight) : u.imgHeight(image,true),
                    complete: function() { return !!this.height && !!this.width;}
                };
            },

                
            /**
             * Set the opacity of the element. This is an IE<8 specific function for handling VML.
             * When using VML we must override the "setOpacity" utility function (monkey patch ourselves).
             * jQuery does not deal with opacity correctly for VML elements. This deals with that.
             * 
             * @param {Element} el The DOM element
             * @param {double} opacity A value between 0 and 1 inclusive.
             */

            setOpacity: function (el, opacity) {
                if ($.mapster.hasCanvas()) {
                    el.style.opacity = opacity;
                } else {
                    $(el).each(function(i,e) {
                        if (typeof e.opacity !=='undefined') {
                           e.opacity=opacity;
                        } else {
                            $(e).css("opacity",opacity);
                        }
                    });
                }
            },


            // fade "el" from opacity "op" to "endOp" over a period of time "duration"
            
            fader: (function () {
                var elements = {},
                        lastKey = 0,
                        fade_func = function (el, op, endOp, duration) {
                            var index, 
                                cbIntervals = duration/15,
                                obj, u = $.mapster.utils;

                            if (typeof el === 'number') {
                                obj = elements[el];
                                if (!obj) {
                                    return;
                                }
                            } else {
                                index = u.indexOfProp(elements, null, el);
                                if (index) {
                                    delete elements[index];
                                }
                                elements[++lastKey] = obj = el;
                                el = lastKey;
                            }

                            endOp = endOp || 1;

                            op = (op + (endOp / cbIntervals) > endOp - 0.01) ? endOp : op + (endOp / cbIntervals);

                            u.setOpacity(obj, op);
                            if (op < endOp) {
                                setTimeout(function () {
                                    fade_func(el, op, endOp, duration);
                                }, 15);
                            }
                        };
                return fade_func;
            } ())
        },
        getBoundList: function (opts, key_list) {
            if (!opts.boundList) {
                return null;
            }
            var index, key, result = $(), list = $.mapster.utils.split(key_list);
            opts.boundList.each(function (i,e) {
                for (index = 0; index < list.length; index++) {
                    key = list[index];
                    if ($(e).is('[' + opts.listKey + '="' + key + '"]')) {
                        result = result.add(e);
                    }
                }
            });
            return result;
        },
        // Causes changes to the bound list based on the user action (select or deselect)
        // area: the jQuery area object
        // returns the matching elements from the bound list for the first area passed (normally only one should be passed, but
        // a list can be passed
        setBoundListProperties: function (opts, target, selected) {
            target.each(function (i,e) {
                if (opts.listSelectedClass) {
                    if (selected) {
                        $(e).addClass(opts.listSelectedClass);
                    } else {
                        $(e).removeClass(opts.listSelectedClass);
                    }
                }
                if (opts.listSelectedAttribute) {
                    $(e).attr(opts.listSelectedAttribute, selected);
                }
            });
        },
        getMapDataIndex: function (obj) {
            var img, id;
            switch (obj.tagName && obj.tagName.toLowerCase()) {
                case 'area':
                    id = $(obj).parent().attr('name');
                    img = $("img[usemap='#" + id + "']")[0];
                    break;
                case 'img':
                    img = obj;
                    break;
            }
            return img ?
                this.utils.indexOfProp(this.map_cache, 'image', img) : -1;
        },
        getMapData: function (obj) {
            var index = this.getMapDataIndex(obj.length ? obj[0]:obj);
            if (index >= 0) {
                return index >= 0 ? this.map_cache[index] : null;
            }
        },
        /**
         * Queue a command to be run after the active async operation has finished
         * @param  {MapData}  map_data    The target MapData object
         * @param  {jQuery}   that        jQuery object on which the command was invoked
         * @param  {string}   command     the ImageMapster method name
         * @param  {object[]} args        arguments passed to the method
         * @return {bool}                 true if the command was queued, false if not (e.g. there was no need to)
         */
        queueCommand: function (map_data, that, command, args) {
            if (!map_data) {
                return false;
            }
            if (!map_data.complete || map_data.currentAction) {
                map_data.commands.push(
                {
                    that: that,
                    command: command,
                    args: args
                });
                return true;
            }
            return false;
        },
        unload: function () {
            this.impl.unload();
            this.utils = null;
            this.impl = null;
            $.fn.mapster = null;
            $.mapster = null;
            $('*').unbind();
        }
    };

    // Config for object prototypes
    // first: use only first object (for things that should not apply to lists)
    /// calls back one of two fuinctions, depending on whether an area was obtained.
    // opts: {
    //    name: 'method name',
    //    key: 'key,
    //    args: 'args'
    //
    //}
    // name: name of method (required)
    // args: arguments to re-call with
    // Iterates through all the objects passed, and determines whether it's an area or an image, and calls the appropriate
    // callback for each. If anything is returned from that callback, the process is stopped and that data return. Otherwise,
    // the object itself is returned.
    
    var m = $.mapster, 
        u = m.utils,
        ap = Array.prototype;


    // jQuery's width() and height() are broken on IE9 in some situations. This tries everything. 
    $.each(["width","height"],function(i,e) {
        var capProp = e.substr(0,1).toUpperCase() + e.substr(1);
        // when jqwidth parm is passed, it also checks the jQuery width()/height() property
        // the issue is that jQUery width() can report a valid size before the image is loaded in some browsers
        // without it, we can read zero even when image is loaded in other browsers if its not visible
        // we must still check because stuff like adblock can temporarily block it
        // what a goddamn headache
        u["img"+capProp]=function(img,jqwidth) {
                return (jqwidth ? $(img)[e]() : 0) || 
                    img[e] || img["natural"+capProp] || img["client"+capProp] || img["offset"+capProp];
        };
     
    });    

    /**
     * The Method object encapsulates the process of testing an ImageMapster method to see if it's being
     * invoked on an image, or an area; then queues the command if the MapData is in an active state.
     * 
     * @param {[jQuery]}    that        The target of the invocation
     * @param {[function]}  func_map    The callback if the target is an imagemap
     * @param {[function]}  func_area   The callback if the target is an area
     * @param {[object]}    opt         Options: { key: a map key if passed explicitly
     *                                             name: the command name, if it can be queued,
     *                                             args: arguments to the method
     *                                            }
     */
    
    m.Method = function (that, func_map, func_area, opts) {
        var me = this;
        me.name = opts.name;
        me.output = that;
        me.input = that;
        me.first = opts.first || false;
        me.args = opts.args ? ap.slice.call(opts.args, 0) : [];
        me.key = opts.key;
        me.func_map = func_map;
        me.func_area = func_area;
        //$.extend(me, opts);
        me.name = opts.name;
        me.allowAsync = opts.allowAsync || false;
    };
    m.Method.prototype = {
        constructor: m.Method,
        go: function () {
            var i,  data, ar, len, result, src = this.input,
                    area_list = [],
                    me = this;

            len = src.length;
            for (i = 0; i < len; i++) {
                data = $.mapster.getMapData(src[i]);
                if (data) {
                    if (!me.allowAsync && m.queueCommand(data, me.input, me.name, me.args)) {
                        if (this.first) {
                            result = '';
                        }
                        continue;
                    }
                    
                    ar = data.getData(src[i].nodeName === 'AREA' ? src[i] : this.key);
                    if (ar) {
                        if ($.inArray(ar, area_list) < 0) {
                            area_list.push(ar);
                        }
                    } else {
                        result = this.func_map.apply(data, me.args);
                    }
                    if (this.first || typeof result !== 'undefined') {
                        break;
                    }
                }
            }
            // if there were areas, call the area function for each unique group
            $(area_list).each(function (i,e) {
                result = me.func_area.apply(e, me.args);
            });

            if (typeof result !== 'undefined') {
                return result;
            } else {
                return this.output;
            }
        }
    };

    $.mapster.impl = (function () {
        var me = {},
        addMap= function (map_data) {
            return m.map_cache.push(map_data) - 1;
        },
        removeMap = function (map_data) {
            m.map_cache.splice(map_data.index, 1);
            for (var i = m.map_cache.length - 1; i >= this.index; i--) {
                m.map_cache[i].index--;
            }
        };

        
        /**
         * Test whether the browser supports VML. Credit: google.
         * http://stackoverflow.com/questions/654112/how-do-you-detect-support-for-vml-or-svg-in-a-browser
         * 
         * @return {bool} true if vml is supported, false if not
         */
        
        function hasVml() {
            var a = $('<div />').appendTo('body');
            a.html('<v:shape id="vml_flag1" adj="1" />');
            
            var b = a[0].firstChild;
            b.style.behavior = "url(#default#VML)";
            var has = b ? typeof b.adj === "object" : true;
            a.remove();
            return has;
        }

        /**
         * Return a reference to the IE namespaces object, if available, or an empty object otherwise
         * @return {obkect} The document.namespaces object.
         */
        function namespaces() {
            return typeof(document.namespaces)==='object' ?
                document.namespaces :
                null;
        }

        /**
         * Test for the presence of HTML5 Canvas support. This also checks to see if excanvas.js has been 
         * loaded and is faking it; if so, we assume that canvas is not supported.
         *
         * @return {bool} true if HTML5 canvas support, false if not
         */
        
        function hasCanvas() {
            var d = namespaces();
            // when g_vml_ is present, then we can be sure excanvas is active, meaning there's not a real canvas.
            
             return d && d.g_vml_ ? 
                false :
                $('<canvas />')[0].getContext ? 
                    true : 
                    false;
        }

        /**
         * Merge new area data into existing area options on a MapData object. Used for rebinding.
         * 
         * @param  {[MapData]} map_data     The MapData object
         * @param  {[object[]]} areas       areas array to merge
         */
        
        function merge_areas(map_data, areas) {
            var ar, index,
                map_areas = map_data.options.areas;

            if (areas) {
                $.each(areas, function (i, e) {
                    
                    // Issue #68 - ignore invalid data in areas array
                    
                    if (!e || !e.key) { 
                        return;
                    }

                    index = u.indexOfProp(map_areas, "key", e.key);

                    if (index >= 0) {
                        $.extend(map_areas[index], e);
                    }
                    else {
                        map_areas.push(e);
                    }
                    ar = map_data.getDataForKey(e.key);
                    if (ar) {
                        $.extend(ar.options, e);
                    }
                });
            }
        }
        function merge_options(map_data, options) {
            var temp_opts = u.updateProps({}, options);
            delete temp_opts.areas;

            u.updateProps(map_data.options, temp_opts);

            merge_areas(map_data, options.areas);
            // refresh the area_option template
            u.updateProps(map_data.area_options, map_data.options);
        }

        // Most methods use the "Method" object which handles figuring out whether it's an image or area called and
        // parsing key parameters. The constructor wants:
        // this, the jQuery object
        // a function that is called when an image was passed (with a this context of the MapData)
        // a function that is called when an area was passed (with a this context of the AreaData)
        // options: first = true means only the first member of a jQuery object is handled
        //          key = the key parameters passed
        //          defaultReturn: a value to return other than the jQuery object (if its not chainable)
        //          args: the arguments
        // Returns a comma-separated list of user-selected areas. "staticState" areas are not considered selected for the purposes of this method.
        
        me.get = function (key) {
            var md = m.getMapData(this);
            if (!(md && md.complete)) {
                throw("Can't access data until binding complete.");
            }

            return (new m.Method(this,
                function () {
                    // map_data return
                    return this.getSelected();
                },
                function () {
                    return this.isSelected();
                },
                { name: 'get',
                    args: arguments,
                    key: key,
                    first: true,
                    allowAsync: true,
                    defaultReturn: ''
                }
            )).go();
        };
        me.data = function (key) {
            return (new m.Method(this,
                null,
                function () {
                    return this;
                },
                { name: 'data',
                    args: arguments,
                    key: key
                }
            )).go();
        };


        // Set or return highlight state.
        //  $(img).mapster('highlight') -- return highlighted area key, or null if none
        //  $(area).mapster('highlight') -- highlight an area
        //  $(img).mapster('highlight','area_key') -- highlight an area
        //  $(img).mapster('highlight',false) -- remove highlight
        me.highlight = function (key) {
            return (new m.Method(this,
                function () {
                    if (key === false) {
                        this.ensureNoHighlight();
                    } else {
                        var id = this.highlightId;
                        return id >= 0 ? this.data[id].key : null;
                    }
                },
                function () {
                    this.highlight();
                },
                { name: 'highlight',
                    args: arguments,
                    key: key,
                    first: true
                }
            )).go();
        };
        // Return the primary keys for an area or group key.
        // $(area).mapster('key')
        // includes all keys (not just primary keys)
        // $(area).mapster('key',true)
        // $(img).mapster('key','group-key')

        // $(img).mapster('key','group-key', true)
        me.keys = function(key,all) {
            var keyList=[], 
                md = m.getMapData(this);

            if (!(md && md.complete)) {
                throw("Can't access data until binding complete.");
            }


            function addUniqueKeys(ad) {
                var areas,keys=[];
                if (!all) {
                    keys.push(ad.key);
                } else {
                    areas=ad.areas();
                    $.each(areas,function(i,e) {
                        keys=keys.concat(e.keys);
                    });
                }
                $.each(keys,function(i,e) {
                    if ($.inArray(e,keyList)<0) {
                        keyList.push(e);                         
                    }
                });
            }

            if (!(md  && md.complete)) {
                return '';
            }
            if (typeof key === 'string') {
                if (all) {
                    addUniqueKeys(md.getDataForKey(key));
                } else {
                    keyList=[md.getKeysForGroup(key)];
                }
            } else {
                all = key;
                this.each(function(i,e) {
                    if (e.nodeName==='AREA') {
                        addUniqueKeys(md.getDataForArea(e));
                    }
                });
            }
            return keyList.join(',');
        

        };
        me.select = function () {
            me.set.call(this, true);
        };
        me.deselect = function () {
            me.set.call(this, false);
        };
        
        /**
         * Select or unselect areas. Areas can be identified by a single string key, a comma-separated list of keys, 
         * or an array of strings.
         * 
         * 
         * @param {boolean} selected Determines whether areas are selected or deselected
         * @param {string|string[]} key A string, comma-separated string, or array of strings indicating 
         *                              the areas to select or deselect
         * @param {object} options Rendering options to apply when selecting an area
         */ 

        me.set = function (selected, key, options) {
            var lastMap, map_data, opts=options,
                key_list, area_list; // array of unique areas passed

            function setSelection(ar) {
                if (ar) {
                    switch (selected) {
                        case true:
                            ar.select(opts); break;
                        case false:
                            ar.deselect(true); break;
                        default:
                            ar.toggle(opts); break;
                    }
                }
            }
            function addArea(ar) {
               if (ar && $.inArray(ar, area_list) < 0) {
                    area_list.push(ar);
                    key_list+=(key_list===''?'':',')+ar.key;
                }
            }
            // Clean up after a group that applied to the same map
            function finishSetForMap(map_data) {
                $.each(area_list, function (i, el) {
                    setSelection(el);
                });
                if (!selected) {
                    map_data.removeSelectionFinish();
                }
                if (map_data.options.boundList) {
                    m.setBoundListProperties(map_data.options, m.getBoundList(map_data.options, key_list), selected);
                }            
            }

            this.filter('img,area').each(function (i,e) {
                var keys;
                map_data = m.getMapData(e);

                if (map_data !== lastMap) {
                    if (lastMap) {
                       finishSetForMap(lastMap);
                    }

                    area_list = [];
                    key_list='';
                }
                
               if (map_data) {
                    
                    keys = '';
                    if (e.nodeName.toUpperCase()==='IMG') {
                        if (!m.queueCommand(map_data, $(e), 'set', [selected, key, opts])) {
                            if (key instanceof Array) {
                                if (key.length) {
                                    keys = key.join(",");
                                }
                            }
                            else {
                                keys = key;
                            }

                            if (keys) {
                                $.each(u.split(keys), function (i,key) {
                                    addArea(map_data.getDataForKey(key.toString()));
                                    lastMap = map_data;
                                });
                            }
                        }
                    } else {
                        opts=key;
                        if (!m.queueCommand(map_data, $(e), 'set', [selected, opts])) {
                            addArea(map_data.getDataForArea(e));
                            lastMap = map_data;
                        }
                    
                    }
                }
            });
            
            if (map_data) {
               finishSetForMap(map_data);
            }

           
            return this;
        };
        me.unbind = function (preserveState) {
            return (new m.Method(this,
                function () {
                    this.clearEvents();
                    this.clearMapData(preserveState);
                    removeMap(this);
                },
                null,
                { name: 'unbind',
                    args: arguments
                }
            )).go();
        };


        // refresh options and update selection information.
        me.rebind = function (options) {
            return (new m.Method(this,
                function () {
                    var me=this;

                    me.complete=false;
                    me.configureOptions(options);
                    me.bindImages().then(function() {
                        me.buildDataset(true);
                        me.complete=true;
                    });
                    //this.redrawSelections();
                },
                null,
                {
                    name: 'rebind',
                    args: arguments
                }
            )).go();
        };
        // get options. nothing or false to get, or "true" to get effective options (versus passed options)
        me.get_options = function (key, effective) {
            var eff = u.isBool(key) ? key : effective; // allow 2nd parm as "effective" when no key
            return (new m.Method(this,
                function () {
                    var opts = $.extend({}, this.options);
                    if (eff) {
                        opts.render_select = u.updateProps(
                            {},
                            m.render_defaults,
                            opts,
                            opts.render_select);

                        opts.render_highlight = u.updateProps(
                            {},
                            m.render_defaults,
                            opts,
                            opts.render_highlight);
                    }
                    return opts;
                },
                function () {
                    return eff ? this.effectiveOptions() : this.options;
                },
                {
                    name: 'get_options',
                    args: arguments,
                    first: true,
                    allowAsync: true,
                    key: key
                }
            )).go();
        };

        // set options - pass an object with options to set,
        me.set_options = function (options) {
            return (new m.Method(this,
                function () {
                    merge_options(this, options);
                },
                null,
                {
                    name: 'set_options',
                    args: arguments
                }
            )).go();
        };
        me.unload = function () {
            var i;
            for (i = m.map_cache.length - 1; i >= 0; i--) {
                if (m.map_cache[i]) {
                    me.unbind.call($(m.map_cache[i].image));
                }
            }
            me.graphics = null;
        };

        me.snapshot = function () {
            return (new m.Method(this,
                function () {
                    $.each(this.data, function (i, e) {
                        e.selected = false;
                    });

                    this.base_canvas = this.graphics.createVisibleCanvas(this);
                    $(this.image).before(this.base_canvas);
                },
                null,
                { name: 'snapshot' }
            )).go();
        };
        
        // do not queue this function
        
        me.state = function () {
            var md, result = null;
            $(this).each(function (i,e) {
                if (e.nodeName === 'IMG') {
                    md = m.getMapData(e);
                    if (md) {
                        result = md.state();
                    }
                    return false;
                }
            });
            return result;
        };

        me.bind = function (options) {

            return this.each(function (i,e) {
                var img, map, usemap, md;

                // save ref to this image even if we can't access it yet. commands will be queued
                img = $(e);

                md = m.getMapData(e);

                // if already bound completely, do a total rebind
                
                if (md) {
                    me.unbind.apply(img);
                    if (!md.complete) {
                        // will be queued
                        img.bind();
                        return true;
                    }
                    md = null;
                }

                // ensure it's a valid image
                // jQuery bug with Opera, results in full-url#usemap being returned from jQuery's attr.
                // So use raw getAttribute instead.
                
                usemap = this.getAttribute('usemap');
                map = usemap && $('map[name="' + usemap.substr(1) + '"]');
                if (!(img.is('img') && usemap && map.size() > 0)) {
                    return true;
                }

                // sorry - your image must have border:0, things are too unpredictable otherwise.
                img.css('border', 0);

                if (!md) {
                    md = new m.MapData(this, options);

                    md.index = addMap(md);
                    md.map = map;
                    md.bindImages().then(function() {
                        md.initialize();
                    });
                }
            });
        };

        me.init = function (useCanvas) {
            var style, shapes;

            // for testing/debugging, use of canvas can be forced by initializing 
            // manually with "true" or "false". But generally we test for it.
            
            m.hasCanvas = function() {
                if (!u.isBool(m.hasCanvas.value)) {
                    m.hasCanvas.value = u.isBool(useCanvas) ?
                        useCanvas : 
                        hasCanvas();
                }
                return m.hasCanvas.value;
            };
            m.hasVml = function() {
                if (!u.isBool(m.hasVml.value)) {
                    // initialize VML the first time we detect its presence.
                    var d = namespaces();

                    if (d && !d.v) {
                        d.add("v", "urn:schemas-microsoft-com:vml");
                        style = document.createStyleSheet();
                        shapes = ['shape', 'rect', 'oval', 'circ', 'fill', 'stroke', 'imagedata', 'group', 'textbox'];
                        $.each(shapes,
                        function (i, el) {
                            style.addRule('v\\:' + el, "behavior: url(#default#VML); antialias:true");
                        });
                    }
                    m.hasVml.value = hasVml();
                }

                return m.hasVml.value;
            };

            m.isTouch = !!document.documentElement.ontouchstart;

            $.extend(m.defaults, m.render_defaults,m.shared_defaults);
            $.extend(m.area_defaults, m.render_defaults,m.shared_defaults);
            
        };
        me.test = function (obj) {
            return eval(obj);
        };
        return me;
    } ());
    
    $.mapster.impl.init();
    
    
} (jQuery));
/* graphics.js
   Graphics object handles all rendering.
*/
(function ($) {
    var p, m=$.mapster,
        u=m.utils,
        canvasMethods,
        vmlMethods;
    
    /**
     * Implemenation to add each area in an AreaData object to the canvas
     * @param {Graphics} graphics The target graphics object
     * @param {AreaData} areaData The AreaData object (a collection of area elements and metadata)
     * @param {object} options Rendering options to apply when rendering this group of areas
     */
    function addShapeGroupImpl(graphics, areaData, options) {
        var me = graphics,
            md = me.map_data,
            isMask = options.isMask;

        // first get area options. Then override fade for selecting, and finally merge in the 
        // "select" effect options.

        $.each(areaData.areas(), function (i,e) {
            options.isMask = isMask || (e.nohref && md.options.noHrefIsMask);
            me.addShape(e, options);
        });

        // it's faster just to manipulate the passed options isMask property and restore it, than to 
        // copy the object each time
        
        options.isMask=isMask;

    }

     /**
     * Convert a hex value to decimal
     * @param  {string} hex A hexadecimal toString
     * @return {int} Integer represenation of the hex string
     */

    function hex_to_decimal(hex) {
        return Math.max(0, Math.min(parseInt(hex, 16), 255));
    }
    function css3color(color, opacity) {
        return 'rgba(' + hex_to_decimal(color.substr(0, 2)) + ','
                + hex_to_decimal(color.substr(2, 2)) + ','
                + hex_to_decimal(color.substr(4, 2)) + ',' + opacity + ')';
    }
    /**
     * An object associated with a particular map_data instance to manage renderin.
     * @param {MapData} map_data The MapData object bound to this instance
     */
    
    m.Graphics = function (map_data) {
        //$(window).unload($.mapster.unload);
        // create graphics functions for canvas and vml browsers. usage:
        // 1) init with map_data, 2) call begin with canvas to be used (these are separate b/c may not require canvas to be specified
        // 3) call add_shape_to for each shape or mask, 4) call render() to finish

        var me = this;
        me.active = false;
        me.canvas = null;
        me.width = 0;
        me.height = 0;
        me.shapes = [];
        me.masks = [];
        me.map_data = map_data;
    };
    
    p = m.Graphics.prototype= {
        constructor: m.Graphics,

        /**
         * Initiate a graphics request for a canvas
         * @param  {Element} canvas The canvas element that is the target of this operation
         * @param  {string} [elementName] The name to assign to the element (VML only)
         */
        
        begin: function(canvas, elementName) {
            var c = $(canvas);

            this.elementName = elementName;
            this.canvas = canvas;

            this.width = c.width();
            this.height = c.height();
            this.shapes = [];
            this.masks = [];
            this.active = true;

        },
        
        /**
         * Add an area to be rendered to this canvas. 
         * @param {MapArea} mapArea The MapArea object to render
         * @param {object} options An object containing any rendering options that should override the
         *                         defaults for the area
         */
        
        addShape: function(mapArea, options) {
            var addto = options.isMask ? this.masks : this.shapes;
            addto.push({ mapArea: mapArea, options: options });
        },

        /**
         * Create a canvas that is sized and styled for the MapData object
         * @param  {MapData} mapData The MapData object that will receive this new canvas
         * @return {Element} A canvas element
         */
        
        createVisibleCanvas: function (mapData) {
            return $(this.createCanvasFor(mapData))
                .addClass('mapster_el')
                .css(m.canvas_style)[0];
        },

        /**
         * Add a group of shapes from an AreaData object to the canvas
         * 
         * @param {AreaData} areaData An AreaData object (a set of area elements)
         * @param {string} mode     The rendering mode, "select" or "highlight". This determines the target 
         *                          canvas and which default options to use.
         * @param {striong} options  Rendering options
         */
        
        addShapeGroup: function (areaData, mode,options) {
            // render includeKeys first - because they could be masks
            var me = this,
                list, name, canvas,
                map_data = this.map_data,
                opts = areaData.effectiveRenderOptions(mode);

            if (options) {
                 $.extend(opts,options);
            }

            if (mode === 'select') {
                name = "static_" + areaData.areaId.toString();
                canvas = map_data.base_canvas;
            } else {
                canvas = map_data.overlay_canvas;
            }

            me.begin(canvas, name);

            if (opts.includeKeys) {
                list = u.split(opts.includeKeys);
                $.each(list, function (i,e) {
                    var areaData = map_data.getDataForKey(e.toString());
                    addShapeGroupImpl(me,areaData, areaData.effectiveRenderOptions(mode));
                });
            }

            addShapeGroupImpl(me,areaData, opts);
            me.render();
            if (opts.fade) {
                
                // fading requires special handling for IE. We must access the fill elements directly. The fader also has to deal with 
                // the "opacity" attribute (not css)

                u.fader(m.hasCanvas() ? 
                    canvas : 
                    $(canvas).find('._fill').not('.mapster_mask'),
                0,
                m.hasCanvas() ? 
                    1 : 
                    opts.fillOpacity,
                opts.fadeDuration); 
               
            }

        }

        // These prototype methods are implementation dependent
    };

    function noop() {}

  
    // configure remaining prototype methods for ie or canvas-supporting browser

    canvasMethods = {
        renderShape: function (context, mapArea, offset) {
            var i,
                c = mapArea.coords(null,offset);

            switch (mapArea.shape) {
                case 'rect':
                    context.rect(c[0], c[1], c[2] - c[0], c[3] - c[1]);
                    break;
                case 'poly':
                    context.moveTo(c[0], c[1]);

                    for (i = 2; i < mapArea.length; i += 2) {
                        context.lineTo(c[i], c[i + 1]);
                    }
                    context.lineTo(c[0], c[1]);
                    break;
                case 'circ':
                case 'circle':
                    context.arc(c[0], c[1], c[2], 0, Math.PI * 2, false);
                    break;
            }
        },
        addAltImage: function (context, image, mapArea, options) {
            context.beginPath();

            this.renderShape(context, mapArea);
            context.closePath();
            context.clip();

            context.globalAlpha = options.altImageOpacity || options.fillOpacity;

            context.drawImage(image, 0, 0, mapArea.owner.scaleInfo.width, mapArea.owner.scaleInfo.height);
        },
        render: function () {
            // firefox 6.0 context.save() seems to be broken. to work around,  we have to draw the contents on one temp canvas,
            // the mask on another, and merge everything. ugh. fixed in 1.2.2. unfortunately this is a lot more code for masks,
            // but no other way around it that i can see.

            var maskCanvas, maskContext,
                        me = this,
                        md = me.map_data,
                        hasMasks = me.masks.length,
                        shapeCanvas = me.createCanvasFor(md),
                        shapeContext = shapeCanvas.getContext('2d'),
                        context = me.canvas.getContext('2d');

            if (hasMasks) {
                maskCanvas = me.createCanvasFor(md);
                maskContext = maskCanvas.getContext('2d');
                maskContext.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

                $.each(me.masks, function (i,e) {
                    maskContext.save();
                    maskContext.beginPath();
                    me.renderShape(maskContext, e.mapArea);
                    maskContext.closePath();
                    maskContext.clip();
                    maskContext.lineWidth = 0;
                    maskContext.fillStyle = '#000';
                    maskContext.fill();
                    maskContext.restore();
                });

            }

            $.each(me.shapes, function (i,s) {
                shapeContext.save();
                if (s.options.fill) {
                    if (s.options.altImageId) {
                        me.addAltImage(shapeContext, md.images[s.options.altImageId], s.mapArea, s.options);
                    } else {
                        shapeContext.beginPath();
                        me.renderShape(shapeContext, s.mapArea);
                        shapeContext.closePath();
                        //shapeContext.clip();
                        shapeContext.fillStyle = css3color(s.options.fillColor, s.options.fillOpacity);
                        shapeContext.fill();
                    }
                }
                shapeContext.restore();
            });


            // render strokes at end since masks get stroked too

            $.each(me.shapes.concat(me.masks), function (i,s) {
                var offset = s.options.strokeWidth === 1 ? 0.5 : 0;
                // offset applies only when stroke width is 1 and stroke would render between pixels.

                if (s.options.stroke) {
                    shapeContext.save();
                    shapeContext.strokeStyle = css3color(s.options.strokeColor, s.options.strokeOpacity);
                    shapeContext.lineWidth = s.options.strokeWidth;

                    shapeContext.beginPath();

                    me.renderShape(shapeContext, s.mapArea, offset);
                    shapeContext.closePath();
                    shapeContext.stroke();
                    shapeContext.restore();
                }
            });

            if (hasMasks) {
                // render the new shapes against the mask

                maskContext.globalCompositeOperation = "source-out";
                maskContext.drawImage(shapeCanvas, 0, 0);

                // flatten into the main canvas
                context.drawImage(maskCanvas, 0, 0);
            } else {
                context.drawImage(shapeCanvas, 0, 0);
            }

            me.active = false;
            return me.canvas;
        },

        // create a canvas mimicing dimensions of an existing element
        createCanvasFor: function (md) {
            return $('<canvas width="' + md.scaleInfo.width + '" height="' +md.scaleInfo.height + '"></canvas>')[0];
        },
        clearHighlight: function () {
            var c = this.map_data.overlay_canvas;
            c.getContext('2d').clearRect(0, 0, c.width, c.height);
        },
        // Draw all items from selected_list to a new canvas, then swap with the old one. This is used to delete items when using canvases.
        refreshSelections: function () {
            var canvas_temp, map_data = this.map_data;
            // draw new base canvas, then swap with the old one to avoid flickering
            canvas_temp = map_data.base_canvas;

            map_data.base_canvas = this.createVisibleCanvas(map_data);
            $(map_data.base_canvas).hide();
            $(canvas_temp).before(map_data.base_canvas);

            map_data.redrawSelections();

            $(map_data.base_canvas).show();
            $(canvas_temp).remove();
        }
    };

    vmlMethods = {

        renderShape: function (mapArea, options, cssclass) {
            var me = this, fill,stroke, e, t_fill, el_name, el_class, template, c = mapArea.coords();
            el_name = me.elementName ? 'name="' + me.elementName + '" ' : '';
            el_class = cssclass ? 'class="' + cssclass + '" ' : '';

            t_fill = '<v:fill color="#' + options.fillColor + '" class="_fill" opacity="' + 
                (options.fill ? 
                    options.fillOpacity :
                    0) + 
                '" /><v:stroke class="_fill" opacity="' + 
                options.strokeOpacity + '"/>';


            stroke = options.stroke ?
                ' strokeweight=' + options.strokeWidth + ' stroked="t" strokecolor="#' + 
                    options.strokeColor + '"' :
                ' stroked="f"';
            
            fill = options.fill ? 
                ' filled="t"' :
                ' filled="f"';

            switch (mapArea.shape) {
                case 'rect':
                    template = '<v:rect ' + el_class + el_name + fill + stroke + 
                        ' style="zoom:1;margin:0;padding:0;display:block;position:absolute;left:' + 
                          c[0] + 'px;top:' + c[1]  + 'px;width:' + (c[2] - c[0]) + 
                          'px;height:' + (c[3] - c[1]) + 'px;">' + t_fill + '</v:rect>';
                    break;
                case 'poly':
                    template = '<v:shape ' + el_class + el_name + fill + stroke + ' coordorigin="0,0" coordsize="' + me.width + ',' + me.height
                                + '" path="m ' + c[0] + ',' + c[1] + ' l ' + c.slice(2).join(',')
                                + ' x e" style="zoom:1;margin:0;padding:0;display:block;position:absolute;top:0px;left:0px;width:' + me.width + 'px;height:' + me.height + 'px;">' + t_fill + '</v:shape>';
                    break;
                case 'circ':
                case 'circle':
                    template = '<v:oval ' + el_class + el_name + fill + stroke
                                + ' style="zoom:1;margin:0;padding:0;display:block;position:absolute;left:' + (c[0] - c[2]) + 'px;top:' + (c[1] - c[2])
                                + 'px;width:' + (c[2] * 2) + 'px;height:' + (c[2] * 2) + 'px;">' + t_fill + '</v:oval>';
                    break;
            }
            e = $(template);
            $(me.canvas).append(e);

            return e;
        },
        render: function () {
            var opts, me = this;

            $.each(this.shapes, function (i,e) {
                me.renderShape(e.mapArea, e.options);
            });

            if (this.masks.length) {
                $.each(this.masks, function (i,e) {
                    opts = u.updateProps({},
                        e.options, {
                            fillOpacity: 1,
                            fillColor: e.options.fillColorMask
                        });
                    me.renderShape(e.mapArea, opts, 'mapster_mask');
                });
            }

            this.active = false;
            return this.canvas;
        },

        createCanvasFor: function (md) {
            var w = md.scaleInfo.width,
                h = md.scaleInfo.height;
            return $('<var width="' + w + '" height="' + h 
                + '" style="zoom:1;overflow:hidden;display:block;width:' 
                + w + 'px;height:' + h + 'px;"></var>')[0];
        },

        clearHighlight: function () {
            $(this.map_data.overlay_canvas).children().remove();
        },
        // remove single or all selections
        removeSelections: function (area_id) {
            if (area_id >= 0) {
                $(this.map_data.base_canvas).find('[name="static_' + area_id.toString() + '"]').remove();
            }
            else {
                $(this.map_data.base_canvas).children().remove();
            }
        }

    };

    // for all methods with two implemenatations, add a function that will automatically replace itself with the correct
    // method on first invocation
    
    $.each(['renderShape',
           'addAltImage',
           'render',
           'createCanvasFor',
           'clearHighlight',
           'removeSelections',
           'refreshSelections'],
        function(i,e) {
            p[e]=(function(method) {
                return function() {
                    p[method] = (m.hasCanvas() ?
                        canvasMethods[method] : 
                        vmlMethods[method]) || noop;
                  
                    return p[method].apply(this,arguments);
                };
            }(e));
    });


} (jQuery));
/* mapimage.js
   the MapImage object, repesents an instance of a single bound imagemap
*/

(function ($) {

    var m = $.mapster, 
        u = m.utils,
        ap=[];
    /**
     * An object encapsulating all the images used by a MapData.
     */
    
    m.MapImages = function(owner) {
        this.owner = owner;
        this.clear();
    };

    
    m.MapImages.prototype = {
        constructor: m.MapImages,

        /* interface to make this array-like */

        slice: function() {
            return ap.slice.apply(this,arguments);
        },
        splice: function() {
            ap.slice.apply(this.status,arguments);
            var result= ap.slice.apply(this,arguments);
            return result;
        },
     
        /** 
         * a boolean value indicates whether all images are done loading 
         * @return {bool} true when all are done
         */
        complete: function() {
            return $.inArray(false, this.status) < 0;
        },
        
        /**
         * Save an image in the images array and return its index 
         * @param  {Image} image An Image object
         * @return {int} the index of the image
         */
        
        _add: function(image) {
            var index = ap.push.call(this,image)-1;
            this.status[index] = false;
            return index;
        },

        /**
         * Return the index of an Image within the images array
         * @param  {Image} img An Image
         * @return {int} the index within the array, or -1 if it was not found
         */
        
        indexOf: function(image) {
            return $.inArray(image, this);
        },
        
        /**
         * Clear this object and reset it to its initial state after binding.
         */
        
        clear: function() {
            var me=this;

            if (me.ids && me.ids.length>0) {
                $.each(me.ids,function(i,e) {
                    delete me[e];
                });
            }
            
            /**
             * A list of the cross-reference IDs bound to this object
             * @type {string[]}
             */
            
            me.ids=[];

            /**
             * Length property for array-like behavior, set to zero when initializing. Array prototype
             * methods will update it after that.
             * 
             * @type {int}
             */
            
            me.length=0;

            /**
             * the loaded status of the corresponding image
             * @type {boolean[]}
             */
            
            me.status=[];
            
            
            // actually erase the images
            
            me.splice(0);
            
        },

        /**
         * Bind an image to the map and add it to the queue to be loaded; return an ID that
         * can be used to reference the
         * 
         * @param {Image|string} image An Image object or a URL to an image
         * @param {string} [id] An id to refer to this image
         * @returns {int} an ID referencing the index of the image object in 
         *                map_data.images
         */
     
        add: function(image,id) {
            var index,src,me = this;

            if (!image) { return; }

            if (typeof image === 'string') {
                src = image;
                image = me[src];
                if (typeof image==='object') {
                    return me.indexOf(image);
                }

                image = $('<img />')
                    .addClass('mapster_el')
                    .hide();

                index=me._add(image[0]);
                
                image
                    .bind('load',function(e) {
                        me.imageLoaded.call(me,e);
                    })
                    .bind('error',function(e) {
                        me.imageLoadError.call(me,e);
                    });
                
                image.attr('src', src);
            } else {

                // use attr because we want the actual source, not the resolved path the browser will return directly calling image.src
                
                index=me._add($(image)[0]);
            }
            if (id) {
                if (this[id]) {
                    throw(id+" is already used or is not available as an altImage alias.");
                }
                me.ids.push(id);
                me[id]=me[index];
            }
            return index;
        },

        /**
         * Bind the images in this object, 
         * @param  {boolean} retry when true, indicates that the function is calling itself after failure 
         * @return {Promise} a promise that resolves when the images have finished loading
         */
        
        bind: function(retry) {
            var me = this,
                promise,
                triesLeft = me.owner.options.configTimeout / 200,

            /* A recursive function to continue checking that the images have been 
               loaded until a timeout has elapsed */

            check=function() {
                var i;

                // refresh status of images
                
                i=me.length;

                while (i-->0) {
                    if (!me.isLoaded(i)) {
                        break;
                    }
                }

                // check to see if every image has already been loaded
                
                if (me.complete()) {
                    me.resolve();
                } else {
                    // to account for failure of onLoad to fire in rare situations
                    if (triesLeft-- > 0) {
                        me.imgTimeout=window.setTimeout(function() {
                            check.call(me,true);
                        }, 50);
                    } else {
                        me.imageLoadError.call(me);
                    }
                }
            
            };

            promise = me.deferred=u.defer();
            
            check();
            return promise;
        },
   
        resolve: function() {
            var me=this,
                resolver=me.deferred;
                
            if (resolver) {
                // Make a copy of the resolver before calling & removing it to ensure
                // it is not called twice
                me.deferred=null;
                resolver.resolve();
            }
        },

        /**
         * Event handler for image onload
         * @param  {object} e jQuery event data
         */
        
        imageLoaded: function(e) {
            var me=this,
                index = me.indexOf(e.target);

            if (index>=0) {

                me.status[index] = true;
                if ($.inArray(false, me.status) < 0) {
                    me.resolve();
                }
            }
        },
        
        /**
         * Event handler for onload error
         * @param  {object} e jQuery event data
         */
        
        imageLoadError: function(e) {
            clearTimeout(this.imgTimeout);
            this.triesLeft=0;
            var err = e ? 'The image ' + e.target.src + ' failed to load.' : 
                'The images never seemed to finish loading. You may just need to increase the configTimeout if images could take a long time to load.';
            throw err;
        },
        /**
         * Test if the image at specificed index has finished loading
         * @param  {int}  index The image index
         * @return {boolean} true if loaded, false if not
         */
        
        isLoaded: function(index) {
            var img,
                me=this,
                status=me.status;

            if (status[index]) { return true; }
            img = me[index];
            
            if (typeof img.complete !== 'undefined') {
                status[index]=img.complete;
            } else {
                status[index]=!!u.imgWidth(img);
            }
            // if complete passes, the image is loaded, but may STILL not be available because of stuff like adblock.
            // make sure it is.

            return status[index];
        }
    };
    } (jQuery));
/* mapdata.js
   the MapData object, repesents an instance of a single bound imagemap
*/


(function ($) {

    var m = $.mapster, 
        u = m.utils;
   
    /**
     * Set default values for MapData object properties
     * @param  {MapData} me The MapData object
     */
    
    function initializeDefaults(me) {
        $.extend(me,{
            complete: false,         // (bool)    when configuration is complete       
            map: null,                // ($)      the image map
            base_canvas: null,       // (canvas|var)  where selections are rendered
            overlay_canvas: null,    // (canvas|var)  where highlights are rendered
            commands: [],            // {}        commands that were run before configuration was completed (b/c images weren't loaded)
            data: [],                // MapData[] area groups
            mapAreas: [],            // MapArea[] list. AreaData entities contain refs to this array, so options are stored with each.
            _xref: {},               // (int)      xref of mapKeys to data[]
            highlightId: -1,        // (int)      the currently highlighted element.
            currentAreaId: -1,
            _tooltip_events: [],     // {}         info on events we bound to a tooltip container, so we can properly unbind them
            scaleInfo: null,         // {}         info about the image size, scaling, defaults
            index: -1,                 // index of this in map_cache - so we have an ID to use for wraper div
            activeAreaEvent: null
        });
    }

    /**
     * Return an array of all image-containing options from an options object; 
     * that is, containers that may have an "altImage" property
     * 
     * @param  {object} obj     An options object
     * @return {object[]}       An array of objects
     */
    function getOptionImages(obj) {
        return [obj, obj.render_highlight, obj.render_select];
    }

    /**
     * Parse all the altImage references, adding them to the library so they can be preloaded
     * and aliased.
     * 
     * @param  {MapData} me The MapData object on which to operate
     */
    function configureAltImages(me)
    {
        var opts = me.options,
            mi = me.images;

        // add alt images
        
        if (m.hasCanvas()) {
            // map altImage library first
            
            $.each(opts.altImages || {}, function(i,e) {
                mi.add(e,i);
            });
            
            // now find everything else

            $.each([opts].concat(opts.areas),function(i,e) {
                $.each(getOptionImages(e),function(i2,e2) {
                    if (e2 && e2.altImage) {
                        e2.altImageId=mi.add(e2.altImage);
                    }
                });
            });
        }

        // set area_options
        me.area_options = u.updateProps({}, // default options for any MapArea
            m.area_defaults,
            opts);
    }

    /**
     * Queue a mouse move action based on current delay settings 
     * (helper for mouseover/mouseout handlers)
     * 
     * @param  {MapData}    me       The MapData context
     * @param  {number}     delay    The number of milliseconds to delay the action
     * @param  {AreaData}   area     AreaData affected
     * @param  {Deferred}   deferred A deferred object to return (instead of a new one)
     * @return {Promise}    A promise that resolves when the action is completed
     */
    function queueMouseEvent(me,delay,area, deferred) {
        
        deferred = deferred || u.when.defer();

        function cbFinal(areaId) {
            if (me.currentAreaId!==areaId && me.highlightId>=0) {
                deferred.resolve();
            }
        }
        if (me.activeAreaEvent) {
            window.clearTimeout(me.activeAreaEvent);
            me.activeAreaEvent=0;
        }
        if (delay<0) {
            return;
        }

        if (area.owner.currentAction || delay) {
            me.activeAreaEvent = window.setTimeout((function() {
                    return function() {
                        queueMouseEvent(me,0,area,deferred);
                    };
                }(area)),
                delay || 100);
        } else {
             cbFinal(area.areaId);
        }
        return deferred;
    }

     /**
     * Mousedown event. This is captured only to prevent browser from drawing an outline around an
     * area when it's clicked.
     *
     * @param  {EventData} e jQuery event data
     */
    
    function mousedown(e) {
        if (!m.hasCanvas()) {
            this.blur();
        }
        e.preventDefault();
    }

    /**
     * Mouseover event. Handle highlight rendering and client callback on mouseover
     * 
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */
    
    function mouseover(me,e) {
        var arData = me.getAllDataForArea(this),
            ar=arData.length ? arData[0] : null;

        // mouseover events are ignored entirely while resizing, though we do care about mouseout events
        // and must queue the action to keep things clean.

        if (!ar || ar.isNotRendered() || ar.owner.currentAction) {
            return;
        }

        if (me.currentAreaId === ar.areaId) {
            return;
        }
        if (me.highlightId !== ar.areaId) {
            me.clearEffects();

            ar.highlight();

            if (me.options.showToolTip) {
                $.each(arData,function(i,e) {
                    if (e.effectiveOptions().toolTip) {
                        e.showToolTip();
                    }
                });
            }
        }

        me.currentAreaId = ar.areaId;

        if ($.isFunction(me.options.onMouseover)) {
            me.options.onMouseover.call(this,
            {
                e: e,
                options:ar.effectiveOptions(),
                key: ar.key,
                selected: ar.isSelected()
            });
        }
    }

    /**
     * Mouseout event.
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */
    
    function mouseout(me,e) {
        var newArea,
            ar = me.getDataForArea(this),
            opts = me.options;


        if (me.currentAreaId<0 || !ar) {
            return;
        }

        newArea=me.getDataForArea(e.relatedTarget);
        
        if (newArea === ar) {
            return;
        }

        me.currentAreaId = -1;
        ar.area=null;

        queueMouseEvent(me,opts.mouseoutDelay,ar)
            .then(me.clearEffects);

        if ($.isFunction(opts.onMouseout)) {
            opts.onMouseout.call(this,
            {
                e: e,
                options: opts,
                key: ar.key,
                selected: ar.isSelected()
            });
        }

    }
    
    /**
     * Clear any active tooltip or highlight
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */
    
    function clearEffects(me) {
        var opts = me.options;

        me.ensureNoHighlight();

        if (opts.toolTipClose 
            && $.inArray('area-mouseout', opts.toolTipClose) >= 0 
            && me.activeToolTip) 
        {
            me.clearToolTip();
        }
    }

    /**
     * Mouse click event handler
     *
     * @param  {MapData} me The MapData context
     * @param  {EventData} e jQuery event data
     * @return {[type]}   [description]
     */
    
    function click(me,e) {
        var selected, list, list_target, newSelectionState, canChangeState, cbResult,
            that = this,
            ar = me.getDataForArea(this),
            opts = me.options;

        function clickArea(ar) {
            var areaOpts,target;
            canChangeState = (ar.isSelectable() &&
                (ar.isDeselectable() || !ar.isSelected()));
            
            if (canChangeState) {
                newSelectionState = !ar.isSelected();
            } else {
                newSelectionState = ar.isSelected();
            }

            list_target = m.getBoundList(opts, ar.key);

            if ($.isFunction(opts.onClick)) 
            {
                cbResult= opts.onClick.call(that,
                {
                    e: e,
                    listTarget: list_target,
                    key: ar.key,
                    selected: newSelectionState
                });

                if (u.isBool(cbResult)) {
                    if (!cbResult) {
                        return false;
                    }
                    target = $(ar.area).attr('href');
                    if (target!=='#') {
                        window.location.href=target;
                        return false;
                    }
                }
            }

            if (canChangeState) {
                selected = ar.toggle();
            }

            if (opts.boundList && opts.boundList.length > 0) {
                m.setBoundListProperties(opts, list_target, ar.isSelected());
            }

            areaOpts = ar.effectiveOptions();
            if (areaOpts.includeKeys) {
                list = u.split(areaOpts.includeKeys);
                $.each(list, function (i, e) {
                    var ar = me.getDataForKey(e.toString());
                    if (!ar.options.isMask) {
                        clickArea(ar);
                    }
                });
            }
        }

        mousedown.call(this,e);

        if (opts.clickNavigate && ar.href) {
            window.location.href=ar.href;
            return;
        }

        if (ar && !ar.owner.currentAction) {
            opts = me.options;
            clickArea(ar);
        }
    }

    /**
     * Prototype for a MapData object, representing an ImageMapster bound object
     * @param {Element} image   an IMG element
     * @param {object} options  ImageMapster binding options
     */
    m.MapData = function (image, options) 
    {
        var me = this;
        
        // (Image)  main map image
        
        me.image = image;              

        me.images = new m.MapImages(me); 
        me.graphics = new m.Graphics(me);

        // save the initial style of the image for unbinding. This is problematic, chrome 
        // duplicates styles when assigning, and cssText is apparently not universally supported.
        // Need to do something more robust to make unbinding work universally.
        
        me.imgCssText = image.style.cssText || null;

        initializeDefaults(me);

        me.configureOptions(options);
        
        // create context-bound event handlers from our private functions
        
        me.mouseover = function(e) { mouseover.call(this,me,e); };
        me.mouseout = function(e) { mouseout.call(this,me,e); };
        me.click = function(e) { click.call(this,me,e); };
        me.clearEffects = function(e) { clearEffects.call(this,me,e); };
    };

    m.MapData.prototype = {
        constructor: m.MapData,

         /**
         * Set target.options from defaults + options
         * @param  {[type]} target      The target
         * @param  {[type]} options     The options to merge
         */
        
        configureOptions: function(options) {
            this.options= u.updateProps({}, m.defaults, options);
        },

        /**
         * Ensure all images are loaded
         * @return {Promise} A promise that resolves when the images have finished loading (or fail)
         */
    
        bindImages: function() {
            var me=this,
                mi = me.images;

            // reset the images if this is a rebind
            
            if (mi.length>2) {
                mi.splice(2);
            } else if (mi.length===0) {

                // add the actual main image
                mi.add(me.image);
                // will create a duplicate of the main image, we need this to get raw size info
                mi.add(me.image.src);
            }
            
            configureAltImages(me);

            return me.images.bind();
        },

        /**
         * Test whether an async action is currently in progress
         * @return {Boolean} true or false indicating state
         */
        
        isActive: function() {
            return !this.complete || this.currentAction;
        },

        /**
         * Return an object indicating the various states. This isn't really used by 
         * production code.
         * 
         * @return {object} An object with properties for various states
         */
        
        state: function () {
            return {
                complete: this.complete,
                resizing: this.currentAction==='resizing',
                zoomed: this.zoomed,
                zoomedArea: this.zoomedArea,
                scaleInfo: this.scaleInfo
            };
        },   

        /**
         * Get a unique ID for the wrapper of this imagemapster
         * @return {string} A string that is unique to this image
         */
        
        wrapId: function () {
            return 'mapster_wrap_' + this.index;
        },
        _idFromKey: function (key) {
            return typeof key === "string" && this._xref.hasOwnProperty(key) ?
                        this._xref[key] : -1;
        },

        /**
         * Return a comma-separated string of all selected keys
         * @return {string} CSV of all keys that are currently selected
         */
        
        getSelected: function () {
            var result = '';
            $.each(this.data, function (i,e) {
                if (e.isSelected()) {
                    result += (result ? ',' : '') + this.key;
                }
            });
            return result;
        },

        /**
         * Get an array of MapAreas associated with a specific AREA based on the keys for that area
         * @param  {Element} area   An HTML AREA
         * @param  {number} atMost  A number limiting the number of areas to be returned (typically 1 or 0 for no limit)
         * @return {MapArea[]}      Array of MapArea objects
         */
        
        getAllDataForArea:function (area,atMost) {
            var i,ar, result,
                me=this,
                key = $(area).filter('area').attr(me.options.mapKey);

            if (key) {
                result=[];
                key = u.split(key);

                for (i=0;i<(atMost || key.length);i++) {
                    ar = me.data[me._idFromKey(key[i])];
                    ar.area=area.length ? area[0]:area;
                    // set the actual area moused over/selected
                    // TODO: this is a brittle model for capturing which specific area - if this method was not used,
                    // ar.area could have old data. fix this.
                    result.push(ar);
                }
            }

            return result;
        },
        getDataForArea: function(area) {
            var ar=this.getAllDataForArea(area,1);
            return ar ? ar[0] || null : null;
        },
        getDataForKey: function (key) {
            return this.data[this._idFromKey(key)];
        },
        
        /**
         * Get the primary keys associated with an area group.
         * If this is a primary key, it will be returned.
         * 
         * @param  {string key An area key
         * @return {string} A CSV of area keys
         */
        
        getKeysForGroup: function(key) {
            var ar=this.getDataForKey(key);
            
            return !ar ? '':
                ar.isPrimary ? 
                    ar.key :
                    this.getPrimaryKeysForMapAreas(ar.areas()).join(',');
        },
        
        /**
         * given an array of MapArea object, return an array of its unique primary keys
         * @param  {MapArea[]} areas The areas to analyze
         * @return {string[]} An array of unique primary keys
         */
        
        getPrimaryKeysForMapAreas: function(areas)
        {
            var keys=[];
            $.each(areas,function(i,e) {
                if ($.inArray(e.keys[0],keys)<0) {
                    keys.push(e.keys[0]);
                }
            });
            return keys;
        },
        getData: function (obj) {
            if (typeof obj === 'string') {
                return this.getDataForKey(obj);
            } else if (obj && obj.mapster || u.isElement(obj)) {
                return this.getDataForArea(obj);
            } else {
                return null;
            }
        },
        // remove highlight if present, raise event
        ensureNoHighlight: function () {
            var ar;
            if (this.highlightId >= 0) {
                this.graphics.clearHighlight();
                ar = this.data[this.highlightId];
                ar.changeState('highlight', false);
                this.setHighlightId(-1);
            }
        },
        setHighlightId: function(id) {
            this.highlightId = id;
        },
        
        /**
         * Clear all active selections on this map
         */
        
        clearSelections: function () {
            $.each(this.data, function (i,e) {
                if (e.selected) {
                    e.deselect(true);
                 }
            });
            this.removeSelectionFinish();
            
        },

        /**
         * Set area options from an array of option data.
         * 
         * @param {object[]} areas An array of objects containing area-specific options
         */
        
        setAreaOptions: function (areas) {
            var i, area_options, ar;
            areas = areas || [];

            // refer by: map_data.options[map_data.data[x].area_option_id]
            
            for (i = areas.length - 1; i >= 0; i--) {
                area_options = areas[i];
                if (area_options) {
                    ar = this.getDataForKey(area_options.key);
                    if (ar) {
                        u.updateProps(ar.options, area_options);
                        
                        // TODO: will not deselect areas that were previously selected, so this only works
                        // for an initial bind.
                        
                        if (u.isBool(area_options.selected)) {
                            ar.selected = area_options.selected;
                        }
                    }
                }
            }
        },
        // keys: a comma-separated list
        drawSelections: function (keys) {
            var i, key_arr = u.asArray(keys);

            for (i = key_arr.length - 1; i >= 0; i--) {
                this.data[key_arr[i]].drawSelection();
            }
        },
        redrawSelections: function () {
            $.each(this.data, function (i, e) {
                if (e.isSelectedOrStatic()) {
                    e.drawSelection();
                }
            });

        },
        ///called when images are done loading
        initialize: function () {
            var imgCopy, base_canvas, overlay_canvas, wrap, parentId, css, i,size,
                img,sort_func, sorted_list,  scale,  
                        me = this,
                        opts = me.options;

            if (me.complete) {
                return;
            }

            img = $(me.image);
            
            parentId = img.parent().attr('id');

            // create a div wrapper only if there's not already a wrapper, otherwise, own it
            
            if (parentId && parentId.length >= 12 && parentId.substring(0, 12) === "mapster_wrap") {
                wrap = img.parent();
                wrap.attr('id', me.wrapId());
            } else {
                wrap = $('<div id="' + me.wrapId() + '"></div>');

                if (opts.wrapClass) {
                    if (opts.wrapClass === true) {
                        wrap.addClass(img[0].className);
                    }
                    else {
                        wrap.addClass(opts.wrapClass);
                    }
                }
            }
            me.wrapper = wrap;
            
            // me.images[1] is the copy of the original image. It should be loaded & at its native size now so we can obtain the true
            // width & height. This is needed to scale the imagemap if not being shown at its native size. It is also needed purely
            // to finish binding in case the original image was not visible. It can be impossible in some browsers to obtain the
            // native size of a hidden image.

            me.scaleInfo = scale = u.scaleMap(me.images[0],me.images[1], opts.scaleMap);
            
            me.base_canvas = base_canvas = me.graphics.createVisibleCanvas(me);
            me.overlay_canvas = overlay_canvas = me.graphics.createVisibleCanvas(me);

            // Now we got what we needed from the copy -clone from the original image again to make sure any other attributes are copied
            imgCopy = $(me.images[1])
                .addClass('mapster_el '+ me.images[0].className)
                .attr({id:null, usemap: null});
                
            size=u.size(me.images[0]);
            
            if (size.complete) {
                imgCopy.css({
                    width: size.width,
                    height: size.height
                });
            }
     
            me.buildDataset();

            // now that we have processed all the areas, set css for wrapper, scale map if needed

            css = {
                display: 'block',
                position: 'relative',
                padding: 0,
                width: scale.width,
                height: scale.height
            };

            if (opts.wrapCss) {
                $.extend(css, opts.wrapCss);
            }
            // if we were rebinding with an existing wrapper, the image will aready be in it
            if (img.parent()[0] !== me.wrapper[0]) {

                img.before(me.wrapper);
            }

            wrap.css(css);

            // move all generated images into the wrapper for easy removal later

            $(me.images.slice(2)).hide();
            for (i = 1; i < me.images.length; i++) {
                wrap.append(me.images[i]);
            }

            //me.images[1].style.cssText = me.image.style.cssText;

            wrap.append(base_canvas)
                        .append(overlay_canvas)
                        .append(img.css(m.canvas_style));

            // images[0] is the original image with map, images[1] is the copy/background that is visible

            u.setOpacity(me.images[0], 0);
            $(me.images[1]).show();

            u.setOpacity(me.images[1],1);

            if (opts.isSelectable && opts.onGetList) {
                sorted_list = me.data.slice(0);
                if (opts.sortList) {
                    if (opts.sortList === "desc") {
                        sort_func = function (a, b) {
                            return a === b ? 0 : (a > b ? -1 : 1);
                        };
                    }
                    else {
                        sort_func = function (a, b) {
                            return a === b ? 0 : (a < b ? -1 : 1);
                        };
                    }

                    sorted_list.sort(function (a, b) {
                        a = a.value;
                        b = b.value;
                        return sort_func(a, b);
                    });
                }

                me.options.boundList = opts.onGetList.call(me.image, sorted_list);
            }
            
            me.complete=true;
            me.processCommandQueue();
            
            if (opts.onConfigured && typeof opts.onConfigured === 'function') {
                opts.onConfigured.call(img, true);
            }
        },

        // when rebind is true, the MapArea data will not be rebuilt.
        buildDataset: function(rebind) {
            var sel,areas,j,area_id,$area,area,curKey,mapArea,key,keys,mapAreaId,group_value,dataItem,href,
                me=this,
                opts=me.options,
                default_group;

            function addAreaData(key, value) {
                var dataItem = new m.AreaData(me, key, value);
                dataItem.areaId = me._xref[key] = me.data.push(dataItem) - 1;
                return dataItem.areaId;
            }

            me._xref = {};
            me.data = [];
            if (!rebind) {
                me.mapAreas=[];
            }

            default_group = !opts.mapKey;
            if (default_group) {
                opts.mapKey = 'data-mapster-key';
            }

            // the [attribute] selector is broken on old IE with jQuery. hasVml() is a quick and dirty
            // way to test for that
            
            sel = m.hasVml() ? 'area' :
                        (default_group ? 
                            'area[coords]' : 
                            'area[' + opts.mapKey + ']');

            areas = $(me.map).find(sel).unbind('.mapster');
                        
            for (mapAreaId = 0;mapAreaId<areas.length; mapAreaId++) {
                area_id = 0;
                area = areas[mapAreaId];
                $area = $(area);

                // skip areas with no coords - selector broken for older ie
                if (!area.coords) {
                    continue;
                }
                // Create a key if none was assigned by the user

                if (default_group) {
                     curKey=String(mapAreaId);
                    $area.attr('data-mapster-key', curKey);
                   
                } else {
                    curKey = area.getAttribute(opts.mapKey);
                }

                // conditions for which the area will be bound to mouse events
                // only bind to areas that don't have nohref. ie 6&7 cannot detect the presence of nohref, so we have to also not bind if href is missing.

                if (rebind) {
                    mapArea = me.mapAreas[$area.data('mapster')-1];
                    mapArea.configure(curKey);
                } else {
                    mapArea = new m.MapArea(me, area,curKey);
                    me.mapAreas.push(mapArea);
                }

                keys = mapArea.keys; // converted to an array by mapArea


                // Iterate through each mapKey assigned to this area
                for (j = keys.length - 1; j >= 0; j--) {
                    key = keys[j];

                    if (opts.mapValue) {
                        group_value = $area.attr(opts.mapValue);
                    }
                    if (default_group) {
                        // set an attribute so we can refer to the area by index from the DOM object if no key
                        area_id = addAreaData(me.data.length, group_value);
                        dataItem = me.data[area_id];
                        dataItem.key = key = area_id.toString();
                    }
                    else {
                        area_id = me._xref[key];
                        if (area_id >= 0) {
                            dataItem = me.data[area_id];
                            if (group_value && !me.data[area_id].value) {
                                dataItem.value = group_value;
                            }
                        }
                        else {
                            area_id = addAreaData(key, group_value);
                            dataItem = me.data[area_id];
                            dataItem.isPrimary=j===0;
                        }
                    }
                    mapArea.areaDataXref.push(area_id);
                    dataItem.areasXref.push(mapAreaId);
                }

                href=$area.attr('href');
                if (href && href!=='#' && !dataItem.href)
                {
                    dataItem.href=href;
                }

                if (!mapArea.nohref) {
                    $area.bind('click.mapster', me.click);
                       
                    if (!m.isTouch) {
                        $area.bind('mouseover.mapster', me.mouseover)
                            .bind('mouseout.mapster', me.mouseout)
                            .bind('mousedown.mapster', me.mousedown);
                        
                    }
                        
                }

                // store an ID with each area. 
                $area.data("mapster", mapAreaId+1);
            }
           
            // TODO listenToList
            //            if (opts.listenToList && opts.nitG) {
            //                opts.nitG.bind('click.mapster', event_hooks[map_data.hooks_index].listclick_hook);
            //            }

            // populate areas from config options
            me.setAreaOptions(opts.areas);
            me.redrawSelections();

        },
        processCommandQueue: function() {
            
            var cur,me=this;
            while (!me.currentAction && me.commands.length) {
                cur = me.commands[0];
                me.commands.splice(0,1);
                m.impl[cur.command].apply(cur.that, cur.args);
            }
        },
        clearEvents: function () {
            $(this.map).find('area')
                        .unbind('.mapster');
            $(this.images)
                        .unbind('.mapster');
        },
        _clearCanvases: function (preserveState) {
            // remove the canvas elements created
            if (!preserveState) {
                $(this.base_canvas).remove();
            }
            $(this.overlay_canvas).remove();
        },
        clearMapData: function (preserveState) {
            var me = this;
            this._clearCanvases(preserveState);

            // release refs to DOM elements
            $.each(this.data, function (i, e) {
                e.reset();
            });
            this.data = null;
            if (!preserveState) {
                // get rid of everything except the original image
                this.image.style.cssText = this.imgCssText;
                $(this.wrapper).before(this.image).remove();
            }

            me.images.clear();

            this.image = null;
            u.ifFunction(this.clearTooltip, this);
        },

        // Compelete cleanup process for deslecting items. Called after a batch operation, or by AreaData for single
        // operations not flagged as "partial"
        
        removeSelectionFinish: function () {
            var g = this.graphics;

            g.refreshSelections();
            // do not call ensure_no_highlight- we don't really want to unhilight it, just remove the effect
            g.clearHighlight();
        }
    };
} (jQuery));
/* areadata.js
   AreaData and MapArea protoypes
*/

(function ($) {
    var m = $.mapster, u = m.utils;
    
    /**
     * Select this area
     * 
     * @param {AreaData} me  AreaData context
     * @param {object} options Options for rendering the selection
     */
    function select(options) {
        // need to add the new one first so that the double-opacity effect leaves the current one highlighted for singleSelect
        
        var me=this, o = me.owner;
        if (o.options.singleSelect) {
            o.clearSelections();
        }

        // because areas can overlap - we can't depend on the selection state to tell us anything about the inner areas.
        // don't check if it's already selected
        if (!me.isSelected()) {
            if (options) {
                
                // cache the current options, and map the altImageId if an altimage 
                // was passed

                me.optsCache = $.extend(me.effectiveRenderOptions('select'),
                    options,
                    { 
                        altImageId: o.images.add(options.altImage)
                    });
            }

            me.drawSelection();

            me.selected = true;
            me.changeState('select', true);
        }

        if (o.options.singleSelect) {
            o.graphics.refreshSelections();
        }
    }

    /**
     * Deselect this area, optionally deferring finalization so additional areas can be deselected
     * in a single operation
     * 
     * @param  {boolean} partial when true, the caller must invoke "finishRemoveSelection" to render 
     */
    
    function deselect(partial) {
        var me=this;
        me.selected = false;
        me.changeState('select', false);

        // release information about last area options when deselecting.
        
        me.optsCache=null;
        me.owner.graphics.removeSelections(me.areaId);

        // Complete selection removal process. This is separated because it's very inefficient to perform the whole
        // process for multiple removals, as the canvas must be totally redrawn at the end of the process.ar.remove
        
        if (!partial) {
            me.owner.removeSelectionFinish();
        }
    }

    /**
     * Toggle the selection state of this area
     * @param  {object} options Rendering options, if toggling on
     * @return {bool} The new selection state
     */
    function toggle(options) {
        var me=this;
        if (!me.isSelected()) {
            me.select(options);
        }
        else {
            me.deselect();
        }
        return me.isSelected();
    }

    /**
     * An AreaData object; represents a conceptual area that can be composed of 
     * one or more MapArea objects
     * 
     * @param {MapData} owner The MapData object to which this belongs
     * @param {string} key   The key for this area
     * @param {string} value The mapValue string for this area
     */
    
    m.AreaData = function (owner, key, value) {
        $.extend(this,{
            owner: owner, 
            key: key || '',
            // means this represents the first key in a list of keys (it's the area group that gets highlighted on mouseover)
            isPrimary: true,
            areaId: -1,
            href: '',
            value: value || '',
            options:{},
            // "null" means unchanged. Use "isSelected" method to just test true/false 
            selected: null,       
            // xref to MapArea objects
            areasXref: [],
            // (temporary storage) - the actual area moused over
            area: null,
            // the last options used to render this. Cache so when re-drawing after a remove, changes in options won't
            // break already selected things. 
            optsCache: null
         });
    };

    /**
     * The public API for AreaData object
     */

    m.AreaData.prototype = {
        constuctor: m.AreaData,
        select: select,
        deselect: deselect,
        toggle: toggle,
        areas: function() {
            var i,result=[];
            for (i=0;i<this.areasXref.length;i++) {
                result.push(this.owner.mapAreas[this.areasXref[i]]);
            }
            return result;
        },
        // return all coordinates for all areas
        coords: function(offset) {
            var coords = [];
            $.each(this.areas(), function (i, el) {
                coords = coords.concat(el.coords(offset));
            });
            return coords;
        },
        reset: function () {
            $.each(this.areas(), function (i, e) {
                e.reset();
            });
            this.areasXref = [];
            this.options = null;
        },
        // Return the effective selected state of an area, incorporating staticState
        isSelectedOrStatic: function () {

            var o = this.effectiveOptions();
            return u.isBool(o.staticState) ? o.staticState :
                        this.isSelected();
        },
        isSelected: function () {
            return u.isBool(this.selected) ? this.selected :
                u.isBool(this.owner.area_options.selected) ? this.owner.area_options.selected : false;
        },
        isSelectable: function () {
            return u.isBool(this.effectiveOptions().staticState) ? false :
                        (u.isBool(this.owner.options.staticState) ? false : u.boolOrDefault(this.effectiveOptions().isSelectable,true));
        },
        isDeselectable: function () {
            return u.isBool(this.effectiveOptions().staticState) ? false :
                        (u.isBool(this.owner.options.staticState) ? false : u.boolOrDefault(this.effectiveOptions().isDeselectable,true));
        },
        isNotRendered: function() {
            var area = $(this.area);
            return area.attr('nohref') ||
                !area.attr('href') ||
                this.effectiveOptions().isMask;

        },

        
         /**
         * Return the overall options effective for this area. 
         * This should get the default options, and merge in area-specific options, finally
         * overlaying options passed by parameter
         * 
         * @param  {[type]} options  options which will supercede all other options for this area
         * @return {[type]}          the combined options
         */
        
        effectiveOptions: function (options) {
            
            var opts = u.updateProps({},
                    this.owner.area_options,
                    this.options,
                    options || {},
                    {
                        id: this.areaId 
                    }
                );

            opts.selected = this.isSelected();
            
            return opts;
        },

        /**
         * Return the options effective for this area for a "render" or "highlight" mode. 
         * This should get the default options, merge in the areas-specific options, 
         * and then the mode-specific options.
         * @param  {string} mode    'render' or 'highlight'
         * @param  {[type]} options  options which will supercede all other options for this area
         * @return {[type]}          the combined options
         */
        
        effectiveRenderOptions: function (mode, options) {
            var allOpts,opts=this.optsCache;
            
            if (!opts || mode==='highlight') {
                allOpts = this.effectiveOptions(options);
                opts = u.updateProps({},
                    allOpts,
                    allOpts["render_" + mode]
                );
                    
                if (mode!=='highlight') {
                    this.optsCache=opts;
                }
            }
            return $.extend({},opts);
        },

        // Fire callback on area state change
        changeState: function (state_type, state) {
            if ($.isFunction(this.owner.options.onStateChange)) {
                this.owner.options.onStateChange.call(this.owner.image,
                    {
                        key: this.key,
                        state: state_type,
                        selected: state
                    }
                );
            }
        },

        // highlight this area
         
        highlight: function (options) {
            var o = this.owner;
            if (this.effectiveOptions().highlight) {
                o.graphics.addShapeGroup(this, "highlight",options);
            }
            o.setHighlightId(this.areaId);
            this.changeState('highlight', true);
        },

        // select this area. if "callEvent" is true then the state change event will be called. (This method can be used
        // during config operations, in which case no event is indicated)
        
        drawSelection: function () {
        

            this.owner.graphics.addShapeGroup(this, "select");
        
        }


    };
    // represents an HTML area
    m.MapArea = function (owner,areaEl,keys) {
        if (!owner) {
            return;
        }
        var me = this;
        me.owner = owner;   // a MapData object
        me.area = areaEl;
        me.areaDataXref=[]; // a list of map_data.data[] id's for each areaData object containing this
        me.originalCoords = [];
        $.each(u.split(areaEl.coords), function (i, el) {
            me.originalCoords.push(parseFloat(el));
        });
        me.length = me.originalCoords.length;
        me.shape = areaEl.shape.toLowerCase();
        me.nohref = areaEl.nohref || !areaEl.href;
        me.configure(keys);
    };
    m.MapArea.prototype= {
        constructor: m.MapArea,
        configure: function(keys) {
            this.keys = u.split(keys);
        },
        reset: function() {
            this.area=null;
        },
        coords: function (offset) {
            return $.map(this.originalCoords,function(e) {
                return offset ? e : e+offset;
            });
        }
    };
} (jQuery));
/* areacorners.js
   determine the best place to put a box of dimensions (width,height) given a circle, rect or poly
*/

(function ($) {
    var u=$.mapster.utils;


    /**
     * Compute positions that will place a target with dimensions [width,height] outside 
     * but near the boundaries of the elements "elements". When an imagemap is passed, the 
     *
     * @param  {Element|Element[]} elements An element or an array of elements (such as a jQuery object)
     * @param  {Element} image The image to which area elements are bound, if this is an image map.
     * @param  {Element} container The contianer in which the target must be constrained (or document, if missing)
     * @param  {int} width The width of the target object
     * @return {object} a structure with the x and y positions
     */
    u.areaCorners = function (elements, image, container, width, height) {
        var pos,found, minX, minY, maxX, maxY, bestMinX, bestMaxX, bestMinY, bestMaxY, curX, curY, nest, j,
           offsetx=0, 
           offsety=0,
           rootx,
           rooty,
           iCoords,radius,angle,el,
           coords=[];

        // if a single element was passed, map it to an array
        
        elements = elements.length ? 
            elements:
            [elements];

        container = container ? 
            $(container):
            $(document.body);

        // get the relative root of calculation

        pos = container.offset();
        rootx = pos.left;
        rooty = pos.top;

        // with areas, all we know about is relative to the top-left corner of the image. We need to add an offset compared to
        // the actual container. After this calculation, offsetx/offsety can be added to either the area coords, or the target's
        // absolute position to get the correct top/left boundaries of the container.

        if (image) {
            pos = $(image).offset();
            offsetx = pos.left;
            offsety = pos.top;
        }

        // map the coordinates of any type of shape to a poly and use the logic. simpler than using three different
        // calculation methods. Circles use a 20 degree increment for this estimation.

        for (j=0;j<elements.length;j++) 
        {
            el=elements[j];
            if (el.nodeName==='AREA') {
                iCoords = u.split(el.coords,parseInt);

                switch(el.shape) {
                    case 'circle':
                        curX=iCoords[0];
                        curY=iCoords[1];
                        radius=iCoords[2];
                        coords=[];
                        for (j=0;j<360;j+=20) {
                             angle=j*Math.PI/180;
                             coords.push(curX+radius*Math.cos(angle),curY+radius*Math.sin(angle));
                        }
                        break;
                      case 'rect':
                          coords.push(iCoords[0],iCoords[1],iCoords[2],iCoords[1],iCoords[2],iCoords[3],iCoords[0],iCoords[3]);
                          break;
                      default:
                          coords=coords.concat(iCoords);
                         break;
                }

                // map area positions to it's real position in the container

                for (j=0;j<coords.length;j+=2)
                {
                    coords[j]=parseInt(coords[j],10)+offsetx;
                    coords[j+1]=parseInt(coords[j+1],10)+offsety;
                }
            } else {
                el=$(el);
                pos = el.position();
                coords.push(pos.left,pos.top,
                            pos.left+el.width(),pos.top,
                            pos.left+el.width(),pos.top+el.height(),
                            pos.left,pos.top+el.height());

            }
        }
        
        minX = minY = bestMinX = bestMinY = 999999;
        maxX = maxY = bestMaxX = bestMaxY = -1;

        for (j = coords.length - 2; j >= 0; j -= 2) {
            curX = coords[j];
            curY = coords[j + 1];
            
            if (curX < minX) {
                minX = curX;
                bestMaxY = curY;
            }
            if (curX > maxX) {
                maxX = curX;
                bestMinY = curY;
            }
            if (curY < minY) {
                minY = curY;
                bestMaxX = curX;
            }
            if (curY > maxY) {
                maxY = curY;
                bestMinX = curX;
            }

        }

        // try to figure out the best place for the tooltip
        
        if (width && height) {
            found=false;
            $.each([[bestMaxX - width, minY - height], [bestMinX, minY - height],
                             [minX - width, bestMaxY - height], [minX - width, bestMinY],
                             [maxX,bestMaxY - height], [ maxX,bestMinY],
                             [bestMaxX - width, maxY], [bestMinX, maxY]
                      ],function (i, e) {
                          if (!found && (e[0] > rootx && e[1] > rooty)) {
                              nest = e;
                              found=true;
                              return false;
                  }
             });
             
             // default to lower-right corner if nothing fit inside the boundaries of the image
             
             if (!found) {
                 nest=[maxX,maxY];
             }
        }
        return nest;
    };
} (jQuery));
/* scale.js: resize and zoom functionality
   requires areacorners.js, when.js
*/


(function ($) {
    var m = $.mapster, u = m.utils, p = m.MapArea.prototype;

    m.utils.getScaleInfo = function (eff, actual) {
        var pct;
        if (!actual) {
            pct = 1;
            actual=eff;
        } else {
            pct = eff.width / actual.width || eff.height / actual.height;
            // make sure a float error doesn't muck us up
            if (pct > 0.98 && pct < 1.02) { pct = 1; }
        }
        return {
            scale: (pct !== 1),
            scalePct: pct,
            realWidth: actual.width,
            realHeight: actual.height,
            width: eff.width,
            height: eff.height,
            ratio: eff.width / eff.height
        };
    };
    // Scale a set of AREAs, return old data as an array of objects
    m.utils.scaleMap = function (image, imageRaw, scale) {
        
        // stunningly, jQuery width can return zero even as width does not, seems to happen only
        // with adBlock or maybe other plugins. These must interfere with onload events somehow.


        var vis=u.size(image),
            raw=u.size(imageRaw,true);

        if (!raw.complete()) {
            throw("Another script, such as an extension, appears to be interfering with image loading. Please let us know about this.");
        }
        if (!vis.complete()) {
            vis=raw;
        }
        return this.getScaleInfo(vis, scale ? raw : null);
    };
    
    /**
     * Resize the image map. Only one of newWidth and newHeight should be passed to preserve scale
     * 
     * @param  {int}   width       The new width OR an object containing named parameters matching this function sig
     * @param  {int}   height      The new height
     * @param  {int}   effectDuration Time in ms for the resize animation, or zero for no animation
     * @param  {function} callback    A function to invoke when the operation finishes
     * @return {promise}              NOT YET IMPLEMENTED
     */
    
    m.MapData.prototype.resize = function (width, height, duration, callback) {
        var p,promises,newsize,els, highlightId, ratio, 
            me = this;
        
        // allow omitting duration
        callback = callback || duration;

        function sizeCanvas(canvas, w, h) {
            if (m.hasCanvas()) {
                canvas.width = w;
                canvas.height = h;
            } else {
                $(canvas).width(w);
                $(canvas).height(h);
            }
        }

        // Finalize resize action, do callback, pass control to command queue

        function cleanupAndNotify() {

            me.currentAction = '';
            
            if ($.isFunction(callback)) {
                callback();
            }
            
            me.processCommandQueue();
        }

        // handle cleanup after the inner elements are resized
        
        function finishResize() {
            sizeCanvas(me.overlay_canvas, width, height);

            // restore highlight state if it was highlighted before
            if (highlightId >= 0) {
                var areaData = me.data[highlightId];
                areaData.tempOptions = { fade: false };
                me.getDataForKey(areaData.key).highlight();
                areaData.tempOptions = null;
            }
            sizeCanvas(me.base_canvas, width, height);
            me.redrawSelections();
            cleanupAndNotify();
        }

        function resizeMapData() {
            $(me.image).css(newsize);
            // start calculation at the same time as effect
            me.scaleInfo = u.getScaleInfo({
                    width: width,
                    height: height
                },
                { 
                    width: me.scaleInfo.realWidth,
                    height: me.scaleInfo.realHeight
                });
            $.each(me.data, function (i, e) {
                $.each(e.areas(), function (i, e) {
                    e.resize();
                });
            });
        }

        if (me.scaleInfo.width === width && me.scaleInfo.height === height) {
            return;
        }

        highlightId = me.highlightId;

        
        if (!width) {
            ratio = height / me.scaleInfo.realHeight;
            width = Math.round(me.scaleInfo.realWidth * ratio);
        }
        if (!height) {
            ratio = width / me.scaleInfo.realWidth;
            height = Math.round(me.scaleInfo.realHeight * ratio);
        }

        newsize = { 'width': String(width) + 'px', 'height': String(height) + 'px' };
        if (!m.hasCanvas()) {
            $(me.base_canvas).children().remove();
        }

        // resize all the elements that are part of the map except the image itself (which is not visible)
        // but including the div wrapper
        els = $(me.wrapper).find('.mapster_el').add(me.wrapper);

        if (duration) {
            promises = [];
            me.currentAction = 'resizing';
            els.each(function (i, e) {
                p = u.defer();
                promises.push(p);

                $(e).animate(newsize, {
                    duration: duration,
                    complete: p.resolve,
                    easing: "linear"
                });
            });

            p = u.defer();
            promises.push(p);

            // though resizeMapData is not async, it needs to be finished just the same as the animations,
            // so add it to the "to do" list.
            
            u.when.all(promises).then(finishResize);
            resizeMapData();
            p.resolve();
        } else {
            els.css(newsize);
            resizeMapData();
            finishResize();
            
        }
    };


    m.MapArea = u.subclass(m.MapArea, function () {
        //change the area tag data if needed
        this.base.init();
        if (this.owner.scaleInfo.scale) {
            this.resize();
        }
    });

    p.coords = function (percent, coordOffset) {
        var j, newCoords = [],
                    pct = percent || this.owner.scaleInfo.scalePct,
                    offset = coordOffset || 0;

        if (pct === 1 && coordOffset === 0) {
            return this.originalCoords;
        }

        for (j = 0; j < this.length; j++) {
            //amount = j % 2 === 0 ? xPct : yPct;
            newCoords.push(Math.round(this.originalCoords[j] * pct) + offset);
        }
        return newCoords;
    };
    p.resize = function () {
        this.area.coords = this.coords().join(',');
    };

    p.reset = function () {
        this.area.coords = this.coords(1).join(',');
    };
    
    m.impl.resize = function (width, height, duration, callback) {
        if (!width && !height) {
            return false;
        }
        var x= (new m.Method(this,
                function () {
                    this.resize(width, height, duration, callback);
                },
                null,
                {
                    name: 'resize',
                    args: arguments
                }
            )).go();
        return x;
    };

/*
    m.impl.zoom = function (key, opts) {
        var options = opts || {};

        function zoom(areaData) {
            // this will be MapData object returned by Method

            var scroll, corners, height, width, ratio,
                    diffX, diffY, ratioX, ratioY, offsetX, offsetY, newWidth, newHeight, scrollLeft, scrollTop,
                    padding = options.padding || 0,
                    scrollBarSize = areaData ? 20 : 0,
                    me = this,
                    zoomOut = false;

            if (areaData) {
                // save original state on first zoom operation
                if (!me.zoomed) {
                    me.zoomed = true;
                    me.preZoomWidth = me.scaleInfo.width;
                    me.preZoomHeight = me.scaleInfo.height;
                    me.zoomedArea = areaData;
                    if (options.scroll) {
                        me.wrapper.css({ overflow: 'auto' });
                    }
                }
                corners = $.mapster.utils.areaCorners(areaData.coords(1, 0));
                width = me.wrapper.innerWidth() - scrollBarSize - padding * 2;
                height = me.wrapper.innerHeight() - scrollBarSize - padding * 2;
                diffX = corners.maxX - corners.minX;
                diffY = corners.maxY - corners.minY;
                ratioX = width / diffX;
                ratioY = height / diffY;
                ratio = Math.min(ratioX, ratioY);
                offsetX = (width - diffX * ratio) / 2;
                offsetY = (height - diffY * ratio) / 2;

                newWidth = me.scaleInfo.realWidth * ratio;
                newHeight = me.scaleInfo.realHeight * ratio;
                scrollLeft = (corners.minX) * ratio - padding - offsetX;
                scrollTop = (corners.minY) * ratio - padding - offsetY;
            } else {
                if (!me.zoomed) {
                    return;
                }
                zoomOut = true;
                newWidth = me.preZoomWidth;
                newHeight = me.preZoomHeight;
                scrollLeft = null;
                scrollTop = null;
            }

            this.resize({
                width: newWidth,
                height: newHeight,
                duration: options.duration,
                scroll: scroll,
                scrollLeft: scrollLeft,
                scrollTop: scrollTop,
                // closure so we can be sure values are correct
                callback: (function () {
                    var isZoomOut = zoomOut,
                            scroll = options.scroll,
                            areaD = areaData;
                    return function () {
                        if (isZoomOut) {
                            me.preZoomWidth = null;
                            me.preZoomHeight = null;
                            me.zoomed = false;
                            me.zoomedArea = false;
                            if (scroll) {
                                me.wrapper.css({ overflow: 'inherit' });
                            }
                        } else {
                            // just to be sure it wasn't canceled & restarted
                            me.zoomedArea = areaD;
                        }
                    };
                } ())
            });
        }
        return (new m.Method(this,
                function (opts) {
                    zoom.call(this);
                },
                function () {
                    zoom.call(this.owner, this);
                },
                {
                    name: 'zoom',
                    args: arguments,
                    first: true,
                    key: key
                }
                )).go();


    };
    */
} (jQuery));
/* tooltip.js - tooltip functionality
   requires areacorners.js
*/

(function ($) {

    var m = $.mapster, u = m.utils;
    
    $.extend(m.defaults, {
        toolTipContainer: '<div style="border: 2px solid black; background: #EEEEEE; width:160px; padding:4px; margin: 4px; -moz-box-shadow: 3px 3px 5px #535353; ' +
        '-webkit-box-shadow: 3px 3px 5px #535353; box-shadow: 3px 3px 5px #535353; -moz-border-radius: 6px 6px 6px 6px; -webkit-border-radius: 6px; ' +
        'border-radius: 6px 6px 6px 6px; opacity: 0.9;"></dteniv>',
        showToolTip: false,
        toolTipFade: true,
        toolTipClose: ['area-mouseout','image-mouseout'],
        onShowToolTip: null,
        onHideToolTip: null
    });
    
    $.extend(m.area_defaults, {
        toolTip: null,
        toolTipClose: null
    });
    

    /**
     * Show a tooltip positioned near this area.
     * 
     * @param {string|jquery} html A string of html or a jQuery object containing the tooltip content.
     * @param {string|jquery} [template] The html template in which to wrap the content
     * @param {string|object} [css] CSS to apply to the outermost element of the tooltip 
     * @return {jquery} The tooltip that was created
     */
    
    function createToolTip(html, template, css) {
        var tooltip;

        // wrap the template in a jQuery object, or clone the template if it's already one.
        // This assumes that anything other than a string is a jQuery object; if it's not jQuery will
        // probably throw an error.
        
        if (template) {
            tooltip = typeof template === 'string' ?
                $(template) : 
                $(template).clone();

            tooltip.append(html);
        } else {
            tooltip=$(html);
        }

        // always set display to block, or the positioning css won't work if the end user happened to
        // use a non-block type element.

        tooltip.css($.extend((css || {}),{
                display:"block",
                position:"absolute"
            })).hide();
        
        $('body').append(tooltip);

        // we must actually add the tooltip to the DOM and "show" it in order to figure out how much space it
        // consumes, and then reposition it with that knowledge.
        // We also cache the actual opacity setting to restore finally.
        
        tooltip.attr("data-opacity",tooltip.css("opacity"))
            .css("opacity",0);
        
        // doesn't really show it because opacity=0
        
        return tooltip.show();
    }


    /**
     * Show a tooltip positioned near this area.
     * 
     * @param {jquery} tooltip The tooltip
     * @param {object} [options] options for displaying the tooltip.
     *  @config {int} [left] The 0-based absolute x position for the tooltip
     *  @config {int} [top] The 0-based absolute y position for the tooltip
     *  @config {string|object} [css] CSS to apply to the outermost element of the tooltip 
     *  @config {bool} [fadeDuration] When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
     */
    
    function showToolTipImpl(tooltip,options)
    {
        var tooltipCss = { 
                "left":  options.left + "px",
                "top": options.top + "px"
            }, 
            actalOpacity=tooltip.attr("data-opacity") || 0,
            zindex = tooltip.css("z-index");
        
        if (parseInt(zindex,10)===0 
            || zindex === "auto") {
            tooltipCss["z-index"] = 9999;
        }

        tooltip.css(tooltipCss)
            .addClass('mapster_tooltip');

        
        if (options.fadeDuration && options.fadeDuration>0) {
            u.fader(tooltip[0], 0, actalOpacity, options.fadeDuration);
        } else {
            u.setOpacity(tooltip[0], actalOpacity);
        }
    }
      
    /**
     * Hide and remove active tooltips
     * 
     * @param  {MapData} this The mapdata object to which the tooltips belong
     */
    
    m.MapData.prototype.clearToolTip = function() {
        if (this.activeToolTip) {
            this.activeToolTip.stop().remove();
            this.activeToolTip = null;
            this.activeToolTipID = null;
            u.ifFunction(this.options.onHideToolTip, this);
        }
    };

    /**
     * Configure the binding between a named tooltip closing option, and a mouse event.
     *
     * If a callback is passed, it will be called when the activating event occurs, and the tooltip will
     * only closed if it returns true.
     *
     * @param  {MapData}  [this]     The MapData object to which this tooltip belongs.
     * @param  {String}   option     The name of the tooltip closing option
     * @param  {String}   event      UI event to bind to this option
     * @param  {Element}  target     The DOM element that is the target of the event
     * @param  {Function} [beforeClose] Callback when the tooltip is closed
     * @param  {Function} [onClose]  Callback when the tooltip is closed
     */
    function bindToolTipClose(options, bindOption, event, target, beforeClose, onClose) {
        var event_name = event + '.mapster-tooltip';
        
        if ($.inArray(bindOption, options) >= 0) {
            target.unbind(event_name)
                .bind(event_name, function (e) {
                    if (!beforeClose || beforeClose.call(this,e)) {
                        target.unbind('.mapster-tooltip');
                        if (onClose) {
                            onClose.call(this);
                        }
                    }
                });
            
            return {
                object: target, 
                event: event_name
            };
        }
    }
    
    /**
     * Show a tooltip.
     *
     * @param {string|jquery}   [tooltip]       A string of html or a jQuery object containing the tooltip content.
     * 
     * @param {string|jquery}   [target]        The target of the tooltip, to be used to determine positioning. If null,
     *                                          absolute position values must be passed with left and top.
     *
     * @param {string|jquery}   [image]         If target is an [area] the image that owns it
     * 
     * @param {string|jquery}   [container]     An element within which the tooltip must be bounded
     *
     *
     * 
     * @param {object|string|jQuery} [options]  options to apply when creating this tooltip - OR -
     *                                          The markup, or a jquery object, containing the data for the tooltip 
     *                                         
     *  @config {string}        [closeEvents]   A string with one or more comma-separated values that determine when the tooltip
     *                                          closes: 'area-click','tooltip-click','image-mouseout' are valid values
     *                                          then no template will be used.
     *  @config {int}           [offsetx]       the horizontal amount to offset the tooltip 
     *  @config {int}           [offsety]       the vertical amount to offset the tooltip 
     *  @config {string|object} [css]           CSS to apply to the outermost element of the tooltip 
     */
    
    function showToolTip(tooltip,target,image,container,options) {
        var corners,
            ttopts = {};
    
        options = options || {};


        if (target) {

            corners = u.areaCorners(target,image,container,
                                    tooltip.outerWidth(true),
                                    tooltip.outerHeight(true));

            // Try to upper-left align it first, if that doesn't work, change the parameters

            ttopts.left = corners[0];
            ttopts.top = corners[1];

        } else {
            
            ttopts.left = options.left;
            ttopts.top = options.top;
        }

        ttopts.left += (options.offsetx || 0);
        ttopts.top +=(options.offsety || 0);

        ttopts.css= options.css;
        ttopts.fadeDuration = options.fadeDuration;

        showToolTipImpl(tooltip,ttopts);

        return tooltip;
    }
    
    /**
     * Show a tooltip positioned near this area.
      *
     * @param {string|jquery}   [content]       A string of html or a jQuery object containing the tooltip content.
     
     * @param {object|string|jQuery} [options]  options to apply when creating this tooltip - OR -
     *                                          The markup, or a jquery object, containing the data for the tooltip 
     *  @config {string|jquery}   [container]     An element within which the tooltip must be bounded
     *  @config {bool}          [template]      a template to use instead of the default. If this property exists and is null,
     *                                          then no template will be used.
     *  @config {string}        [closeEvents]   A string with one or more comma-separated values that determine when the tooltip
     *                                          closes: 'area-click','tooltip-click','image-mouseout' are valid values
     *                                          then no template will be used.
     *  @config {int}           [offsetx]       the horizontal amount to offset the tooltip 
     *  @config {int}           [offsety]       the vertical amount to offset the tooltip 
     *  @config {string|object} [css]           CSS to apply to the outermost element of the tooltip 
     */
    m.AreaData.prototype.showToolTip= function(content,options) {
        var tooltip, closeOpts, target, tipClosed, template,
            ttopts = {},
            ad=this,
            md=ad.owner,
            areaOpts = ad.effectiveOptions();
    
        // copy the options object so we can update it
        options = options ? $.extend({},options) : {};

        content = content || areaOpts.toolTip;
        closeOpts = options.closeEvents || areaOpts.toolTipClose || md.options.toolTipClose || 'tooltip-click';
        
        template = typeof options.template !== 'undefined' ? 
                options.template :
                md.options.toolTipContainer;

        options.closeEvents = typeof closeOpts === 'string' ?
            closeOpts = u.split(closeOpts) :
            closeOpts;

        options.fadeDuration = options.fadeDuration ||
                 (md.options.toolTipFade ? 
                    (md.options.fadeDuration || areaOpts.fadeDuration) : 0);

        target = ad.area ? 
            ad.area :
            $.map(ad.areas(),
                function(e) {
                    return e.area;
                });

        if (md.activeToolTipID===ad.areaId) {
            return;
        }

        md.clearToolTip();

        md.activeToolTip = tooltip = createToolTip(content,
            template,
            options.css);

        md.activeToolTipID = ad.areaId;

        tipClosed = function() {
            md.clearToolTip();
        };

        bindToolTipClose(closeOpts,'area-click', 'click', $(md.map), null, tipClosed);
        bindToolTipClose(closeOpts,'tooltip-click', 'click', tooltip,null, tipClosed);
        bindToolTipClose(closeOpts,'image-mouseout', 'mouseout', $(md.image), function(e) {
            return (e.relatedTarget && e.relatedTarget.nodeName!=='AREA' && e.relatedTarget!==ad.area);
        }, tipClosed);


        showToolTip(tooltip,
                    target,
                    md.image,
                    options.container,
                    template,
                    options);

        u.ifFunction(md.options.onShowToolTip, ad.area,
        {
            toolTip: tooltip,
            options: ttopts,
            areaOptions: areaOpts,
            key: ad.key,
            selected: ad.isSelected()
        });

        return tooltip;
    };
    

    /**
     * Parse an object that could be a string, a jquery object, or an object with a "contents" property
     * containing html or a jQuery object.
     * 
     * @param  {object|string|jQuery} options The parameter to parse
     * @return {string|jquery} A string or jquery object
     */
    function getHtmlFromOptions(options) {

            // see if any html was passed as either the options object itself, or the content property

            return (options ?
                ((typeof options === 'string' || options.jquery) ?
                    options :
                    options.content) :
                null);
    }

    /**
     * Activate or remove a tooltip for an area. When this method is called on an area, the
     * key parameter doesn't apply and "options" is the first parameter.
     *
     * When called with no parameters, or "key" is a falsy value, any active tooltip is cleared.
     * 
     * When only a key is provided, the default tooltip for the area is used. 
     * 
     * When html is provided, this is used instead of the default tooltip.
     * 
     * When "noTemplate" is true, the default tooltip template will not be used either, meaning only
     * the actual html passed will be used.
     *  
     * @param  {string|AreaElement} key The area for which to activate a tooltip, or a DOM element.
     * 
     * @param {object|string|jquery} [options] options to apply when creating this tooltip - OR -
     *                                         The markup, or a jquery object, containing the data for the tooltip 
     *  @config {string|jQuery} [content]   the inner content of the tooltip; the tooltip text or HTML
     *  @config {Element|jQuery} [container]   the inner content of the tooltip; the tooltip text or HTML
     *  @config {bool}          [template]  a template to use instead of the default. If this property exists and is null,
     *                                      then no template will be used.
     *  @config {int}           [offsetx]   the horizontal amount to offset the tooltip.
     *  @config {int}           [offsety]   the vertical amount to offset the tooltip.
     *  @config {string|object} [css]       CSS to apply to the outermost element of the tooltip 
     *  @config {string|object} [css] CSS to apply to the outermost element of the tooltip 
     *  @config {bool}          [fadeDuration] When non-zero, the duration in milliseconds of a fade-in effect for the tooltip.
     * @return {jQuery} The jQuery object
     */
    
    m.impl.tooltip = function (key,options) {
        return (new m.Method(this,
        function mapData() {
            var tooltip, target, md=this;
            if (!key) {
                md.clearToolTip();
            } else {
                target=$(key);
                if (md.activeToolTipID ===target[0]) {
                    return;
                }
                md.clearToolTip();

                md.activeToolTip = tooltip = createToolTip(getHtmlFromOptions(options),
                            options.template || md.options.toolTipContainer,
                            options.css);
                md.activeToolTipID = target[0];

                bindToolTipClose(['tooltip-click'],'tooltip-click', 'click', tooltip, null, function() {
                    md.clearToolTip();
                });

                md.activeToolTip = tooltip = showToolTip(tooltip,
                    target,
                    md.image,
                    options.container,
                    options);
            }
        },
        function areaData() {
            if ($.isPlainObject(key) && !options) {
                options = key;
            }

            this.showToolTip(getHtmlFromOptions(options),options);
        },
        { 
            name: 'tooltip',
            args: arguments,
            key: key
        }
    )).go();
    };
} (jQuery));

/*!
Copyright (c) 2011, 2012 Julien Wajsberg <felash@gmail.com>
All rights reserved.

Official repository: https://github.com/julienw/jquery-trap-input
License is there: https://github.com/julienw/jquery-trap-input/blob/master/LICENSE
This is version 1.2.0.
*/

(function( $, undefined ){

/*
(this comment is after the first line of code so that uglifyjs removes it)

Redistribution and use in source and binary forms, with or without
modification, are permitted without condition.

Although that's not an obligation, I would appreciate that you provide a
link to the official repository.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES ARE DISCLAIMED.
*/

/*jshint boss: true, bitwise: true, curly: true, expr: true, newcap: true, noarg: true, nonew: true, latedef: true, regexdash: true */
    
    var DATA_ISTRAPPING_KEY = "trap.isTrapping";

    function onkeypress(e) {
        if (e.keyCode === 9) {
            var goReverse = !!(e.shiftKey);
            if (processTab(this, e.target, goReverse)) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    }
    
    // will return true if we could process the tab event
    // otherwise, return false
    function processTab(container, elt, goReverse) {
        var $focussable = getFocusableElementsInContainer(container),
            curElt = elt,
            index, nextIndex, prevIndex, lastIndex;
        
        do {
        
            index = $focussable.index(curElt);
            nextIndex = index + 1;
            prevIndex = index - 1;
            lastIndex = $focussable.length - 1;

            switch(index) {
                case -1:
                    return false; // that's strange, let the browser do its job
                case 0:
                    prevIndex = lastIndex;
                    break;
                case lastIndex:
                    nextIndex = 0;
                    break;
            }
                            
            if (goReverse) {
                nextIndex = prevIndex;
            }
            
            curElt = $focussable.get(nextIndex);
            // IE sometimes throws when an element is not visible
            try {
                curElt.focus();
            } catch(e) {
            }
        
        } while (elt === elt.ownerDocument.activeElement);

        return true;        
    }
    
    function filterKeepSpeciallyFocusable() {
        return this.tabIndex > 0;
    }
    
    function filterKeepNormalElements() {
        return !this.tabIndex; // true if no tabIndex or tabIndex == 0
    }
    
    function sortFocusable(a, b) {
        return (a.t - b.t) || (a.i - b.i);
    }
    
    function getFocusableElementsInContainer(container) {
        var $container = $(container);
        var result = [],
            cnt = 0;

        fixIndexSelector.enable && fixIndexSelector.enable();
        
        // leaving away command and details for now
        $container.find("a[href], link[href], [draggable=true], [contenteditable=true], :input:enabled, [tabindex=0]")
            .filter(":visible")
            .filter(filterKeepNormalElements)
            .each(function(i, val) {
                result.push({
                    v: val, // value
                    t: 0, // tabIndex
                    i: cnt++ // index for stable sort
                });
            });
            
        $container
            .find("[tabindex]")
            .filter(":visible")
            .filter(filterKeepSpeciallyFocusable)
            .each(function(i, val) {
                result.push({
                    v: val, // value
                    t: val.tabIndex, // tabIndex
                    i: cnt++ // index
                });
            });

        fixIndexSelector.disable && fixIndexSelector.disable();
        
        result = $.map(result.sort(sortFocusable), // needs stable sort
            function(val) {
                return val.v;
            }
        );
            
        
        return $(result);
        
    }
    
    function trap() {
        this.keydown(onkeypress);
        this.data(DATA_ISTRAPPING_KEY, true);
        return this;
    }
    
    function untrap() {
        this.unbind('keydown', onkeypress);
        this.removeData(DATA_ISTRAPPING_KEY);
        return this;
    }
    
    function isTrapping() {
        return !!this.data(DATA_ISTRAPPING_KEY);
    }
    
    $.fn.extend({
        trap: trap,
        untrap: untrap,
        isTrapping: isTrapping
    });

    // jQuery 1.6.x tabindex attr hooks management
    // this triggers problems for tabindex attribute
    // selectors in IE7-
    // see https://github.com/julienw/jquery-trap-input/issues/3
    
   var fixIndexSelector = {};

   if ($.find.find && $.find.attr !== $.attr) {
        // jQuery uses Sizzle (this is jQuery >= 1.3)
        // sizzle uses its own attribute handling (in jq 1.6.x and below)
       (function() {
            var tabindexKey = "tabindex";
            var sizzleAttrHandle = $.expr.attrHandle;
                
            // this function comes directly from jQuery 1.7.2 (propHooks.tabIndex.get)
            // we have to put it here if we want to support jQuery < 1.6 which
            // doesn't have an attrHooks object to reference.
            function getTabindexAttr(elem) {
                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                var attributeNode = elem.getAttributeNode(tabindexKey);

                return attributeNode && attributeNode.specified ?
                    parseInt( attributeNode.value, 10 ) :
                    undefined;
            }
            
            function fixSizzleAttrHook() {
                // in jQ <= 1.6.x, we add to Sizzle the attrHook from jQuery's attr method
                sizzleAttrHandle[tabindexKey] = sizzleAttrHandle.tabIndex = getTabindexAttr;
            }
            
            function unfixSizzleAttrHook() {
                delete sizzleAttrHandle[tabindexKey];
                delete sizzleAttrHandle.tabIndex;
            }

            
            fixIndexSelector = {
                enable: fixSizzleAttrHook,
                disable: unfixSizzleAttrHook
            };
        })();
    }
})( jQuery );

/*
 *	jQuery dotdotdot 1.8.3
 *
 *	Copyright (c) Fred Heusschen
 *	www.frebsite.nl
 *
 *	Plugin website:
 *	dotdotdot.frebsite.nl
 *
 *	Licensed under the MIT license.
 *	http://en.wikipedia.org/wiki/MIT_License
 */
!function(t,e){function n(t,e,n){var r=t.children(),o=!1;t.empty();for(var i=0,d=r.length;d>i;i++){var l=r.eq(i);if(t.append(l),n&&t.append(n),a(t,e)){l.remove(),o=!0;break}n&&n.detach()}return o}function r(e,n,i,d,l){var s=!1,c="a, table, thead, tbody, tfoot, tr, col, colgroup, object, embed, param, ol, ul, dl, blockquote, select, optgroup, option, textarea, script, style",u="script, .dotdotdot-keep";return e.contents().detach().each(function(){var h=this,f=t(h);if("undefined"==typeof h)return!0;if(f.is(u))e.append(f);else{if(s)return!0;e.append(f),!l||f.is(d.after)||f.find(d.after).length||e[e.is(c)?"after":"append"](l),a(i,d)&&(s=3==h.nodeType?o(f,n,i,d,l):r(f,n,i,d,l)),s||l&&l.detach()}}),n.addClass("is-truncated"),s}function o(e,n,r,o,d){var c=e[0];if(!c)return!1;var h=s(c),f=-1!==h.indexOf(" ")?" ":"　",p="letter"==o.wrap?"":f,g=h.split(p),v=-1,w=-1,b=0,m=g.length-1;for(o.fallbackToLetter&&0==b&&0==m&&(p="",g=h.split(p),m=g.length-1);m>=b&&(0!=b||0!=m);){var y=Math.floor((b+m)/2);if(y==w)break;w=y,l(c,g.slice(0,w+1).join(p)+o.ellipsis),r.children().each(function(){t(this).toggle().toggle()}),a(r,o)?(m=w,o.fallbackToLetter&&0==b&&0==m&&(p="",g=g[0].split(p),v=-1,w=-1,b=0,m=g.length-1)):(v=w,b=w)}if(-1==v||1==g.length&&0==g[0].length){var x=e.parent();e.detach();var C=d&&d.closest(x).length?d.length:0;if(x.contents().length>C?c=u(x.contents().eq(-1-C),n):(c=u(x,n,!0),C||x.detach()),c&&(h=i(s(c),o),l(c,h),C&&d)){var T=d.parent();t(c).parent().append(d),t.trim(T.html())||T.remove()}}else h=i(g.slice(0,v+1).join(p),o),l(c,h);return!0}function a(t,e){return t.innerHeight()>e.maxHeight}function i(e,n){for(;t.inArray(e.slice(-1),n.lastCharacter.remove)>-1;)e=e.slice(0,-1);return t.inArray(e.slice(-1),n.lastCharacter.noEllipsis)<0&&(e+=n.ellipsis),e}function d(t){return{width:t.innerWidth(),height:t.innerHeight()}}function l(t,e){t.innerText?t.innerText=e:t.nodeValue?t.nodeValue=e:t.textContent&&(t.textContent=e)}function s(t){return t.innerText?t.innerText:t.nodeValue?t.nodeValue:t.textContent?t.textContent:""}function c(t){do t=t.previousSibling;while(t&&1!==t.nodeType&&3!==t.nodeType);return t}function u(e,n,r){var o,a=e&&e[0];if(a){if(!r){if(3===a.nodeType)return a;if(t.trim(e.text()))return u(e.contents().last(),n)}for(o=c(a);!o;){if(e=e.parent(),e.is(n)||!e.length)return!1;o=c(e[0])}if(o)return u(t(o),n)}return!1}function h(e,n){return e?"string"==typeof e?(e=t(e,n),e.length?e:!1):e.jquery?e:!1:!1}function f(t){for(var e=t.innerHeight(),n=["paddingTop","paddingBottom"],r=0,o=n.length;o>r;r++){var a=parseInt(t.css(n[r]),10);isNaN(a)&&(a=0),e-=a}return e}if(!t.fn.dotdotdot){t.fn.dotdotdot=function(e){if(0==this.length)return t.fn.dotdotdot.debug('No element found for "'+this.selector+'".'),this;if(this.length>1)return this.each(function(){t(this).dotdotdot(e)});var o=this,i=o.contents();o.data("dotdotdot")&&o.trigger("destroy.dot"),o.data("dotdotdot-style",o.attr("style")||""),o.css("word-wrap","break-word"),"nowrap"===o.css("white-space")&&o.css("white-space","normal"),o.bind_events=function(){return o.bind("update.dot",function(e,d){switch(o.removeClass("is-truncated"),e.preventDefault(),e.stopPropagation(),typeof l.height){case"number":l.maxHeight=l.height;break;case"function":l.maxHeight=l.height.call(o[0]);break;default:l.maxHeight=f(o)}l.maxHeight+=l.tolerance,"undefined"!=typeof d&&(("string"==typeof d||"nodeType"in d&&1===d.nodeType)&&(d=t("<div />").append(d).contents()),d instanceof t&&(i=d)),g=o.wrapInner('<div class="dotdotdot" />').children(),g.contents().detach().end().append(i.clone(!0)).find("br").replaceWith("  <br />  ").end().css({height:"auto",width:"auto",border:"none",padding:0,margin:0});var c=!1,u=!1;return s.afterElement&&(c=s.afterElement.clone(!0),c.show(),s.afterElement.detach()),a(g,l)&&(u="children"==l.wrap?n(g,l,c):r(g,o,g,l,c)),g.replaceWith(g.contents()),g=null,t.isFunction(l.callback)&&l.callback.call(o[0],u,i),s.isTruncated=u,u}).bind("isTruncated.dot",function(t,e){return t.preventDefault(),t.stopPropagation(),"function"==typeof e&&e.call(o[0],s.isTruncated),s.isTruncated}).bind("originalContent.dot",function(t,e){return t.preventDefault(),t.stopPropagation(),"function"==typeof e&&e.call(o[0],i),i}).bind("destroy.dot",function(t){t.preventDefault(),t.stopPropagation(),o.unwatch().unbind_events().contents().detach().end().append(i).attr("style",o.data("dotdotdot-style")||"").removeClass("is-truncated").data("dotdotdot",!1)}),o},o.unbind_events=function(){return o.unbind(".dot"),o},o.watch=function(){if(o.unwatch(),"window"==l.watch){var e=t(window),n=e.width(),r=e.height();e.bind("resize.dot"+s.dotId,function(){n==e.width()&&r==e.height()&&l.windowResizeFix||(n=e.width(),r=e.height(),u&&clearInterval(u),u=setTimeout(function(){o.trigger("update.dot")},100))})}else c=d(o),u=setInterval(function(){if(o.is(":visible")){var t=d(o);c.width==t.width&&c.height==t.height||(o.trigger("update.dot"),c=t)}},500);return o},o.unwatch=function(){return t(window).unbind("resize.dot"+s.dotId),u&&clearInterval(u),o};var l=t.extend(!0,{},t.fn.dotdotdot.defaults,e),s={},c={},u=null,g=null;return l.lastCharacter.remove instanceof Array||(l.lastCharacter.remove=t.fn.dotdotdot.defaultArrays.lastCharacter.remove),l.lastCharacter.noEllipsis instanceof Array||(l.lastCharacter.noEllipsis=t.fn.dotdotdot.defaultArrays.lastCharacter.noEllipsis),s.afterElement=h(l.after,o),s.isTruncated=!1,s.dotId=p++,o.data("dotdotdot",!0).bind_events().trigger("update.dot"),l.watch&&o.watch(),o},t.fn.dotdotdot.defaults={ellipsis:"... ",wrap:"word",fallbackToLetter:!0,lastCharacter:{},tolerance:0,callback:null,after:null,height:null,watch:!1,windowResizeFix:!0},t.fn.dotdotdot.defaultArrays={lastCharacter:{remove:[" ","　",",",";",".","!","?"],noEllipsis:[]}},t.fn.dotdotdot.debug=function(t){};var p=1,g=t.fn.html;t.fn.html=function(n){return n!=e&&!t.isFunction(n)&&this.data("dotdotdot")?this.trigger("update",[n]):g.apply(this,arguments)};var v=t.fn.text;t.fn.text=function(n){return n!=e&&!t.isFunction(n)&&this.data("dotdotdot")?(n=t("<div />").text(n).html(),this.trigger("update",[n])):v.apply(this,arguments)}}}(jQuery),jQuery(document).ready(function(t){t(".dot-ellipsis").each(function(){var e=t(this).hasClass("dot-resize-update"),n=t(this).hasClass("dot-timer-update"),r=0,o=t(this).attr("class").split(/\s+/);t.each(o,function(t,e){var n=e.match(/^dot-height-(\d+)$/);null!==n&&(r=Number(n[1]))});var a=new Object;n&&(a.watch=!0),e&&(a.watch="window"),r>0&&(a.height=r),t(this).dotdotdot(a)})}),jQuery(window).on("load",function(){jQuery(".dot-ellipsis.dot-load-update").trigger("update.dot")});
// Namespace loader
if (typeof Cube !== 'object') {
	var Cube = {};
}
if (typeof Cube.Map !== 'object') {
	Cube.Map = {};
}


// Class loader & defaults parameters
Cube.Map.Map = function() {
	this.MapType = null;
	this.Map = null;
	this.mapLoaded = false;
	this.Geocoder = null;
	this.GeocoderAutocomplete = null;
	this.mapId = 'map';
	this.geocoderId = 'map-geocoder';
	this.geocoderDataId = 'map-geocoder-data';
	this.geolocationId = 'map-geolocation';
	this.centerLat = 0;
	this.centerLng = 0;
	this.zoom = 4;
	this.zoomAggregation = 10;
	this.zoomLocation = 14; // Zoom used while locating a store, an address or the user
	this.userLat = null;
	this.userLng = null;
	this.userMarkerList = {}; // Keep the user location marker and used for refreshing 
	this.markerList = {};
	this.infowindowList = {};
	this.poiList = {};
	this.openedInfowindow = null;
};


// Class methods
Cube.Map.Map.prototype = {

	/* **************************************** */
	/* ********** API public methods ********** */
	/* **************************************** */
	
	/**
	 * Set Map center (Latitude, longitude and zoom level)
	 */
	setCenter: function(data) {
		this.centerLat = data.lat;
		this.centerLng = data.lng;
		
		if (typeof data.zoom !== 'undefined') {
			this.zoom = data.zoom;
		}
		
		return this;
	},
	
	/**
	 * Add marker
	 */
	addMarker: function(data) {
		var marker = {};
		
		// Edit marker
		marker.id = (Object.keys(this.markerList).length === 0) ? 1 : (Math.max.apply(Math, Object.keys(this.markerList)) + 1);
		marker.name = data.name;
		marker.lat = data.lat;
		marker.lng = data.lng;
		
		// Add marker to list
		this.markerList[marker.id] = marker;
		
		// Display it
		if (this.Map !== null) {
			this._addMarker(this.markerList[marker.id]);
		}
		
		return this.markerList[marker.id];
	},
	
	/**
	 * Add infowindow
	 */
	addInfowindow: function(data) {
		var infowindow = {};
		
		// Edit infowindow
		infowindow.id = (Object.keys(this.infowindowList).length === 0) ? 1 : (Math.max.apply(Math, Object.keys(this.infowindowList)) + 1);
		infowindow.name = data.name;
		infowindow.address = data.address;
		
		// Add infowindow to list
		this.infowindowList[infowindow.id] = infowindow;
		
		// Display it
		if (this.Map !== null) {
			this._addInfowindow(this.infowindowList[infowindow.id]);
		}
		
		return this.infowindowList[infowindow.id];
	},
	
	showPOI: function(data) {
		// Display it
		var targetPoint;
		if (this.Map !== null) {
			var poiList = this.poiList;
			for (var point in poiList) {
				if (poiList[point].name === data.name) {
					targetPoint = poiList[point];
					
					break;
				}
			}
			
			this._showPOI(targetPoint);
		}
	},
	
	/**
	 * Add POI (Point Of Interest: Marker & Infowindow)
	 */
	addPOI: function(data) {
		var poi = {};
		
		// Edit POI
		poi.id = (Object.keys(this.poiList).length === 0) ? 1 : (Math.max.apply(Math, Object.keys(this.poiList)) + 1);
		poi.marker = this.addMarker(data);
		poi.infowindow = this.addInfowindow(data);
		poi.name = data.name;
		poi.lat = data.lat;
		poi.lng = data.lng;
		poi.address = data.address;
		poi.storeUrl = Cube.Utils.localizeUri(data.storeUrl);
		poi.mapBaseUrl = data.mapBaseUrl;
		poi.city = data.city;
		poi.country = data.country;
		
		// Add POI to list
		this.poiList[poi.id] = poi;
		
		// Display it
		if (this.Map !== null) {
			this._addPOI(this.poiList[poi.id]);
		}
		
		return this.poiList[poi.id];
	},
	
	/**
	 * Add Geocoder loader to find an address
	 */
	addGeocoder: function() {
		this._addGeocoder();
		
		return this;
	},
	
	/**
	 * Get user location
	 */
	getGeolocation: function(centerMap) {
		var that = this;
		
		if (navigator.geolocation) {
			navigator.geolocation.getCurrentPosition(function(position) {
				that.userLat = position.coords.latitude;
				that.userLng = position.coords.longitude;
				
				// Center map if required
				if (typeof centerMap !== 'undefined' && centerMap === true) {
					that._setMapCenter({
						lat: that.userLat,
						lng: that.userLng,
						zoom: that.zoomLocation
					});
					
					// Add user location marker
					new google.maps.Marker({
						position: {lat:that.userLat, lng:that.userLng},
						draggable: false,
						icon: {url:'/assets/images/pin-icon-green.png'},
						animation: google.maps.Animation.DROP,
						map: that.Map
					});
				}
			});
		} else {
			that.userLat = null;
			that.userLng = null;
		}

		return this;
	},
	
	/**
	 * Get store address string for map provider
	 */
	getStoreAddress: function(data) {
		var addressString = '';
		if (data.address1 !== null) {
			addressString += data.address1;
			addressString += ' ';
		}
		
		if (data.address2 !== null) {
			addressString += data.address2;
			addressString += ' ';
		}
		
		if (data.city !== null) {
			addressString += data.city;
			addressString += ' ';
		}
		
		if (data.state !== null) {
			addressString += data.state;
			addressString += ' ';
		}
		
		if (data.postalCode !== null) {
			addressString += data.postalCode;
			addressString += ' ';
		}
		
		if (data.country !== null) {
			addressString += data.country;
		}
		
		return addressString;
	},
	
	/**
	 * Load API
	 */
	load: function() {
		var that = this;
		
		// Create and center Map
		this._createMap();
		
		// Set map options
		this._setMapOptions({
			mapType: false,
			scroll: false,
		    streetView: true,
		    zoom: true
		});
		
		// Add markers
		for(var markerId in this.markerList) {
			var marker = this.markerList[markerId];
			this._addMarker(marker);
		}
		
		// Add infowindow
		for(var infowindowId in this.infowindowList) {
			var infowindow = this.infowindowList[infowindowId];
			this._addInfowindow(infowindow);
		}
		
		// Add POI
		for(var poiId in this.poiList) {
			var poi = this.poiList[poiId];
			this._addPOI(poi);
		}
		
		// Clink on store itinerary link
		$('body').on('click', '.itinerary-link', function(e){
		    e.preventDefault();
		    that.itinaryGmap($(e.target));
		  });
		
		// Add Geocoder
		this.addGeocoder();
		
		// Geolocation
		var geolocationDiv = document.getElementById(that.geolocationId);
		google.maps.event.addDomListener(geolocationDiv, 'click', function() {
			that.getGeolocation(true);
		});
		
		return this;
	}
};

// Namespace loader
if (typeof Cube !== 'object') {
	var Cube = {};
}
if (typeof Cube.Map !== 'object') {
	Cube.Map = {};
}


// Class loader & defaults parameters
Cube.Map.Baidu = function() {
	Cube.Map.Map.call(this);
	this.Cluster = null;
	this.MapType = 'Baidu';
	this.zoom = 5;
	this.zoomAggregation = 10;
};


// Class methods
Cube.Map.Baidu.prototype = $.extend(new Cube.Map.Map(), {
		
	/* ************************************** */
	/* ********** Internal methods ********** */
	/* ************************************** */
	
	/**
	 * Create Map instance
	 */
	_createMap: function() {
		var that = this;
		var mapDiv = document.getElementById(that.mapId);
		
		this.Map = new BMap.Map(mapDiv);
		this.Map.centerAndZoom(new BMap.Point(that.centerLng, that.centerLat), that.zoom);
		
		return this;
	},
	
	/**
	 * Update Map options
	 */
	_setMapOptions: function(data) {
		// TODO
		
		return this;
	},
	
	/**
	 * Set Map center (Latitude, longitude and zoom level)
	 */
	_setMapCenter: function(data) {
		// TODO
		
		return this;
	},
	
	/**
	 * Add marker
	 */
	_addMarker: function(data) {
		// TODO
		
		return this;
	},
	
	/**
	 * Add infowindow
	 */
	_addInfowindow: function(data) {
		// TODO
		
		return this;
	},
	
	/**
	 * Add POI (Point Of Interest: Marker & Infowindow)
	 */
	_addPOI: function(data) {
		// TODO
		
		return this;
	},
	
	/**
	 * Add Geocoder loader to find an address
	 */
	_addGeocoder: function() {
		// TODO
		
		return this;
	},
	
	/**
	 * Get display view distance from center to a corner
	 */
	_getViewRadius: function() {
		// TODO
		
		return this;
	}
	
});

// Namespace loader
if (typeof Cube !== 'object') {
	var Cube = {};
}
if (typeof Cube.Map !== 'object') {
	Cube.Map = {};
}


// Class loader & defaults parameters
Cube.Map.Google = function() {
	Cube.Map.Map.call(this);
	this.Cluster = null;
	this.MapType = 'Google';
	this.zoom = 8;
	this.zoomAggregation = 10;
};


// Class methods
Cube.Map.Google.prototype = $.extend(new Cube.Map.Map(), {
	
	/* ************************************** */
	/* ********** Internal methods ********** */
	/* ************************************** */
	
		
	/**
	 * Create Map instance
	 */
	_createMap: function() {
		
		var that = this;
		var mapDiv = document.getElementById(that.mapId);
		
		this.Map = new google.maps.Map(mapDiv, {
			center: {lat: that.centerLat, lng: that.centerLng},
			zoom: that.zoom		
		});
		
		// Load clustering lib to aggregate markers
		if (typeof MarkerClusterer !== 'undefined') {
			this.Cluster = new MarkerClusterer(this.Map, [], {
				minimumClusterSize: 1,
				maxZoom: that.zoomAggregation
			});
			this.Cluster.setStyles([{
				url: '/assets/images/cluster-min.png',
				height: 38,
				width: 38,
				anchor: [0, 0],
				textColor: '#ffffff',
				textSize: 12
			}, {
				url: '/assets/images/cluster-mid.png',
				height: 44,
				width: 44,
				anchor: [0, 0],
				textColor: '#ffffff',
				textSize: 14
			}, {
				url: '/assets/images/cluster-max.png',
				height: 50,
				width: 50,
				anchor: [0, 0],
				textColor: '#ffffff',
				textSize: 16
			}]);
		}
		
		this.Map.addListener('idle', function() {
			// Only do on first load
			if (!that.mapLoaded) {
				that.loadPOI();
				
				// Set Map as loaded
				that.mapLoaded = true;
			}
		});
		
		
		
		this.Map.addListener('tilesloaded', function() {
			// On every load
			that.loadStores();
		});
		
		
		
		return this;
	},
	
	/**
	 * Update Map options
	 */
	_setMapOptions: function(data) {
		var that = this;
		var options = {};
		
		// Map types selector
		if (data.mapType) {
			$.extend(options, {
				mapTypeControl: true,
				mapTypeControlOptions: {
			        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
			        position: google.maps.ControlPosition.BOTTOM_CENTER
			    }
			});
		} else {
			$.extend(options, {
				mapTypeControl: false
			});
		}
		
		// Mouse scrolling capability
		if (data.scroll) {
			$.extend(options, {
				scrollwheel: true
			});
		} else {
			$.extend(options, {
				scrollwheel: false
			});
		}
		
		// Street View controls
		if (data.streetView) {
			$.extend(options, {
			    streetViewControl: true,
			    streetViewControlOptions: {
		    		position: google.maps.ControlPosition.RIGHT_CENTER
			    }
			});
		} else {
			$.extend(options, {
			    streetViewControl: false
			});
		}
		
		// Zoom controls
		if (data.zoom) {
			$.extend(options, {
				zoomControl: true,
				zoomControlOptions: {
			    	position: google.maps.ControlPosition.RIGHT_CENTER
			    }
			});
		} else {
			$.extend(options, {
				zoomControl: false
			});
		}
		
		// Never display scale control
		$.extend(options, {
			scaleControl: false
		});

		this.Map.setOptions(options);

		return this;
	},
	
	/**
	 * Set Map center (Latitude, longitude and zoom level)
	 */
	_setMapCenter: function(data) {
		// Center map if defined
		if (typeof data.lat !== 'undefined' && typeof data.lng !== 'undefined' && data.lat !== null && data.lng !== null) {
			this.Map.setCenter({
				lat:data.lat,
				lng:data.lng
			});
		}
		
		// Zoom map if defined and lat/lng too, to avoid zooming only
		if (typeof data.zoom !== 'undefined' && data.lat !== null && data.lng !== null) {
			this.Map.setZoom(data.zoom);
		}
		
		return this;
	},
	
	/**
	 * Add marker
	 */
	_addMarker: function(data) {
		var that = this;
		this.markerList[data.id].Relation = new google.maps.Marker({
			position: {lat:data.lat, lng:data.lng},
			title: data.name,
			draggable: false,
			icon: {url:'/assets/images/pin-icon-blue.png'},
			animation: google.maps.Animation.DROP,
			map: that.Map
		});
		
		// Push the marker in the cluster (marker aggregation)
		if (this.Cluster !== null) {
			this.Cluster.addMarker(this.markerList[data.id].Relation);
		}
		
		return this.markerList[data.id];
	},
	
	/**
	 * Add infowindow
	 */
	_addInfowindow: function(data) {
		var that = this;
		
		this.infowindowList[data.id].Relation = new google.maps.InfoWindow({
			content: that._getInfowindowTemplate(data)
		});
		this.infowindowList[data.id].Relation.isOpen = false;
		
		return this.infowindowList[data.id];
	},
	
	_openInfowindow: function(markerId, infowindowId) {
		var marker = this.markerList[markerId].Relation;
		
		var infowindow = this.infowindowList[infowindowId].Relation;
		
		if (this.Map.openedInfowindow !== null && this.Map.openedInfowindow !== undefined) {
			this.Map.openedInfowindow.close(this.Map, marker);
			this.Map.openedInfowindow.isOpen = false;
		}
		
		infowindow.open(this.Map, marker);
		infowindow.isOpen = true;
		this.Map.openedInfowindow = infowindow;
	},
	
	/**
	 * Add POI (Point Of Interest: Marker & Infowindow)
	 */
	_addPOI: function(data) {
		var that = this;
		
		// Add marker/infowindow events
		this.markerList[data.marker.id].Relation.addListener('click', function() {
			that._openInfowindow(data.marker.id, data.infowindow.id);
		});

		return this;
	},
	
	/**
	 * Add POI (Point Of Interest: Marker & Infowindow)
	 */
	_showPOI: function(data) {
		var that = this;
		
		// Add information to sidebar
		var newPoiElement = $(that._getSidebarTemplate(data));
		
		$('#map-panel-list').append(newPoiElement);
		
		// bind event on sidebar store name link to zoom on marker and display info window
		newPoiElement.find(".store-name" ).click(function() { 
			var marker = that.markerList[$(this).data("marker-id")].Relation;
			
			that.Map.setZoom(that.zoomLocation);
			that.Map.setCenter(marker.getPosition());
			
			that._openInfowindow($(this).data("marker-id"), $(this).data("infowindow-id"));
		});

		return this;
	},
	
	/**
	 * Add Geocoder loader to find an address
	 */
	_addGeocoder: function() {
		var that = this;
		this.Geocoder = new google.maps.Geocoder();
		var geocoderDiv = document.getElementById(this.geocoderId);
		var geocoderDataDiv = document.getElementById(this.geocoderDataId);
		
		// Add autocompletion (require "places" librairy)
		if (typeof google.maps.places !== 'undefined') {
			this.GeocoderAutocomplete = new google.maps.places.Autocomplete(geocoderDataDiv);
			this.GeocoderAutocomplete.bindTo('bounds', that.Map);
		}
		
		var $form = $('#' + this.geocoderDataId).parents('form').first();
		$form.on('submit', function(event) {			
			event.preventDefault();
			var address = geocoderDataDiv.value;
			that.Geocoder.geocode({'address': address}, function(results, status) {
				if (status === google.maps.GeocoderStatus.OK) {
					// Center and zoom to found address
					that.Map.setCenter(results[0].geometry.location);
					that.Map.setZoom(that.zoomLocation);
					//console.log(that.userMarkerList[0])
					
					if (typeof that.userMarkerList[0] !== 'undefined'){
						that.userMarkerList[0].setMap(null);
					}
					
					that.userMarkerList[0] = new google.maps.Marker({
						position: {lat:results[0].geometry.location.lat(), lng:results[0].geometry.location.lng()},
						draggable: false,
						icon: {url:'/assets/images/pin-icon-green.png'},
						animation: google.maps.Animation.DROP,
						map: that.Map
					});
					
					// hide the potentiel error message for previous request
					$('.geolocate-error').hide();
				} else if (status === google.maps.GeocoderStatus.ZERO_RESULTS) {
					$('.geolocate-error').show();
				}
			});
		});
		
		return this;
	},
	
	/**
	 * Build link to the map and open a new window to this link.
	 * 
	 * For googlemaps, we need lat, lon,store name, city and country
	 * 
	 */
	itinaryGmap: function(cible){
		  var _this = this,
		    user,
		    storeName,
		    userLat,
		    userLng;
		  
		  	var mapUrl = cible.closest('.info-store').find('.map-provider-url').val();
			
		  	// var storeAddress = cible.closest('.info-store').find('.store-address').val();
		  	
		  	var itLink = cible.closest('.info-store').find('.itinary-gmap');
		  	var name = itLink.data('storename').replace(' ', '+'); 
		  	var lat = itLink.data('lat');
		  	var lon = itLink.data('long');
		  	var city = 'near=' + itLink.data('city');
		  	var zoom = 'z=17';
		  	var country = 'hl=' + itLink.data('country').toLowerCase();
		  	
		  	var storeAddress = name + '&' + city + '&ll=' + lat + ',' + lon + '&' + zoom + '&' + country;
		  	
		  	var apiSrc = mapUrl + storeAddress;
			    
			window.open(apiSrc);
		},
	
	/**
	 * Get display view distance from center to a corner
	 */
	_getViewRadius: function() {
		var that = this;
		var distance = 0;
		
		// Get map view diameter
		distance = google.maps.geometry.spherical.computeDistanceBetween(that.Map.getBounds().getSouthWest(), that.Map.getBounds().getNorthEast());
		
		// Calculate the radius
		distance = distance / 2;
		
		// Convert meters to kilometers
		distance = distance / 1000;
		
		// Round result
		distance = distance.toFixed(2);

		return distance;
	}
	
	

});

// Namespace loader
if (typeof Cube !== 'object') {
	var Cube = {};
}
if (typeof Cube.Map !== 'object') {
	Cube.Map = {};
}


// Class methods
$.extend(Cube.Map.Map.prototype, {
	
	/* ************************************** */
	/* ********** Internal methods ********** */
	/* ************************************** */
	
	/**
	 * Get infowindow template
	 * TODO: Store page link
	 * TODO: Itinerary link
	 * TODO: Zoom map on the store link
	 */
	_getInfowindowTemplate: function(data) {
		var template = '';

		template += '<div class="info-store">';
			template += '<div class="content">';
				template += '<p class="store-name">#' + data.id + ' ' + data.name + '</p>';
				template += '<p class="store-address">' + data.address + '</p>';
			template += '</div>';
			template += '<div class="store-picture">';
				template += '<img src="/assets/images/decathlon-logo.svg" alt="' + data.name + '" />';
			template += '</div>';
		template += '</div>';

		return template;
	},

	/**
	 * Get sidebar template
	 * Builds the part on the left of the map.
	 * 
	 */
	_getSidebarTemplate: function(data) {
		var that = this;
		var template = '';
		
		var itinarylink = '<a class="itinary-gmap" data-lat="' + data.lat + '" data-long="' + data.lng + '" data-city="' + data.city + '" data-storename="' + data.name + '" data-country="' + data.country + '" href="#">' + Messages('storeview.itinary') + '</a>';
  		var storeLink = "";
  		var actionsLine = "";
  		
		if(data.storeUrl) {
			var storeURL = Cube.Utils.localizeUri(data.storeUrl);
		    storeLink = '<a href="'+storeURL+'">' + Messages('storeview.seeStorePage') + '</a>';
		    actionsLine = storeLink + '<span class="itinerary-link"> | ' + itinarylink + '</span>';
		} else {
		    actionsLine = itinarylink;
		}
		
		var storeAddress = data.address;
		var mapBaseUrl = data.mapBaseUrl;
		
		template += '<div class="info-store">';
			template += '<div class="content">';
				template += '<input type="hidden" class="store-address" value="' + storeAddress + '" />';
				template += '<input type="hidden" class="map-provider-url" value="' + mapBaseUrl + '" />';
				template += '<p class="store-name" data-infowindow-id="'+data.infowindow.id+'" data-marker-id="'+data.marker.id+'">#' + data.id + ' ' + data.name + '</p>';
				template += '<p class="store-address">' + data.address + '</p>';
				template += '<div class="actions">'+actionsLine+'</div>';
			template += '</div>';
			template += '<div class="store-picture">';
				template += '<img src="/assets/images/decathlon-logo.svg" alt="' + data.name + '" />';
			template += '</div>';
		template += '</div>';
		template += '<hr />';
		
		return template;
	},

	/* **************************************** */
	/* ********** API public methods ********** */
	/* **************************************** */

	
	loadStores: function() {
		var that = this;
		
		if (this.Map.getZoom() >= 11) {
			var center = this.Map.getCenter();
			var bounds = this.Map.getBounds();
			// The calculated distance is too big to cause mis-retrieve extra stores near the current map center, so we reduce it to a smaller scale.
			var distance = this._getViewRadius()/10;
		    
			var url = '/' + 'en' + '/ajax/rest/model/com/decathlon/cube/commerce/locations/LocationActor/getNearbyStoresTO?longitude=' + center.lng() + "&latitude=" + center.lat() + "&distance=" + 30;
			
			$.ajax({
				type: 'get',
				url: url,
				success: function(data) {
					// Reload panel
					$('#map-panel .map-panel-list').html('');
					$('#map-panel-list').empty();
					
					// Display POIs
					if (data.responseTO.data.length !== 0) {
						var mapBaseUrl= $('#map-base-url').val();
						$('#map-panel .welcome-sentance').hide();
						
						for (var i in data.responseTO.data) {
							var store = data.responseTO.data[i];
							store.position = store.geoCode.split(',');
							
							var poi = {};
							poi.lat = Number(store.position[0]);
							poi.lng = Number(store.position[1]);
							poi.name = store.storeName;
							
							poi.address = that.getStoreAddress(store.address);
							
							poi.storeUrl = Cube.Utils.localizeUri(store.storeUrl);
							poi.mapBaseUrl = mapBaseUrl;
							poi.city = store.address.city;
							poi.country = store.address.country;
							
							console.log("Show POI", poi);
							
							that.showPOI(poi);
						}
					} else {
						var errorMsg = Messages('storelocator.errormsg.nostorefound');

						  $('#geolocate-error-message').html(errorMsg);
						  $('.geolocate-error').show();
					}
					
				}
			});
		} else {
			$('#map-panel-list').empty();
			$('#map-panel .welcome-sentance').show();
		}
		
		return this;
	},
		
	/**
	 * Load POIs data
	 */
	loadPOI: function() {
		var that = this;
		this.Request = null;
		this.welcomeMessage = $('#map-panel .welcome-sentance').text();
		var lat = that.centerLat;
		var lng = that.centerLng;
		var distance = this._getViewRadius();
		
		var url = '/' + 'en' + '/ajax/rest/model/com/decathlon/cube/commerce/locations/LocationActor/getAllStoresTO';
		// Use all store and do request only once.
		$.ajax({
			type: 'post',
			url: url,
			success: function(data) {
				// Reload panel
				$('#map-panel .map-panel-list').html('');
				
				var mapBaseUrl= $('#map-base-url').val();
				// Display POIs
				for (var i in data.responseTO.data) {
					var store = data.responseTO.data[i];
					store.position = store.geoCode.split(',');
					
					var poi = {};
					poi.lat = Number(store.position[0]);
					poi.lng = Number(store.position[1]);
					poi.name = store.storeName;
					
					poi.address = that.getStoreAddress(store.address);
					
					poi.storeUrl=Cube.Utils.localizeUri(store.storeUrl);
					poi.mapBaseUrl = mapBaseUrl;
					poi.city = store.address.city;
					poi.country = store.address.country;
					
					that.addPOI(poi);
				}
			}
		});
		
		return this;
	}
	
	
	
});

;(function (window, $, document, undefined) {

    // Based on http://lehelk.com/2011/05/06/script-to-remove-diacritics/

    function removeDiacritics(subject) {

        if (!subject && this instanceof String) {
            subject = this;
        }

        var diacriticsMap = {
            'A': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g,
            'AA': /[\uA732]/g,
            'AE': /[\u00C6\u01FC\u01E2]/g,
            'AO': /[\uA734]/g,
            'AU': /[\uA736]/g,
            'AV': /[\uA738\uA73A]/g,
            'AY': /[\uA73C]/g,
            'B': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g,
            'C': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g,
            'D': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g,
            'DZ': /[\u01F1\u01C4]/g,
            'Dz': /[\u01F2\u01C5]/g,
            'E': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g,
            'F': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g,
            'G': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g,
            'H': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g,
            'I': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g,
            'J': /[\u004A\u24BF\uFF2A\u0134\u0248]/g,
            'K': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g,
            'L': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g,
            'LJ': /[\u01C7]/g,
            'Lj': /[\u01C8]/g,
            'M': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g,
            'N': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g,
            'NJ': /[\u01CA]/g,
            'Nj': /[\u01CB]/g,
            'O': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g,
            'OI': /[\u01A2]/g,
            'OO': /[\uA74E]/g,
            'OU': /[\u0222]/g,
            'P': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g,
            'Q': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g,
            'R': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g,
            'S': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g,
            'T': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g,
            'TZ': /[\uA728]/g,
            'U': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g,
            'V': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g,
            'VY': /[\uA760]/g,
            'W': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g,
            'X': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g,
            'Y': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g,
            'Z': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g,
            'a': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g,
            'aa': /[\uA733]/g,
            'ae': /[\u00E6\u01FD\u01E3]/g,
            'ao': /[\uA735]/g,
            'au': /[\uA737]/g,
            'av': /[\uA739\uA73B]/g,
            'ay': /[\uA73D]/g,
            'b': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g,
            'c': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g,
            'd': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g,
            'dz': /[\u01F3\u01C6]/g,
            'e': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g,
            'f': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g,
            'g': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g,
            'h': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g,
            'hv': /[\u0195]/g,
            'i': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g,
            'j': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g,
            'k': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g,
            'l': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g,
            'lj': /[\u01C9]/g,
            'm': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g,
            'n': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g,
            'nj': /[\u01CC]/g,
            'o': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g,
            'oi': /[\u01A3]/g,
            'ou': /[\u0223]/g,
            'oo': /[\uA74F]/g,
            'p': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g,
            'q': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g,
            'r': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g,
            's': /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g,
            't': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g,
            'tz': /[\uA729]/g,
            'u': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g,
            'v': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g,
            'vy': /[\uA761]/g,
            'w': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g,
            'x': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g,
            'y': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g,
            'z': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
        };

        for (var key in diacriticsMap) {
            subject = subject.replace(diacriticsMap[key], key);
        }

        return subject;
    }

    String.prototype.removeDiacritics = removeDiacritics;

    window.removeDiacritics = removeDiacritics;

    jQuery.fn.extend({
        removeDiacritics: function(element, options) {
            $(this).each(function(i, e) {
                var c = $(this).children();
                if (c.length > 0) {
                    $(c).removeDiacritics();
                } else {
                    $(this).text(removeDiacritics($(this).text()));
                }
            });
        }
    });


    /*https://gist.github.com/oziks/3664787*/
    $.expr[':'].containsChar = function(a, i, m) {

      var element = $(a).text().removeDiacritics();
      var search = m[3].removeDiacritics();

      if (!search) return false;
      return new RegExp(search,"i").test(element);
    };

}(window, jQuery, document));
/*jshint laxcomma: true */
/*jshint multistr: true */

/**
 * Protect window.console method calls, e.g. console is not defined on IE
 * unless dev tools are open, and IE doesn't define console.debug
 * 
 * Chrome 41.0.2272.118: debug,error,info,log,warn,dir,dirxml,table,trace,assert,count,markTimeline,profile,profileEnd,time,timeEnd,timeStamp,timeline,timelineEnd,group,groupCollapsed,groupEnd,clear
 * Firefox 37.0.1: log,info,warn,error,exception,debug,table,trace,dir,group,groupCollapsed,groupEnd,time,timeEnd,profile,profileEnd,assert,count
 * Internet Explorer 11: select,log,info,warn,error,debug,assert,time,timeEnd,timeStamp,group,groupCollapsed,groupEnd,trace,clear,dir,dirxml,count,countReset,cd
 * Safari 6.2.4: debug,error,log,info,warn,clear,dir,dirxml,table,trace,assert,count,profile,profileEnd,time,timeEnd,timeStamp,group,groupCollapsed,groupEnd
 * Opera 28.0.1750.48: debug,error,info,log,warn,dir,dirxml,table,trace,assert,count,markTimeline,profile,profileEnd,time,timeEnd,timeStamp,timeline,timelineEnd,group,groupCollapsed,groupEnd,clear
 */
 (function() {
      // Union of Chrome, Firefox, IE, Opera, and Safari console methods
      var methods = ["assert", "assert", "cd", "clear", "count", "countReset",
      "debug", "dir", "dirxml", "dirxml", "dirxml", "error", "error", "exception",
      "group", "group", "groupCollapsed", "groupCollapsed", "groupEnd", "info",
      "info", "log", "log", "markTimeline", "profile", "profileEnd", "profileEnd",
      "select", "table", "table", "time", "time", "timeEnd", "timeEnd", "timeEnd",
      "timeEnd", "timeEnd", "timeStamp", "timeline", "timelineEnd", "trace",
      "trace", "trace", "trace", "trace", "warn"];
      var length = methods.length;
      var console = (window.console = window.console || {});
      var method;
      var noop = function() {};
      while (length--) {
        method = methods[length];
        // define undefined methods as noops to prevent errors
        if (!console[method])
          console[method] = noop;
    }
})();


// SHOW BODY TAG ONLY AFTER LOADING JQUERY TO ELIMINATE FOUC
$('body').removeClass('jquery-loading');

// Warns if the same ID is used multiple times in a page
$('[id]').each(function(){
  var ids = $('[id="'+this.id+'"]');
  if(ids.length>1 && ids[0]==this)
    console.warn('This ID : #'+this.id+ ' is being used '+ ids.length + ' times');
});


var decathlon = window.decathlon || {};





/* Decathlon breakpoint sizes */

;(function(window){
  
  window.decathlon.uxBreakpoints = (typeof window.decathlon.uxBreakpoints === 'object') ? window.decathlon.uxBreakpoints : {};
  window.decathlon.uxBreakpoints = {
    "xxsMin" : 321, /* used only in some slick carousels */
    "xxsMax" : 480, /* used only in some slick carousels */
    "xsMin" : 481,
    "xsMax" : 800, /* END OF MOBILE */
    "smMin" : 801, /* START OF DESKTOP */
    "smMax" : 1079,
    "mdMin" : 1080,
    "mdMax" : 1179,
    "lgMin" : 1180
  };

  var windowWidth = 0;

  window.decathlon.uxBreakpoints.is = function(size){

    windowWidth = uxDynamicSizes.windowWidth || $(window).width();
    windowWidth = windowWidth + uxDynamicSizes.scrollbarWidth;

    if(size === 'small-screen'){
      if(windowWidth <= decathlon.uxBreakpoints.xsMax) {
        //console.log(size + ' size (small-screen)');
        return true;
      }
    }
    // if(size === 'medium-screen'){
    //   if(windowWidth >= decathlon.uxBreakpoints.smMin && windowWidth <= decathlon.uxBreakpoints.mdMax) {
    //     //console.log(size + ' size (medium-screen)');
    //     return true;
    //   }
    // } 

    if(size === 'large-screen'){
      if(windowWidth > decathlon.uxBreakpoints.xsMax) {
        //console.log(size + ' size (large-screen)');
        return true;
      }
    } 
    

  };

})(window);



;(function(window, $){

  // call jRespond and add breakpoints
  window.jRes = jRespond([
  {
      label: 'small',
      enter: 0,
      exit: decathlon.uxBreakpoints.xsMax
  },{
      label: 'large',
      enter: decathlon.uxBreakpoints.smMin,
      exit: 20000
  }
  ]);
  
  $(function(){
    if(window.jRes){
      jRes.addFunc([
        {
            breakpoint: 'small',
            enter: function(){
              $(window).trigger('enter-small-screen');
            },
            exit: function(){
              $(window).trigger('exit-small-screen');
            }
        },
        {
            breakpoint: 'large',
            enter: function(){
              $(window).trigger('enter-large-screen');
            },
            exit: function(){
              $(window).trigger('exit-large-screen');
            }
        }
      ]);
    }
  });

})(window, jQuery);

Modernizr.addTest('csscalc', function() {
    var prop = 'width:';
    var value = 'calc(10px);';
    var el = document.createElement('div');

    el.style.cssText = prop + Modernizr._prefixes.join(value + prop);

    return !!el.style.length;
});

Modernizr.addTest('ios', function () {
  return navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false;
});

decathlon.noConflictTooltip  = function(){
    var bootstrapTooltip = $.fn.tooltip.noConflict(); // return $.fn.button to previously assigned value
    $.fn.bootstrapTooltip = bootstrapTooltip;

    return bootstrapTooltip;
};


/* Loader Function - Use by dev. */
/*
    @Param : item - DOM object - Target of submit
*/
var disableLoader = function(item){

    var _tInputs = item.find('input:visible:not(:checkbox, :radio)');
    var _tButton = $(item).find('button[type="submit"]');

    for(var i=0;i<_tInputs.length;i++){

        $(_tInputs[i]).removeAttr('disabled').animate({
            opacity: 1
        }, 200);
    }
    
    _tButton.text(_tButton.attr('data-text'));
    _tButton.removeAttr('style').removeClass('disabled');
        
};

/*
    @Param : elt                - DOM Object - Target of submit
    @Param : successCallback    - Function - Optional - Call XHTTP request for developers
    @Param : disableFormLoader  - Function to disable form loader  
*/
var enableLoader = function(elt){
    var _t = elt;

    if(!_t.find('button[type="submit"]').hasClass('disabled')){

        var _tButton = _t.find('button[type="submit"]');
        var _tButtonWidth = _tButton.width();
        var _tText = _tButton.text();
        var _imgLoader = '<img src="/assets/images/ajax-loader.gif" width="" height="" alt="Loading" class="loader-img" />';
       


        _t.find('input:visible:not(:checkbox, :radio)').attr('disabled', 'disabled').animate({
            opacity: 0.5
        }, 200);
        
        _tButton.attr('data-text', _tText);
        _tButton.width(_tButtonWidth);
        _tButton.append(_imgLoader).addClass('disabled');
    }
};

decathlon.tools = {};
decathlon.tools.init = function () {
  /*
   * Specific dropdown composant for China
   */
  decathlon.tools.multipleDropdown = function(){
      /* LOCATION LAYER - CHINESE ITEM */
      $('body').on('click', '.dropdown-cn button', function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          if ($(this).next('div.result-layout-location').is(':hidden')) {
            $(this).next('div.result-layout-location').show();
          } else
          if ($(this).next('div.result-layout-location').is(':visible')) {
            $(this).next('div.result-layout-location').hide();
          }
      });

      $(document).on('click', function(e){
        if($('.result-layout-location').is(':visible') && $(e.target).parents('div.result-layout-location').length === 0){
          $('.result-layout-location').hide();
        }
      });
  };
  /**
   * Transform data-date attribute selector to UTC countdown
   * @param  {string} - selector - class or id of jquery object (That contains a data-date attribute in MS)
   *
   * Example : data-date="1448985600000"
   */
  decathlon.tools.countdown = function(selector, callbackCountdown){
      function timeRemaining(endtime){
        var t = Date.parse(endtime) - Date.parse(new Date());
        var seconds = Math.floor( (t/1000) % 60 );
        var minutes = Math.floor( (t/1000/60) % 60 );
        var hours = Math.floor( (t/(1000*60*60)) % 24 );
        // var days = Math.floor( t/(1000*60*60*24) );
        
        return {
          'total': t,
          'hours': hours,
          'minutes': minutes,
          'seconds': seconds
        };
      }

      var timerElement = parseFloat($(selector).attr('data-date'));
      var d = new Date(timerElement);
      var now = new Date();
      if (d > now) {
          var deadline = d.toUTCString();
          
          (function initializeCountdown(selector, endtime){
            var t             = $(selector);
            var hoursBlock    = t.find($('.hours'));
            var minBlock      = t.find($('.minutes'));
            var secondsBlock  = t.find($('.seconds'));

            function updateCountdown(){
              var t = timeRemaining(endtime);
              
              if(t.total === 0){

                $(selector).find('.hours, .minutes').text('00:');
                $(selector).find('.seconds').text('00');
                
                clearInterval(timeinterval);
                if(callbackCountdown && typeof callbackCountdown === "function"){
                  return callbackCountdown();
                }

              } else{
                if(hoursBlock.text() !== '00:'){
                  hoursBlock.text(('0' + t.hours).slice(-2)+':');
                }
                if(minBlock.text() !== '00:'){
                  minBlock.text(('0' + t.minutes).slice(-2)+':');
                }
                
                secondsBlock.text(('0' + t.seconds).slice(-2).replace('-', '0'));
              }
            }

            updateCountdown();
            var timeinterval = setInterval(updateCountdown,1000);

          })(selector, deadline);
      }
  };

  /**
   * Display the decathlon loader
   * @param  {boolean}          - display - Display or not the loader
   * @param  {boolean}          - onContent - Display Loader on content with overlay
   * @param  {string} optional  - elt - Define jQuery object where the loader should be displayed, load on body by default.
   */
  decathlon.tools.displayLoader = function(display, onContent, elt){

    if(display === false){
      $('div.d-loader-layout').remove();
      $('body').removeAttr('style');
    }
    else{
      if(display === true){
        var loader = '<div class="d-loader-layout"><div class="d-loader"><img class="d-loader-elt" src="/assets/images/loading.gif" width="36" height="36" alt="Loading" /></div></div>';

        if(typeof elt === 'undefined'){
          $('body').append(loader);
          $('.d-loader-layout').addClass('full-display');

          if(onContent === true) {

            var totalHeightOfHeaderCheckout = $('.header-checkout').height()+$('#breadcrumb-checkout').height()-$(window).scrollTop();
            var layerheight = $(window).height()-totalHeightOfHeaderCheckout-$('div.payment-bar').outerHeight();
            var layoutContent = '<div class="d-loader-layout-content"></div>';

            $('body').css('overflow', 'hidden');
            $('.d-loader-layout').prepend(layoutContent);

            if($('body').hasClass('mobile') && $(window).scrollTop() > 106){
            $('.d-loader-layout-content').css({
                height: $(window).height()-$('div.payment-bar').outerHeight(),
                top: 0
              });
            }
            else{
              $('.d-loader-layout-content').css({
                height: layerheight,
                top: totalHeightOfHeaderCheckout
              });
            }

          }
        }
        else{
          $(elt).append(loader);
        }

      }
    }
  };

};


/**
 * Reinit slick slider after ajax call
 * @param  {[string]} slickParent           CLASS of parent slick slider
 * @param  {[string]} slickElement          CLASS of element to slick
 * @param  {[string]} slickNavElement       CLASS of optionnal slick nav
 * @param  {[function]} slickSettings       Settings for slider
 * @param  {[function]} slickNavSettings    Settings for optional navigation slider
 */
decathlon.tools.slickReinitSlider = function(slickParent, slickElement, slickNavElement, slickSettings, slickNavSettings){

  var callPictureFill = false;

  $(slickParent).each(function(){
    var _t = $(this);

    if(_t.closest('.slick-initialized').length === 0 && _t.find('.slick-initialized').length === 0 && _t.find(slickElement).length > 0 && _t.find(slickElement+' img').length > 1){
        if(slickSettings && typeof slickSettings === "function"){
          _t.find(slickElement).slick(slickSettings(_t.find(slickNavElement)));
        }
        if(slickNavSettings && typeof slickNavSettings === "function"){
          _t.find(slickNavElement).slick(slickNavSettings(_t.find(slickElement)));
        }
    }

    if(_t.find('picture').length > 0){
      callPictureFill = true;
    }
    
  });

  if(callPictureFill === true){
    picturefill();
  }

};

/**
 * gets the slick object options object
 * slickObject : the target slick object
 */
decathlon.tools.getCurrentSlickOptions = function(slickObject){

  var options;

  slickObject = slickObject instanceof jQuery ? slickObject[0] : slickObject;

  if(typeof slickObject.slick !== 'undefined'){
    options = slickObject.slick.options;
  }

  return options;
  
};

/**
 * refreshes all the slick carousels in a container
 * $container : jquery object.
 * If the container is not passed to the function, all the slick objects in the page are refreshed.
 */
decathlon.tools.refreshAllSlicksInTheContainer = function($container){

  var callPictureFill = false,
  options;

  $container = typeof $container === 'undefined' || !($container instanceof jQuery) ? $('body') : $container;

  $container.find('.slick-initialized').each(function(){

    if(typeof this.slick !== 'undefined'){

        options = decathlon.tools.getCurrentSlickOptions(this);

        $(this).slick('unslick').slick(options);

        if($(this).find('picture').length > 0){
          callPictureFill = true;
        }
    }
  });
  
  if(callPictureFill === true){
    picturefill();
  }

};

/**
 * CORE VERSION
 * selector quantity handling
 * @param  {jQuery object} elt - element bind for quantity handling ()
 */
decathlon.tools.selectorQuantity = function(elt){

  var quantityInput = $(elt).siblings('.quantity-input'),
      currentQty = parseInt(quantityInput.val()),
      itemAvailability = quantityInput.attr('data-maxquantity');

  var disabledOrEnabledIfQuantityIsLessThanOne = function(quantity, elt) {
    if(quantity <= 1) {
      elt.attr('disabled', 'disabled');
    } else {
      elt.removeAttr('disabled');
    }
  };
  var newQuantity;
  if($(elt).hasClass('quantity-less')){
  	$(elt).siblings('.quantity-more').removeAttr('disabled');
    if(!isNaN(currentQty)) {
      newQuantity = currentQty - 1;
      quantityInput.val(newQuantity);
      disabledOrEnabledIfQuantityIsLessThanOne(newQuantity, $(elt));
    } else {
      quantityInput.val(1);
    }
  } else if($(elt).hasClass('quantity-more')){
    if(!isNaN(currentQty)) {
      newQuantity = currentQty + 1;
      quantityInput.val(newQuantity);
      disabledOrEnabledIfQuantityIsLessThanOne(newQuantity, $(elt).siblings('.quantity-less'));
      if(newQuantity === parseInt(itemAvailability)) {
        $(elt).attr('disabled', 'disabled');
      }
    } else {
      quantityInput.val(1);
    }
  } else if($(elt).hasClass('quantity-input')){
    var inputQty = parseInt($(elt).val());

    if(inputQty > 1) {
      $(elt).siblings('.quantity-less').removeAttr('disabled');
    } else if(inputQty === 1){
      $(elt).siblings('.quantity-less').attr('disabled', 'disabled');
    } else { // quantity selected lesser than 1 : it's forbidden
      $('.quantity-input').val(1);
    }
  }

};

/**
 * Quantity management for products
 * @param  {string} selector - Your selector to manage
 */
decathlon.tools.selectQuantity = function(selector){

    var customInput = '<div class="custom-input"><input autocomplete="off" min="1" maxLength="3" type="number" class="form-control filter-option" value="'+selector.attr("data-quantity")+'"/></div>';

    if(selector.next('.bootstrap-select').find('.custom-input').length === 0){
      if(!$('body').hasClass('mobile')){
        selector.next('.bootstrap-select').addClass('bt-custom-select').prepend(customInput);
        if(selector.next('.bootstrap-select').hasClass('disabled')) {
          selector.next('.bootstrap-select').find('.filter-option').attr('disabled', 'disabled');
          selector.next('.bootstrap-select').find('button').attr('disabled', 'disabled');
        }
      }
      else{
        if(selector.parent().find('div.custom-input').length === 0){
          selector.parents('.bootstrap-select').addClass('bt-custom-select').prepend(customInput);
          if(selector.next('.bootstrap-select').hasClass('disabled')) {
            selector.next('.bootstrap-select').find('.filter-option').attr('disabled', 'disabled');
          }
        }
      }
    }
};

/**
 * Update count - Add basket
 * @param  {string} elementToUpdate - jQuery Object to update
 * @param  {string} quantityToBaseUpdate - jQuery Object - Value for update
 * @param  {string} fromMainAddToCartButton - True if the addToCart event has been thrown by the main ADD TO CART button on PDP page
 */
decathlon.tools.updateItemCount = function(elementToUpdate, quantityToBaseUpdate, fromMainAddToCartButton){
  
  var initCount = parseInt($(elementToUpdate).text(), 10);
  $(elementToUpdate).text(initCount + parseInt(quantityToBaseUpdate, 10));
  decathlon.tools.displayCartMessage(fromMainAddToCartButton, false);
  
};

/**
 * Display a message, success or error, on top of the conversion zone or I BUY panel
 * @param  {string} fromMainAddToCartButton - True if the addToCart event has been thrown by the main ADD TO CART button on PDP page
 * @param  {boolean} isError - Set to true if we display the message as an error
 */
decathlon.tools.displayCartMessage = function(fromMainAddToCartButton, isError){
	
	var popTop = 0,
	  itemMessage,
	  topPositionOfMessage,
	  positionOfMessage = $('#container-header').height()+$('#top-message-bar').height();
	

		if ($(window).scrollTop() > 66) {
			topPositionOfMessage = 0;
		} else {
			if ($('#modal-product-bundles').hasClass('open in') && $('#modal-product-bundles').offset().top === 0) {
				topPositionOfMessage = 0;
			} else {
				topPositionOfMessage = positionOfMessage;
			}
	  }
  
	  $('#pop-cart').toggleClass("error", isError);
	  $('#pop-cart').find("#add-to-cart-confirm-icon-error").toggle(isError);
	  $('#pop-cart').find("#add-to-cart-confirm-icon-success").toggle(!isError);
	  
	  if (fromMainAddToCartButton) {
		  $('#pop-cart').width($('#modal-product-layout').width());
	  } else {
		  $('#pop-cart').width("100%");
	  }
	  
	  $('#pop-cart').css({
	    top: topPositionOfMessage,
	  }).show();

	  setTimeout(function() {
	    $('#pop-cart').fadeOut(300);
	    $(window).off('scroll.pop-top-position');
	  }, 2000); 
	
};

decathlon.tools.createJqueryPlugin = function(pluginObject){

  var pluginName = pluginObject.pluginName;
  var defaults = pluginObject.defaultOptions;
    
  function Plugin( element, options ) {
      this.el = $(element);
      this.options = $.extend( {}, defaults, options);
      this._defaults = defaults;
      this._name = pluginName;
      this.init();
  }

  Plugin.prototype = pluginObject.prototypeMethods;

  $.fn[pluginName] = function ( options ) {

      var args = arguments;

      var createPluginInstance = function(_this){
        if (!$.data(_this, 'plugin_' + pluginName)) {
            $.data(_this, 'plugin_' + pluginName, new Plugin( _this, options ));
        }
      };

      if (options === undefined || typeof options === 'object') {

          return this.each(function () {
              
              createPluginInstance(this);

          });

      } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
          
          var returns;

          this.each(function () {

              createPluginInstance(this);

              var instance = $.data(this, 'plugin_' + pluginName);

              if (instance instanceof Plugin && typeof instance[options] === 'function') {
                  returns = instance[options].apply( instance, Array.prototype.slice.call( args, 1 ) );
              }

              if (options === 'destroy') {
                $.data(this, 'plugin_' + pluginName, null);
              }
          });

          return returns !== undefined ? returns : this;
      }
  };

};












var uxDynamicSizes = (function(window, $){

  return {

    getScrollbarWidth : function() {
        /* FUNCTION TO DETECT THE SCROLLBAR WIDTH */
        /* USED TO RECALCULATE THE BODY WHEN THE NOSCROLL CLASS IS APPLIED TO THE HTML */
        /*FROM http://davidwalsh.name/detect-scrollbar-width and http://stackoverflow.com/questions/13382516/getting-scroll-bar-width-using-javascript#13382873*/

        var scrollDiv = document.createElement("div");
        scrollDiv.style.width = "100px";
        scrollDiv.style.paddingTop = '10px';
        scrollDiv.style.overflow = "scroll";
        scrollDiv.style.position = "absolute";
        scrollDiv.style.top = "-9999px";
        scrollDiv.style.msOverflowStyle = "scrollbar";
        document.body.appendChild(scrollDiv);

        // Get the scrollbar width
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

        // Delete the DIV 
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
    },

    triggerWindowSpecificResizeEvents : function () {
      var _this = this,
      newWindowWidth = $(window).width(),
      newWindowHeight = $(window).height();

      if(_this.windowWidth != newWindowWidth){
        $(window).trigger('resize-width');
        _this.windowWidth = newWindowWidth;
      }

      if(_this.windowHeight != newWindowHeight){
        $(window).trigger('resize-height');
        _this.windowHeight = newWindowHeight;
      }
    },

    resizeUnits : function () {

        var _this = this,
        containerOpecoHeightDefault = 589,
        leftMenuWidth = 288,
        leftMenuBackgroundMarginLeft = 37;
        _this.globalMenuHeight = 0;

        var windowWidthLimits = _this.windowWidth;
        
        if(windowWidthLimits >= decathlon.uxBreakpoints.lgMin) {
            windowWidthLimits =  decathlon.uxBreakpoints.lgMin;
        } else if (windowWidthLimits <= decathlon.uxBreakpoints.xsMax) {
            windowWidthLimits =  decathlon.uxBreakpoints.xsMax;
        }

        //COEFFICIENTS
        _this.cWidth =  windowWidthLimits / decathlon.uxBreakpoints.lgMin;

        /* DYNAMIC CSS APPLIED TO THE PAGE */

        /* CALCULATES THE SUBMENU LEFT */
        menuSubmenuContentLeft = 360 * _this.cWidth;
        menuSubmenuContentLeft = menuSubmenuContentLeft <= 260 ? 260 : menuSubmenuContentLeft;
        menuSubmenuContentLeft = menuSubmenuContentLeft >= 325 ? 325 : menuSubmenuContentLeft;


        /* CALCULATES THE GLOBAL MENU HEIGHT */
        if (decathlon.uxBreakpoints.is('small-screen')) {
            $('body').addClass('mobile').removeClass('large');
            _this.globalMenuHeight = _this.windowHeight - _this.mobileMenuHeight;
        } else {
            $('body').addClass('large').removeClass('mobile');
            _this.globalMenuHeight = _this.windowHeight - _this.desktopMenuHeight;
        }
        var sportsSearchHeight = $('.menu-search.sports').outerHeight();

        var css = "\
        html.noscroll #block_vertical-nav.show-nav{\
            margin-right : " + _this.scrollbarWidth + "px;\
        }\
        html.noscroll .go-to-top{\
            right : " + _this.scrollbarWidth + "px;\
        }\
        html.noscroll #header,\
        html.noscroll #product-filters.sticky .m-filters,\
        html.noscroll #alert-wrapper{\
            width : " + (_this.windowWidth) + "px!important;\
        }\
        body.large #menu-fixed-opeco,\
        body.large .menu-background,\
        body.large #container-opeco .opeco-carousel,\
        body.large #container-opeco .opeco-carousel .slide {\
            height: " + containerOpecoHeightDefault * _this.cWidth + "px;\
        }\
        html.ie8 #container-opeco{\
            height : auto;\
        }\
        body.mobile #menu-global,\
        body.mobile #menu-global .buttons{\
            width: " + (_this.windowWidth - _this.mobileMenuHeight) + "px;\
        }\
        body.mobile #menu-global{\
            height: " + _this.windowHeight + "px;\
        }\
        body.mobile #menu-global .menu-content,\
        body.mobile #menu-global .menu-submenu{\
            height: " + (_this.windowHeight - _this.mobileMenuHeight) + "px;\
        }\
        body.mobile .sports-list-container-content{\
          height: " + (_this.windowHeight - _this.mobileMenuHeight - sportsSearchHeight) + "px;\
        }\
        body.mobile .sports-list-container-content{\
            width: " + _this.windowWidth + "px;\
        }\
        body.mobile #menu-global .sports-list-container .sports-list-container-content .sports-slide,\
        body.mobile #menu-global .sports-list-container .sports-list-container-content .sports-slide .row a{\
            width: " + (_this.windowWidth - _this.mobileMenuHeight) + "px;\
        }\
        #menu-global,\
        #menu-global .menu,\
        #menu-global .menu-background {\
            height: " + _this.globalMenuHeight + "px;\
        }\
        body.mobile #menu-global .menu-submenu .menu-submenu-contents .menu-submenu-content,\
        body.mobile #menu-global .menu-submenu .menu-submenu-contents .menu-submenu-content .links-group.active ul {\
            height: " + _this.globalMenuHeight + "px;\
        }\
        body.large .menu-group-title,\
        body.large .menu-group-title .text {\
          height: " + Math.round(50 * _this.cWidth) + "px;\
        }\
        body.large .menu-submenu-background{\
            width: " + (_this.windowWidth / 2) + "px;\
        }\
        .menu-background,\
        .menu-shadow,\
        .menu-content{\
            width: " + Math.round((leftMenuWidth+leftMenuBackgroundMarginLeft) * _this.cWidth) + "px;\
        }\
        .menu-content{\
            width: " + Math.round((leftMenuWidth+leftMenuBackgroundMarginLeft+15) * _this.cWidth) + "px;\
        }\
        html.ie8 body .menu-background,\
        html.ie8 body .menu-shadow{\
            width: " + Math.round((leftMenuWidth+leftMenuBackgroundMarginLeft+50) * _this.cWidth) + "px!important;\
        }\
        body.large .menu-all-sports ul li,\
        body.large .menu-sports ul li {\
            height: " + Math.round(80 * _this.cWidth) + "px;\
        }\
        body.large .menu-all-sports ul li a,\
        body.large .menu-sports ul li a {\
            width: " + Math.round(340 * _this.cWidth) + "px;\
            height: " + Math.round(80 * _this.cWidth) + "px;\
        }\
        body.large .menu-all-sports ul li.focus a .image:before,\
        body.large .menu-all-sports ul li.active a .image:before,\
        body.large .menu-sports ul li.focus a .image:before,\
        body.large .menu-sports ul li.active a .image:before {\
            height: " + Math.round(79 * _this.cWidth) + "px;\
        }\
        body.large .menu-all-sports ul li a .image,\
        body.large .menu-sports ul li a .image{\
            width: " + Math.round(80 * _this.cWidth) + "px;\
            height: " + Math.round(80 * _this.cWidth) + "px;\
        }\
        html:not(.ie9) body.large .menu-all-sports ul li a .image .after,\
        html:not(.ie9) body.large .menu-sports ul li a .image .after{\
            width: " + Math.round(80 * _this.cWidth) + "px;\
            height: " + Math.round(80 * _this.cWidth) + "px;\
            padding-top: " + Math.round(80 * _this.cWidth) + "px;\
            background-size: auto " + Math.round(80 * _this.cWidth) + "px;\
        }\
        body.large .menu-all-sports ul li a .text,\
        body.large .menu-sports ul li a .text{\
            width: " + Math.round(130 * _this.cWidth) + "px;\
        }\
        body.large .menu-all-sports ul li a.more-sports .text,\
        body.large .menu-sports ul li a.more-sports .text{\
            width: " + Math.round(230 * _this.cWidth) + "px;\
        }\
        body.large .menu-all-sports ul li a .arrow,\
        body.large .menu-sports ul li a .arrow{\
            width: " + Math.round(40 * _this.cWidth) + "px;\
        }\
        body.large .menu-categories{\
            width: " + Math.round(350 * _this.cWidth) + "px;\
        }\
        body.large .menu-categories ul li a{\
            height: " + Math.round(38 * _this.cWidth) + "px;\
            line-height: " + Math.round(38 * _this.cWidth) + "px;\
        }\
        body.large .menu-categories ul li a .text{\
            width: " + Math.round(256 * _this.cWidth) + "px;\
        }\
        body.large .menu-submenu .menu-submenu-contents .menu-submenu-background {\
            max-width: " + Math.round(1115 *  _this.cWidth) + "px;\
        }\
        body.large .menu-submenu .menu-submenu-contents {\
            width: " + Math.round(1133 *  _this.cWidth) + "px;\
        }\
        body.large .menu-submenu:not(.sports-75) .menu-submenu-contents .menu-submenu-content {\
            padding-left: " + menuSubmenuContentLeft + "px;\
        }\
        body.large .menu-submenu.sports-75 .menu-submenu-contents .menu-submenu-content {\
            padding-left: " + (menuSubmenuContentLeft - 20) + "px;\
        }\
        body.large .menu-submenu:not(.sports-75) .menu-submenu-contents .menu-submenu-content {\
            padding-top: " + Math.round(40 *  _this.cWidth) + "px;\
        }\
        body.large .menu-submenu.sports-75 .menu-search .row,\
        body.large .sports-list-container-content a,\
        html:not(.ie9) body.large .sports-list-container-content a .image .after{\
            height: " + Math.round(80 *  _this.cWidth) + "px;\
        }\
        html:not(.ie9) body.large .sports-list-container-content a .image .after {\
          width: " + Math.round(80 * _this.cWidth) + "px;\
          background-size: auto " + Math.round(80 * _this.cWidth) + "px;\
        }\
        body.large .sports-menu-letters-navigation{\
          height: calc(100% - " + Math.round(80 * _this.cWidth) + "px);\
          top: " + Math.round(80 *  _this.cWidth) + "px;\
        }\
        body.large .sports-list-container .sports-list-container-content .sports-slide a {\
            height: " + Math.round(150 *  _this.cWidth) + "px;\
        }\
        ";


        /* INJECTS A DYNAMIC CSS IN THE HEAD */
        var head = document.head || document.getElementsByTagName('head')[0];
        var style = document.createElement('style');

        style.type = 'text/css';
        style.id = 'override'; // PUT AN ID ON IT IN ORDER TO IDENTIFY IT EASILLY

        if(style.styleSheet){
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }

        var override = document.getElementById("override");
        if (typeof(override) !== 'undefined' && override !== null){
            override.parentNode.removeChild(override);
        }
        
        head.appendChild(style);
        

    },

    init : function(){
        var _this = this;
        _this.cWidth = 1;
        _this.mobileMenuHeight = 58;
        _this.desktopMenuHeight = 66;
        _this.windowWidth = $(window).width();
        _this.windowHeight = $(window).height();
        _this.scrollbarWidth = _this.getScrollbarWidth();

        $(window).on('resize', function() {
            _this.triggerWindowSpecificResizeEvents();
            _this.resizeUnits();
        });

        _this.resizeUnits();
    }
    

  };

})(window, jQuery);


uxDynamicSizes.init();


var uxDynamicStyles = (function(window, $){

  return {

    applyCss : function(cssStylesArrayStyle){

      var _this = this;

      /* INJECTS A DYNAMIC CSS IN THE HEAD */
      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');

      style.type = 'text/css';
      style.id = 'uxdynstyle'; // PUT AN ID ON IT IN ORDER TO IDENTIFY/ADD/REMOVE IT EASILY

      if(style.styleSheet){
          style.styleSheet.cssText = cssStylesArrayStyle;
      } else {
          style.appendChild(document.createTextNode(cssStylesArrayStyle));
      }

      var override = document.getElementById(style.id);

      if (typeof(override) !== 'undefined' && override !== null){
          override.parentNode.removeChild(override);
      }

      head.appendChild(style);
    },

    removeCssStylesArrayFromHeader : function(uniqueIdToRemove){
      var _this = this;

      cssStylesArrayStyle = "";
      
      _this.cssStylesArray = _.reject(_this.cssStylesArray, function(item){
        return item.uniqueId === uniqueIdToRemove;
      });

      for (var i = 0; i < _this.cssStylesArray.length; i++) {
        cssStylesArrayStyle += _this.cssStylesArray[i].selectors.join("") + '{'+_this.cssStylesArray[i].properties.join("")+'}';
      }

      _this.applyCss(cssStylesArrayStyle);
    },

    appendCssStylesArrayToHeader : function(csstoAdd){
      var _this = this;

      cssStylesArrayStyle = "";

      _this.cssStylesArray = _.reject(_this.cssStylesArray, function(item){
        return item.uniqueId === csstoAdd.uniqueId;
      });

      _this.cssStylesArray.push(csstoAdd);

      
      for (var i = 0; i < _this.cssStylesArray.length; i++) {
        cssStylesArrayStyle += _this.cssStylesArray[i].selectors.join("") + '{'+_this.cssStylesArray[i].properties.join("")+'}';
      }
      _this.applyCss(cssStylesArrayStyle);
      

      
      
    },

    init : function(){
      var _this = this;
      
      _this.cssStylesArray = _this.cssStylesArray || [];

      // _this.appendCssStylesArrayToHeader();

      // $(function(){
      //   _this.appendCssStylesArrayToHeader();
      //   $(window).on('resize', _.debounce(function() {
      //       _this.appendCssStylesArrayToHeader();
      //   },100));
      // });
    }

  };

})(window, jQuery);
uxDynamicStyles.init();



/* Dropdown list behavior (display selected value in the dropdown) */
/* WHY IT IS TARGETING ALL THE DROPDOWN MENUS =S I HAD TO FILTER THE DROP-LANG-LIST OFF */
$(".dropdown-menu:not('.drop-lang-list') li a").click(function(e){
    e.preventDefault();
    var parent = $(this).closest(".dropdown");
    var target = parent.find("button[type='button']");
    parent.find('.active').removeClass('active');

    if($(this).text().length > 0){
        target.html($(this).html());
        target.val($(this).html());
    }
    else if($(this).find('img')){
        target.empty();
        $(this).find('img').clone().appendTo(target);
    }


    $(this).parent().addClass('active');
});

/* CONFIGURES LAZYSIZES GLOBALLY */
window.lazySizesConfig = window.lazySizesConfig || {};
window.lazySizesConfig.addClasses = true;
window.lazySizesConfig.preloadAfterLoad = false;

/* ANIMATION TIMES */
var uxGAP = (function(){

  return {

    _name : 'Global Animation Times',
    pixelsPerSecond : 400,
    minimumSpeed : 0.5,
    maximumSpeed : 1.5,

    speed : function(dim){
      _this = this;
      _this.dimension = typeof dim == 'number' ? dim : 300;
      _this.parametricSpeed = _this.dimension / _this.pixelsPerSecond;
      _this.animationSpeed = _this.parametricSpeed > _this.minimumSpeed ? _this.parametricSpeed : _this.minimumSpeed;
      _this.animationSpeed = _this.animationSpeed < _this.maximumSpeed ? _this.animationSpeed : _this.maximumSpeed;
      return _this.animationSpeed;
    },

    uxCheckScrollDirection : function(){
      var _this = this,
      direction = "static";
      function directionfn() {
          var st = window.pageYOffset;

          if (st > _this.lastScrollTop) {
              direction = "down";
          } else if (st < _this.lastScrollTop ){
              direction = "up";
          }
          _this.lastScrollTop = st;
          return direction;
      }
      return directionfn();

    }

  };

})();


;(function(window, $){
  
  var uxCheckScrollSpeed = (function(settings){
    settings = settings || {};

    var lastPos, newPos, timer, delta,
        delay = settings.delay || 30;

    function clear() {
      lastPos = null;
      delta = 0;
    }

    clear();

    return function(){
      newPos = window.scrollY;
      if ( lastPos !== null ){
        delta = newPos -  lastPos;
      }
      lastPos = newPos;
      clearTimeout(timer);
      timer = setTimeout(clear, delay);
      return delta;
    };
  })();

  $(window).on('scroll.uxGAP', function(){
    if(uxDynamicSizes.windowWidth <= decathlon.uxBreakpoints.xsMax){
      uxGAP.windowScrollSpeed = uxCheckScrollSpeed();
      uxGAP.windowScrollDirection = uxGAP.uxCheckScrollDirection();
    } else {
      uxGAP.windowScrollSpeed = 0;
      uxGAP.windowScrollDirection = "static";
    }
  });

})(window, jQuery);

// On DOM ready, check selectpicker element & become a nativ select element.
$(function(){
  if($('html').hasClass('touch') && $('body').hasClass('mobile') && $('.selectpicker').length > 0){
      $('.selectpicker').selectpicker('mobile');
  }

  $(document).on('focus', 'input.filter-option', function(){
    if($(this).parents('.bootstrap-select').hasClass('open')){
      $(this).parents('.bootstrap-select').removeClass('open');
    }
  }).on('blur', 'input.filter-option', function() {
    if($(this).val() < 1 || $(this).val() === ''){
      $(this).val($(this).attr('value'));
    }
  }).on('keyup', 'input.filter-option', function(e){
    if($(this).val().length === 0){
      $(this).val('');
    }
    else if($(this).val() < 0){
      $(this).val(1);
    }
  });

});

/* Prevent window from scrolling when the nowscroll when the html has the noscroll class */
;(function(window, $){
  $(document).on('touchmove', function(e) {
    if($('html').hasClass('noscroll') && decathlon.uxBreakpoints.is('large-screen')){
      e.preventDefault();
    } else if( $('html').hasClass('mobile-popin-open') && decathlon.uxBreakpoints.is('small-screen')){
      e.preventDefault();
    }
  });
})(window, jQuery);


/* method used by product-filters.js */
;(function(window, $){
  $.fn.extend({
    has_scrollbar : function(){
      var divnode = this.get(0);
        if(divnode.scrollHeight > divnode.clientHeight)
            return true;
    }
  });
})(window, jQuery);


/* For small screens, even if there is a target _blank set in an anchor, the url opens in the same tab */
;(function(window, $){
  $(document).on('click', 'a[target="_blank"]', function(e){
    if(decathlon.uxBreakpoints.is('small-screen')){
      e.preventDefault();
      window.open($(this).attr('href'), '_self');
    }
  });

  //KAMELEON CONTENT 
  $(document).on('click', 'a.kameleon-content', function(e){
    if(decathlon.uxBreakpoints.is('small-screen')){
      e.preventDefault();
      var newUrl = $(this).attr('href') + '?version=no-header&back=' + window.location.href;
      window.open(newUrl, '_self');
    }
  });

})(window, jQuery);


;(function(window, $){

  /* When the user clicks or presses enter or the space bar on an internal anchor, this js focuses the target container */
  /* this function doesn't control the window scroll */

  decathlon.tools.internalLinkFocusOnTheContainer = function(e, selector){
    
    e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = false;
    
    $target = $('[id^="'+selector+'"]');
    $target = $target.length === 0 ? $('a[name^="'+selector+'"]') : $target;
    $target = $target.length === 0 ? $('a[data-dynamic-nav^="'+selector+'"]') : $target;

    if($target.length === 1){
      $target.attr('tabindex', -1).focus().on('blur', function(){
        $(this).removeAttr('tabindex');
      });
    }

  };

  $('body').not('.workshop-template').on('click',
      'a[href^="#"]:not([href="#"]):not([href="#phrase-editor-tab-source-translation"]):not([href="#phrase-editor-tab-meta"])',
      function(e){
    decathlon.tools.internalLinkFocusOnTheContainer(e, $(this).attr('href').replace('#',''));
  })

  .on('keydown', 'a[href^="#"]:not([href="#"])', function(e){
      var keycode = (event.keyCode ? event.keyCode : event.which);
      if( keycode === 13 || keycode === 32 ){
        decathlon.tools.internalLinkFocusOnTheContainer(e, _this.attr('href').replace('#',''));
      }
  });

})(window, jQuery);

(function(namespace) {
  
  /**
   * Returns true/false whether the viewport bootstrap size corresponds to the actual size.
   */
  namespace.isViewportOfSize = function(size) {
    var $checkers = $('#viewport-checkers');
    if ($checkers.length === 0) {
      $checkers = $('' +
        '<div id="viewport-checkers">' +
          '<div id="xs-tester" class="visible-xs-block"></div>' +
          '<div id="sm-tester" class="visible-sm-block"></div>' +
          '<div id="md-tester" class="visible-md-block"></div>' +
          '<div id="lg-tester" class="visible-lg-block"></div>' +
        '</div>');
      $('body').append($checkers);
    }
    switch(size) {
    case 'xs':
      return $checkers.children('#xs-tester').is(':visible');
    case 'sm':
      return $checkers.children('#sm-tester').is(':visible');
    case 'md':
      return $checkers.children('#md-tester').is(':visible');
    case 'lg':
      return $checkers.children('#lg-tester').is(':visible');
    default:
      console.error('Available viewport sizes are xs, sm, md and lg.');
    }
    return false;
  };
  
  /**
   * Attaches a callback for the resize event, limiting the number of executions for performance reasons.
   * Limitation is set to 2 times per second.
   */
  namespace.onResize = function(callback) {
    window.addEventListener('resize', limiter, false);
    var timeout;
    function limiter() {
      if (!timeout) {
        timeout = setTimeout(function() {
          timeout = null;
          callback();
        }, 500);
      }
    }
  };
  
})(decathlon.tools = decathlon.tools || {});


// Bootstrap Select plugin to manage tooltip errors
// For example, pls check cube components page
(function ($){

    $.fn.setBootstrapSelectError = function(options) {
      var parentThis = $(this);

      // Internal function called at two moments (see below)
      function _internal(element){
        options.errorText = typeof options.errorText !== 'undefined' ? options.errorText : 'Please select a value';
        options.placement = typeof options.placement !== 'undefined' ? options.placement : 'auto';

        if( !$(element).parent().hasClass('bootstrap-select-has-error') )
        {
          $(element).wrap('<div style="display:inline-block" class="bootstrap-select-has-error" data-toggle="tooltip" data-placement="'+options.placement+'" title="'+options.errorText+'"></div>');
          $(element).addClass('has-error');
        }

        if(options == 'show')
          $(element).addClass('has-error');

        if(options == 'destroy')
          $(element).removeClass('has-error');

        if(options.errorText)
          $(element).parent().attr('data-original-title', options.errorText);

        if(options.placement)
          $(element).parent().attr('data-placement', options.placement);

        $(element).parent().tooltip(options);
      }

      // Called at window BS init
      $(window).on('load.bs.select.data-api', function(){ _internal(parentThis); });

      // Called another time
      _internal(parentThis);

      return $(parentThis);


    };
}(jQuery));

(function ( $ ) {

    $.fn.pushAlert = function(options) {

      /*
        Example for options

        var options ={
          type:'info (or danger, warning, success)',
          text:'My text to show, with HTML tags if needed :)'
          icon:'bell (or chrono)'
          delay: 3000,
          class: "my-class",
          show: true
        }

      */

      // Get parent node
      var $this = $($(this).selector);

      // Get options
      options = ((typeof options !== 'undefined') ? options : Array());
      options.type = ((typeof options.type !== 'undefined') ? options.type : 'info');
      options.text = ((typeof options.text !== 'undefined') ? options.text : 'My text goes here');
      options.icon = ((typeof options.icon !== 'undefined') ? options.icon : false);
      options.delay = ((typeof options.delay !== 'undefined') ? options.delay : 10000);
      options.limit = ((typeof options.limit !== 'undefined') ? options.limit :  $('#header').height() + $('#top-message-bar').height() + $('.header-checkout').height() + $('.breadcrumb-checkout').height());
      options.show = ((typeof options.show !== 'undefined') ? options.show : false);
      options.klass = ((typeof options.klass !== 'undefined') ? options.klass : "");

      // Save in localStorage an historic of this message alert, for TNR purposes
      function historizeError(errorType, errorMessage) {
  		if (typeof Storage !== void(0)) {
  			var lastErrors = JSON.parse(localStorage.getItem("LastErrors"));
  			if (!lastErrors) {
  				lastErrors = new Array();
  			}
  			lastErrors.push({type: errorType, message: errorMessage, location: location.href});
        try { localStorage.setItem("LastErrors", JSON.stringify(lastErrors)); } catch (e) { }
  		}
      }
      
      // This function will delete existing alert, and replace it with new call
      function _checkExists(){
        $('#alert-wrapper').remove();
      }

      function _initUX()
      {
        // Call
        new UX_CheckoutAlert($('#alert-wrapper'), Math.floor(options.limit) , options.delay);
      }

      // Internal functions
      function _init(){

        // Check if previous alert exists, and delete it if needed
        _checkExists();

        // Alert structure
        var content = '<div id="alert-wrapper" class="'+options.klass+'">'+
                        '<div style="top: -100px;" class="alert alert-'+options.type+'">';

        // If icon option is specified
        if(options.icon)
          content += '<div class="container-icon"><span class="animate-icon '+options.icon+'"></span></div>';

        content +='<div class="wrapper">'+
                      '<div class="text">'+
                        '<p>'+ options.text +'</p>'+
                      '</div><span class="close icon icon-x-line"></span>'+
                    '</div>'+
                  '</div>'+
                '</div>';

        $this.prepend(content);

        _initUX();

      }
      
      historizeError(options.type, options.text);

      if(options.show){
        _initUX();
      }
      else{
        _init();
      }


      // Return node
      return this;
    };

}( jQuery ));

// STICKY ALERT OBJECT
// - obj alert
// - limitHeight - offsetTop
// - alert Duration

var UX_CheckoutAlert = function(obj, limit, delay) {
  this.objAlert = obj;
  this.limitHeight = limit;
  this.alertDuration = delay;

  this.listenEvents();
};
// Event listener & dispatcher
UX_CheckoutAlert.prototype.listenEvents = function(){
    var _this = this;

    // animation for alert appearance
    this.alertAppears();

    // activate associated listeners
    _this.alertOn();

    // calling for disactivate alert & associated listeners after a delay
    setTimeout( function(){
        _this.alertOff(false);
    }, _this.alertDuration);

    // event listener to disable alert manually
    this.objAlert.find('.close').on('click', function(){
        _this.alertOff(true);
    });
};
// Animation for alert appearance
UX_CheckoutAlert.prototype.alertAppears = function(){
	//CUBE.Analytics.trackAlert("DisplayAlert");
    var _this = this;
    var scrolltop = $(window).scrollTop();
    var offsetTop = ((_this.limitHeight - scrolltop > 0) ? (_this.limitHeight - scrolltop) : 0);

    $('#alert-wrapper').css('z-index', '9999');

    if($('#header').hasClass('sticky') || $('html').hasClass('product-head-sticky')){
      offsetTop = $('#header').height();
    }

    _this.stickToTop(scrolltop);

    _this.objAlert.find('.alert').animate({
        'top': '0px'
    }, 500, function(){
        _this.objAlert.addClass('on');
    });
};
// Animation for alert disappearance
UX_CheckoutAlert.prototype.alertDisappears = function(){
    var _this = this;
    _this.objAlert.find('.alert').animate({
        'top': '-100px'
    }, 500, function(){
        _this.objAlert.removeClass('on');
        $('#alert-wrapper').remove();
        if($('body').hasClass('with-alert')){
          $('body').removeClass('with-alert');
        }
    });
};
// function for unable alert & associated listeners
UX_CheckoutAlert.prototype.alertOn = function(){
    var _this = this;

    $(window).on('scroll.stickyAlert', function() {
        var scrolltop = $(window).scrollTop();
        _this.stickToTop(scrolltop);
    });
};
// function for disable alert & associated listeners
UX_CheckoutAlert.prototype.alertOff = function(manual){
    var _this = this;

    if(_this.objAlert.hasClass('on')){
    	if (manual) {
    		//CUBE.Analytics.trackAlert("CloseAlertManually");
    	} else {
    		//CUBE.Analytics.trackAlert("CloseAlertAutomated");
    	}
        $(window).off('scroll.stickyAlert');
        _this.objAlert.removeClass('on');
        _this.alertDisappears();
    }
};
// function which stick alert -
// below the breadcrumb if scrollTop < limitHeight - at 0px if scrollTop > limitHeight
UX_CheckoutAlert.prototype.stickToTop = function(scrolltop){
     var _this = this;
     var headerHeight = $('#header').height();

     // Fix header to right position
     if(_this.limitHeight - scrolltop > 0) {
       _this.objAlert.css('top', _this.limitHeight - scrolltop+'px');
     }
     else {

      //  // Header hidden or not fixed
      //  if (headerPosition < 0 || isNaN(headerPosition)) {
      //    _this.objAlert.css('top', '0px');
      //  }
      //  // Header displayed
      //  else{
      //    _this.objAlert.css('top', headerHeight + 'px');
      //  }



    	//_this.objAlert.css('top', headerHeight + 'px');


       if($('#header').hasClass('sticky') || $('#header').hasClass('mobile-sticky')){
        _this.objAlert.css('top', headerHeight + 'px');
       } else {
        _this.objAlert.css('top', '0px');
       }
     }

};

// Namespace loader
if (typeof Cube !== 'object') {
	var Cube = {};
}

// Class loader & defaults parameters
Cube.InfiniteScroll = function() {
	
	/**
	 * Internal parameters
	 */
	this._parameters = {
		navigationToBottomGap: null
	};
	
	/**
	 * API options
	 */
	this.options = {
		$nextButton: null,
		bufferHeight: 40
	};
	
};

// Class methods
Cube.InfiniteScroll.prototype = {
	
	/* ************************************** */
	/* ********** Internal methods ********** */
	/* ************************************** */
	
	/**
	 * Create instance
	 */
	_create: function() {
		var that = this;
		var opts = this.options;
		var params = this._parameters;
		
		// Distance from nav links to bottom
		if(params.navigationToBottomGap === null) {
			params.navigationToBottomGap = $(document).height() - opts.$nextButton.offset().top;
		}
		
		$(window).on('smartscroll.infscr', function() {
			that._bindScroll();
		});
	},
	
	/**
	 * Scroll binder
	 */
	_bindScroll: function() {
		if (this._nearbottom()) {
			this.pageNext();
		}
	},
	
	/**
	 * Check scroll position regarding page bottom
	 */
	_nearbottom: function() {
		var opts = this.options;
		var params = this._parameters;
		var near = false;
		
		var windowToBottomGap = 0 + $(document).height() - ($(window).scrollTop()) - $(window).height();
		// If distance remaining in the scroll (including buffer) is less than the orignal nav to bottom....
		if (windowToBottomGap - opts.bufferHeight < params.navigationToBottomGap) {
			near = true;
		}
		
		return near;
	},
	
	/* **************************************** */
	/* ********** API public methods ********** */
	/* **************************************** */
	
	/**
	 * Set class options
	 */
	setOptions: function(options) {
		this.options = $.extend(true, {}, this.options, options);
		
		return this;
	},
	
	/**
	 * Load API
	 */
	load: function() {
		var opts = this.options;
		
		// Only create if $nextButton is defined and navigation elements are in the DOM
		if (opts.$nextButton !== null && opts.$nextButton.length > 0) {
			this._create();
		}
		
		return this;
	},

	destroy: function(){
		$(window).off('smartscroll.infscr');
	},
	
	/**
	 * Load next page
	 */
	pageNext: function() {
		this.options.$nextButton.click();
		
		return this;
	}
	
};

var UX_Global = function() {
  
};

UX_Global.prototype.ajaxHandler = function(method, url, dataString, dataType, successCallback, completeCallback, errorCallback) {
  $.ajax({
    type: method,
    url: url,
    data: dataString,
    dataType: dataType,
    success: function(data){
      if(successCallback && typeof successCallback === "function"){
        return successCallback(data);
      }
    },
    complete: function(){
      if(completeCallback && typeof completeCallback === "function"){
        return completeCallback();
      }
    },
    error: function(jqXHR, textStatus, errorThrown){
      if(errorCallback && typeof errorCallback === "function"){
        return errorCallback();
      }
    }
  });
};


UX_Global.prototype.defineResolution = function(){
  var res;
  if($(window).width() >= decathlon.uxBreakpoints.lgMin){
    res = "desktop";
  } else if($(window).width() <= decathlon.uxBreakpoints.mdMax && $(window).width() >= decathlon.uxBreakpoints.smMin) {
    res = "tablet";
  } else {
    res = "mobile";
  }
  return res;
};

UX_Global.prototype.defineEnvironment = function(){
  var uxEnvironment = 'distant';
  return uxEnvironment;
};

// CROSS BROWSER TRIGGER EVENT
UX_Global.prototype.triggerEvent = function(el,eventName){
  var event;
  if(document.createEvent){
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName,true,true);
  }else if(document.createEventObject){// IE < 9
      event = document.createEventObject();
      event.eventType = eventName;
  }
  event.eventName = eventName;
  if(el.dispatchEvent){
      el.dispatchEvent(event);
  }else if(el.fireEvent && htmlEvents['on'+eventName]){// IE < 9
      el.fireEvent('on'+event.eventType,event);// can trigger only real event (e.g. 'click')
  }else if(el[eventName]){
      el[eventName]();
  }else if(el['on'+eventName]){
      el['on'+eventName]();
  }
};

/*
  UX_MapObject 
  a class for each googlemaps and baidu maps

  parameters :
    - mapObject : string
      Mandatory
      id of map container (no need '#')
    - typeMap : string
      Mandatory
      gmap or bmap
    - storesData : json data
      Mandatory
    - callURL : jstring - url
      optional - ( = null)
      an url to call data form server
    - localisator : jquery object (true) or false
      optional - ( = false)
      is 'locate me' button there ?
    - formAddress : jquery object (true) or false
      optional - ( = false)
      is search address area there ?
    - offCentered : boolean
      optional - ( = false)
      is the map  offcentered ? (like in store page, desktop and tablet view)
    - panel : jquery object (true) or false
      optional - ( = false)
      is the side panel with list of results there ?
    - showStore : boolean
      optional - ( = false)
      is the first shop activate after init ?


  methods :
    dispatcher
      void
    initGMap - TODO
    initBMap
      void
    switchOverlays
      position (BaiduPoint - center of Map)
    createAggregation
      void
    createStores
      void
    clickOnmarkers
      marker (BaiduMarker)
      _iw -(json data)
    createCustomOverlay 
      -- call from createStores
      point - Baidu Point
      i - loop index
      -> return custom template for our own marker
    createInfoWindow
      -- call from createStores
      dataObj - data from bdd or baidu (if parsed)
      -> return info window template, need createtemplateInfo to set data
    fillPanel
      -- call from createtemplateInfo
      dataObj - json data
      i - iterator
    createtemplateInfo
      -- call from createInfoWindow
      dataObj - data from bdd or baidu (if parsed)
      -> return generic template with info store
    adjustView
     void
    geolocation
      void
    locateMe
      void
    searchAddress
      form - the form element
    markUser
      point - Baidu Point
    callServer
      global - boolean (is the initilisation ?)
    setStoreData 
      data - data from bdd
    itinary
      cible - the event button
    calculateDistance
      point (BaiduPoint)

*/

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

var UX_MapObject = function(attr) {
  this.map = {}; // the map object itself

  this.mapObject = attr.mapObject; // id of dom element which wrap the map
  this.typeMap = attr.typeMap; // 'gmap' or 'bmap'
  this.storesData = attr.storesData; // json array - data of one or several stores
  this.callURL = ((attr.callURL) ? attr.callURL : null); // string - 
  this.callGlobalURL = ((attr.callGlobalURL) ? attr.callGlobalURL : null); // string - 
  this.localisator = ((attr.localisator) ? attr.localisator : null); // the 'locate me !' button, if exists
  this.formAddress = ((attr.formAddress) ? attr.formAddress : null); // the search address area, if exists
  this.offCentered = ((attr.offCentered) ? attr.offCentered : false); // is the map is offcentered (like storepage in dektop and tablet view)
  this.panel = ((attr.panel) ? attr.panel : null); // side panel which contain a list of results (in storelocator page)
  this.showStore = ((attr.showStore) ? attr.showStore : false); // boolean - 
  
  this.globalTool = new UX_Global(); // an instance of Global Class for usefull tools !

  this.allStoresData = {};

  // define environnement and configure some var according to this environnement
  this.environment = this.globalTool.defineEnvironment();
  this.pathToAssets = ((this.environment == 'local') ? '../' : '/assets/');

  // TODO - need to externalize those data
  this.originalData = [37,105,5];
  this.isAggregated = false;
  this.isLocalised = false;

  // this.panorama; -- WIP

  this.point = null; // the center of map
  this.markers = []; // a list of all the markers
  this.markerClusterer = [];
  // this.resolution; // use the the defineResolution function in Global Class (call bellow in dispatcher);

  this.welcomeMessage = '';

  // let the music plays !
  this.dispatcher();
  
  this.location = {}; // User location
};

// Event listener & dispatcher
UX_MapObject.prototype.dispatcher = function(){
  var _this = this;
  var the_timer;

  // dispacth init function - default is googlemaps
  switch(_this.typeMap) {
    case 'gmap' :
      _this.initGMap();
      break;
    case 'bmap' :
      _this.initBMap();
      break;
    default :
      _this.initGMap();
      break;
  }

  // need the defineResolution function in Global Class
  _this.resolution = _this.globalTool.defineResolution();
    
  // listener for adjust the map viewport
  $(window).on('resize', function(){
    clearTimeout(the_timer);
    the_timer = setTimeout(function(){
      _this.resolution = _this.globalTool.defineResolution();
      _this.adjustView();
    }, 75);
  });

  // locate me ! if button exists !
  if(_this.localisator){

    // we don't display the localisation until we have user coords
    $('.location, .geolocate-error').hide();

    if(_this.typeMap == 'bmap') {
    	_this.localisator.on('click', function(e){
    	      e.preventDefault();
    	       _this.locateMe();
    	      //_this.markerClusterer.clearMarkers();
    	      // we need the geolocation result to call server because user location data are required
    	      //_this.callServer();
    	    });
    }
    
  }

  // search address
  if(_this.formAddress){
    _this.formAddress.on('submit', function(e){
      e.preventDefault();
       _this.searchAddress($(this));
    });
  }

  $('body').on('click', '.itinary', function(e){
    e.preventDefault();
    _this.itinary($(e.target));
  });

};

// Launch GoogleMaps
UX_MapObject.prototype.initGMap = function(){
    var _this = this;
    
    console.log("Init Map for GoogleMap");
    // TODO
};

// Launch BaiduMaps
UX_MapObject.prototype.initBMap = function(){
	console.log("Init Map for BAIDU");
    var _this = this;

    _this.map = new BMap.Map(_this.mapObject);

    // those data are defined in constructor
    var data = _this.originalData;
    //var data = _this.storesData.split(',');

    // baidu map require long before lat !!!
    // at this moment _this.point represent the default coords
    _this.point = new BMap.Point(data[1], data[0]);
    

    // Disable dragg and drop on mobile
    if (jQuery('body').hasClass('mobile')) {
        _this.map.disableDragging();
    }
    
    // disable scroll zoom wheel
    _this.map.disableScrollWheelZoom();
    // add scale control and zoom control tool in bottom right
    _this.map.addControl(new BMap.ScaleControl({anchor: BMAP_ANCHOR_BOTTOM_RIGHT}));
    _this.map.addControl(new BMap.NavigationControl({anchor: BMAP_ANCHOR_BOTTOM_RIGHT}));
    
    // center the point
    _this.map.centerAndZoom(_this.point, data[2]);
    _this.currentZoom = data[2];

    if(!_this.offCentered){
      _this.map.addEventListener('tilesloaded', function(){
        var position = _this.map.getCenter();
        _this.switchOverlays(position);
      });

      _this.callServer(true);
    }

    if(_this.panel){
      _this.welcomeMessage = _this.panel.find('.welcome-sentance');
    }

};

// should we display aggregation or simple marker - according to zoom level (call in function above)
UX_MapObject.prototype.switchOverlays = function(position){
  var _this = this; 

  if(_this.map.getZoom() >= 11){
    _this.point = position;
    // _this.map.clearOverlays();
    _this.markerClusterer.clearMarkers();
    //_this.markerClusterer.setOptions({"visible": false});
    _this.callServer();
  } else if(_this.isAggregated !== true){
    _this.panel.removeClass('loading');
    _this.map.clearOverlays();
    _this.panel.empty().append(_this.welcomeMessage);
    _this.createAggregation();
  }

  if(_this.isLocalised){
    _this.markUser(_this.user);
  }
};

// create aggregates markers on the maps, according to datas get by ajax calling
UX_MapObject.prototype.createAggregation = function(){
  var _this = this;
  var fromLocation = 'OC';
  var points = [];

  _this.markers.length = 0;
  // we are allready JSON parsed data in callServer function

  for(var i = 0; i < _this.allStoresData.length; i++) {
    // we keep the obj storeData in var
    var dataObj = _this.allStoresData[i];

    // create a point and marker for each store in storesData array
    var pos = dataObj.geoCode.split(',');
    var point = new BMap.Point(pos[1], pos[0]);
   

    // we create markers
    var icon = new BMap.Icon(_this.pathToAssets+"images/pin-icon-blue.png", new BMap.Size(22,35));
    var marker = new BMap.Marker(point,{icon: icon});
    _this.markers.push(marker);

    points.push(point);

  }

  var markerClustererStyles = [
    {
        url: _this.pathToAssets + 'images/cluster-min.png',
        size: new BMap.Size(38, 38),
        opt_anchor: [24, 0],
        textColor: 'white',
        textSize: 12
    }, {
        url: _this.pathToAssets + 'images/cluster-mid.png',
        size: new BMap.Size(44, 44),
        opt_anchor: [28, 0],
        textColor: 'white',
        textSize: 14
    }, {
        url: _this.pathToAssets + 'images/cluster-max.png',
        size: new BMap.Size(50, 50),
        opt_anchor: [32, 0],
        textColor: 'white',
        textSize: 16
    }
  ];

  _this.markerClusterer = new BMapLib.MarkerClusterer(_this.map, {
    markers:_this.markers, 
    minClusterSize: 1,
    maxZoom: 12,
    isAverangeCenter: true,
    styles: markerClustererStyles
  });

  _this.isAggregated = true;
};

// create the marker(s) on the maps, according to datas get by ajax calling
UX_MapObject.prototype.createStores = function(){
  var _this = this;

  // we are allready JSON parsed data in callServer function
  _this.markers.length = 0;

  for(var i = 0; i < _this.storesData.length; i++) {
    // we keep the obj storeData in var
    var dataObj = _this.storesData[i];
    var icon, point;

    // create a point and marker for each store in storesData array
    var pos = dataObj.geoCode.split(',');
    point = new BMap.Point(pos[1], pos[0]);

   
    // if we have more than one icon, we must create custom marker with an number in order to identicate then easily
    if( _this.storesData.length > 1) {
      // false markers with number if there are more than one 
      icon = new BMap.Icon(_this.pathToAssets+"images/pin-icon-transparent.png", new BMap.Size(22,35));
      // create custom marker
      var myCompOverlay = _this.createCustomOverlay(point, i);
      // add custom marker(s) on map
      _this.map.addOverlay(myCompOverlay);

    } else {
      // basic blue icon if there is only one marker
      icon = new BMap.Icon(_this.pathToAssets+"images/pin-icon-blue.png", new BMap.Size(22,35));

      // we need to fix the point origin for further uses
      _this.point = point;
    }


    // we create markers
    var marker = new BMap.Marker(point,{icon: icon, title: (i+1)});
    _this.markers.push(marker);
    
    var _json = dataObj;
    var _iw = _this.createInfoWindow(_json);
    _this.clickOnmarkers(marker, _iw);
      
    
    // finally we add real transparent baidu marker in order to make interaction with infoWindow
    // because custom marker can't be associated with infoWindow
    _this.map.addOverlay(_this.markers[i]);
  }

  // open the info window after map initialisation
  if(_this.showStore){
    _this.globalTool.triggerEvent(_this.markers[0], 'click');
    _this.map.setZoom(10);
  }

  // create the side panel, if exists and we have store data
  if(_this.panel && (_this.storesData.length > 0)){
    _this.panel.addClass('loading');
    _this.createPanel();
  } else if((_this.storesData.length <= 0)) {
	  var errorMsg = Messages('storelocator.errormsg.nostorefound');

	  $('#geolocate-error-message').html(errorMsg);
	  $('.geolocate-error').show();
  }

  _this.isAggregated = false;
};

// creation of custom overlay - marker and number
UX_MapObject.prototype.clickOnmarkers = function(marker, _iw){
  var _this = this;

  // if browser supports addEventListener method - always but ie8 :(
  if(marker.addEventListener){
        marker.addEventListener("click",function(){
          this.openInfoWindow(_iw);
          var index = _this.markers.indexOf(this);
          _this.panel.find('.selected').removeClass('selected');
          _this.panel.find('li:nth-child('+(index+1)+')').addClass('selected');
        });
      } else {
        // still the same - for ie8
        marker.attachEvent('onclick', function(){
          this.openInfoWindow(_iw);
        });
      }
};

// creation of custom overlay - marker and number
UX_MapObject.prototype.createCustomOverlay = function(point, i){
  var _this = this;

  // Baidu's method to create custom overlay, we want our own markers !
  function ComplexCustomOverlay(point, text){
    this._point = point;
    this._text = text;
  }

  ComplexCustomOverlay.prototype = new BMap.Overlay();
  ComplexCustomOverlay.prototype.initialize = function(map){
    this._map = map;
    var div = this._div = document.createElement("div");
    div.style.position = "absolute";
    //div.style.zIndex = BMap.Overlay.getZIndex(this._point.lat);
    div.style.background = "url('"+_this.pathToAssets+"images/pin-icon-blue-plain.png') no-repeat center center";
    div.style.color = "white";
    div.style.height = "35px";
    div.style.width = "22px";
    div.style.padding = "7px 2px";
    div.style.lineHeight = "12px";
    div.style.whiteSpace = "nowrap";
    div.style.textAlign = "center";
    div.style.MozUserSelect = "none";
    div.style.fontSize = "16px";
    var span = this._span = document.createElement("span");
    div.appendChild(span);
    span.appendChild(document.createTextNode(this._text));
    var that = this;

    _this.map.getPanes().labelPane.appendChild(div);
    
    return div;
  };

  ComplexCustomOverlay.prototype.draw = function(){
    var map = this._map;
    var pixel = map.pointToOverlayPixel(this._point);
    this._div.style.left = pixel.x - 11 + "px";
    this._div.style.top  = pixel.y - 18 + "px";
  };

  var myCompOverlay = new ComplexCustomOverlay(point, String(i+1));

  return myCompOverlay;
};

// create window info on map - use createtemplateInfo() method bellow
UX_MapObject.prototype.createInfoWindow = function(dataObj){
  var _this = this,
  content = '';

  // call the common template with createtemplateInfo()
  var templateInfo = _this.createtemplateInfo(dataObj);

  if(_this.typeMap == 'gmap') {

  } else if(_this.typeMap == 'bmap') {
    // baidumap
    content =  new BMap.InfoWindow('<div class="info-store">'+templateInfo+'</div>');
  }
  return content;
};

// generic function to load informations into panel - called by createPanel() function
UX_MapObject.prototype.fillPanel = function(dataObj, i){
  var _this = this;

  var templateInfo = _this.createtemplateInfo(dataObj);
  // creation of each list element
  var result = $('<li></li>');
  result.addClass('info-store');
  result.append(templateInfo);

  var marker = _this.markers[i];

  // attach event - a click in element triggers an event on the associated marker
  result.find('.store-name').on('click', function(e){
    _this.panel.find('.selected').removeClass('selected');
    $(this).closest('li').addClass('selected');
    var ev = document.createEvent('HTMLEvents');
    ev.initEvent('click', false, true);
    marker.dispatchEvent(ev);
  });

  return result;
};

// create a common template for window info (in map) and list element (in side panel)
UX_MapObject.prototype.createtemplateInfo = function(dataObj){
  var _this = this;
  // common data extraction
  var storeId = ((dataObj.storeId) ? dataObj.storeId : "");

  var storeName = ((dataObj.storeName) ? dataObj.storeName : "");

  var address = ((dataObj.address.address1) ? dataObj.address.address1 : "");
  var postalCode = ((dataObj.address.postalCode) ? dataObj.address.postalCode : "");
  var city = ((dataObj.address.city) ? dataObj.address.city : "");
  
  var storeAddress = address +'<br/>'+postalCode +' '+city;
  var storeContact = ((dataObj.phoneNumber) ? dataObj.phoneNumber : "");

  var pos = dataObj.geoCode.split(',');
  var itinarylink = '<a class="itinary" data-lat="'+pos[0]+'" data-long="'+pos[1]+'" href="#">' + Messages('storeview.itinary') + '</a>';
  var storeLink = "";
  var actionsLine = "";
  if(dataObj.storeUrl) {
    var storeURL = Cube.Utils.localizeUri(dataObj.storeUrl);
    storeLink = '<a href="'+storeURL+'">' + Messages('storeview.seeStorePage') + '</a>';
    actionsLine = storeLink + '<span class="itinerary-link"> | ' + itinarylink + '</span>';
  } else {
    actionsLine = itinarylink;
  }
  
  var tagImg = "";

  // is data picture is kept in dom element (input hidden) ?
  if($('input#store_image').length > 0 && $('input#store_image').val() != "null"){
    storeImg = $('#store_image').val();
    storeImg = storeImg.replace(/"/g, "");  // remove double quotes
    tagImg = '<img src="'+storeImg+'" alt="'+storeName+'" />';
  } else {
    tagImg = '<img src="'+_this.pathToAssets+'images/decathlon-logo.svg" alt="'+storeName+'" />';
  }

  var distance = ((dataObj.distance) ? '<br/>'+dataObj.distance : "");

  // build of the common template
  var tpl = '<div class="content" data-store-id="'+storeId+'">'+
  				'<input type="hidden" class="store-geocode" value="' + dataObj.geoCode + '" />' +
                '<p class="store-name">'+storeName+'</p>'+
                '<p class="store-address">'+storeAddress+ ((storeContact) ? '<br/>'+storeContact : '')+distance+'</p>'+
                '<div class="actions">'+actionsLine+'</div>'+
                '<a href="#" class="panorama-button">Panorama</a>'+
            '</div>'+
            '<div class="store-picture">'+tagImg+'</div>';

  return tpl;
};

// create a list of result in side panel, if exists - use createtemplateInfo()
UX_MapObject.prototype.createPanel = function(){
  var _this = this;

  var listResult = $('<ul class="stores-list"></ul>');
  var dataObj;
  
  if(_this.isLocalised){
    var defferedArray = [];

    for(var i =0; i < _this.storesData.length; i++) {
      dataObj = _this.storesData[i];
      var pos = dataObj.geoCode.split(',');

      defferedArray.push(_this.calculateDistance(new BMap.Point(pos[1], pos[0])));
    }
    
    $.when.apply($, defferedArray).done(function () {

      for(var i =0; i < arguments.length; i++) {
        var dataDeffered = _this.storesData[i];
        dataDeffered.distance = arguments[i];

        var result = _this.fillPanel(dataDeffered, i);
        listResult.append(result);
        _this.panel.removeClass('loading');
      }

    });

  } else {
    for(var j =0; j < _this.storesData.length; j++) {
      dataObj = _this.storesData[j];

      var result = _this.fillPanel(dataObj, j);
      listResult.append(result);
      _this.panel.removeClass('loading');
    }
  }

  // append the complete list in side panel
  _this.panel.empty().append(listResult);
  
};

// to center the point in center of map when resize - when offcentered the point must stay visible
UX_MapObject.prototype.adjustView = function(){
  var _this = this;

  _this.map.setCenter(_this.point);

  // if the point is offcentered
  // in storepage, when resolution is desktop or tablet, the point is shifted of about 32% to the right
  if(_this.offCentered){
    if($(window).width() > 1080){

      //_this.map.setCenter(_this.point);
      if(_this.typeMap == 'gmap') {

      } else if(_this.typeMap == 'bmap') {
        // baidumap
        _this.map.panBy( ($(window).width() * 0.322),0);
      }
    }
  }
    
};

// locate me - geolocation function
UX_MapObject.prototype.geolocation = function(){
  var _this = this,
    deferredObj = $.Deferred();

  // test geolocation if supported by browser
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(function(position) {
      //return position;
      deferredObj.resolve(position);
      
    }, function() {
    });
  } else {
    // TODO
    // return an error
    alert('Your browser doest not support geolocation ! Please use the search location input.');
  }
  return deferredObj;
};

// locate me - geolocation function
UX_MapObject.prototype.locateMe = function(){
  var _this = this,
    user;

  var deferredObj = _this.geolocation();

  $.when(deferredObj).then(function (position) {
	  var lat = position.coords.latitude;
	  var lng = position.coords.longitude;
	  
      if(_this.environment == 'local') {
    	  lat = _this.originalData[0];
		  lng = _this.originalData[1];
	  }
	  
      if(_this.typeMap == 'bmap') {
    	  user = new BMap.Point(lng, lat);
      }

      if(_this.isLocalised){
    	  _this.map.clearOverlays();
      }
      
      // reference point is now the user location
      _this.point = user;
      if(_this.typeMap == 'bmap') {
    	  _this.map.centerAndZoom(user, 12);
          _this.markUser(user);
      }
      
      
      _this.location = {'lat':lat, 'lng':lng};
  });
};

// catch address from dedicated input - 
UX_MapObject.prototype.searchAddress = function(form){
  var _this = this;

  if(_this.isLocalised){
    _this.map.clearOverlays();
  }

  // we get the input entry
  var query = form.find('input').val();
  
  if(_this.typeMap == 'bmap') {
	// call baidu method to find coords from address
	  var myGeo = new BMap.Geocoder();
	  
	  myGeo.getPoint(query, function(point){
		  var lat = _this.originalData[0];
		  var lng = _this.originalData[1];
	    if (point) {
	    	lat = point.lat;
	    	lng = point.lng;
	      _this.isLocalised = true;
	      _this.point = point;
	      _this.user = point;
	      _this.map.centerAndZoom(point, 11);
	      // make sure clear the error message when a valid address has entered.
	      $('.geolocate-error').css( "display", "none");
	    } else {    	  
	      // if errors, we reinit the map to its initial view
	      $('.geolocate-error').css( "display", "inline-block");
	      _this.map.clearOverlays();
	      var data = _this.originalData;
	      var originalPoint = new BMap.Point(_this.originalData[1], _this.originalData[0]);
	      _this.map.centerAndZoom(originalPoint, _this.originalData[2]);

	      // TEMP
	      // _this.panel.empty();
	      // var data = [37,105,5];
	      // var point = new BMap.Point(data[1], data[0]);
	      // _this.map.centerAndZoom(_this.point, data[2]);
	    }
	    _this.location = {'lat':lat, 'lng':lng};
	  }, query);
  }
  
};

// generic function to mark user - data maybe be from browser geolocation or ip address
UX_MapObject.prototype.markUser = function(point){
  var _this = this;

  // we keep the user point in variable 
  _this.user = point;

  _this.isLocalised = true;
  var myIcon = new BMap.Icon(_this.pathToAssets+"images/pin-icon-green.png", new BMap.Size(22,35));
  var myMarker = new BMap.Marker( point,{icon: myIcon});
  
  _this.map.addOverlay(myMarker); 
};

// request data to server - or distant files (must return data in json format)
UX_MapObject.prototype.callServer = function(global){
  var _this = this;

  var urlToCall;

  if(global){
    urlToCall = _this.callGlobalURL;
  } else {
    var bounds = _this.map.getBounds();
    var distance = _this.map.getDistance( bounds.getSouthWest(), _this.point);
    distance = distance / 1000;
    distance = distance.toFixed(2);
    urlToCall = _this.callURL+ _this.point.lng+'&latitude='+ _this.point.lat +'&distance='+distance;
  }
  // real server call
  _this.globalTool.ajaxHandler(
    'get',
    urlToCall,
    '',
    'json',
    function(data){
      
      if(data){
        if(global) {
          _this.allStoresData = data.responseTO.data;
          _this.createAggregation();
        } else {
          _this.storesData = data.responseTO.data;
          _this.createStores();
        }
      }

      // we can display the user location now
      /*var city = _this.storesData[0].address.city;
      $('.location').css( "display", "inline-block");
      $('.location .area').text(city);*/
    }
  );
};

// set data for one store - on storepage
UX_MapObject.prototype.setStoreData = function(data){
  var _this = this;
  if(data) {
    // we store data in array in order to unify process of store creation (in a loop)
    _this.storesData = [];
    _this.storesData.push(JSON.parse(data));
    // real coord is already in MapObject
    var pos = _this.storesData[0].geoCode.split(',');
    _this.point = new BMap.Point(pos[0], pos[1]);
    
    _this.createStores();
    _this.adjustView();
  }
};

// set data for one store - on storepage
UX_MapObject.prototype.itinary = function(cible){
  var _this = this,
    user,
    storeName;

  if(false){ // Desactivate buggy itinerary
  //if(_this.isLocalised){
    //_this.map.removeEventListener('dragend', _this.callSwitchOverlays());
    //_this.map.removeEventListener('zoomend', _this.callSwitchOverlays());
    _this.createItinary(cible);
  } else {
    if($('#storeName').length > 0){
    	storeName = $('#storeName').val();
    	storeName = encodeURI(storeName);
    	window.open('http://map.baidu.com/?newmap=1&ie=utf-8&s=s%26wd%3D'+storeName,'_blank');
    } else {
        var storeGeocode = cible.closest('.info-store').find('.store-geocode').val().split(',');
        var storeLat = storeGeocode[0];
        var storeLng = storeGeocode[1];
        var apiSrc = '';
        
        if(!_this.isLocalised) {
        	apiSrc = 'http://api.map.baidu.com/geocoder?' +
				'output=html&' +
				'location=' + storeLat + ',' + storeLng + '&' +
				'zoom=10';
        } else {
        	apiSrc = 'http://api.map.baidu.com/direction?' +
    			'output=html&' +
    			'mode=driving&' +
    			'region=湖北&' +
    			'origin=latlng:' + _this.location.lat + ',' + _this.location.lng + '|name:区位&' +
    			'destination=latlng:' + storeLat + ',' + storeLng + '|name:迪卡侬';
        }
    	window.open(apiSrc,'_blank');
    }
  }
};

UX_MapObject.prototype.calculateDistance = function(point){
  var _this = this,
    deferredObj = $.Deferred();

  var driving = new BMap.DrivingRoute(_this.map);
  driving.search(_this.user, point);

  driving.setSearchCompleteCallback( function(results){
    if (driving.getStatus() == BMAP_STATUS_SUCCESS){
      var plan = results.getPlan(0);
      var distance = plan.getDistance();

      deferredObj.resolve(distance);
      
    }
  });
  return deferredObj;
};


////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////// DO WE USE THIS ANYMORE ?
////////////////////////////////////////////////////////////////////////////////////
UX_MapObject.prototype.createItinary = function(cible){
  var _this = this;

  var pointCible = new BMap.Point(cible.attr('data-long'), cible.attr('data-lat'));

  var options = {
    renderOptions:{map: _this.map, autoViewport: true}
  };
  var driving = new BMap.DrivingRoute(_this.map, options);
  driving.search(_this.user, pointCible);

  driving.setSearchCompleteCallback( function(results){
    if (driving.getStatus() == BMAP_STATUS_SUCCESS){
      if(_this.offCentered) {
        //window.open(results.moreResultsUrl);
      } else {
        _this.drawItinary(results);
      }
    }
  });

  _this.adjustView();

  $('body').on('click', '.itinary-panel', function(e){
    e.preventDefault();
    _this.panel.removeClass('panel-itinary').empty();
    driving.clearResults();
    
    if(_this.localisator){
      _this.locateMe();
    } else {
      _this.createStores();
    }
    //_this.adjustView();
  });
};

UX_MapObject.prototype.drawItinary = function(results){
  var _this = this;

  // we clear the map
  _this.map.clearOverlays();
  var plan = results.getPlan(0);
  var distance = plan.getDistance();
  var route = plan.getRoute(0);
  var li = '<li>'+distance+'</li>';
  for(var j = 0; j < plan.getNumRoutes(); j++){
    route = plan.getRoute(j);
    for (var i = 0; i < route.getNumSteps(); i++){
      var step = route.getStep(i);
      li += '<li>' + step.getDescription()+'</li>';
    }
  }
  //document.getElementById("r-result").innerHTML = s.join("<br/>");
  _this.panel.addClass('panel-itinary').prepend('<div class="itinary-panel"><a class="close-itinary-panel" href="#"><span class="icon icon-close"></span></a><ul class="itinary-list">'+li+'</ul>');
};
////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////////////////////////////

// Open streeview
////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////// WORK IN PROGRESS
////////////////////////////////////////////////////////////////////////////////////
UX_MapObject.prototype.panorama = function(button, dataObj){
  var _this = this;

  if(!button.hasClass('active')){
    
    var pos = dataObj.position_in_baidu_map.split(',');
    var point = new BMap.Point(pos[0], pos[1]);

    _this.panorama = new BMap.Panorama('panorama');
    _this.panorama.setPosition(point);
    _this.panorama.show();

    $('#panorama').animate({
      'left': 0
    }, 500);
    button.text('Map');

  } // else {
  //   _this.panorama.hide();
  //   $('#panorama').hide();
  //   button.text('Panorama');
  // }

 $('#panorama').find('.pano_close').on('click', function(){
  $('#panorama').animate({
    'left': '100%'
  }, 500);
  button.text('Panorama');
  _this.panel.find('.setback').removeClass('setback');
 });

  button.toggleClass('active');
};

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
/////////////////////////////////////// PasswordChecking
////////////////////////////////////////////////////////

/*
    formGroup = jquery object
        the field to control
        mandatory
    formGroupConfirm = jquery object
        the field to compare with formGroup
        optional
*/

var PasswordChecking = function(attr){
    this.formGroup = attr.formGroup;

    this.fieldObject = this.formGroup.find('input[type="password"]');
    this.checkingObject = this.formGroup.find('.password-checking');
    this.helpObject = this.formGroup.find('.help-password');

    // some regex //////////////////////////////////////////////////////////////////////////////////////////// WORK IN PROGRESS !!!
    // at least one number, one lowercase and one uppercase letter and one special character and 8 characters
    this.regexVeryStrong = /(?=.*[!@#\$%\^&\*])(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}/;
    // at least one number, one lowercase and one uppercase letter and 8 characters
    this.regexStrong = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}/;
    // at least 8 characters
    this.regexMedium = /(?=.{8,})/;
    // at least 8 characters
    this.regexWeak = /(?=.{7,})/;
    // at least 8 characters
    this.regexVeryWeak = /(?=.{6,})/;
    //////////////////////////////////////////////////////////////////////////////////////////// WORK IN PROGRESS !!!

    // an array to keep all regex
    this.groupRegex = [];
    this.groupRegex.push(this.regexVeryStrong, this.regexStrong, this.regexMedium, this.regexWeak, this.regexVeryWeak);

    if(this.formGroup && this.fieldObject && this.checkingObject) {
        this.dispatcher();
    }
};

// dispatch and listen events
PasswordChecking.prototype.dispatcher = function(){
    var _this = this;

    // catch key event on password field
    _this.fieldObject.on('keyup', function() {
        _this.checkingPassword( $(this).val() );
    });

    // tooltip management - if exists
    if(_this.helpObject) {
        _this.manageTooltip();
    }
};

// testing strenght password
PasswordChecking.prototype.checkingPassword = function(fieldValue) {
    var _this = this;
    
    _this.checkingObject.find('.level').removeClass('highlighted');
    
    // invalid style is remove if field value match to one regex
    for(var i = 0; i < _this.groupRegex.length; i++) {
        if(_this.groupRegex[i].test(fieldValue)){
            _this.passwordStrength(i);
            break;
        }
    }
};

// styling the checking object - visual informations
PasswordChecking.prototype.passwordStrength = function(strength) {
    var _this = this;

    // remove all existing class in ordeer to have the right render
    _this.checkingObject.removeClass('very-weak  weak  medium  strong  very-strong');
    _this.checkingObject.find('.level').removeClass('highlighted');

    // be careful, value are in descending order !
    switch(strength) {
        case 0 :
            _this.checkingObject.addClass('very-strong');
            _this.checkingObject.find('.level').addClass('highlighted');
            break;
        case 1 :
            _this.checkingObject.addClass('strong');
            _this.checkingObject.find('.level:nth-child(-n+4)').addClass('highlighted');
            break;
        case 2 :
            _this.checkingObject.addClass('medium');
            _this.checkingObject.find('.level:nth-child(-n+3)').addClass('highlighted');
            break;
        case 3 :
            _this.checkingObject.addClass('weak validated');
            _this.checkingObject.find('.level:nth-child(-n+2)').addClass('highlighted');
            break;
        case 4 :
            _this.checkingObject.addClass('very-weak');
            _this.checkingObject.find('.level:nth-child(-n+1)').addClass('highlighted');
            break;
    }
};

// manage help tooltip if exists
PasswordChecking.prototype.manageTooltip = function() {
    var _this = this;

    _this.helpObject.tooltip({
        trigger: 'hover'
    });
    _this.helpObject.on('mouseover', function(){
        _this.helpObject.tooltip('toggle');
    });
};

// Password Strength

var PasswordStrength = function(attr){
    this.formGroup = attr.formGroup;
    this.fieldObject = this.formGroup.find('input[type="password"]');
    this.checkingObject = this.formGroup.find('.password-strengh-list');
    var regexes = JSON.parse(this.fieldObject.attr('data-regex'));
    
    this.fieldObject.on('keyup', function() {
    	
        for(var regex in regexes){
        	var field = $('#'+regex);
        	var regexp = new RegExp(regexes[regex]);
        	
            if (regexp.test($(this).val())) {
            	field.addClass('passed');
            } else {
            	field.removeClass('passed');
            }
        }
    });  
};

/*
  DynamicNavigation 
  a class for anchor link - need this type of link
    <a title="Title with space and special character" data-dynamic-nav="idName"></a>
    or
    <a title="Title with space and special character" data-dynamic-nav="idName" data-image="path/to/image"></a>

  parameters :
    - navObject : jquery object
      Mandatory
      id of nav container
    - limitSticky : int or an $object
      optional - ( = 0)
      is the nav sticky - if not this parameter must be equal to 0
    - stickyClass : String
      optional - ( = null)
      is the nav sticky ? if sticky the nav need a css class (this script just toggle class on the nav element)
     - topSticky : boolean
      optional - ( = false)
      is the nav sticky at the top of screen - if yes we must to consider nav height with the scrollTop
    - offsetTop : int
      optional - ( = 0)
      a gap in pixel (useful if there another sticky element on the page) which substract to offset top of the target anchor - may be 0 or more
      -- cf goToElement() function
    - thumbs : boolean
      optional - ( = false)
      is there a thumb ? anchor need a data-image
*/

var DynamicNavigation = function(options) {
  // this.nav; // the nav object itself

  this.navObject = options.navObject; // id of dom element which wrap the nav
  
  this.limitSticky = ((options.limitSticky) ? options.limitSticky : 0);

  this.stickyClass = ((options.stickyClass) ? options.stickyClass : null);
  this.topSticky = ((options.topSticky) ? options.topSticky : false);
  this.offsetTop = ((options.offsetTop) ? options.offsetTop : 0);
  this.thumbs = ((options.thumbs) ? options.thumbs : false);

  this.navList = ((options.navListParentObject) === '' ? this.navObject : ((options.navListParentObject) ? this.navObject.find(options.navListParentObject) : this.navObject.find('ul')));
  this.anchorWrapper = ((options.anchorWrapper) ? options.anchorWrapper : null);
  this.dynamicAnchors = [];
  this.targetsPosition = [];
  this.activeAnchor = 0;
  this.scrollTop = 0;

  //if(this.navObject) {
    this.createNav();
 // }

  // let the music play !
  
};

var navElement = '';

// Event listener & dispatcher
DynamicNavigation.prototype.createNav = function(){
  var _this = this;

  $('a[data-dynamic-nav]').each( function(i){
    
    if($(this).parent().is(':visible')){

      _this.dynamicAnchors.push($(this));

      if(_this.anchorWrapper){
        navElement += '<'+_this.anchorWrapper+'>';
      }

      if(_this.thumbs) {
        navElement += '<a tabindex="-1" href="#'+$(this).attr('data-dynamic-nav')+'"><span class="details"><span class="image"><img class="lazyload" data-src="'+$(this).attr('data-image')+'"/></span><span class="text">'+$(this).attr('title')+'</span></span></a>';
      } else {
        navElement += '<a id="'+$(this).attr('id')+'" href="#'+$(this).attr('data-dynamic-nav')+'">'+$(this).attr('title')+'</a>';
      }

      if(_this.anchorWrapper){
        navElement += '</'+_this.anchorWrapper+'>';
      }

    }
      
    
    
    
  });

  _this.navList.append(navElement);

  // Edge hack to avoid navigation to be under navigator scrollbar
  if (navigator.userAgent.indexOf("Trident/7") > -1) {
      _this.navObject.css('right', uxDynamicSizes.scrollbarWidth);
  }

  this.dispatcher();
};

// Event listener & dispatcher
DynamicNavigation.prototype.dispatcher = function(){
  var _this = this;

  _this.activeAnchor = _this.navList.find('a:first-child').addClass('active');

  /* AS THE DYNAMIC NAV IS AN INTERNAL LINK, THIS IS CONTROLLED BY THE decathlon.tools.internalLinkFocusOnTheContainer FUNCTION */
  _this.navList.on('click', 'a', function(e){
    e.preventDefault();
    e.stopPropagation();
    e.cancelBubble = false;
  });

  _this.navList.on('click', 'a', _.debounce(function(e){
    _this.activeAnchor = $(this);
    _this.goToElement($(this));
  }, 300));

  if(_this.stickyClass){

    $(window).on('scroll.stickyClass', function(){
        _this.scrollTop = $(window).scrollTop();
        _this.stickyNav();
        _this.followScroll();
    }).trigger('scroll');
  }

  $(window).on('resize-width.stickyClass', _.debounce(function(){
    _this.followScroll();
  },100));

  
};

// Event listener & dispatcher
DynamicNavigation.prototype.goToElement = function(cible){
  var _this = this;

  var idCible = cible.attr('href').replace('#', '');
  var cibleTop = $('a[data-dynamic-nav="'+idCible+'"]')[0].getBoundingClientRect().top + _this.scrollTop;
  var navHeight = ((_this.topSticky) ? _this.navObject.outerHeight() : 0);

  TweenMax.to($(window), 1, {scrollTo:{y: cibleTop - _this.offsetTop - navHeight}, ease:Power4.easeInOut});
};

DynamicNavigation.prototype.followScroll = function(){
  var _this = this;

  var navHeight = ((_this.topSticky) ? _this.navObject.outerHeight() : 0);

  for (var i = 0; i < _this.dynamicAnchors.length; i++) {
    var yPosition = _this.dynamicAnchors[i][0].getBoundingClientRect().top + _this.scrollTop;
    var next = ((i < _this.targetsPosition.length) ? true : false);
    
    if(yPosition <= _this.scrollTop + _this.offsetTop + navHeight) {

      _this.activeAnchor = _this.navList.find('a').eq(i);
      _this.highlightElement();

      if(next){
        continue;
      }
    }
  }
};

// Event listener & dispatcher
DynamicNavigation.prototype.highlightElement = function(){
  var _this = this;

  _this.navList.find('a').removeClass('active');
  _this.activeAnchor.addClass('active');

};

// Event listener & dispatcher
DynamicNavigation.prototype.stickyNav = function(){
  var _this = this;

  if (typeof _this.limitSticky == 'object') {
    _this.limitStickyPosY = _this.limitSticky.height();
  } else {
    _this.limitStickyPosY = _this.limitSticky;
  }

  if (_this.scrollTop >= _this.limitStickyPosY) {
    _this.navObject.addClass(_this.stickyClass);
  } else if (_this.scrollTop < _this.limitStickyPosY) {
    _this.navObject.removeClass(_this.stickyClass);
  }
};

    /* FALLBACK FOR THE PLACEHOLDER */
    /* */
    /* */
    /* */
    if (!Modernizr.input.placeholder) {
        $('[placeholder]').each(function() {

            var inputText = $(this);
            var placeholderValue = inputText.attr('placeholder');

            if (inputText.val() === '') {
                inputText.val( placeholderValue );
                inputText.addClass('hasPlaceholderText');
            }

            inputText.focus(function() {
                if (inputText.val() == placeholderValue) {
                    inputText.val('');
                    inputText.removeClass('hasPlaceholderText');
                }
            });

            inputText.blur(function() {
                if (inputText.val() === '' || inputText.val() === placeholderValue) {
                    inputText.val(placeholderValue);
                    inputText.addClass('hasPlaceholderText');
                }
            });

            inputText.closest('form').submit(function() {
                if (inputText.val() == inputText.attr('placeholder')) {
                    inputText.val('');
                }
            });

        }); /* END OF EACH */
    }


    /**/
    /* Some browsers don't change the focus when navigating through internal links */

    $('a[href="#main-container"]').click(function(e){
        e.preventDefault();
        this.targetContainer = $("#"+this.href.split('#')[1]);
        this.targetContainer.attr('tabindex', -1).on('blur focusout', function () {
            $(this).removeAttr('tabindex');
        }).focus();
    });


;(function ( $, window, document, undefined ) {

    var pluginName = 'uxBreadcrumbsMethods',

        defaults = {
            length: 20
        };

    
    function Plugin( element, options ) {
        this.el = $(element);
        this.options = $.extend( {}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
    }


    

    Plugin.prototype = {

      getMaxLength : function(){

        var _this = this,
        textLength,
        maxLength = 0;

        _this.links.each(function(index){

          if(index < (_this.links.length - 1)){

            this.textText = $(this).find('.content').text().replace( /\s\s+/g,' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            textLength = this.textText.length;
            if(textLength > maxLength){
              maxLength = textLength;
            }
          }

        });

        return maxLength;

      },

      trimText : function(expandOrContract){

        var _this = this,
        trimmed = false,
        textLength,
        maxLength = _this.getMaxLength();

        _this.links.each(function(index){
          textLength = 0;

          if(index < (_this.links.length - 1)) {

            anchorTitle = $(this).find('a').attr('title');
            textLength = anchorTitle.length;

            if(textLength > 0){

              if(expandOrContract === 'contract'){

                if(textLength > maxLength - 1){

                  $(this).find('.content').text(anchorTitle.substring(0, maxLength - 1));
                  $(this).addClass('trimmed');
                  trimmed = true;

                }

              } else {

                $(this).find('.content').text(anchorTitle.substring(0, maxLength + 1));
                if(textLength <= maxLength){
                  $(this).removeClass('trimmed');
                }

              }
            }
          }

        });

        if (trimmed === true){
          _this.trimOrNot();
        }
      },

      resetAllTexts : function(){
        var _this = this,
        anchorTitle;

        _this.links.each(function(){
          anchorTitle = $(this).find('a').attr('title');
          $(this).find('.content').text(anchorTitle);
          $(this).removeClass('trimmed');
        });
      },

      getLinksWidth : function(){
        
        var _this = this,
        totalWidth = 0;
        

        _this.links.each(function(){
          totalWidth += $(this).outerWidth();
        });

        totalWidth = totalWidth + 50;

        _this.totalLinksWidth = totalWidth > _this.totalLinksWidth ? totalWidth : _this.totalLinksWidth;

        return totalWidth;

      },

      trimOrNot : function(){
        
        var _this = this;

        if(decathlon.uxBreakpoints.is('large-screen') && _this.totalLinksWidth > $(window).width()){

          if(_this.getLinksWidth() > $(window).width()){
            
            _this.trimText('contract');

          } else {

            if(_this.totalLinksWidth > $(window).width()){
              _this.trimText('expand');
            }

          }
        }

      },

      init : function () {
        
        var _this = this;
        _this.links = _this.el.find('li:visible');
        _this.wrapper = _this.el.parent();
        _this.totalLinksWidth = 0;
        _this.getLinksWidth();

        $(window).bind('resize-width', _.debounce(function() {
          _this.trimOrNot();
        },700));

        _this.trimOrNot();

      }

    };
    

    


    $.fn[pluginName] = function ( options ) {

        var args = arguments;

        var createPluginInstance = function(_this){
          if (!$.data(_this, 'plugin_' + pluginName)) {
              $.data(_this, 'plugin_' + pluginName, new Plugin( _this, options ));
          }
        };

        if (options === undefined || typeof options === 'object') {

            return this.each(function () {
                
                createPluginInstance(this);

            });

        } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
            
            var returns;

            this.each(function () {

                createPluginInstance(this);

                var instance = $.data(this, 'plugin_' + pluginName);

                if (instance instanceof Plugin && typeof instance[options] === 'function') {
                    returns = instance[options].apply( instance, Array.prototype.slice.call( args, 1 ) );
                }

                if (options === 'destroy') {
                  $.data(this, 'plugin_' + pluginName, null);
                }
            });

            return returns !== undefined ? returns : this;
        }
    };

}(jQuery, window, document));

$('.breadcrumbs').uxBreadcrumbsMethods();
var UxTopMessageFunction = function($this){
  this.el = $this;
  this.init();
};


UxTopMessageFunction.prototype = {
  lineHeight : function (){
    var _this = this;
    var lh = parseInt(this.el.css('line-height').replace('px',''), 10);
    if (lh === 1) {
      lh = parseInt(this.el.css('font-size').replace('px',''), 10) * 1.4; /* IE 8 ?? */
    }
    return lh;
  },
  textheight : function(){
    return this.el.height() - parseInt(this.el.find('.text:first-child').css('paddingTop').replace('px',''), 10) - parseInt(this.el.find('.text:first-child').css('paddingTop').replace('px',''), 10);
  },
  toggleClasses : function(){
    var _this = this;

    if(Math.floor(_this.textheight() / _this.lineHeight()) > 1) {
        _this.el.removeClass('short').addClass('long');
    } else {
        _this.el.removeClass('long').addClass('short');
    }

  },
  showNote : function(){
    var _this = this;
    if(window.TweenMax){
      if(_this.el.data('closedBy') !== 'user' && _this.el.attr('aria-hidden', 'true')){
        TweenMax.to(_this.el, 0.55, {height:_this.initialHeight, ease: Power4.easeInOut, onComplete : function(){
          _this.el.attr('aria-hidden', 'false');
          $('#menu-global').css({'top': _this.initialHeight + $('#container-header').outerHeight()});
        }});
        
      }
    }
  },
  dismissNote : function(e){
    var _this = this;
    if(window.TweenMax){
      
      _this.removePaddings = function(){
        _this.el.css({paddingTop:0, paddingBottom:0});
      };

      var speed = e ? uxGAP.speed(_this.initialHeight) : 0.55;

      TweenMax.to(_this.el, speed, {height:0, onStart : function(){
        _this.removePaddings();
      }, ease: Power4.easeInOut, onComplete : function(){
        _this.el.attr('aria-hidden', 'true');
        _this.el.css({paddingTop:'', paddingBottom:''});
        if(e){
          _this.el.attr('data-closed-by', 'user');
        }
      }});
      
    }
  },
  addCloseButton : function(){
    var _this = this;
    _this.el.find('.text').append(_this.closeLink);

    _this.el.on('click', 'a[data-role="close"]', function(e){
      e.preventDefault();
      // Create cookie "SKIP_PROMOTION_MESSAGE" to hide the message bar by default
      $.cookie("SKIP_PROMOTION_MESSAGE", "true", { path: '/' });
      _this.dismissNote(e);
    });

  },
  init : function(){
    var _this = this;

    _this.closeLink = '<a href="#" role="button" data-role="close" class="close"><div class="text">Close</div><div class="icon icon-x"></div></a>';
    
    $(window).on('resize-width', _.debounce(function(){
      _this.toggleClasses();
    },50));

    _this.toggleClasses();

    if(_this.el.hasClass('dismissible') && _this.el.find('.close').length === 0){
      _this.addCloseButton();
    }

    setTimeout(function(){
      _this.initialHeight = _this.el.height();
    },0);
    
  }
};



$.fn.extend({
  
  uxTopMessage : function(){

    return this.each(function() {

      var $el = $(this);

      if ($el.length > 0 && $el.jquery) {

        if ($el.data('uxTopMessage')) return;

        var uxTopMessagev = new UxTopMessageFunction($el);

        $el.data('uxTopMessage', uxTopMessagev);

        // Condition that work with the cookie "SKIP_PROMOTION_MESSAGE" to hide the message bar
        if($.cookie("SKIP_PROMOTION_MESSAGE")){
        	uxTopMessagev.dismissNote();
        }else{
        	$('#top-message-bar').removeClass("hide");
        }

      }

    });
  }

});

$('#top-message-bar').uxTopMessage();
$.fn.extend({
  UX_Cookies : function(){

    var _this = this;

    // Show the cookies banner
    _this.init = function(){

      $('#modal-cookies').on('shown.bs.modal', function(e) {
        $('#modal-cookies').css({
          zIndex: 7001
        });
      });

      $('#modal-cookies').on('hide.bs.modal', function(e) {
        $('.panel.options').hide();
        $('.panel.info').show();
      });

      if(_this.hasClass('dismissible') && _this.find('.close').length === 0){
        _this.addCloseButton();
      }
    };

    // Switch from info cookies to options
    _this.actions = function(){
      $('#cookies-more').on('click', function(e){
        e.preventDefault();
        $('.panel.info').slideUp(600, function(){
          $('.panel.options').slideDown();
        });
      });

      // Closing modal by validate
      $('.cookies-validate').on('click', function(){
        //e.preventDefault();
        $('.close-modal').trigger('click');
      });
    };

    if (_this.length > 0 && _this.jquery) {

      _this.dismissNote = function(){
        _this.fadeOut();
      };

      _this.addCloseButton = function(){

        _this.find('.text').append(_this.closeLInk);

        _this.on('click', 'a[data-role="close"]', function(e){
          e.preventDefault();
          _this.dismissNote();
        });

      };

      _this.closeLInk = '<a href="#" role="button" data-role="close" class="close"><div class="text">Close</div><div class="icon icon-x"></div></a>';

      _this.init();
      _this.actions();

    }
  }
});

// closing panel when in panel account
$('.user.no-log .drop-container').on('click', function(e){
    // exclude click on dropdown element
    if(!$(e.target).hasClass('.dropdown-lang') && $(e.target).closest('.dropdown-lang').length === 0) {
        $('.dropdown-lang .dropdown').removeClass('open');
    }
});

var UxHeaderFunctions = {
  ellipseCustomersName: function() {
    if (tc_vars.user_status === "unknown")
      return;

    var customerIdentity = $('#hdr-customers-identity').first();
    if (customerIdentity) {
      customerIdentity.dotdotdot({ height:  24});
    }
  },

  positionHelpDropdownInCheckout: function() {
    if ($('body').hasClass('checkout') && tc_vars.user_status === "authenticated")
      $('.dropdown-menu.help').addClass('help-loggedin');
  }
};

function switchLanguage(lg) {
  var path = '/' + lg + window.location.pathname.substr(3);
  if (window.location.href.indexOf('?') > 0) {
    path += window.location.href.substr(window.location.href.indexOf('?'));
  }
  window.location.href = path;
}

(function(window, $){

  var UxHeaderDropdownFunctions = function($element){
    this.el = $element;
    this.init();
  };

  UxHeaderDropdownFunctions.prototype = {

    closeTheOtherOpenLayers : function(){
      var _this = this;
      _this.el.allDropdowns.each(function(){
        if(_this.el.attr('id') !== $(this).attr('id')){
          $(this).closest('.dropdown').removeClass('open').attr('aria-expanded', 'false');
          $(this).attr('aria-expanded', 'false');
        }
      });
    },

    openLayer : function(){
      var _this = this;
      _this.container.addClass('open');
      _this.container.attr('aria-expanded', 'true');
      _this.el.attr('aria-expanded', 'true');
    },

    closeLayer : function(){
      var _this = this;
      setTimeout(function(){
        _this.container.removeClass('open');
        _this.container.attr('aria-expanded', 'false');
        _this.el.attr('aria-expanded', 'false');
      }, 100);
    },

    openMobileSearch : function(){
      var searchMenuResize = true;
      function mobileSearchBehavior() {
        searchMenuResize = false;
        var HeaderMobileSearchPanel = $('.HeaderMobileSearch-panel'),
            HeaderMobileSearchPanelTop = parseInt(HeaderMobileSearchPanel.css('top'), 10),
            topMessageBar = $('#top-message-bar'),
            topMessageBarHeight = topMessageBar.outerHeight();
        $('.HeaderMobileSearch-openPanel').unbind('click').on('click',function(){
          HeaderMobileSearchPanel.css('top',HeaderMobileSearchPanelTop+topMessageBarHeight-1);
          $('body').toggleClass('HeaderMobileSearch-opened');
          $('html').toggleClass('noscroll');
        });
        $('.menu-toggler').on('click',function(){
          if($('body').hasClass('HeaderMobileSearch-opened')){
            $('body').removeClass('HeaderMobileSearch-opened');
          }
        });
        topMessageBar.on('click','.close',function(){
          var speed = 0.55;
          var top = parseInt(HeaderMobileSearchPanel.css('top'))-topMessageBarHeight;
          TweenMax.to(HeaderMobileSearchPanel, speed, {top:top, ease: Power4.easeInOut});
          topMessageBarHeight = 0;
        });
      }

      function mobileSearchResize(){
        if (decathlon.uxBreakpoints.is('small-screen') && searchMenuResize === true) {
          mobileSearchBehavior();
        }else if(decathlon.uxBreakpoints.is('large-screen')){
          searchMenuResize = true;
        }
      }

      $(window).on('resize', _.debounce(mobileSearchResize,300));

      if(decathlon.uxBreakpoints.is('small-screen')) {
        mobileSearchBehavior();
      }

    },

    init : function(){

      var _this = this;

      UxHeaderFunctions.ellipseCustomersName();
      UxHeaderFunctions.positionHelpDropdownInCheckout();

      _this.container = _this.el.closest('.dropdown');

      _this.dropdown = _this.container.find('.dropdown-menu');

      _this.el.on('touchstart', function(e){
          _this.el.off('mouseenter');
      });

      _this.el.on('mouseenter', function(e){

          _this.closeTheOtherOpenLayers();

          _this.el.addClass('hover');

          setTimeout(function(){
            if(_this.el.hasClass('hover')){
              _this.openLayer();
            }
          }, 200);

      });

      _this.el.on('mouseleave', function(){

          _this.el.removeClass('hover');

          setTimeout(function(){
            if(!_this.container.hasClass('hover') && !_this.el.hasClass('hover')){
              _this.closeLayer();
            }
          }, 300);

      });

      _this.dropdown.on('mouseenter', function(e){
        _this.container.addClass('hover');
        _this.openLayer();
      });

      _this.dropdown.on('mouseleave', function(){
        _this.container.removeClass('hover');
        setTimeout(function(){
          if(!_this.el.hasClass('hover')){
            _this.closeLayer();
          }
        },50);
      });

      _this.dropdown.find('.with-scroll').on( 'mousewheel DOMMouseScroll', function (e) {

        if(decathlon.uxBreakpoints.is('large-screen')){
          var e0 = e.originalEvent,
          delta = e0.wheelDelta || -e0.detail;

          if ((this.scrollTop === 0 && delta > 0) || ((this.scrollTop + this.offsetHeight) >= this.scrollHeight && delta < 0)) {
              e.preventDefault();
          }
        }
      });

      _this.openMobileSearch();

      }
  };


  $.fn.extend({

    uxHeaderDropdownFunctions : function(){

      var allDropdowns = $(this);

        return this.each(function() {

          var $el = $(this);

          $el.allDropdowns = allDropdowns;

          if ($el.length > 0 && $el.jquery) {
            if ($el.data('uxHeaderDropdownFunctions')) return;
            var uxHeaderDropdownFunctions = new UxHeaderDropdownFunctions($el);
            $el.data('uxHeaderDropdownFunctions', uxHeaderDropdownFunctions);
          }

        });
      }

  }); /* END OF EXTEND */

})(window, jQuery);

$('#dropdown-help, #dropdown-account, #dropdown-cart').uxHeaderDropdownFunctions();

;(function (window, $, document, undefined) {

    function resetOpecoMenuHeights(){
        // Recalculates the height of the menu
        $('.menu-sports-mask, .menu-sports').css({
            'height': opecoHeight - $('.menu-all-sports').outerHeight() - $('.menu-categories').outerHeight() +5,
            'max-height': opecoHeight - $('.menu-all-sports').outerHeight() - $('.menu-categories').outerHeight() +5
        });
        $('.menu-background').css({'height':opecoHeight});
        $('.navigation-menu, .navigation-menu .menu').css('height', opecoHeight);
    }

    var body = $('body');

    if(body.hasClass('homepage')){
        var scrollStatus = true, // Helps to not reload displayOpecoMenu at each scroll
            opecoHeight = $('.opeco-carousel').outerHeight(),
            opecoOffset = ($('.opeco-carousel').offset()).top + opecoHeight,
            navigationMenu = $('.navigation-menu'),
            topMessageBarHeight = $('#top-message-bar').outerHeight(),
            headerHeight = $('#container-header').outerHeight();

        $('#top-message-bar').on('click','.close',function(){
            if(!body.hasClass('mobile')){
                var speed = 0.55;
                var top = parseInt(navigationMenu.css('top'))-topMessageBarHeight;
                TweenMax.to(navigationMenu, speed, {top:top, ease: Power4.easeInOut});
            }
        });

        function displayOpecoMenu(){
            $('html').addClass('displayOpecoMenu');
            scrollStatus = false;
            setTimeout(function(){
                if(!decathlon.uxBreakpoints.is('small-screen')){
                    $(".navigation-menu").uxMainMenuFunctions('toggleMenuLarge');
                } else {
                    $(".navigation-menu").uxMainMenuFunctions('toggleMenuSmall');
                }
                
                if($.cookie("SKIP_PROMOTION_MESSAGE")){
                    $('#menu-global').css({'top': headerHeight});
                }
                else{
                    $('#menu-global').css({'top': topMessageBarHeight + headerHeight});
                }
                
                resetOpecoMenuHeights();
            }, 0);
            $('.sports-75').on('click',function(){
                $('#menu-global').css({'background-color':''});
                $('#menu-global-sports-nav').css('top', ($('.navigation-menu').offset()).top + $('.menu-close-button .button').outerHeight() + 20 + 'px');
            });
            //$('#extra-close-menu').hide();
        }

        function hideOpecoMenu(){
            $('#menu-global').removeAttr('style');
            $('#menu-global, #menu-global .menu, .menu-background').css({'height':''});
            $('#extra-close-menu').css({'display':'block'});
            $('html').removeClass('displayOpecoMenu');
            scrollStatus = true;
            $('.menu-toggler').trigger('click');
        }

        // Executes after 300ms without scrolling
        function menuPageScroll(){
            if($(window).scrollTop() < opecoOffset && scrollStatus === true && !body.hasClass('mobile')){
                displayOpecoMenu();
            }else if($(window).scrollTop() > opecoOffset && scrollStatus === false && !body.hasClass('mobile')){
                hideOpecoMenu();
            }
        }

        // Executes after 300ms without resizing
        function menuPageResize(){
            if(body.hasClass('mobile')){
                $('.navigation-menu').css({'top':'','height':'','background-color':''});
                $('.navigation-menu .menu, .menu-sports-mask').css({'height':'','max-height':''});
                scrollStatus = true;
                TweenMax.set($('.menu-group').find('.icon'), {x: 0});
                $('.menu').css('visibility', 'visible');
            }else if(!body.hasClass('mobile') && scrollStatus === true){
                $('#top-message-bar').show();
                displayOpecoMenu();
            }
            else if(!body.hasClass('mobile') && scrollStatus === false){
                resetOpecoMenuHeights();
            }
        }

        // Executes at page loading
        if($(window).scrollTop() < opecoOffset && !body.hasClass('mobile')){
            displayOpecoMenu();
        }else if($(window).scrollTop() > opecoOffset && !body.hasClass('mobile')){
            hideOpecoMenu();
        }
        $(window).on('scroll', _.debounce(menuPageScroll,300));
        $(window).on('resize', _.debounce(menuPageResize,300));
    }

    var prototypeMethods = prototypeMethods || {};
    prototypeMethods.appendDividerLinesToMenuItems = function(){
        var _this = this;
        _this.el.find(".menu-sports ul li").each(function(){
            if($(this).find('.line').length === 0){
                $(this).append('<div class="line"></div>');
            }
        });

        _this.el.find(".menu-categories ul li").each(function(){
            if($(this).find('.line').length === 0){
                $(this).append('<div class="line"></div>');
            }
        });

        _this.resizeMenuLinesWidth();
    };

    prototypeMethods.setSportsmenuHeight = function(){
        
        var _this = this,
            $homepageOpeco = $('#container-opeco'),
            homepageOpecoHeight = 0,
            menuCategoriesHeight = _this.el.find('.menu-categories').outerHeight(),
            menuSportsTop = Math.abs(_this.el[0].getBoundingClientRect().top - _this.sportsMenu[0].getBoundingClientRect().top),
            menuSportsHeight = 0,
            menuSportsMinHeight = 390,
            menuSportsTitleHeight = _this.el.find('.menu-group-title').outerHeight();

        var setMenuFixedOpecoSportsMenuHeight = function(){

            menuSportsHeight = homepageOpecoHeight - (menuSportsTop + menuCategoriesHeight) - 60;

            uxDynamicStyles.appendCssStylesArrayToHeader({
                uniqueId : 'menuSportsMenu01',
                selectors : [
                'body.large #menu-fixed-opeco .menu-sports'
                ],
                properties : [
                  'height: '+ ($('.navigation-menu').outerHeight() - $('.menu-all-sports').outerHeight() - $('.menu-categories').outerHeight() +5 ) + 'px;'
                  //'max-height: '+ Math.round((menuSportsMinHeight + menuSportsTitleHeight) * uxDynamicSizes.cWidth) + 'px;'
                ]
            });

            uxDynamicStyles.appendCssStylesArrayToHeader({
                uniqueId : 'menuSportsMenu01-mask',
                selectors : [
                'body.large #menu-fixed-opeco .menu-sports-mask'
                ],
                properties : [
                  'height: '+ ($('.navigation-menu').outerHeight() - $('.menu-all-sports').outerHeight() - $('.menu-categories').outerHeight() +5 ) + 'px;'
                  //'max-height: '+ Math.round((menuSportsMinHeight + menuSportsTitleHeight) * uxDynamicSizes.cWidth) + 'px;'
                ]
            });
        };

        var setMenuGlobalSportsMenuHeight = function(){

            menuSportsHeight = uxDynamicSizes.globalMenuHeight - (menuSportsTop + menuCategoriesHeight) - 42;

            uxDynamicStyles.appendCssStylesArrayToHeader({
                uniqueId : 'menuSportsMenu02',
                selectors : [
                'body.large #menu-global .menu-sports'
                ],
                properties : [
                  'height: '+ ($('.navigation-menu').outerHeight() - $('.menu-all-sports').outerHeight() - $('.menu-categories').outerHeight() +5 ) + 'px;'
                  //'max-height: '+ Math.round(menuSportsMinHeight * uxDynamicSizes.cWidth) + 'px;'
                ]
            });

            uxDynamicStyles.appendCssStylesArrayToHeader({
                uniqueId : 'menuSportsMenu02-mask',
                selectors : [
                'body.large #menu-global .menu-sports-mask'
                ],
                properties : [
                  'height: '+ ($('.navigation-menu').outerHeight() - $('.menu-all-sports').outerHeight() - $('.menu-categories').outerHeight() +5 ) + 'px;'
                  //'max-height: '+ Math.round((menuSportsMinHeight + menuSportsTitleHeight) * uxDynamicSizes.cWidth) + 'px;'
                ]
            });
        };
        
        if(body.is('.homepage') && $homepageOpeco.length > 0){
            homepageOpecoHeight = $homepageOpeco.outerHeight();
            setMenuFixedOpecoSportsMenuHeight();
        }

        setMenuGlobalSportsMenuHeight();



        // body.large .menu-sports {\
        //     height: " + Math.round(305 * _this.cWidth) + "px;\
        //     max-height: " + Math.round(390 * _this.cWidth) + "px;\
        // }\
        // body.large .menu-sports-mask {\
        //     height: " + Math.round(355 * _this.cWidth) + "px;\
        //     max-height: " + Math.round(440 * _this.cWidth) + "px;\
        // }\
        // body.large #menu-global .menu-sports{\
        //     height: " + (globalMenuHeight - 195)+ "px;\
        // }\
        // body.large #menu-global .menu-sports-mask {\
        //     height: " + (globalMenuHeight - 245)+ "px;\
        // }\
    };

    prototypeMethods.resizeMenuLinesWidth = function(){
        var _this = this;

        /* ONLY ON THE DESKTOP MENU MODEL */
        if(decathlon.uxBreakpoints.is('small-screen')) {

            _this.el.find('.line').css({'width' : ''});

        } else {

            _this.el.offsetTop = _this.el.offset().top;

            _this.el.menuBgWidth = _this.el.find("div.menu-shadow").outerWidth();
            
            _this.el.find(".menu-group ul li").each(function(){

                if($(this).closest('.menu-sports').length > 0){
                    widthoffset = 30;
                } else {
                    widthoffset = 5;
                }

                var y = $(this).offset().top - _this.el.offsetTop;
                var diff = y * _this.el.tangDuAngle;
                $(this).find('.line').css({'width' : _this.el.menuBgWidth - diff - (widthoffset * uxDynamicSizes.cWidth)});
                $(this).find('.bg').css({'width' : _this.el.menuBgWidth  - diff});
                TweenMax.set($(this).find('.icon'), {x: -diff});
            });

            // _this.el.find(".menu-categories ul li").each(function(){
            //     var y = $(this).offset().top - _this.el.offsetTop;
            //     var diff = y * _this.el.tangDuAngle;
            //     $(this).find('.line').css({'width' : _this.el.menuBgWidth - diff - (3 * uxDynamicSizes.cWidth)});
            //     TweenMax.set($(this).find('.icon'), {x: -diff});
            // });

            _this.el.find('.menu-sports-shadow, .menu-sports-shadow-top').each(function(){
                var y = $(this).offset().top - _this.el.offsetTop;
                var diff = y * _this.el.tangDuAngle;
                $(this).css({'width' : _this.el.menuBgWidth - diff + 1});
            });

            _this.el.find('.menu-group-title').each(function(){
                var y = $(this).offset().top - _this.el.offsetTop;
                var diff = y * _this.el.tangDuAngle;
                $(this).find('.line').css({'width' : _this.el.menuBgWidth - diff - (30 * uxDynamicSizes.cWidth)});
            });

            _this.uxSetCategoriesWidth();

        }
    };

    prototypeMethods.quickLooptoResize = function(){
        var _this = this;
        
        var i = 0;
        function loop(){
            i++;
            setTimeout(function() {
                _this.resizeMenuLinesWidth();
                if(i < 100){
                    loop();
                }
            }, 100);
        }
        loop();
    };

    prototypeMethods.uxResizeImageBackgrounds = function(){
            var _this = this;

            var $slidesImagesWithBg = _this.el.find('.image .after');

            if($slidesImagesWithBg.length > 0){

                var originalBgp = 0,
                dimentionRef = 0,
                newBgp = 0;

                var setImageBgPosition = function($image, index){
                    
                    $image.css({'backgroundPosition': ''});
                    
                    var dimentionRef =+ $image.css('font-size').replace('px', ''),
                    originalBgp = parseInt($image.css('background-position').split(" ")[0].replace('px', ''), 10),

                    newBgp = $image.width() * (originalBgp/dimentionRef);

                    $image.css({'backgroundPosition': newBgp + 'px 0'});
                    $image.parent().find('img').css({'left': newBgp + 'px'});
                    
                    
                };
                if(!$('html').hasClass('ie9')){
                    $slidesImagesWithBg.each(function(index){
                        if(!decathlon.uxBreakpoints.is('small-screen')){
                            setImageBgPosition($(this), index);
                        } else {
                            $(this).css({'backgroundPosition': ''});
                            $(this).parent().find('img').css({'left': ''});
                        }
                    });
                }
            }
    };

    prototypeMethods.uxSetCategoriesWidth = function(){
        
        var _this = this;

        if(!decathlon.uxBreakpoints.is('small-screen') && uxDynamicSizes.windowWidth <= decathlon.uxBreakpoints.mdMax) {
            var anchorRefSport = _this.el.find('.menu-sports li:first');
            var anchorRefCategory = _this.el.find('.menu-categories li:first');

            /*if(anchorRefSport.length > 0 && anchorRefCategory.length > 0){

                var sportsTdWidth = anchorRefSport.find('a>.image').outerWidth() + anchorRefSport.find('a>.text').outerWidth();
                _this.el.find('.menu-categories a>.text').css({'width':sportsTdWidth});
            }*/
        } else {
            _this.el.find('.menu-categories a>.text').css({'width':''});
        }
    };

    prototypeMethods.showHideSportsShadows = function(scrollY){
        var _this = this;

        if(scrollY > 0){
            _this.el.find('.menu-sports-shadow-top').removeClass('hidden');
            _this.el.find('.menu-group-title .line').addClass('hidden');
        } else {
            _this.el.find('.menu-sports-shadow-top').addClass('hidden');
            _this.el.find('.menu-group-title .line').removeClass('hidden');
        }
    };

    prototypeMethods.scrollSportsMenu = function(){
        var _this = this;
        TweenMax.to(_this.sportsMenu, 1, {scrollTo:{y: 0}, delay : 0, ease:Power3.easeInOut});
    };

    prototypeMethods.sameColumnsHeight = function(){
        var _this = this;
        var sameColumnsHeightArray = _this.targetSubmenuObject.find('.sameheight ul'),
        sameColumnsMaxHeight = 0;

        if(sameColumnsHeightArray.length > 1){

            sameColumnsHeightArray.each(function(){

                if ($(this).outerHeight() > sameColumnsMaxHeight) {
                    
                    sameColumnsMaxHeight = $(this).outerHeight();
                }
            });

            sameColumnsHeightArray.each(function(i){
                $(this).height(sameColumnsMaxHeight);
            });
        }
    };

    prototypeMethods.expandSubmenuBackground = function(size){
        var _this = this,
        submenuBgWidth = size === 'large' ? 1115 * uxDynamicSizes.cWidth : 550 ;
        submenuBgWidth = size === 'sports' ? 670 : submenuBgWidth ;

        TweenMax.to(_this.submenuCloseButton, 0.5, {x:submenuBgWidth, ease:Power2.easeOut});

        if(!_this.targetSubmenuObject.hasClass('scrollable')){
            TweenMax.set(_this.el.find('.menu-submenu-contents'), {width:550});
        } else {
            TweenMax.set(_this.el.find('.menu-submenu-contents'), {width:submenuBgWidth});
            
        }


        TweenMax.to(_this.submenuBg, 0.5, {
            width:   submenuBgWidth,
            ease:Power2.easeOut,
            onStart: function(){
                
            }
        });
    };

    prototypeMethods.openLargeSubmenu = function(){
        var _this = this;

        TweenMax.set(_this.submenuBg,{width: $('.menu-background').outerWidth() + 100});
        TweenMax.set(_this.submenuCloseButton,{x: $('.menu-background').outerWidth() + 100});

        if(!_this.targetSubmenuObject.hasClass('scrollable')){
            _this.expandSubmenuBackground();
        } else {
            _this.expandSubmenuBackground('sports');
        }

        TweenMax.to( _this.submenuContent, 1, {delay:0.3, autoAlpha:1} );

        _this.theActiveSport = _this.targetSubmenuClass;
        _this.el.addClass('open');

        _this.menuItem.addClass('active');
        _this.submenuContainer.addClass(_this.targetSubmenuClass);
        _this.targetSubmenuObject.addClass('active');

        if(!_this.targetSubmenuObject.hasClass('scrollable')){
            _this.sameColumnsHeight();
        }

        if(_this.targetSubmenuObject.hasClass('scrollable')){
            setTimeout(function(){
                _this.el.trigger('ux.displaySportsMenu');
            }, 100);
        }

        setTimeout(function(){
            _this.menuItem.find('a').blur(); //.attr('tabindex','-1');

            var targetSubmenuObjectAnchors = _this.targetSubmenuObject.find('a');

            targetSubmenuObjectAnchors.attr('tabindex','-1');
            targetSubmenuObjectAnchors.eq(0).attr('tabindex','0').focus().addClass('focus'); //.css('border','1px solid #000');

            var prevent = function(e){
                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = false;
            };

            targetSubmenuObjectAnchors.each(function(index){

                this.position = index;

                $(this).on('keydown.submenuAnchorsKeydown', function(e){
                    var keycode = (event.keyCode ? event.keyCode : event.which);

                    if(keycode === 39){ /* RIGHT */
                        prevent(e);
                        $(this).attr('tabindex','-1').removeClass('focus');
                        targetSubmenuObjectAnchors.eq(this.position + 1).attr('tabindex','0').focus().addClass('focus');
                    }

                    if(keycode === 37){ /* LEFT */
                        prevent(e);

                        if(this.position === 0){
                            _this.closeLargeSubmenu();
                            _this.setFocusOnTheLastActiveMenuAnchor();
                            targetSubmenuObjectAnchors.unbind('keydown.submenuAnchorsKeydown');

                        } else {
                            $(this).attr('tabindex','-1').removeClass('focus');
                            targetSubmenuObjectAnchors.eq(this.position - 1).attr('tabindex','0').focus().addClass('focus');
                        }
                    }

                    if(keycode === 40){ /* DOWN */
                        prevent(e);
                        $(this).attr('tabindex','-1').removeClass('focus');
                        targetSubmenuObjectAnchors.eq(this.position + 3).attr('tabindex','0').focus().addClass('focus');
                    }

                    if(keycode === 38){ /* UP */
                        prevent(e);
                        $(this).attr('tabindex','-1').removeClass('focus');
                        targetSubmenuObjectAnchors.eq(this.position - 3).attr('tabindex','0').focus().addClass('focus');
                    }
                });
            });

            _this.addTheCurrentOpenSportToHtml(_this.theActiveSport);

        },200);

        _this.bindWindowcloseLargeSubmenu();
    };

    prototypeMethods.closeLargeSubmenu = function(){
        var _this = this;

        _this.removeAnyOpenSportClassFromHtml();

        TweenMax.set( _this.submenuContent,{autoAlpha:0});
        TweenMax.set(_this.submenuBg,{width:0});
        TweenMax.set(_this.submenuCloseButton,{x:0});

        _this.el.removeClass('open');
        _this.el.find('li').removeClass('active').removeClass('focus');
        _this.submenuContent.removeClass('active');
        _this.submenuContent.find('.links-group').removeClass('active');
        _this.submenuContainer.removeClass('open').removeClass(_this.theActiveSport);
        _this.theActiveSport = '';
    };

    prototypeMethods.changeLargeSubmenu = function(){
        var _this = this;

        _this.removeAnyOpenSportClassFromHtml();

        _this.addTheCurrentOpenSportToHtml(_this.theActiveSport);

        function unsetCurrentSport(){
            _this.submenuContent.removeClass('active');
            _this.submenuContent.find('.links-group').removeClass('active');
            _this.el.find('li').removeClass('active');
            _this.menuItem.addClass('active');
        }

        unsetCurrentSport();

        function setNewSport(){
            _this.submenuContainer.removeClass().addClass('menu-submenu').addClass(_this.targetSubmenuClass);
            _this.targetSubmenuObject.addClass('active');
            

            if(!_this.targetSubmenuObject.hasClass('scrollable')){
                _this.sameColumnsHeight();
            }
        }
        

        if(_this.targetSubmenuObject.hasClass('scrollable')) {

            _this.expandSubmenuBackground('sports');

            setTimeout(function(){
                setNewSport();

                setTimeout(function(){
                    _this.el.trigger('ux.displaySportsMenu');
                }, 10);

            },200);
            
            
        } else {

            _this.expandSubmenuBackground();
            
            setNewSport();

        }
    };

    prototypeMethods.removeAnyOpenSportClassFromHtml = function(){
        $('html').removeClass (function (index, css) {
            return (css.match (/(^|\s)submenu-open-\S+/g) || []).join(' ');
        });
    };

    prototypeMethods.addTheCurrentOpenSportToHtml = function(sport){
        $('html').addClass('submenu-open-'+sport);
    };

    prototypeMethods.menuAnchorClickLarge = function($anchor){
        var _this = this,
        targetSubmenuId = $anchor.data('submenu'), /* EX: href="#submenu-sports-raquette" */
        targetURL = $anchor.attr('href');
        
        // Direct link
        if (!_.isUndefined(targetURL) && _.isUndefined(targetSubmenuId)) {
            window.location.href = targetURL;
        } else { // Sub menu

            _this.menuBlock = $anchor.closest('.menu-group');
            _this.menuItem = $anchor.closest('li');
            _this.targetSubmenuObject = $(targetSubmenuId);
            
            var sufixPattern = '-opeco';
            if (_this.el.attr('id') == 'menu-global') {
                sufixPattern = '-global';
            }

            if(typeof _this.targetSubmenuObject !== 'undefined' && targetSubmenuId.indexOf(_this.targetMenuPattern) >= 0) {

                _this.targetSubmenuClass = targetSubmenuId.replace(_this.targetMenuPattern, '').replace(sufixPattern, '');

                if(_this.submenuContainer.length > 0 && _this.submenuBg.length > 0 && _this.submenuContent.length > 0){
                    
                    _this.theActiveSport = '';

                    var classList = _this.submenuContainer.attr('class').split(/\s+/);

                    for (var i = classList.length - 1; i >= 0; i--) {
                        if( classList[i].indexOf(_this.targetSubmenuClass) >= 0){
                         _this.theActiveSport = classList[i];
                       }
                    }

                    /* ALWAYS CORRECT THE MENU ANCHOR POSITION */
                    _this.correctAnchorposition('fast');

                    /* THEN SHOW/HIDE THE SUBMENU */
                    /* IF IT IS OPEN */
                    if(_this.el.hasClass('open')) {

                        
                        if($anchor.closest('li').hasClass('active') && _this.targetSubmenuClass === _this.theActiveSport){

                            /* A CLICK ON THE OPEN TAB CLOSES THE SUBMENU */
                            _this.closeLargeSubmenu();
                            
                        } else {

                            /* A CLICK ON  DIFFERENT TAB LEAVES THE SUBMENU BACKGROUND OPEN AND CHANGES THE VISIBILITY OF THE MENU CONTENT */
                            _this.theActiveSport = _this.targetSubmenuClass;
                            _this.changeLargeSubmenu(_this.theActiveSport);

                        }

                    /* ELSE IF IT IS CLOSED */
                    } else {
                        /* A CLICK ON THE A TAB OPENS THE SUBMENU */
                        _this.openLargeSubmenu();

                    }
                } /* END OF IF THERE ARE THE SUBMENU ITEMS */
            } /* END OF IF THE CLICKED MENU ITEM HAS A DATA-SUBMENU ATTRIBUTE */
        }
    };

    prototypeMethods.correctAnchorposition = function(speed){
        var _this = this,
        thisMenuItemTopPosition = _this.menuItem.offset().top - _this.menuBlock.offset().top,
        thisMenuItemBottomPosition = thisMenuItemTopPosition + _this.menuItem.outerHeight(),
        menuHeight = _this.menuBlock.outerHeight();

        var scrollSpeed = speed === 'fast' ? 0.5 : 1;

        if(thisMenuItemTopPosition < 0) {
            TweenMax.to(_this.menuBlock, scrollSpeed, {scrollTo:{y: _this.menuBlock[0].scrollTop + thisMenuItemTopPosition}, ease:Power4.easeInOut});
        } else if(thisMenuItemBottomPosition > menuHeight) {
            TweenMax.to(_this.menuBlock, scrollSpeed, {scrollTo:{y:_this.menuBlock[0].scrollTop + (thisMenuItemBottomPosition - menuHeight)}, ease:Power4.easeInOut});
        }
    };

    prototypeMethods.bindWindowcloseLargeSubmenu = function(){
        var _this = this;
        $(window).on('keydown.closeLargeSubmenu', function(e){
            var keycode = (event.keyCode ? event.keyCode : event.which);
            if(keycode === 27 && !$('html').hasClass('displayOpecoMenu')){ /* ESC */
                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = false;
                _this.closeLargeSubmenu();
                _this.setFocusOnTheLastActiveMenuAnchor();
                $(window).unbind('keydown.closeLargeSubmenu');
            }
            
        });
    };

    prototypeMethods.setFocusOnTheLastActiveMenuAnchor = function(){
        var _this = this;
        _this.menuAnchorsArray.each(function(){
            if($(this).attr('tabindex') === '0'){
                $(this).focus();
            }
        });
    };

    prototypeMethods.watchMenuitemPosition = function(){
        var _this = this,
        scanTimer;

        clearTimeout(scanTimer);

        scanTimer = setTimeout(function(){

            if(_this.sportsMenu.find('li.active').length > 0 && _this.enableCorrectMenuItemPosition === true){
                _this.correctAnchorposition();
                _this.enableCorrectMenuItemPosition = false;
            }

        },3000);
    };

    prototypeMethods.menuAnchorClickSmall = function($anchor){
        var _this = this,
        
        targetSubmenuId = $anchor.data('submenu'), /* EX: data-submenu="#submenu-sports-raquette" */
        targetSubmenuTitle = $anchor.find('.text').html(); /* EX: data-submenu="#submenu-sports-raquette" */


        _this.menuBlock = $anchor.closest('.menu-sports, .menu-all-sports, .menu-categories');
        _this.menuItem = $anchor.closest('li');
    
        /* IF THERE IS A DATA-MENU ATTRIBUTE AND THE VALUE RESPECTS THE PATTERN #SUBMENU-... */
        if(typeof targetSubmenuId !== 'undefined' && targetSubmenuId.indexOf(_this.targetMenuPattern) >= 0) {

            _this.targetSubmenuObject = $(targetSubmenuId);

            _this.targetSubmenuClass = targetSubmenuId.replace(_this.targetMenuPattern, '').replace('-global', '');

            if(_this.el.hasClass('open')) {

                _this.currentSubmenuLevel = 0;
                _this.moveMobileSubmenu(null, _this.targetSubmenuClass);

                /* WAIT UNTIL THE ANIMATION IS RUNNING */
                setTimeout(function(){
                    _this.el.removeClass('open');
                    _this.menuBlock.find('li').removeClass('active');
                    _this.submenuContent.removeClass('active');
                    // TweenMax.to( $submenuContent, 0, {autoAlpha:0} );
                    // submenuContainer.removeClass(theActiveSport);
                },_this.openSportsSubMenuAnimationSpeed);
                    
            } else {

                TweenMax.to( _this.submenuContent, 0, {autoAlpha:1} );
                // theActiveSport = _this.targetSubmenuClass;
                _this.el.addClass('open');
                _this.menuItem.addClass('active');
                // submenuContainer.addClass(_this.targetSubmenuClass);
                _this.targetSubmenuObject.addClass('active');

                $('#menu-global .menu-column2').find('.title span.text').html(targetSubmenuTitle);

                // var tl = new TimelineMax();

                // tl
                // .staggerFrom($('.sports-list-container-content .sports-slide:first-child .row:first-child a'), 0.3, {x:200, opacity:0, ease: Power4.easeInOut}, 0.1)
                // .staggerFrom($('.sports-list-container-content .sports-slide:first-child .row:not(:first-child) a'), 0.1, {opacity:0, delay:0, ease: Power4.easeInOut}, 0.1)
                // .from($('.sports-list-container-content .sports-slide:not(:first-child) a'), 0.1, {opacity:0, delay:0, ease: Power4.easeInOut});

                /* ADDED TO DISABLE THE SCROLLABLE SPORTS MENU ON MOBILE */
                var soixantquinze = $("#menu-global .sports-list-container");
                if(soixantquinze.length > 0 && soixantquinze.is(':visible')) {
                    // Draggable.get("#menu-global .sports-list-container").disable();
                    TweenMax.set(soixantquinze,{clearProps:"all"});
                }

                _this.currentSubmenuLevel = 1;
                _this.moveMobileSubmenu(null, _this.targetSubmenuClass);

            }
            
        }
    };

    prototypeMethods.moveMobileSubmenu = function (option, sportClass){
        var _this = this;

        var menuGlobalColumn1 = $('#menu-global .menu-column1');
        var menuGlobalColumn2 = $('#menu-global .menu-column2');
        var menuGlobalColumn3 = $('#menu-global .menu-column3');

        var columnWidth = _this.el.outerWidth();

        speed = option === 'fast' ? 0 : _this.openSportsSubMenuAnimationSpeed/1000;

        var move = function(speed, position, sportClass){

            if(menuGlobalColumn1.length > 0 && menuGlobalColumn2.length > 0 && menuGlobalColumn3.length > 0){

                TweenMax.to( menuGlobalColumn1, speed , {x:position, ease: Power4.easeInOut} );
                TweenMax.to( menuGlobalColumn2, speed , {x:position, ease: Power4.easeInOut} );
                TweenMax.to( menuGlobalColumn3, speed , {x:position, ease: Power4.easeInOut} );

                setTimeout(function(){
                    if(position === 0){
                        if(sportClass !== ''){
                            $('html').removeClass (function (index, css) {
                                return (css.match (/(^|\s)submenu-open-\S+/g) || []).join(' ');
                            });
                        }
                    } else {
                        if(sportClass !== ''){
                            _this.addTheCurrentOpenSportToHtml(sportClass);
                        }
                    }
                },speed);
                
            }
        };

        if(typeof _this.currentSubmenuLevel === 'undefined'){
            _this.currentSubmenuLevel = 0;
        }

        if(_this.currentSubmenuLevel === 0){
            _this.currentSubmenuLevelXposition = 0;
        }

        if(_this.currentSubmenuLevel === 1){
            _this.currentSubmenuLevelXposition = _this.el.outerWidth() * -1;
            _this.el.trigger('ux.displaySportsMenu');
        }

        if(_this.currentSubmenuLevel === 2){
            _this.currentSubmenuLevelXposition = _this.el.outerWidth() * -2;
        }
        

        if(option === 'close-menu'){

            if(_this.currentSubmenuLevel !== 0){

                move(speed, _this.currentSubmenuLevelXposition + _this.el.outerWidth());

                setTimeout(function(){
                    move(0, 0, sportClass);
                    _this.currentSubmenuLevel = 0;
                },500);
            }

        } else {
            move(speed, _this.currentSubmenuLevelXposition, sportClass);
        }
    };

    prototypeMethods.moveMobileSubmenuCloseMenu = function(){
        var _this = this;
        _this.moveMobileSubmenu('close-menu');
    };

    prototypeMethods.moveMobileSubmenuFast = function(){
        var _this = this;
        _this.moveMobileSubmenu('fast');
    };

    prototypeMethods.categoryTitleClickSmall = function($title){

        var _this = this,
        targetSubmenuTitle = $title.html(),
        subMenu = $title.closest('.menu-submenu'),
        subMenuLinksGroup = $title.closest('.links-group'),
        subMenuTop = $title.closest('.menu-submenu-content').offset().top,
        subMenuLinksGroupTop = subMenuLinksGroup.offset().top;

        _this.el.find('.menu-column3 .title span.text').html(targetSubmenuTitle);

        subMenu.addClass('open').find('.links-group').removeClass('active');
        subMenuLinksGroup.addClass('active').find('ul').css('top', subMenuTop - subMenuLinksGroupTop);

        _this.currentSubmenuLevel = 2;
        _this.moveMobileSubmenu(null);
    };

    prototypeMethods.categoryTitleClickLarge = function($title){
        var _this = this;
        subMenuLinksGroup = $title.closest('.links-group');

        _this.expandSubmenuBackground('large');

        var subMenuTop = $title.closest('.menu-submenu-content').find('.row').offset().top - $title.closest('.menu-submenu-content').offset().top;

        _this.submenuContainer.addClass('open').find('.links-group').removeClass('active');
        subMenuLinksGroup.addClass('active').find('ul').css('top', subMenuTop);
    };

    prototypeMethods.disableDraggableSportsMenu = function(){
        var _this = this;
        _this.draggableSportsMenu[0].disable();
        TweenMax.set(_this.draggableSportsMenu[0],{clearProps:"all"});
    };

    prototypeMethods.enableDraggableSportsMenu = function(){
        var _this = this;
        _this.draggableSportsMenu[0].enable();
    };

    prototypeMethods.setFocusOnTheNextPreviousAnchor = function(anchor, direction){
        var _this = this;
        
        _this.menuAnchorsArray.attr('tabindex','-1');

        if(direction === 'down'){
            gotoNUmber = anchor.position + 1;
            if(gotoNUmber > _this.menuAnchorsArray.length - 1){
                gotoNUmber = 0;
            }
        } else if(direction === 'up'){
            gotoNUmber = anchor.position - 1;
            if(gotoNUmber < 0){
                gotoNUmber = _this.menuAnchorsArray.length - 1;
            }
        }

        _this.menuAnchorsArray.eq(gotoNUmber).attr('tabindex','0').focus(); //.closest('li').addClass('focus');
    };

    prototypeMethods.init = function(){
        
        var _this = this;
        _this.submenuContainer =   _this.el.find('.menu-submenu');
        _this.submenuBg =          _this.el.find('.menu-submenu-background');
        _this.submenuContent =     _this.el.find('.menu-submenu-content');
        _this.submenuCloseButton = _this.el.find('.menu-close-button .button');

        _this.menuAnchorsArray = _this.el.find('.menu-content a');

        _this.el.skewAngle = 3.5;
        _this.el.tangDuAngle = Math.tan(_this.el.skewAngle * Math.PI/180);

        _this.sportsMenu = _this.el.find('.menu-sports');
        _this.theActiveSport = '';
        
        _this.currentSubmenuLevelXposition = 0;
        _this.openSportsSubMenuAnimationSpeed = 500; /* IN MILISECONDS */
        // _this.el.find(".menu-sports ul li") = _this.el.find(".menu-sports ul li");
        // _this.el.find(".menu-categories ul li") = _this.el.find(".menu-categories ul li");

        _this.el.draggableMenuOptions = {
            type:"scrollTop",
            dragClickables:"true",
            cursor:"pointer",
            edgeResistance:0.9,
            throwProps:true,
            lockAxis:true,
            onDrag:function() {
                _this.resizeMenuLinesWidth();
            },
            onDragEnd:function() {
                _this.quickLooptoResize();
            }
        };

        _this.draggableSportsMenu = Draggable.create(_this.sportsMenu, _this.el.draggableMenuOptions);
        TweenMax.set(_this.sportsMenu,{scrollTo:{y: _this.sportsMenu.outerHeight()/2}});

        _this.appendDividerLinesToMenuItems();

        _this.enableCorrectMenuItemPosition = false;

        _this.sportsMenu.on('scroll', function(){
            _this.showHideSportsShadows($(this).scrollTop());
            _this.resizeMenuLinesWidth();
            
        })

        .on('touchend', function(){

            _this.sportsMenu.on('scroll', function(){
                _this.enableCorrectMenuItemPosition = false;
                var debouncer_timer;
                clearTimeout(debouncer_timer);
                debouncer_timer = setTimeout(function(){
                    if(_this.sportsMenu.find('li.active').length > 0){
                        _this.enableCorrectMenuItemPosition = true;
                        _this.watchMenuitemPosition();
                    }
                }, 7000);
            });

        })

        .on('mouseenter mousemove', function(){
            _this.enableCorrectMenuItemPosition = false;
        })

        .on('mouseleave', function(){
            if(_this.sportsMenu.find('li.active').length > 0){
                _this.enableCorrectMenuItemPosition = true;
                _this.watchMenuitemPosition();
            }
        })

        .on( 'mousewheel DOMMouseScroll', function (e) {

            if(!decathlon.uxBreakpoints.is('small-screen') && _this.el.attr('id') !== 'menu-global'){

                var e0 = e.originalEvent,
                delta = e0.wheelDelta || -e0.detail;

                if (((this.scrollTop + this.offsetHeight) === this.scrollHeight && delta < 0)) {
                    e.preventDefault();
                }
            }
        });

        _this.scrollSportsMenu();


        var basicMenuUpdate = function(){
            
            var resize_timer;

            if(_this.el.is(':visible')){
                _this.resizeMenuLinesWidth();
                _this.uxResizeImageBackgrounds();
                _this.setSportsmenuHeight();
                
                clearTimeout(resize_timer);
                resize_timer = setTimeout(function(){
                  _this.uxResizeImageBackgrounds(_this.el);
                }, 300);
            }
        };

        $(window).on('resize', function() {
            basicMenuUpdate();
            _this.resizeMenuLinesWidth();
        });

        basicMenuUpdate();

        _this.el.on('click', '.menu-close-button', _.debounce(function(){
            if($('html').hasClass('displayOpecoMenu')){
                _this.closeLargeSubmenu();
            }else{
                $('.menu-toggler').trigger('click');
            }
            
            if(_this.el.closest('#menu-global').length === 1 && !$('html').hasClass('displayOpecoMenu')){
                //_this.el.uxMainMenuFunctions('closeMenuGlobalLarge');
            }

        }, 300, true));


        _this.targetMenuPattern = '#submenu-';

        _this.el.on('click', '.menu-group li a', function(e){
            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = false; /* FOR IE */
        });
                    
        _this.el.on('click', '.menu-group li a', _.debounce(function(){

            if(!decathlon.uxBreakpoints.is('small-screen')){
                
                _this.menuAnchorsArray.attr('tabindex','-1');
                $(this).attr('tabindex','0').focus();

                _this.menuAnchorClickLarge($(this));

            } else {
                _this.menuAnchorClickSmall($(this));
            }
        }, 300, true));


        _this.menuAnchorsArray.each(function(index){

            this.position = index;

            $(this).on('keydown', function(e){

                if(!decathlon.uxBreakpoints.is('small-screen')){
                    
                    var keycode = (e.keyCode ? e.keyCode : e.which);

                    var prevent = function(e){
                        e.preventDefault();
                        e.stopPropagation();
                        e.cancelBubble = false;
                    };

                    if(keycode === 40){ /* DOWN */
                        prevent(e);
                        _this.setFocusOnTheNextPreviousAnchor(this, 'down');
                    }

                    if(keycode === 38){ /* UP */
                        prevent(e);
                        _this.setFocusOnTheNextPreviousAnchor(this, 'up');
                    }

                    if(keycode === 39){ /* RIGHT */
                        prevent(e);
                        _this.menuAnchorClickLarge($(this));
                    }

                    if(keycode === 37){ /* LEFT */
                        prevent(e);
                        _this.closeLargeSubmenu();
                    }

                }
            });

            $(this).on('focus', function(){
                $(this).closest('li').addClass('focus');
            });

            $(this).on('blur', function(){
                $(this).closest('li').removeClass('focus');
            });
        });

        /* THE BACK CLICK TRIGGERS A MENU TOGGLE */
        $('#menu-global .menu-column2 .back').on('click', function(){
            
            _this.currentSubmenuLevel = 0;
            _this.moveMobileSubmenu(null);

            /* AND FINALLY - WAIT FOR THE ANIMATION TO FINISH */
            setTimeout(function(){
                _this.el.removeClass('open');
                _this.el.find('li').removeClass('active');
                _this.submenuContainer.removeClass(_this.theActiveSport);
                _this.submenuContent.removeClass('active');
                TweenMax.to( _this.submenuContent, 0, {autoAlpha:0} );
            },_this.openSportsSubMenuAnimationSpeed);

        });

        $('#menu-global .menu-column3 .back').on('click', function(){
            _this.currentSubmenuLevel = 1;
            _this.moveMobileSubmenu(null);
        });
        
        _this.el.on('click', '.menu-submenu .title', function(e){
            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = false; /* FOR IE */
        });

        _this.el.on('click', '.menu-submenu .title', _.debounce(function(e){
            if(!decathlon.uxBreakpoints.is('small-screen')){
                // if(uxDynamicSizes.windowWidth <= 1080){
                    _this.categoryTitleClickLarge($(this));
                // }
            } else {
                _this.categoryTitleClickSmall($(this));
            }

        }, 300, true));
    };


    decathlon.tools.createJqueryPlugin({
        pluginName : 'uxMenuBasicFunctions',
        defaultOptions : {
        },
        prototypeMethods :  prototypeMethods
    });
}(window, jQuery, document));



;(function (window, $, document, undefined) {

    var prototypeMethods = prototypeMethods || {};
    
    var body = $('body');

    function resetMenuHeights(){
        if(!body.hasClass('mobile')){
            var menuHeight;
            if(!body.hasClass('homepage')){
                menuHeight = 0;
                if($('.product-head').length && $('.product-head').css('position') === "fixed"){
                    menuHeight = $(window).height() - $('.product-head').outerHeight();
                }else{
                    menuHeight = $(window).height() - ((($('.m-header-main').offset()).top + $('.m-header-main').outerHeight()) - $(window).scrollTop());
                }
            }else if(body.hasClass('homepage') && !$('html').hasClass('noscroll')){
                menuHeight = $('.opeco-carousel').outerHeight();
            }
            $('#menu-global, #menu-global .menu, #menu-global .menu-background').css({
                'height': menuHeight,
                'min-height': menuHeight
            });
            var submenuHeight = $('.menu-content').outerHeight() - ($('.menu-all-sports').outerHeight() + $('.menu-categories').height());
            $('.menu-sports-mask').css({
                'height': submenuHeight
            });
            $('.menu-sports').css({
                'height': submenuHeight - $('.menu-group-title').outerHeight()
            });
        }
        $('#menu-global-sports-nav').css('top', ($('.navigation-menu').offset()).top + $('.menu-close-button .button').outerHeight() + 20 + 'px');
    }

    prototypeMethods.setFocusOnTheMenu = function(){
        var _this = this;
        // _this.menuAnchorsArray.attr('tabindex','-1').closest('li').removeClass('focus');
        _this.el.find('.menu-content a').attr('tabindex','-1').closest('li').removeClass('focus');
        _this.el.find('.menu-sports a:first').attr('tabindex','0').focus().closest('li').addClass('focus');
    };

    prototypeMethods.bindWindowCloseMenuGlobalLarge = function(){
        var _this = this;
        $(window).on('keydown.closeMenuGlobalLarge', function(e){
            var keycode = (event.keyCode ? event.keyCode : event.which);
            if(keycode === 27 && !$('html').hasClass('displayOpecoMenu')){ /* ESC */
                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = false;
                _this.closeMenuGlobalLarge();
                $(window).unbind('keydown.closeMenuGlobalLarge');
            }
        });
    };

    prototypeMethods.openMenuGlobalLarge = function(){
        body.addClass('noscroll');
        var _this = this,
            $animationTarget = _this.el.globalMainMenu,
            targetXposition = 0,
            topMessageBarHeight = $('#top-message-bar').outerHeight(),
            menuTopPosition = 0;

            // CALCULATES THE TOP POSITION OF THE MENU
            if($('.product-head').length && $('.product-head').css('position') === "fixed"){
                menuTopPosition = ($('.product-head').offset()).top + $('.product-head').outerHeight();
            }else{
                menuTopPosition = ($('.m-header-main').offset()).top + $('.m-header-main').outerHeight();
            }
            

        var onAnimationStart = function(){

            if(!$('html').hasClass('displayOpecoMenu')){
                $('html').addClass('noscroll');
                _this.el.css('top', menuTopPosition + 'px');
            }
            $('html').addClass('menu-open');

            //_this.el.css('visibility', 'visible');
            
            _this.el.uxMenuBasicFunctions('uxResizeImageBackgrounds')
                    .uxMenuBasicFunctions('resizeMenuLinesWidth')
                    .uxMenuBasicFunctions('setSportsmenuHeight')
                    .uxMenuBasicFunctions('enableDraggableSportsMenu');

            _this.globalMenuToggler.addClass('close').attr('aria-expanded','true'); //.attr('tabindex', '-1');

            _this.bindWindowCloseMenuGlobalLarge();


            TweenMax.set( _this.el.find('menu-column1'), {clearProps:"all"});
            TweenMax.set( _this.el.find('menu-column2'), {clearProps:"all"});
            TweenMax.set( _this.el.find('menu-column3'), {clearProps:"all"});
            _this.el.css('display', 'block');
            // TweenMax.staggerFrom($('#menu-global .menu-categories ul li'), 0.2, {x:-100, opacity:0, delay:0.2, ease: Power4.easeInOut}, 0.1);
        };

        var onAnimationComplete = function(){

            $animationTarget.attr('aria-hidden', 'false');

            _this.el.attr('aria-hidden', 'false');

            /* ADDS AN EXTRA DIV TO DETECT THE OFF-MENU CLICKS, WHICH CLOSES THE MENU */
            if ($('#extra-close-menu').length === 0){
                $('#menu-global nav').append('<div id="extra-close-menu"></div>');
            }

            $('#extra-close-menu').unbind('click.closeMenu').on('click.closeMenu', function(){
                if(!$('html').hasClass('displayOpecoMenu')){
                    _this.closeMenuGlobalLarge();
                }
            });

            _this.setFocusOnTheMenu();

            _this.el.uxMenuBasicFunctions('resizeMenuLinesWidth');

            resetMenuHeights();
        };

        TweenMax.to(
            $animationTarget,
            _this.globalSpeed,
            {
                x:          targetXposition,
                ease:       Power4.easeInOut,
                onStart:    onAnimationStart,
                onComplete: onAnimationComplete
            }
        );
    };

    prototypeMethods.openMenuGlobalSmall = function(){
        var _this = this;
        var $animationTarget = _this.el;
        var targetXClosedPosition = -(uxDynamicSizes.windowWidth - uxDynamicSizes.mobileMenuHeight);

        
        _this.el.uxMenuBasicFunctions('uxResizeImageBackgrounds');
        _this.el.uxMenuBasicFunctions('resizeMenuLinesWidth');
        _this.el.uxMenuBasicFunctions('disableDraggableSportsMenu');
        

        /*$topMessage = $('#top-message-bar').data('uxTopMessage');
        if(typeof $topMessage !== 'undefined'){
            $topMessage.dismissNote();
        }*/
        $('#top-message-bar').hide();

        var onAnimationStart = function(){
            
            //$animationTarget.css('visibility', 'visible');
            $('#menu-global').css('display', 'block');
            
            $('html').addClass('noscroll').addClass('menu-open');

            $animationTarget.before('<div class="'+_this.globalMaskMenuClassName+'"></div>');

            if($('#modal-product').is(':visible')) {
                $('.menu-mask').css('z-index', '9999');
            }

            _this.globalMenuToggler.addClass('close');

            _this.el.find('.menu-submenu-contents').css({'width':''});
            
            // TweenMax.staggerFrom($('#menu-global ul li'), 0.2, {x:-100, opacity:0, delay:0.1, ease: Power4.easeInOut}, 0.1);

        };

        var onAnimationComplete = function(){
            
            _this.el.globalMainMenu.attr('aria-hidden', 'false');
            $animationTarget.attr('aria-hidden', 'false');


            $('.'+_this.globalMaskMenuClassName).one('click', function(){
                _this.closeMenuGlobalSmall();
            });
        };

        TweenMax.set($animationTarget, {x:targetXClosedPosition});
        
        TweenMax.to(
            $animationTarget,
            _this.globalSpeed,
            {
                x:          0,
                ease:       Power4.easeInOut,
                onStart:    onAnimationStart,
                onComplete: onAnimationComplete
            }
        );

        TweenMax.to( _this.$globalHeader, _this.globalSpeed, {x:$animationTarget.outerWidth(), ease: Power4.easeInOut} );
    };

    prototypeMethods.closeMenuGlobalLarge = function(mode){
        
        var _this = this;
        var $animationTarget = _this.el.globalMainMenu;
        var speed = mode ===  'force' ? 0 : _this.globalSpeed;
        // var targetXposition = -($animationTarget.outerWidth() * uxDynamicSizes.cWidth);
        var targetXposition = decathlon.uxBreakpoints.is('small-screen') ? 0 : uxDynamicSizes.windowWidth * -1;

        if(mode === 'force'){
            _this.el.css('opacity',0);
        }

        _this.globalMenuToggler.removeClass('close').attr('aria-expanded','false');


        $('html').removeClass('noscroll');

        
        _this.el.uxMenuBasicFunctions('closeLargeSubmenu');
        


        var onAnimationStart = function(){
            $('html').removeClass (function (index, css) {
                return (css.match (/(^|\s)submenu-open-\S+/g) || []).join(' ');
            });
        };

        var onAnimationComplete = function(){

            /* SCROLLS THE MENU BACK TO THE TOP */
            TweenMax.to(_this.el.globalSportsMenu, 0, {scrollTo:{y: 0}});

            if(!$('html').hasClass('displayOpecoMenu')){
                _this.el.css('top', '');
            }
            //_this.el.css('visibility', 'hidden');

            $animationTarget.attr('aria-hidden', 'true');
            _this.el.attr('aria-hidden', 'true');
            //$('html').removeClass('menu-open');


            if(mode === 'force'){
                _this.el.css('opacity','');
            }
        };

        TweenMax.to(
            $animationTarget,
            speed,
            {
                x:          targetXposition,
                ease:       Power4.easeInOut,
                onStart:    onAnimationStart,
                onComplete: onAnimationComplete
            }
        );
    };

    prototypeMethods.closeMenuGlobalSmall = function(mode){

        var _this = this;
        var $animationTarget = _this.el;
        var speed = mode ===  'force' ? 0 : _this.globalSpeed;
        var targetXposition = -(uxDynamicSizes.windowWidth - uxDynamicSizes.mobileMenuHeight);
        _this.el.css('height',0);
        if(mode === 'force'){
            _this.el.css('opacity',0);
        }
        
        $('#top-message-bar').show();
        /*$topMessage = $('#top-message-bar').data('uxTopMessage');
        if(typeof $topMessage !== 'undefined' && mode !== 'force'){
            $topMessage.showNote();
        }*/

        
        _this.el.uxMenuBasicFunctions('moveMobileSubmenuCloseMenu');
        _this.el.uxMenuBasicFunctions('closeLargeSubmenu');
        
        _this.globalMenuToggler.removeClass('close').attr('aria-expanded','false');
            

        var onAnimationComplete = function(){
            
            _this.el.globalMainMenu.attr('aria-hidden', 'true');
            $animationTarget.attr('aria-hidden', 'true');

            $('html').removeClass('menu-open');

            $('.'+_this.globalMaskMenuClassName).remove();

            $('html').removeClass('noscroll');

            /* CORRECT THE MENU POSITION WHEN CHANGING RESPONSIVE SIZES */
            if(mode ===  'force') {
                TweenMax.set($animationTarget, {x:0});
                TweenMax.set(_this.$globalHeader, {x:0});
            }

            //$animationTarget.hide();

            if(mode === 'force'){
                _this.el.css('opacity','');
            }
        };

        /* THEN CLOSES THE MAIN MENU */
        TweenMax.to(
            $animationTarget,
            speed,
            {
                x:          targetXposition,
                ease:       Power4.easeInOut,
                // onStart:    onAnimationStart,
                onComplete: onAnimationComplete
            }
        );
        

        TweenMax.to( _this.$globalHeader, speed, {x:0, ease: Power4.easeInOut, onComplete:function(){
        }} );

        $('.m-header-main').removeClass('mobile-sticky on');
        
        
        // TweenMax.staggerTo($('#menu-global .menu-categories ul li'), 1, {x:-100}, 0.5);
    };

    prototypeMethods.toggleMenuSmall = function(){
        var _this = this;
        if(_this.el.length > 0){
            if(_this.el.attr('aria-hidden') === 'false'){
                _this.closeMenuGlobalSmall();
            } else {
                _this.openMenuGlobalSmall();
            }
        }
    };

    prototypeMethods.toggleMenuLarge = function(){
        var _this = this;
        if(_this.el.attr('aria-hidden') === 'false'){
            _this.closeMenuGlobalLarge();
        } else {
            $("#menu-fixed-opeco").uxMenuBasicFunctions('closeLargeSubmenu');
            _this.openMenuGlobalLarge();
        }
    };

    prototypeMethods.smallEnter = function (){
        var _this = this;
        var sportsMenu = $("#menu-global .menu-sports");
        if(sportsMenu.length > 0){
            // Draggable.get("#menu-global .menu-sports").disable();
            TweenMax.set(sportsMenu,{clearProps:"all"});
        }

        if($("#menu-global .sports-list-container").length > 0){
            // Draggable.get("#menu-global .sports-list-container").disable();
        }


        _this.closeMenuGlobalLarge('force');
        _this.closeMenuGlobalSmall('force');
    };

    prototypeMethods.smallExit = function (){
        var _this = this;
        _this.closeMenuGlobalSmall('force');
        _this.closeMenuGlobalLarge('force');
    };

    prototypeMethods.correctOffcanvasPosition = function(){
        var _this = this;

        if(decathlon.uxBreakpoints.is('small-screen')){
            if(_this.el.attr('aria-hidden') === 'true') {
                TweenMax.set(_this.el, {x:-_this.el.outerWidth()} );
                TweenMax.set(_this.$globalHeader, {x:0} );
            } else {
                _this.el.uxMenuBasicFunctions('moveMobileSubmenuFast');
                TweenMax.set(_this.el, {x:0} );
                TweenMax.set(_this.$globalHeader, {x: (uxDynamicSizes.windowWidth - _this.globalMenuToggler.outerWidth()) } );
            }
            
        }
    };

    prototypeMethods.init = function(){
        var _this = this;
        var resizeTimer;
        _this.el.globalMainMenu = _this.el.find('.menu');
        _this.el.globalSportsMenu = _this.el.find('.menu-sports');

        _this.$globalHeader = $('#header');
        _this.globalMenuToggler = _this.$globalHeader.find('.menu-toggler');
        _this.globalMaskMenuClassName = 'menu-mask';
        _this.globalSpeed = 0.5;
        _this.currentSubmenuLevel = 0;

        setTimeout(function(){
            _this.closeMenuGlobalLarge('force');
        },0);

        $(window).bind('resize-width.menu-resize', function() {
            _this.correctOffcanvasPosition();
        });

        $(window).on('resize', function(){
            resetMenuHeights();
        });

        _this.correctOffcanvasPosition();

        $(window).on('enter-small-screen', function(){
          _this.smallEnter();
        });

        $(window).on('exit-small-screen', function(){
          _this.smallExit();
        });
    };

    decathlon.tools.createJqueryPlugin({
        pluginName : 'uxMainMenuFunctions',
        defaultOptions : {
        },
        prototypeMethods :  prototypeMethods
    });

}(window, jQuery, document));


;(function (window, $, document, undefined) {

  var prototypeMethods = prototypeMethods || {};

     prototypeMethods.init = function () {

        var _this = this;

        _this.el.on('click', function(e){
            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = false; /* FOR IE */
        });

        _this.el.on('click', _.debounce(function(e){

            if(!decathlon.uxBreakpoints.is('small-screen')){
                $("#menu-global").uxMainMenuFunctions('toggleMenuLarge');
            } else {
                $("#menu-global").uxMainMenuFunctions('toggleMenuSmall');
            }
        }, 300, true));

        _this.el.on('keydown', function(e){

            var keycode = (event.keyCode ? event.keyCode : event.which);

            if(keycode === 13 || keycode === 32 ){

                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = false; /* FOR IE */

                if(!decathlon.uxBreakpoints.is('small-screen')){
                    $("#menu-global").uxMainMenuFunctions('toggleMenuLarge');
                } else {
                    $("#menu-global").uxMainMenuFunctions('toggleMenuSmall');
                }
            }
            
        });
        
        // force newTab
        $('.newTab').on('click', function() { window.open(this.href, 'blank'); return false; });
    };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'uxMenuHeaderMenuToggler',
    defaultOptions : {
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));
// GENERIC MENU 
$("#menu-fixed-opeco, #menu-global").uxMenuBasicFunctions();

// SPECIFIC TO GLOBAL
$("#menu-global").uxMainMenuFunctions();

$('#header .menu-toggler').uxMenuHeaderMenuToggler();
;(function (window, $, document, undefined) {

  var prototypeMethods = prototypeMethods || {};

  prototypeMethods.highlightSearch = function(string, phrase) {
    return string.replace(new RegExp("(" + phrase + ")", "gi") , "<b>$1</b>");
  };

  prototypeMethods.createListOfSports = function(){

    var _this = this;

    if(_this.$sportsListFilter.length > 0 && _this.orderedSportsArray.length > 0){
      var sportsFilteredList = '<div class="sports-menu-filtered-list"><ul>';

      _this.orderedSportsArray.each(function(){
        
        // $(this).find('.image').remove();

        sportsFilteredList += '<li>';
        sportsFilteredList += $(this)[0].outerHTML;
        sportsFilteredList += '</li>';
      });

      sportsFilteredList += '</ul></div>';

      _this.$filteredList = $(sportsFilteredList).addClass('hidden');

      _this.$sportsListFilter.parent().append(_this.$filteredList);
    }
  };

  prototypeMethods.attachSportsListFilterMethods = function(){
    var _this = this, search, $target;

    var charCount = $('html').attr('lang') === 'zh' ? _this.options.charCountZh : _this.options.charCountEn;

    _this.$sportsListFilter.on("propertychange change click keyup input paste focus",function () {

        search = $(this).val();

        $target = _this.$filteredList.find('li');

        $(document).on('click.close-sports-filter-list', function(){
          if(!_this.$sportsListFilter.is(':focus')){
            _this.$filteredList.addClass('hidden').attr('aria-hidden', 'true');
          }
        });

        if (search && search.length >= charCount) {

          /* show list */

          _this.$filteredList.removeClass('hidden').attr('aria-hidden', 'false');
          $target.removeClass('last-child').addClass('hidden').attr('aria-hidden', 'true');
          $target.closest('.sports-menu-filtered-list').css('top', $(this).closest('.submenu-search-field').position().top + $(this).closest('.submenu-search-field').outerHeight() -1 );

          var matchingSportsArray = $target.find('.text:containsChar("' + search + '")');

          if(matchingSportsArray.length > 0){

            _this.$filteredList.find('.no-results').remove();

            matchingSportsArray.each(function(index){
              
              if( index+1 === matchingSportsArray.length){
                $(this).closest('li').addClass('last-child');
              }
              $(this).closest('li').removeClass('hidden').attr('aria-hidden', 'false');
              $(this).html(_this.highlightSearch($(this).text(), search));
            });

          } else {

            if(_this.$filteredList.find('.no-results').length === 0) {
              _this.$filteredList.append('<div class="no-results">'+_this.nothingFoundPhrase+'</div>');
            }
          }

        } else {

          /* hide list */

          $target.find('.text').each(function(){
            $(this).html($(this).text());
          });

          $target.removeClass('hidden').attr('aria-hidden', 'false');
          _this.$filteredList.addClass('hidden').attr('aria-hidden', 'true');

          $(document).off('click.close-sports-filter-list');

        }
    });
  };

  prototypeMethods.replaceSportsListContentByAlpha = function(){

    var _this = this;

    _this.groupedArrayofSports = [
      { letter:'A',
        sports:[],
        scrollYPos:null
      },
      { letter:'B',
        sports:[],
        scrollYPos:null
      },
      { letter:'C',
        sports:[],
        scrollYPos:null
      },
      { letter:'D',
        sports:[],
        scrollYPos:null
      },
      { letter:'E',
        sports:[],
        scrollYPos:null
      },
      { letter:'F',
        sports:[],
        scrollYPos:null
      },
      { letter:'G',
        sports:[],
        scrollYPos:null
      },
      { letter:'H',
        sports:[],
        scrollYPos:null
      },
      { letter:'I',
        sports:[],
        scrollYPos:null
      },
      { letter:'J',
        sports:[],
        scrollYPos:null
      },
      { letter:'K',
        sports:[],
        scrollYPos:null
      },
      { letter:'L',
        sports:[],
        scrollYPos:null
      },
      { letter:'M',
        sports:[],
        scrollYPos:null
      },
      { letter:'N',
        sports:[],
        scrollYPos:null
      },
      { letter:'O',
        sports:[],
        scrollYPos:null
      },
      { letter:'P',
        sports:[],
        scrollYPos:null
      },
      { letter:'Q',
        sports:[],
        scrollYPos:null
      },
      { letter:'R',
        sports:[],
        scrollYPos:null
      },
      { letter:'S',
        sports:[],
        scrollYPos:null
      },
      { letter:'T',
        sports:[],
        scrollYPos:null
      },
      { letter:'U',
        sports:[],
        scrollYPos:null
      },
      { letter:'V',
        sports:[],
        scrollYPos:null
      },
      { letter:'W',
        sports:[],
        scrollYPos:null
      },
      { letter:'X',
        sports:[],
        scrollYPos:null
      },
      { letter:'Y',
        sports:[],
        scrollYPos:null
      },
      { letter:'Z',
        sports:[],
        scrollYPos:null
      }
    ];

    _this.orderedSportsArray.each(function(){

      var firstChar = $(this).data('ordering-text').charAt(0).removeDiacritics();

      for (var i = 0; i < _this.groupedArrayofSports.length; i++) {

        if(_this.groupedArrayofSports[i].letter === firstChar){
          _this.groupedArrayofSports[i].sports.push($(this));
        }
        
      }

    });


    var carouselOutput = '';

    for (var k in _this.groupedArrayofSports){
      if (_this.groupedArrayofSports.hasOwnProperty(k)) {

        var sportsLength = _this.groupedArrayofSports[k].sports.length;
        if(sportsLength > 0){
          carouselOutput += '<div class="sports-group" data-letter="'+_this.groupedArrayofSports[k].letter+'">';
          // carouselOutput +=   '<div class="sports-wrapper">';
          carouselOutput +=     '<div class="letter"><span>' + _this.groupedArrayofSports[k].letter + '</span></div>';
          carouselOutput +=     '<div class="sports">';

          for(var i in _this.groupedArrayofSports[k].sports){
            carouselOutput += _this.groupedArrayofSports[k].sports[i][0].outerHTML;
          }

          carouselOutput +=     '</div>';
          // carouselOutput +=   '</div>';
          carouselOutput += '</div>';

        }
      }
    }

    

    _this.$sportsList.empty().append($(carouselOutput));

    if(_this.$sportsList.closest('#menu-global').length > 0){
      _this.$sportsList.parent().prepend('<div id="menu-global-fake-letter" class="letter fake-letter">A</div>');
    }
  };

  prototypeMethods.prepareSportsAndReorderThenOrNot = function(){

    var _this = this;

    var orderingText, pingying;

    var sportsArray = _this.$sportsList.find('a');

    sportsArray.each(function(){
      $(this).attr('data-ordering-text', $(this).find('.text').text().replace(/^\s\s*/, ''));
    });

    var aText, bText;

    if($('html').attr('lang') !== 'zh'){

      _this.orderedSportsArray = sportsArray.sort(function(a, b){
        aText = $(a).data('ordering-text');
        bText = $(b).data('ordering-text');
        if(aText < bText) return -1;
        if(aText > bText) return 1;
        return 0;
      });

      _this.replaceSportsListContentByAlpha();

    } else {
      _this.orderedSportsArray = sportsArray;
    }
  };

  prototypeMethods.initAlphabeticalScrollMethods = function(){

    var _this = this;
    var itemLetter = '';
    var itemYPos;

    var $sportsAlphaListNav = $('#'+_this.el.closest('#menu-global, #menu-fixed-opeco').attr('id')+'-sports-nav');
    var sportsGroupsArray = _this.el.find('.sports-group');

    var updateAlphaNavBarCss = function(){
      
      setTimeout(function(){
        var lisHeight;

        totalHeight = _this.el.find('.sports-menu-letters-navigation').height();

        if(totalHeight > 100) {

          lisHeight = (totalHeight - 15) / _this.groupedArrayofSports.length;

          uxDynamicStyles.appendCssStylesArrayToHeader({
            uniqueId : 'sportsMenuList1',
            selectors : [
            '.sports-menu-letters-navigation li'
            ],
            properties : [
              'height: '+ Math.round(lisHeight) + 'px;'
            ]
          });

          uxDynamicStyles.appendCssStylesArrayToHeader({
            uniqueId : 'sportsMenuList2',
            selectors : [
            'body.mobile #menu-global-sports-nav'
            ],
            properties : [
              'top: '+ _this.$sportsList[0].getBoundingClientRect().top + 'px;'
            ]
          });

        }

      },100);

    };

    var updateTheAlphaNavBar = function(sportsGroupsArray){

      sportsGroupsArray.each(function(index){

        var $group = $(this);

        $sportsAlphaListNavLis = $sportsAlphaListNav.find('li');

        $sportsAlphaListNavLis.each(function(){

          $(this).data('scroll-position');

          if($group.data('letter') === $(this).data('letter')){
            $(this).data('scroll-position', $group.position().top - $group.parent().position().top);
          }

          $(this).data('scroll-position');

        });
        
      });

      updateAlphaNavBarCss();

    };


    var setActiveNav = function(){

      var groupYPosTop, groupYPosBottom, listTop, groupLetter;
      var activeLetters = [];

      var iosLetterOnScreen = [];
      var iosLetterPrevious = [];

      sportsGroupsArray.each(function(index){

        listTop = $(this).parent().position().top;
        listHeight = $(this).parent().outerHeight();

        groupLetter = $(this).data('letter');
        groupYPosTop = $(this).position().top - listTop;
        groupYPosBottom = groupYPosTop + $(this).height();

        if( ( groupYPosTop >= 0 && groupYPosTop <= listHeight) || ( activeLetters.length === 0 && groupYPosTop < 0 && groupYPosBottom >= listHeight) ){
          activeLetters.push($(this).data('letter'));
        }

        if(groupYPosBottom >= -20){
          iosLetterOnScreen.push($(this).data('letter'));
        }

        if(groupYPosTop < 21){
          iosLetterPrevious.push($(this).data('letter'));
        }

        // if(groupYPosTop <= 0){
        //   iosLetterPrevious.push($(this).data('letter'));
        // }

      });

      activeLetter = _this.sportsListScrollEnd() === false ? activeLetters[0] : activeLetters[activeLetters.length-1];

      sportsGroupsArray.parent().find('.active').removeClass('active');
      if(decathlon.uxBreakpoints.is('small-screen')) {
        sportsGroupsArray.parent().find('[data-letter="'+activeLetter+'"]').addClass('active');
      }

      $('#'+_this.el.closest('#menu-global, #menu-fixed-opeco').attr('id')+'-sports-nav').find('li.active').removeClass('active');
      $('#'+_this.el.closest('#menu-global, #menu-fixed-opeco').attr('id')+'-sports-nav').find('li[data-letter="'+activeLetter+'"]').addClass('active');

      var $fakeLetter = _this.$sportsList.parent().find('.fake-letter');

      if($fakeLetter.text() !== iosLetterOnScreen[0]) {
        $fakeLetter.text(iosLetterOnScreen[0]);
      }

      
      var $groupWithClassLetterOnScreen = sportsGroupsArray.parent().find('.letter-on-screen');
      if($groupWithClassLetterOnScreen.length > 0){
        $groupWithClassLetterOnScreen.each(function(){
          if($(this).data('letter') !== iosLetterPrevious[iosLetterPrevious.length-1]){
            $(this).removeClass('letter-on-screen');
          }
        });
      }
      sportsGroupsArray.parent().find('[data-letter="'+iosLetterPrevious[iosLetterPrevious.length-1]+'"]').addClass('letter-on-screen');


      var $groupWithClassPreviousLetter = sportsGroupsArray.parent().find('.previous-letter');
      if($groupWithClassPreviousLetter.length > 0){
        $groupWithClassPreviousLetter.each(function(){
          if($(this).data('letter') !== iosLetterPrevious[iosLetterPrevious.length-2]){
            $(this).removeClass('previous-letter');
          }
        });
      }
      sportsGroupsArray.parent().find('[data-letter="'+iosLetterPrevious[iosLetterPrevious.length-2]+'"]').addClass('previous-letter');

    };


    var injectTheAlphaNavBar = function(sportsGroupsArray){
          
      sportsGroupsArray.each(function(){

        for (var i = 0; i < _this.groupedArrayofSports.length; i++) {
          if(_this.groupedArrayofSports[i].letter === $(this).data('letter')){
            _this.groupedArrayofSports[i].scrollYPos = $(this).position().top - $(this).parent().position().top;
          }
        }

      });

      var sportsMenuParentId = "";

      _this.$sportsList.closest('#menu-global, #menu-fixed-opeco').each(function(){
        sportsMenuParentId = $(this).attr('id');
      });

      $sportsAlphaListNav = '<div id="'+sportsMenuParentId+'-sports-nav" class="sports-menu-letters-navigation"><ul>';
    
      /*creates the navLIst */
      for (var i = 0; i < _this.groupedArrayofSports.length; i++) {

        enabledDisabled = _this.groupedArrayofSports[i].scrollYPos === null ? 'disabled' : '';
        itemYPos = _this.groupedArrayofSports[i].scrollYPos === null ? 0 : _this.groupedArrayofSports[i].scrollYPos;
        itemLetter = _this.groupedArrayofSports[i].letter;
        $sportsAlphaListNav += '<li class="'+enabledDisabled+'" data-scroll-position="'+itemYPos+'" data-letter="'+itemLetter+'">' + itemLetter + '</li>';
      }

      $sportsAlphaListNav += '</ul></div>';
      _this.$sportsAlphaListNav = $($sportsAlphaListNav);

      _this.$sportsList.closest('#menu-global, #menu-fixed-opeco').each(function(){




        if($(this).attr('id') === 'menu-global'){
          $(this).before($sportsAlphaListNav);
        } else {
          _this.$sportsList.closest('.menu-submenu-content').append($sportsAlphaListNav);
        }

      });

      updateAlphaNavBarCss();

    };

    if($sportsAlphaListNav.length === 0){
      if(sportsGroupsArray.length > 0){
        injectTheAlphaNavBar(sportsGroupsArray);
      }

    } else {
        updateTheAlphaNavBar(sportsGroupsArray);
    }

    _this.$sportsList.on('scroll', function(){
      setActiveNav();
    });

    setActiveNav();

    var newScrollPosition = _this.$sportsList.scrollTop();

    $(document).on('mousedown mousemove touchstart touchmove', '.sports-menu-letters-navigation', function(e){

      var navTop = $(this)[0].getBoundingClientRect().top;
      var navBottom = $(this)[0].getBoundingClientRect().top + $(this).outerHeight();
      var navLeft = $(this)[0].getBoundingClientRect().left;
      var navRight = $(this)[0].getBoundingClientRect().left + $(this).outerWidth();

      var e0 = e.originalEvent;

      var cursorRelativeYPos;
      var navClientX;
      var navClientY;

      if(e0.which==1 || e0.buttons==1 || e0.type === 'touchstart' || e0.type === 'touchmove') {

        navClientX = e0.clientX || e0.touches[0].clientX;
        navClientY = e0.clientY || e0.touches[0].clientY;

        if(navClientX >= navLeft && navClientX <= navRight && navClientY <= navBottom ){

          $sportsAlphaListNavLis = $(this).find('li:not(.disabled)');

          cursorRelativeYPos = navClientY - navTop;

          $sportsAlphaListNavLis.each(function(){

            if(cursorRelativeYPos >= $(this).position().top && cursorRelativeYPos <= ($(this).position().top + $(this).height()) ){

              liScrollPosition = $(this).data('scroll-position');

              if(Math.abs(newScrollPosition - liScrollPosition) > 10){
                newScrollPosition = liScrollPosition;
                _this.$sportsList.stop().animate({scrollTop: newScrollPosition}, 700, 'swing');
              }
              
            }
          });
        }
      }
    });
  };

  prototypeMethods.sportsListScrollEnd = function(){
    var _this = this;
    return _this.$sportsList.scrollTop() + _this.$sportsList.outerHeight() >= _this.$sportsList.prop('scrollHeight') ? true : false;
  };

  prototypeMethods.init = function () {
    var _this = this;
    
    _this.$sportsList = _this.el.find('.sports-list-container-content');
    _this.$sportsListFilter = _this.el.find('.sports-menu-filter');
    

    _this.nothingFoundPhrase = _this.$sportsListFilter.data('nothing-found-text') || 'there is no result';

    _this.prepareSportsAndReorderThenOrNot();
    _this.createListOfSports();

    $.each([_this.$sportsList, _this.$filteredList], function(index, val) {
       $(this).on( 'mousewheel DOMMouseScroll', function (e) {
        if(decathlon.uxBreakpoints.is('large-screen')){
          var e0 = e.originalEvent,
          delta = e0.wheelDelta || -e0.detail;
          if ((this.scrollTop === 0 && delta > 0) || ((this.scrollTop + this.offsetHeight) >= this.scrollHeight && delta < 0)) {
              e.preventDefault();
          }
        }
      });
    });

    $(function(){
      _this.$sportsList.scrollTop(0);
      _this.attachSportsListFilterMethods();
      _this.initAlphabeticalScrollMethods();
    });

    _this.el.closest('#menu-global, #menu-fixed-opeco').on('ux.displaySportsMenu', function(){
      _this.$sportsList.scrollTop(0);
      _this.initAlphabeticalScrollMethods();
    });

    $(window).on('resize-width', _.debounce(function(){
      _this.initAlphabeticalScrollMethods();
    },100));


    // _this.$sportsList.on('scroll', function(){
    //   console.log("scroll");
    // });
  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'uxSporstMenuMethods',
    defaultOptions : {
      charCountEn: 3,
      charCountZh: 1
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));


$('[id^="submenu-sports-75"]').uxSporstMenuMethods();

decathlon.decathlonServices = {};

decathlon.decathlonServices.init = function() {

  $('.slick-services').slick({
    infinite: false,
    speed: 300,
    slidesToShow: 5,
    slidesToScroll: 5,
    useCSS:true,
    useTransform:true,
    responsive: [
      {
        breakpoint: 1024,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2
        }
      },
       {
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: {
          slidesToShow: 1,
          slidesToScroll: 1
        }
      }
    ]
  });

};

// GO !
if($('.slick-services').length > 0){
  $(function() {

    decathlon.decathlonServices.init();

  });
}
decathlon.mainFooter = {};

decathlon.mainFooter.init = function() {

  // ----------------------
  // --- LINKS (SLIDER) ---
  // ----------------------
  fadeInLinksSlider = function(){
    jQuery(".accordion .accordion-section-content .slick-list").animate({opacity: 1}, 300, function(){});
  };

  footerSlick = $('.slick-footer-links').slick({
    infinite: true,
    dots:true,
    arrows: false,
    speed: 300,
    slidesToShow: 4,
    slidesToScroll: 4,
    useCSS:true,
    useTransform:true,
    responsive: [

       {
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: {
          slidesToShow: 2,
          slidesToScroll: 2
        }
      },
      {
        breakpoint: decathlon.uxBreakpoints.xxsMin,
        settings: {
          slidesToShow: 1,
          slidesToScroll: 1
        }
      }

    ]
  });

  // -----------------
  // --- ACCORDION ---
  // -----------------
  jQuery('.accordion-section-title').click(function(e) {
    // Grab current anchor value
    $this = jQuery(this);

    // Close all accordions
    close_accordion_section($this);

    // Handle current accordion
    if($this.is('.active')){
      $this.removeClass('active');
      jQuery('.accordion ' + $this.attr('href')).slideUp(300).removeClass('open');
    }else{

      $this.addClass('active');
      jQuery('.accordion ' + $this.attr('href')).slideDown(300, function(){fadeInLinksSlider();}).addClass('open');

      // Refresh slider state to adapt right width
      // this line is now at the end, because on iPad, slick function doesn't reconize accordion's size if closed
      footerSlick.slick("slickSetOption","refresh", "refresh", true);
    }

    e.preventDefault();
  });


  close_accordion_section = function(current) {
      jQuery('.accordion .accordion-section-title').each(function(){
        if(jQuery(this).attr('href') != current.attr('href')){
          jQuery(this).removeClass('active');
        }
      });

      jQuery('.accordion .accordion-section-content').each(function(){
        if(jQuery(this).attr('id') != jQuery('.accordion ' + current.attr('href')).attr('id') ){
          jQuery(this).slideUp(300).removeClass('open');
        }
      });
  };


  // -----------------
  // --- COUNTRIES ---
  // -----------------
  $("#countries_arrow").on("click", function() {
    var listFlag = $("#countries li:not(.selected)");
    if (listFlag.is(":hidden")) {
      listFlag.slideDown();
    } else {
      listFlag.slideUp();
    }
  });

  $("#countries li").on("click", function() {
    var parent = $(this).parent();
    if (parent.find("li:not(.selected)").is(":visible")) {
      parent.find(".selected").removeClass("selected");
      $(this).addClass("selected");
      parent.find("li:not(.selected)").slideUp("slow", function() {
      });
    }
  });
    
  $('.container-footer-countries .drop-countries-list').on('click.bs.dropdown', function() { 
	  var link = jQuery(this).find('li.active a').attr('href'); 
	  window.open(link, '_blank'); });
  
};

if($('.block-footer').length > 0){
  $(function() {

    decathlon.mainFooter.init();

  });
}
decathlon.userReviewsFloor = {};

decathlon.userReviewsFloor.init = function() {

  /* user reviews collapsible user data*/
  $('.reviews-container .sidebar .bottom').collapse('hide');

  if(decathlon.uxBreakpoints.is('small-screen')){
    $('.reviews-container .sidebar .bottom').addClass('collapse');
  }

  $('.reviews-container .sidebar .bottom').on('hidden.bs.collapse', function () {
    $(this).closest('.sidebar').find('[data-toggle="review-user-data"]').attr('aria-expanded', 'false');
  });

  $('.reviews-container .sidebar .bottom').on('shown.bs.collapse', function () {
    $(this).closest('.sidebar').find('[data-toggle="review-user-data"]').attr('aria-expanded', 'true');
  });

  $('.reviews-container .sidebar').on('click', '[data-toggle="review-user-data"]', function(){
    if(decathlon.uxBreakpoints.is('small-screen')){
      $(this).closest('.sidebar').find('.bottom').collapse('toggle');
    }
  });

  $(window).on('enter-small-screen', function(){
    $('.reviews-container .sidebar .bottom').collapse('hide');
  });

  $(window).on('enter-large-screen', function(){
    $('.reviews-container .sidebar .bottom').collapse('show');
  });

  $('a[href="#container-floor-review"]').on('click', function() {
    setTimeout(function() { $('[id="USER REVIEWS_Tab"]').trigger('click'); }, 100);
  });
};


if($('body').hasClass('product-page') || $('body').hasClass('reviews-page')){
  $(function() {
    decathlon.userReviewsFloor.init();
  });
}
$.fn.extend({

  stickyHeaderMethods : function(){

    var $this = $(this);

    if ($this.length > 0 && $this.jquery) {


        $this.stickUnstickOnScroll = function(){

            if(decathlon.uxBreakpoints.is('large-screen')) {

                $this.windowScrollTop = $(window).scrollTop();
                $this.removeClass('mobile-sticky').removeClass('off-fast').removeClass('off').removeClass('on');

                if($this.scrollToStick === 0){
                    
                    $this.addClass('sticky');

                } else {

                    if($this.animatedSticky === true){

                        if($this.windowScrollTop > $this.Top + $this.Height) {

                            $this.addClass('sticky');

                            if($this.windowScrollTop > ($this.scrollToStick + $this.Top + $this.Height)) {
                                TweenMax.to($this, 0.7, {top:0, ease:Power4.easeInOut});
                            } else {
                                var animationSpeed = $this.lastScrollTop > $this.windowScrollTop ? 0.7 : 0;
                                TweenMax.to($this, animationSpeed, {top: ($this.Height * -1) , ease:Power4.easeInOut});
                            }

                        } else {

                            $this.removeClass('sticky');

                            TweenMax.set($this, {top: 0});
                        }

                    } else if($this.animatedSticky === false){
                        
                        TweenMax.set($this, {top: 0});

                        if($this.windowScrollTop > $this.Top) {
                            $this.addClass('sticky');
                        } else {
                            $this.removeClass('sticky');
                        }
                    }

                }

                $this.lastScrollTop = $this.windowScrollTop;
     
            } else {

                    TweenMax.set($this, {top: 0});
                    $this.removeClass('sticky');

                    if($this.windowScrollTop > ($this.Top + $this.Height)) {
                        $this.addClass('mobile-sticky');

                        if(uxGAP.windowScrollSpeed < -18) {

                            $this.addClass('on').removeClass('off').removeClass('off-fast');

                        } else if (uxGAP.windowScrollSpeed >= 0 && uxGAP.windowScrollDirection === 'down') {


                            if($this.hasClass('on')){
                                $this.addClass('off').removeClass('off-fast');
                            } else {
                                $this.addClass('off-fast').removeClass('off');
                            }

                            $this.removeClass('on');

                        }

                    } else if($this.windowScrollTop <= $this.Top){

                        $this.removeClass('mobile-sticky').removeClass('on').removeClass('off').removeClass('off-fast');

                    }
                    
                

                // TweenMax.to($this, 1, {top:0, ease:Power4.easeInOut});
            }
        };


        $this.init = function(){
            var $this = this;
            $this.windowScrollTop = $(window).scrollTop();
            $this.Top = $this.offset().top;
            $this.Height = $this.outerHeight();
            $this.lastScrollTop = 0;

            $this.scrollToStick = 0;

            $this.animatedSticky = false;

            if ($('#top-message-bar').length > 0) {
                $this.animatedSticky = false;
                $this.scrollToStick = $('#top-message-bar').height();
            }

            if ($("#container-opeco").length > 0) {
                $this.animatedSticky = true;
                $this.scrollToStick = $("#container-opeco").outerHeight() - $('nav.services').height();
            }


            // Bind sticky except for black list pages
            if ($("body.product-page, body.account").length === 0) {
                $this.stickUnstickOnScroll();

                $(document).on('scroll', function(e) {

                    $this.windowScrollTop = $(window).scrollTop();

                    if(!$('html').hasClass('noscroll')){
                        $this.stickUnstickOnScroll();
                    }
                });

                $(window).on('resize', function() {
                    $this.stickUnstickOnScroll();
                });
            }
        };
          
        $this.init();

    } /* END OF IF */

  } /* END OF stickyHeaderMethods() */
});

$("#header").stickyHeaderMethods();
decathlon.home = decathlon.home || {};

decathlon.home.init = function() {

  var containerOpeco = $('#container-opeco');

  if(containerOpeco.length > 0 ){
    
    var containerOpecoHeight = containerOpeco.outerHeight();
    
    // Create the loadTime variable with the time of domContentLoadedEvent (End and Final)
    var loadTime = window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart;
    // Create the loadCurrentTime variable to store the current time of domContentLoadedEvent (End and Final)
    var loadCurrentTime;
    // Each 0.5 second (500) the loadVariable will check if loadTime is different of 
    // domContentLoadedEvent (End and Final) which means that the page is still loading
    // when domContentLoadedEvent (End and Final) is the same of the last value of loadTime 
    // means that the page is loaded and the interval will stop and the slick will be triggered
    var loadVariable = setInterval(function(){
    	loadCurrentTime = window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart;
    	if(loadTime != loadCurrentTime){
			loadTime = loadCurrentTime;
		}else{
			clearInterval(loadVariable);
			containerOpeco.find('.opeco-carousel').slick({
			  dots: true,
			  infinite: true,
			  speed: 500,
			  fade: true,
			  autoplay: true,
			  arrows: false,
			  useCSS:true,
			  useTransform:true
		    });	
		}
		 
	}, 
	500); 

    var servicesSlick = containerOpeco.find('.services-mask>div');


    if(servicesSlick.length > 0){

      if(servicesSlick.find('.column').length > 1 && $.fn.slick) {

      var servicesSlickActivate = function(){

          servicesSlick.slick({
            dots: false,
            infinite: false,
            speed: 500,
            slidesToShow: 5,
            slidesToScroll: 1,
            variableWidth:false,
            edgeFriction:0,
            useCSS:true,
            useTransform:true,
            focusOnSelect:false,
            responsive: [
              {
                breakpoint: decathlon.uxBreakpoints.smMin,
                settings: {
                  slidesToShow: 2,
                  slidesToScroll: 1
                }
              },
              {
                breakpoint: decathlon.uxBreakpoints.xsMin,
                settings: {
                  slidesToShow: 1,
                  slidesToScroll: 1
                }
              }
            ]
          });
        };

        var servicesSlickDesactivate = function(){
          if(servicesSlick.hasClass('slick-initialized')){
            servicesSlick.slick('unslick'); //.unslick(); this is not working =S
          }
        };

        servicesSlickActivate();

    } /* ! IF */

    }
    
  }
    $('.slick-brands').slick({
    dots: true,
    infinite: false,
    speed: 300,
    rows:3,
    slidesPerRow: 5,
    slidesToScroll: 1,
    useCSS:true,
    useTransform:true,
    variableWidth:false,
    responsive: [
      {
        breakpoint: decathlon.uxBreakpoints.lgMin,
        settings: {
          slidesPerRow: 4
        }
      },
      {
        breakpoint: 961,
        settings: {
          slidesPerRow: 3
        }
      },
      {
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: {
          arrows: false,
          slidesPerRow: 2
        }
      },
      {
        breakpoint: decathlon.uxBreakpoints.xsMin,
        settings: {
          arrows: false,
          slidesPerRow: 1
        }
      }
    ]
  });

  // $('.slick-sports').slick({
  //   dots: true,
  //   infinite: false,
  //   speed: 300,
  //   rows:3,
  //   slidesPerRow: 5,
  //   slidesToScroll: 1,
  //   useCSS:true,
  //   useTransform:true,
  //   variableWidth:false,
  //   responsive: [
  //     {
  //       breakpoint: 980,
  //       settings: {
  //         slidesPerRow: 4
  //       }
  //     }
  //   ]
  // });


  var resizeProductBlocks = function($slickElement){

    if($slickElement.closest('.list-products').length > 0){

      var thisHeight = 0;
      var maxTitleHeight = 0;
      var maxProductHeight = 0;

      var titleWrappersArray = $slickElement.find('.title-reviews-wrapper .title');

      if(titleWrappersArray.length > 1){

        titleWrappersArray.each(function(){
          
          $(this).attr('style','');

          thisHeight = $(this).height();
          
          if(thisHeight > maxTitleHeight){
            maxTitleHeight = thisHeight;
          }

        });

        titleWrappersArray.each(function(){
          $(this).height(maxTitleHeight);
        });

      }


      
      var productsAndContentArray = $slickElement.find('.inner-product, .inner-content');
      

      if(productsAndContentArray.length > 1){
        
        productsAndContentArray.each(function(){
          
          $(this).attr('style','');

          thisHeight = $(this).height();
          
          if(thisHeight > maxProductHeight){
            maxProductHeight = thisHeight;
          }

        });

        productsAndContentArray.each(function(){

          if($(this).hasClass('inner-content')){
            $(this).height(maxProductHeight + 2);
          } else {
            $(this).height(maxProductHeight);
          }

        });

      }
    }
  };


  

  $('.slick-push').on('init reInit', function(event, slick){

    var sameHeight = function(){
      $('.slick-push').each(function(){
          resizeProductBlocks($(this));
        });
    };

    sameHeight();

    $(function(){
      sameHeight();
    });

    $(window).on('resize-width.slickPush', _.debounce(function() {
      sameHeight();
    },300));

  });

  //SLIDER PUSH
  $('.slick-push').slick({
    dots: true,
    infinite: false,
    speed: 300,
    rows:2,
    slidesPerRow: 3,
    useCSS:true,
    useTransform:true,
    slidesToScroll: 1,
    responsive: [
        {
          breakpoint: decathlon.uxBreakpoints.lgMin,
          settings: {
            arrows: false,
            activateRows:true,
            rows:2,
            slidesPerRow: 2,
            slidesToScroll: 1
          }
        },
        {
          breakpoint: 920,
          settings: {
            arrows: false,
            activateRows:true,
            rows:1,
            slidesPerRow: 3,
            slidesToScroll: 1
          }
        },
        {
          breakpoint: decathlon.uxBreakpoints.xsMin,
          settings: {
            arrows: false,
            activateRows:true,
            rows:1,
            slidesPerRow: 2,
            slidesToScroll: 1
          }
        }
    ]
  });


  

  $('.slick-informations').slick({
    dots: false,
    infinite: false,
    speed: 300,
    slidesToShow: 1,
    useCSS:true,
    useTransform:true,
    slidesToScroll: 1,
    responsive: [
      {
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: {
          arrows: false,
          dots: true,
          slidesToShow: 1,
          slidesToScroll: 1
        }
      }
    ]
  });

}; /* END OF INIT */

(function(window, $){

  if($('body').hasClass('homepage')){

    decathlon.home.init();

    $(function() {

      // Call cookies banner
      $('#cookies-banner').UX_Cookies();

      // call instance for dynamic navigation
      var dynamicHomeNav = new DynamicNavigation({
          navObject: $('#block_vertical-nav'),
          navListParentObject:'ul',
          anchorWrapper:'li',
          limitSticky: 300,
          stickyClass: 'show-nav',
          offsetTop: $('#header').height(),
          thumbs: true
      });

      // close menu if opened on click on dynamiv nav
      $('#block_vertical-nav').on('click', 'a', function(){
        if($('html').hasClass('noscroll')) {
          $('#header .menu-toggler.close').click();
        }
        
      });
    });
  }

})(window, jQuery);
// INIT OBJECT PRODUCT PAGE
/*

  product
    |
    +-- SLIDER VISUAL PRODUCT
    |
    +-- NAV SLIDER VISUAL PRODUCT
    |
    +-- MODAL PRODUCT HANDLER
    |
    +-- MODAL DELIVERY PRODUCT
    |
    +-- PRODUCTS BENEFITS
    |
    +-- SLICK VIDEO
    |
    +-- SCROLLMAGIC
    |
    +-- ION.RANGESLIDER

*/

decathlon.product = {};
decathlon.product.init = function() {
  var mobile = false,
      mainSliderWrapper = $('.slick-pp-product-visual'),
      mainSlickNavWrapper = $('.slider-nav-product-visual'),
      modalProductLayout = $('#modal-product-layout'),
      modalXpressPaymentLayout = $('#modal-express-payment-layout');

  if ($('body').hasClass('mobile')) {
    mobile = true;
  }

  /* Main slider settings */
  var mainSlickSettings = function (){
    return {
      slidesToShow: 1,
      slidesToScroll: 1,
      useCSS:true,
      useTransform:true,
      infinite: false,
      arrows: false,
      fade: true,
      asNavFor: mainSlickNavWrapper
    };
  };

  /* Main slider navigation settings */
  var mainSlickNavSettings = function (){
    return {
      slidesToShow: 3,
      infinite: false,
      slidesToScroll: 1,
      asNavFor: mainSliderWrapper,
      focusOnSelect: true,
      responsive: [
        {
          breakpoint: decathlon.uxBreakpoints.smMin,
          settings: {
            arrows: true,
            infinite: false,
            variableWidth: true,
            speed: 200,
            slidesToShow: 6,
            slidesToScroll: 2,
            swipe: true,
            draggable: false,
            swipeToSlide: true
          }
        }
      ]
    };
  };

  $('#sticker-display-div').children().addClass('product-details');

  var headerMenuToggler = $('#header a.menu-toggler'),
      tooltipWrapper = $('#product-container .right-wrapper .tooltip-wrapper'),
      makeYourChoiceBtn = $('#modal-product-cta');
      productHeader = $('#header-pp .product-head');
      theDesktopProductHeaderIsSticky = false;

  $('.slick-pp-product-visual').slick(mainSlickSettings());
  mainSlickNavWrapper.slick(mainSlickNavSettings());
  var indexOfSelectedColor = mainSliderWrapper.slick('slickCurrentSlide');
  
  mainSliderWrapper.on({
    beforeChange: function (event, slick, current_slide_index, next_slide_index) {
      $('.right-wrapper .thumbs-product-list .slick-slide').removeClass('slick-current');
      $('.right-wrapper .thumbs-product-list .slick-slide[data-slick-index=' + next_slide_index + ']').addClass('slick-current');
    }
  }).slick('slickGoTo', indexOfSelectedColor, true);

  /* HEADER ON SCROLL */
  if (productHeader.length > 0) {

    $(window).on('scroll', function() {

      var htmlTag = $('html'),
          scroll = $(window).scrollTop(),
          htmlStickyClass = 'product-head-sticky',
          hideProductHeaderClass = 'phs-off',
          showProductHeaderClass = 'phs-on';

      var addHTMLStickyClass = function(){
        if(!htmlTag.hasClass(htmlStickyClass)){
          htmlTag.addClass(htmlStickyClass);
        }
      };

      var removeHTMLStickyClass = function(){
        if(htmlTag.hasClass(htmlStickyClass)){
          htmlTag.removeClass(htmlStickyClass);
        }
      };

      var addHTMLStickyAnimationClass = function(){
        if(htmlTag.hasClass(hideProductHeaderClass) && !htmlTag.hasClass(showProductHeaderClass)){
          htmlTag.removeClass(hideProductHeaderClass).addClass(showProductHeaderClass);
        }
      };

      var removeHTMLStickyAnimationClass = function(){
        if(!htmlTag.hasClass(hideProductHeaderClass)){
          htmlTag.addClass(hideProductHeaderClass);
        }

        if(htmlTag.hasClass(showProductHeaderClass)){
          htmlTag.removeClass(showProductHeaderClass);
        }
      };

      var addMakeYourChoiceBtnSmallClass = function(){
        if(!makeYourChoiceBtn.hasClass('small')){
          makeYourChoiceBtn.addClass('small');
        }
      };

      var removeMakeYourChoiceBtnSmallClass = function(){
        if(makeYourChoiceBtn.hasClass('small')){
          makeYourChoiceBtn.removeClass('small');
        }
      };

      if(decathlon.uxBreakpoints.is('large-screen')){
        if (scroll < 750){

          if(theDesktopProductHeaderIsSticky === true){

            removeHTMLStickyAnimationClass();

            setTimeout(function(){
              removeHTMLStickyClass();
              removeMakeYourChoiceBtnSmallClass();
            },100);

            theDesktopProductHeaderIsSticky = false;

          }

        } else {

          if(theDesktopProductHeaderIsSticky === false){

            addHTMLStickyClass();
            addMakeYourChoiceBtnSmallClass();
            addHTMLStickyAnimationClass();

            theDesktopProductHeaderIsSticky = true;

          }
        }


      } else if(decathlon.uxBreakpoints.is('small-screen')){
        if (scroll < $('#main-container').offset().top){
          removeHTMLStickyClass();
        } else {
          addHTMLStickyClass();
        }
      }

    });

  }


  decathlon.tools.multipleDropdown();

  $('.modal-multibuy').detach().appendTo('body');

  /* MODAL DELIVERY PRODUCT */
  $('#modal-delivery, #modal-multibuy, #modal-stock').on('shown.bs.modal', function(e) {

    if($(e.relatedTarget).hasClass('see-more-stores')){
      $('#modal-delivery .see-delivery, #delivery').removeClass('active');
      $('#modal-delivery .see-pick-up, #pickup').addClass('active');
    }
    if($(e.relatedTarget).hasClass('change')){
      $('#modal-delivery .see-pick-up, #pickup').removeClass('active');
      $('#modal-delivery .see-delivery, #delivery').addClass('active');
    }

  });

/* THE PRODUCT AND AMBIANCE PICTURES CAROUSEL */
/*
*
* NOW USING SWIPER
*/

  $(function(){


    var imagesToScroll = function(pictureFloor){

      var $imagesArray = pictureFloor.find('.inner-wrapper');
      var numberOfImagesToScroll = 0;
      var totalImagesWidth = 0;

      $imagesArray.each(function(){
        if($(this)[0].getBoundingClientRect().right > 0 && totalImagesWidth < $(window).width() ){
          totalImagesWidth = $(this)[0].getBoundingClientRect().right;
          numberOfImagesToScroll ++;
        }
      });

      numberOfImagesToScroll = numberOfImagesToScroll - 2; // excluding the left and right images that are cut by the arrows
      numberOfImagesToScroll = numberOfImagesToScroll < 1 ? 1 : numberOfImagesToScroll;
      return numberOfImagesToScroll;

    };

    var reinitSwiper = function(pictureFloor, swiperObject){
      swiperParams.slidesPerGroup = imagesToScroll(pictureFloor);
      swiperObject.destroy();
      pictureFloor.find('.inner-wrapper').css('width', '');
      swiperObject = new Swiper(pictureFloor, swiperParams);
    };

    var $productPicturesFloor = $('#picturesFloor');
    var $ambiencePicturesFloor = $('#ambienceFloor');

    var swiperParams = {
      slidesPerView: 'auto',
      //slidesPerGroup: 4,
      //speed: 400,
      freeMode: true,
      //freeModeMomentumRatio: 1,
      //freeModeSticky: true,
      //freeModeMinimumVelocity: 0,
      //longSwipes: false,
      loop: true,
      //loopAdditionalSlides: 1,
      //loopedSlides: 0,
      //setWrapperSize: true,
      //touchMoveStopPropagation: true,
      nextButton: '.swiper-button-next',
      prevButton: '.swiper-button-prev',
      onInit:function(swiper){
        swiper.wrapper.parent().addClass('swiper-initialized');
      }
    };

    $(window).on('load', function(){
      var totalWidth = 0;
      $productPicturesFloor.find('.swiper-wrapper >a').each(function(){
        totalWidth += $(this).width();
      });
      if(totalWidth > $productPicturesFloor.width()){
        var productPicturesFloorSwiper = new Swiper($productPicturesFloor, swiperParams);
        //productPicturesFloorSwiper.update();
      }

      totalWidth = 0;
      $ambiencePicturesFloor.find('.swiper-wrapper >a').each(function(){
        totalWidth += $(this).width();
      });
      if(totalWidth > $ambiencePicturesFloor.width()){
        var ambiencePicturesFloorSwiper = new Swiper($ambiencePicturesFloor, swiperParams);
        //ambiencePicturesFloorSwiper.update();
      }
    });

    $(window).on('resize-width.swiper-product-images enter-small-screen enter-larger-screen', _.debounce(function(){
      if($productPicturesFloor.hasClass('.swiper-initialized')){
        reinitSwiper($productPicturesFloor, productPicturesFloorSwiper);
        productPicturesFloorSwiper.update();
      }

      if($ambiencePicturesFloor.hasClass('.swiper-initialized')){
        reinitSwiper($ambiencePicturesFloor, ambiencePicturesFloorSwiper);
        ambiencePicturesFloorSwiper.update();
      }
    },100));

  });


  var productBenefitsMethods = (function(window, $){

    return {

      disableCarousels : function(){

        var _this = this;

        _this.productBenefitsSlides.parent().find('.slick-initialized').each(function(){
          $(this).slick('unslick');
        });

      },

      activateSlickDesktop : function(){

        var _this = this;
        _this.disableCarousels();

        _this.productBenefitsSlider.slick({
          dots: true,
          arrows: false,
          infinite: false,
          speed: 500,
          useCSS:true,
          useTransform:true,
          variableWidth:true,
          rows: 3,
          slidesPerRow: 2
        });

      },

      activateSlickMobile : function(){

        var _this = this;
        _this.disableCarousels();

        _this.productBenefitsSlider.slick({
          dots: true,
          arrows: false,
          infinite: false,
          speed: 500,
          useCSS:true,
          useTransform:true,
          variableWidth:true,
          rows: 2,
          slidePerRow: 1
        });

      },

      setBenefitparagraphsHeights : function(){

        var _this = this;

        var productBenefitsMinHeight = 0,
        benefitparagraphsHeight = 0;

        _this.productBenefitsArrayOfPs.each(function(){
          benefitparagraphsHeight = $(this)[0].scrollHeight;
          if(benefitparagraphsHeight > productBenefitsMinHeight){
            productBenefitsMinHeight = benefitparagraphsHeight;
          }
        });

        uxDynamicStyles.removeCssStylesArrayFromHeader(_this.benefitsCssId);

        setTimeout(function(){
          uxDynamicStyles.appendCssStylesArrayToHeader({
            uniqueId : _this.benefitsCssId,
            selectors : [
            '.product-benefits .benefit p'
            ],
            properties : [
              'height: '+ (productBenefitsMinHeight) + 'px;'
            ]
          });
        },0);

      },

      init : function(){
        var _this = this;

        _this.productBenefitsSlides = $('#collapse-benefits');
        _this.productBenefitsSlider = _this.productBenefitsSlides.find('.benefits-slider');

        _this.productBenefitsArrayOfPs = _this.productBenefitsSlides.find('.benefit p');
        _this.benefitsCssId = 'setBenefitparagraphsHeights';

        $(window).on('resize-width.benefitsFloor', _.debounce(function(){
        if(decathlon.uxBreakpoints.is('large-screen')){
          _this.setBenefitparagraphsHeights();
          }
        },100));

        if(decathlon.uxBreakpoints.is('large-screen')){
          _this.setBenefitparagraphsHeights();
          _this.activateSlickDesktop();
        } else {
          _this.activateSlickMobile();
        }

        $(window).on('enter-small-screen',function(){
          uxDynamicStyles.removeCssStylesArrayFromHeader(_this.benefitsCssId);
          _this.activateSlickMobile();
        });

        $(window).on('enter-large-screen',function(){
          _this.activateSlickDesktop();
        });
      }

    };
  })(window, jQuery);

  productBenefitsMethods.init();

  var containerFloorProductPictures = $('#container-floor-product-pictures .slick-pp-pictures-img');

  containerFloorProductPictures.on('init reInit', function(){
    setTimeout(function(){
      picturefill();
      containerFloorProductPictures.slick('setPosition');
    },500);
  });

  containerFloorProductPictures.slick({
      centerMode: true,
      useCSS:true,
      useTransform:true,
      variableWidth: true,
      responsive: [{
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: {
          slidesToShow: 1,
          slidesToScroll: 1
        }
      }]
    });



  var containerFloorProductVideos = $('#container-floor-video div.slick-pp-video');

  if(containerFloorProductVideos.length > 0){
    setTimeout(function(){
      if($.fn.slick && containerFloorProductVideos.find('.video').length > 0){
        containerFloorProductVideos.slick({
          dots: true,
          centerMode: false,
          slidesToShow: 1,
          slidesToScroll: 1,
          useCSS:true,
          useTransform:true,
          variableWidth: true,
          appendArrows: '#video_container .slick-list'
        });
      }
    },0);
  }



  var delay = ( function(){
    var timer = 0;
    return function(callback,ms){
      clearTimeout(timer);
      timer = setTimeout(callback,ms);
    };
  })();


  /*
  Display Product reviews
   */
  $('.notation-stars')
    .on('mouseenter mouseover', function() {
      if ($(window).width() >= decathlon.uxBreakpoints.smMin) {
        $('#details-review-content').fadeIn(200);
      }
    })
    .on('mouseleave', function() {
      setTimeout(function() {
        var $detailsReviewContent = $('#details-review-content');
        if (!$detailsReviewContent.hasClass('active')) {
          $detailsReviewContent.fadeOut(200);
        }
      }, 200);
    });

  $('#details-review-content')
    .on('mouseenter mouseover', function() {
      if (!$(this).hasClass('active')) {
        $(this).addClass('active');
      }
    })
    .on('mouseleave', function() {
      var that = this;
      setTimeout(function() {
        $(that).fadeOut(200, function() {
          $(that).removeClass('active');
        });
      }, 200);
    });

  /*****************************************************************************************************
    PRODUCT LAYER SETTINGS
   *****************************************************************************************************/
   decathlon.tools.selectQuantity($('select.management-amount'));

  /*
   * Settings for Slick layer
   */
  var productLayerSlickSettings = function (){
    return {
      slidesToShow: 1,
      slidesToScroll: 1,
      infinite: false,
      arrows: false,
      asNavFor: '#modal-product-layout .slider-nav-product-visual'
    };
  };

  /*
   * Settings for navigation Slick layer
   */
  var productLayerSlickNavSettings = function (){
    return {
      slidesToShow: 6,
      slidesToScroll: 1,
      asNavFor: '.slick-pp-product-visual',
      useCSS:true,
      useTransform:true,
      infinite: false,
      swipe: true,
      focusOnSelect: true,
      swipeToSlide: true,
      responsive: [{
          breakpoint: decathlon.uxBreakpoints.xsMin,
          settings: {
            arrows: false,
            infinite: true
          }
        }]
    };
  };


  /**
   * Return position relative to the viewport
   * @param  {DOM object} el
   */
  var getOffset = function (el) {
    el = el.getBoundingClientRect();
    return {
      left: el.left + window.scrollX,
      top: el.top + window.scrollY
    };
  };

  /**
   * Width adaptation for product layout, left of layer === right position of call to action button
   * Height of layout
   */
  var checkDeltaOfWidth = function(){

    var deltaOfWidth = $(window).width() - getOffset(document.getElementById('modal-product-cta')).left,
        newHeight = $(window).height() - getOffset(document.getElementById('shipping-wrapper')).top - $('#shipping-wrapper').height() -30,
        newWidth = deltaOfWidth+12;

    if(deltaOfWidth > modalProductLayout.width()){
      $('#modal-product-layout').width(newWidth);
    }

    $('#modal-express-payment-layout').css({
      right: -$(window).width()-12
    });

    $('#modal-express-payment-layout .steps-showcase').width($('#modal-product-layout').width()*2);
    $('#modal-express-payment-layout').width($('#modal-product-layout').width());

    /*
    $('#shipping-wrapper').css({
      paddingBottom: newHeight
    });
    */

    // $('#shipping-wrapper').height($(window).height()-$('.shipping-wrapper').position().top);

    /*
    if($(document).scrollTop() < 66) {
      $('.common-layout').height($(window).height()-($('#top-message-bar').height()+$('#container-header').height()));
    }
     */

  };

  /**
   * Desactivate Old Slick & activate new slick target
   * @param  {string}   navToUnslick      Old navigation to unslick
   * @param  {string}   slider            New slider to slick
   * @param  {string}   navSlider         New navigation to slick
   * @param  {function} sliderSettings    Settings of slider
   * @param  {function} sliderNavSettings Settings of navigation slider
   */
  var slickActivator = function(navToUnslick, slider, navSlider, sliderSettings, sliderNavSettings) {
    $(navToUnslick).slick('unslick');
    $(slider).slick('unslick').slick(sliderSettings);
    $(navSlider).slick(sliderNavSettings);
  };

  /**
   * Animation on checkout layout for steps
   * @param  {string}   parentElt        Parent of target
   * @param  {string}   elt              Target to click
   * @param  {function} callbackFunction Optionnal - Called when animation is over
   */
  var stepAnimation = function(parentElt, elt, callbackFunction){
    $(parentElt).on('click', elt, function(e){
      $(this).parents('.step-content:first').animate({
        right: -document.getElementById('modal-product-layout').offsetWidth-12
      }, 200, function(){
        if(callbackFunction && typeof callbackFunction === "function"){
          return callbackFunction();
        }
      });
    });
  };

  /**
   * Close the product modal layout
   * @param  {String} elt Target of click
   */

  // Blocks the click on a next product for 500ms (the transition time) to prevent for exemple : yellow is select in thumbs but red is displayed on the main visual
  $('.thumbs-product-list').on('click','.model-selection',function(){
    $(this).closest('.slick-list').addClass('model-selection-disabled');
    setTimeout(function(){
      $('.thumbs-product-list').find('.slick-list').removeClass('model-selection-disabled');
    }, 500);
  });

  var closeModalProductLayout = function(elt) {
   $(elt).on('click', function(e){
    e.preventDefault();
    if($('body').hasClass('checkout-layer')){

      $('body').css('position', '');

      var indexOfSelectedColor = mainSliderWrapper.slick('slickCurrentSlide');

       $('#modal-express-payment-layout').removeClass('open');
       $('#modal-express-payment-layout').animate({
         right: -document.getElementById('modal-product-layout').offsetWidth-12
       }, 200);

       $('#modal-product-layout').animate({
         right: -document.getElementById('modal-product-layout').offsetWidth-12
       }, 200, function(){
    	 slickActivator('#modal-product-layout .slider-nav-product-visual', '.slick-pp-product-visual', mainSlickNavWrapper, mainSlickSettings(), mainSlickNavSettings());
    	 mainSliderWrapper.on({
   	      beforeChange: function (e, slick, current_slide_index, next_slide_index) {
   	    	$('.right-wrapper .slider-nav-product-visual .model-selection.slick-slide.slick-active').removeClass('slick-current');
  	        $('.right-wrapper .slider-nav-product-visual .model-selection.slick-slide.slick-active[data-slick-index=' + next_slide_index + ']').addClass('slick-current');
  	      }
  	     }).slick('slickGoTo', indexOfSelectedColor, true);
        $('#modal-product-layout, #modal-express-payment-layout').removeAttr('style');
       });

       $('.fullscreen-layer').hide();
       $('body').removeClass('checkout-layer');
       if($('html').attr('data-is-express-checkout') === 'true') {
          $.fn.XpressCartPlugin('cancelExpressCheckout');
        }
       $('html').attr('data-is-express-checkout', 'false');
       $.fn.QrCodePaymentPlugin('clearCheckStatusTimer');
     }
   });
  };

  $(window).on('resize', function() {
      checkDeltaOfWidth();
  });

  /*****************************************************************************************************
    OPEN CHECKOUT LAYOUTS - Checkout layout & One click layout
  *****************************************************************************************************/
  $('#modal-product-cta, #express-payment-cta').on('click', function(e){
    e.preventDefault();
    // This removes the sticky class on html on mobile when we open the Add product layer (resolves mobile AND desktop bug) :
    if(decathlon.uxBreakpoints.is('small-screen')){
      if($('html').hasClass('product-head-sticky')){
        $('html').removeClass('product-head-sticky');
      }
    }
    if(!$(this).hasClass('disabled')) {
      var layoutToAnimate,
        topOfModalLayout,
        heightOfHeader = $('#header').height();

      $('body').addClass('checkout-layer');
      if($('body').hasClass('mobile')){
        $('body').css('position', 'absolute');
      }

      if($(this).attr('id') === 'modal-product-cta') {
        layoutToAnimate = $('#modal-product-layout');
        var indexOfSelectedColor = mainSliderWrapper.slick('slickCurrentSlide');

        slickActivator(mainSlickNavWrapper, '.slick-pp-product-visual', '#modal-product-layout .slider-nav-product-visual', productLayerSlickSettings(), productLayerSlickNavSettings());
        mainSliderWrapper.on({
          beforeChange: function (event, slick, current_slide_index, next_slide_index) {
            $('#modal-product-layout .thumbs-product-list .slick-slide').removeClass('slick-current');
            $('#modal-product-layout .thumbs-product-list .slick-slide[data-slick-index=' + next_slide_index + ']').addClass('slick-current');
          }
        }).slick('slickGoTo', indexOfSelectedColor, true);
      } else{
        layoutToAnimate = $('#modal-express-payment-layout');
        $('html').attr('data-is-express-checkout', 'true');
      }

      // COMMON - CLOSE ALERT BEHAVIOR
      if($('#top-message-bar').length > 0 && $('#top-message-bar').is(':visible')){
        var heightOfFullHeader = $('#top-message-bar').height()+heightOfHeader;
        if($(document).scrollTop() > heightOfFullHeader) {
          topOfModalLayout = 0;
        } else{
          topOfModalLayout = heightOfFullHeader-$(document).scrollTop();
        }
      } else{
        if($(document).scrollTop() > heightOfHeader) {
          topOfModalLayout = 0;
        } else{
          topOfModalLayout = heightOfHeader-$(document).scrollTop();
        }
      }

      $('.fullscreen-layer').show();


      layoutToAnimate.css({
        top: topOfModalLayout
      }).animate({
        right: 0
      }, 260,
      function() {
    	  $(this).addClass('open');
      });


      checkDeltaOfWidth();
    }

  });

  /*****************************************************************************************************
    CLOSE LAYOUT
   *****************************************************************************************************/
  $('#modal-express-payment-layout').on('click', 'span.back', function(){
    if(!$(this).hasClass('back-step')){

      $('html').attr('data-is-express-checkout', 'false');
    	$.fn.QrCodePaymentPlugin('clearCheckStatusTimer');

    	$('#modal-express-payment-layout').removeClass('open');
      $('#modal-express-payment-layout').animate({
        right: -document.getElementById('modal-product-layout').offsetWidth-12
      }, 200, function(){
        $('#modal-express-payment-layout').removeAttr('style');
      });
	  $.fn.XpressCartPlugin('cancelExpressCheckout');
    }
  });

  /*****************************************************************************************************
    TABS ONE CLICK
   *****************************************************************************************************/
  $('#modal-express-payment-layout').on('change', 'div.method-option > .radio input', function(){
    if($(this).parents('.radio').siblings('.shipping-method-informations').length > 0) {
      $('div.shipping-method-informations:visible').stop().slideToggle(200);
      $(this).parents('.radio').siblings('.shipping-method-informations').stop().slideToggle(200);
    } else{
      $('#modal-express-payment-layout .shipping-method-informations:visible').stop().slideToggle(200);
    }
  });

  /*****************************************************************************************************
    CLOSE PRODUCT LAYER
   *****************************************************************************************************/
   closeModalProductLayout('#close-modal-product-layout');
   closeModalProductLayout('.fullscreen-layer');

   // This adds the sticky class on html when we close the Add product layer on mobile
    $('#close-modal-product-layout').on('click',function(){
      if(decathlon.uxBreakpoints.is('small-screen') && $(window).scrollTop() >= 750 && !$('html').hasClass('product-head-sticky')){
        $('html').addClass('product-head-sticky');
      }
    });

  /*****************************************************************************************************
    CLOSE TOP MESSAGE BAR WITH MODAL DISPLAYED
   *****************************************************************************************************/
  $('#top-message-bar').on('click', 'a.close', function(){
    if($('body').hasClass('checkout-layer')){
      $('#modal-product-layout').animate({
        top: $('#header').height()
      }, 700);
      $('#modal-express-payment-layout').animate({
        top: $('#header').height()
      }, 700);
    }
  });

  /*****************************************************************************************************
    CORE VERSION - QUANTITY SELECTOR - TODO : BLUR EVENT
   ****************************************************************************************************/
  if(parseInt($('.quantity-selector').find('input').val()) === 1){
    $('.quantity-selector').find('button.icon-minus').attr('disabled', 'disabled');
  }

  // VIEW VOLUME PRICING
  $('.view-volume-price, #saleByLot').on('click', function(){
    //if($(window).width() >= decathlon.uxBreakpoints.smMin){
		 var sku = $("a#saleByLot").data("sku");
		 var skuVolumePriceContent = $('.volume-price-content').filter("[data-sku='" + sku + "']");

		 if(! skuVolumePriceContent.hasClass('active')){
			 skuVolumePriceContent.show().animate({
		        opacity: 1
		      }, 200, function(){
		    	  $(this).addClass('active');
		      });
		 } else {
			 skuVolumePriceContent.stop().animate({
			        opacity: 0
			 }, 200, function(){
		        $(this).hide();
		        $(this).removeClass('active');
		      });
		 }
    //}
  }).on('mouseleave', function(e){
	  var sku = $("a#saleByLot").data("sku");
	  var skuVolumePriceContent = $('.volume-price-content').filter("[data-sku='" + sku + "']");

	    if(skuVolumePriceContent.hasClass('active')){
	    	skuVolumePriceContent.stop().animate({
	        opacity: 0
	      }, 200, function(){
	        $(this).hide();
	        $(this).removeClass('active');
	      });
	    }

  });

  /*****************************************************************************************************
    SIZE SELECTION
   *****************************************************************************************************/
  modalProductLayout.on('click', '.size-selection ul li:not(.choose-link) a', function(e){
    e.preventDefault();

    var _t = $(this);
    _t.parents('.size-selection').find('a.selected').removeClass('selected');
    _t.addClass('selected');

  });

  /*****************************************************************************************************
    TABS
   *****************************************************************************************************/
  $('#modal-product-layout .localized').on('click', '.tabs a', function(e){
    e.preventDefault();
    // go to this element.
    // include the lib
    $('#modal-product-layout').scrollTo('#shipping-wrapper', 500);


    if(!$(this).parent('h3').hasClass('disabled')) {
      var tabs = $('#modal-product-layout .localized > div');

      $('#modal-product-layout .localized').find('h3').removeClass('active');

      for(var i=0;i<tabs.length;i++){

        var _t = $(tabs[i]);

        _t.removeClass('active');
        if(_t.attr('id') === $(this).attr('href').split('#')[1]){
          _t.addClass('active');
          $(this).parent('h3').addClass('active');
        }
      }
    }

  });

  /*****************************************************************************************************
    TABS COLLAPSE EVENTS
   *****************************************************************************************************/
  $('#shipping-information').on('click', 'div.shipping-mode', function(){
    var _t = $(this),
        _tParent = _t.parent('.shipping-type');

    if(!_tParent.hasClass('selected') && _t.next('.shipping-stores-list').length !== 0){
      _tParent.addClass('selected');
    } else{
      _tParent.removeClass('selected');
    }
    _t.next('ul').stop().slideToggle(200);
  }).on('click', 'ul.shipping-stores-list > li strong, ul.shipping-stores-list > li .icon', function(){

    var _t = $(this),
    _tParent = _t.parent('li');

    if(!_tParent.hasClass('deployed')){
      $('#shipping-information .shipping-stores-list .deployed').find('div.shipping-store-details').stop().slideToggle(200);
      $('#shipping-information .shipping-stores-list .deployed').removeClass('deployed');
      _tParent.addClass('deployed');
    } else{
      _tParent.removeClass('deployed');
      $('#shipping-information .shipping-stores-list .deployed').find('div.shipping-store-details').stop().slideToggle(200);
      $('#shipping-information .shipping-stores-list .deployed').removeClass('deployed');
    }
    _t.siblings('div.shipping-store-details').stop().slideToggle(200);
  });




  $('#shipping-wrapper').on('click', '.stores-located > li > i, .stores-located > li > strong, .stores-located > li > span', function(e){

    var _t = $(this),
    _tParent = _t.parent('li');

    if(!_tParent.hasClass('deployed')){
      $('#stock-information .stores-located .deployed').find('div.shipping-store-details').stop().slideToggle(200);
      $('#stock-information .stores-located .deployed').removeClass('deployed');
      _tParent.addClass('deployed');
    } else{
      _tParent.removeClass('deployed');
      $('#stock-information .stores-located .deployed').find('div.shipping-store-details').stop().slideToggle(200);
      $('#stock-information .stores-located .deployed').removeClass('deployed');
    }

    _t.siblings('div.shipping-store-details').stop().slideToggle(200);

  });



};

// function specifics to mobile view
decathlon.product.mobileIn = function(){
  var cible = null;

  var $headerH1 = $('#header-pp').find('h1');

  var copyTheReviewsToTheTop = function(){
    if($headerH1.siblings('.link-review').length === 0) {
      $headerH1.after($('#product-container').find('.link-review').clone().addClass('visible-xs'));
    }
  };

  if($headerH1.length === 1){
    copyTheReviewsToTheTop();
  }

  // $('.product-page .container-floor .collapse').removeClass('in');

  // init button attr (aria)
  $('.btn-collapse').attr('aria-expanded', 'false');

  // ecnt listener for button collapse
  $('.btn-collapse').on('click.collapse-toggle', function(e){
    e.preventDefault();
    $(this).attr('aria-expanded', (($(this).attr('aria-expanded') == 'true') ? false : true));
    cible = $(this).parent().find('.collapse:first').collapse('toggle');
  });
};

// if we leave the mobile view
decathlon.product.mobileOut = function() {
  $('.product-page .container-floor .collapse').addClass('in');
  $('.btn-collapse').off('click.collapse-toggle');
  $('.floor-collapse .collapse').attr('aria-expanded', true).height('auto');
};

// GO !
if($('body').hasClass('product-page')){
  $(function() {

    decathlon.tools.init();
    decathlon.product.init();

    $('.fullscreen-layer').appendTo('body');

    if($('#myGallery').length > 0){
      $('body').append($('#myGallery'));
    }

    // detect mobile in order to activate / desactivate collapsed floor

    if( decathlon.uxBreakpoints.is('small-screen') ) {
      decathlon.product.mobileIn();
    } else {
      decathlon.product.mobileOut();
    }

    $(window).on('enter-small-screen', function(){
      decathlon.product.mobileIn();
    });

    $(window).on('exit-small-screen', function(){
      decathlon.product.mobileOut();
    });

    /* RESIZE FOR DISPLAY PRODUCT INFORMATIONS - FLUID & TABLET */
    $(window).on('resize-width', _.debounce(
      function() {
      if ($('#modal-product').is(':visible')) {
        if ($(window).width() > 960) {
          $('#product-container .product-informations').show();
        }
        if ($(window).width() < 960) {
          $('#product-container .product-informations').hide();
        }
      }

      },100));

    $('body').on('shown.bs.collapse', function (e) {
      decathlon.tools.refreshAllSlicksInTheContainer($(e.target));
    });

    var containerFloorAmbiencePictures = $('#container-floor-ambience div.slick-pp-pictures-img');

    containerFloorAmbiencePictures.on('init reInit', function(){
      setTimeout(function(){
        picturefill();
        containerFloorAmbiencePictures.slick('setPosition');
      },500);
    });

    containerFloorAmbiencePictures.slick({
      centerMode: true,
      useCSS:true,
      useTransform:true,
      variableWidth: true,
      responsive: [{
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: {
          slidesToShow: 1,
          slidesToScroll: 1
        }
      }]
    });

    function initPDPAdvicesSlider(){
      $('.PDPAdvices-slider').slick({
        dots: true,
        infinite: false,
        speed: 300,
        arrows: false,
        slidesToShow: 4,
        slidesToScroll: 4,
        responsive: [
          {
            breakpoint: 800,
            settings: "unslick"
          }
        ]
      });
    }
    $(window).on('resize',_.debounce(function(){
      if(!decathlon.uxBreakpoints.is('small-screen')){
        initPDPAdvicesSlider();
      }
    },300));
    if(!decathlon.uxBreakpoints.is('small-screen')){
      initPDPAdvicesSlider();
    }

    // call instance for dynamic navigation

    var StickyProductNav = $('#sticky-product-nav');

    setTimeout( function(){

      var dynamicProductNav = new DynamicNavigation({
        navObject: StickyProductNav,
        navListParentObject:'',
        limitSticky: $('.m-product-wrapper'),
        topSticky: true,
        stickyClass: 'sticky',
        offsetTop: $('#header').outerHeight(),
        thumbs: false
      });

    }, 0);

    $('.link-review.goTo').on('click', function(e) {
      e.preventDefault();
      e.stopPropagation();

      $('html, body').animate({
        scrollTop: $('#container-floor-review').offset().top - 106 // Header + nav menu heights
      }, 500);
    });

    // This condition is to hide the internal navigation picture option if the model has one image. It is put here because the code in the internal navigation needs to be rendered to be hidden
    if($("#container-floor-product-pictures").find("a[data-dynamic-nav*='floor_pictures']").data("imagesNumber") < 2){
      $("ul.container-floor").find("li a[href*='floor_pictures']").hide();
    }

    $('body').append($('#modal-product-layout'));
    $('body').append($('#modal-express-payment-layout'));
    $('body').append($('#location-modal'));

  });
}

// Init Bundles slider
/*var selectorBundleSlider = $('#modal-product-bundles');

if(selectorBundleSlider)
  var MyBundlesSidebar = new Cube.BundlesSidebar(selectorBundleSlider);*/


// Init Gallery
var myGallery = new Cube.Gallery.Gallery('#myGallery');
myGallery.setFolder('');

//TODO override myGallery with the link from JSON


// link review
$(document).on('click touchend', 'a[href^="#container-floor-review"]', function(){
  var the_id = $(this).attr("href");

  $('html, body').animate({
    scrollTop:$(the_id).offset().top - $('.product-head').outerHeight()
  }, 'slow');

  if(decathlon.uxBreakpoints.is('small-screen')){
    $(the_id).find('.collapse').first().collapse('show');
    $(the_id).find('.btn-collapse').attr('aria-expanded', 'true');
  }

  return false;

});


/**
 * Gift card balance page
 */
(function() {

  if ($('#giftcard-balance-container').length) {

    var GiftCardHistoric = function($container, data) {

      this.$container = $container;
      this.$table = this.$container.find('table');
      this.$giftCardNumber = this.$container.find('#giftcard-balance-giftcard-number');
      this.$balance = this.$container.find('#giftcard-balance-balance');
      this.$validityDate = this.$container.find('#giftcard-balance-validitydate');

      this.$tbody = $('<tbody></tbody>');
      this.$debitBadge = $('<span class="status-type blue">Debit</span>');
      this.$adjustementBadge = $('<span class="status-type orange">Adjustement</span>');
      this.$creditBadge = $('<span class="status-type green">Credit</span>');

      this.addRow = function(detailLine) {
        var $tdStore = $('<td class="store-name">' + detailLine.store + ' <span class="visible-xs">' + detailLine.transactionDate + '</span></td>');

        var $tdProcessing = $('<td></td>');
        if (detailLine.amount < 0) {
          $tdProcessing.append(this.$debitBadge.clone());
        }
        else if (detailLine.amount > 0) {
          $tdProcessing.append(this.$creditBadge.clone());
        }

        var $tdAmount = $('<td>' + detailLine.amount/100 + " " + detailLine.currencyDisplayCode + '</td>');
        var $tdDate = $('<td class="hidden-xs">' + detailLine.transactionDate + '</td>');
        var $tr = $('<tr></tr>').append($tdStore).append($tdProcessing).append($tdAmount).append($tdDate);
        this.$tbody.append($tr);
      };

      this.setOverallInfo = function(data) {
        this.$giftCardNumber.text(data.cardNumber);
        this.$balance.text(data.balance/100 + " " + data.currencyDisplayCode);
        this.$validityDate.text(data.expiryDate);
      };

      this.$table.append(this.$tbody);
    };
    GiftCardHistoric.prototype.initialize = function(data) {
      if (data.cardNumber) {
        this.setOverallInfo(data);
        for (var line in data.responseDetail) {
          this.addRow(data.responseDetail[line]);
        }
        this.$container.show();
        
        var positionToScroll = $('#giftcard-balance-container').offset().top - 70;
        $.scrollTo(positionToScroll, 500);
       
      }
    };
    GiftCardHistoric.prototype.clear = function(data) {
      this.$container.hide();
      this.$tbody.empty();
      this.$giftCardNumber.text("");
      this.$balance.text("");
      this.$validityDate.text("");
    };

    window.setCaptchaChecked = function() {
      decathlon.captcha.isCaptchaChecked = true;
    };

    window.setCaptchaUnchecked = function() {
      decathlon.captcha.isCaptchaChecked = false;
    };

    var giftCardBalanceSuccessCb = function($form, result) {
      giftCardHistoric.initialize(result.responseTO.data);
      if (decathlon.captcha.isCaptchaChecked) {
        decathlon.captcha.resetCaptcha();
      }
    };

    var giftCardBalanceErrorCb = function($form, result) {
      var error = result.responseTO.errors[0];
      if (error) {
        $('body').pushAlert({ type: "danger", text: error.message, icon: "bell" });
      }
      if (decathlon.captcha.isCaptchaChecked) {
        decathlon.captcha.resetCaptcha();
      }
    };

    $('#giftcard-history-form [type="submit"]').on('click', function() {
      giftCardHistoric.clear();
    });

    $('#giftcard-history-form').handleform('init', { successCb: giftCardBalanceSuccessCb, errorCb: giftCardBalanceErrorCb });
    $('#giftcard-history-form').validate($.extend(null, $.validator.cubeOptions));

    var giftCardHistoric = new GiftCardHistoric( $('#giftcard-balance-container') );

  }
})();

decathlon.basket = {};
decathlon.basket.tooltipPlacement = function(tooltip, trigger, alreadyClose){
    var the_timer;
    var windowWidth = $(window).width();

    $(window).on('resize.placeTooltip', function(){
      if($(window).width() != windowWidth) {
        $(tooltip).tooltip('show');
        windowWidth = $(window).width();
      }
      
      if(alreadyClose === true){
        $(window).off('resize.placeTooltip');
      }
    });
};

decathlon.checkout = {};
decathlon.checkout.init = function () {

	if($('#gifts .choose-discount button').length>0){
		$('#gifts .choose-discount button').attr('title', $('#gifts .choose-discount button').attr('title').replace(/\&amp;/g,'&'));
	}

	var callbackCompleteCountdown = function() {
		$('.modal').modal('hide');
		$('#modal-reused-expiration').modal('show');
	};
	
    if($('#countdown-qrcode').length === 1){
        decathlon.tools.countdown('#countdown-qrcode');
    }    

    /* COUNTDOWN */
    if($('.checkout-payment .countdown').length > 0){
    	
    	$('body').pushAlert({
		  show:'true',
		  delay: 86400000
		});

        if($('.checkout-payment .countdown').length === 1){
            decathlon.tools.countdown('.countdown', callbackCompleteCountdown);
        }
    }

    decathlon.tools.multipleDropdown();

	/*	COMMON
		- PANEL BORDER HANDLE
		- INFORMATIONS CHOICE HANDLE
	*/
	
	/****************************************************************************
																PAYMENT
	****************************************************************************/

	// GIFTS & VOUCHER - FIRST PANEL
//	$('#gifts .dropdown').on('click', 'a', function(){
//		$('#gifts .discount-infos').show().stop().animate({
//			opacity: 1,
//			marginTop: 16
//		}, 200);
//	});
	
    $('#choose-voucher').on('changed.bs.select', function(e) {
    	toggleCardForm();
     });
    
    $('.mobile #choose-voucher').change(function() {
    	toggleCardForm();
    });
    
    function toggleCardForm() {
    	
    	var selectedSecondaryPayment = $('#choose-voucher').selectpicker('val');
    	
        if(selectedSecondaryPayment != 10 && selectedSecondaryPayment != 11) {
            $('.discount-infos').slideUp();
        } else {
            $('.discount-infos').slideDown();
        }
    }
	   
	/*	FORM HANDLE
		- INFORMATIONS CHOICE HANDLE (2)
		- SUBMENU CARD BANK HANDLE
	*/
	$('#main-container form.panel-group').on('change','input[name=delivery-type], input[name=store-choice]', handleFormChange);
	$('#main-container div#payment-informations').on('change','input[name=paymentTypeId]', handleFormChange);
	
	function handleFormChange(){
		var _this = $(this),
		panelFirst = _this.parents('.panel:first'),
		leftToPay = panelFirst.siblings('.panel').find('#left-to-pay');

		$('#secondary-block .panel-group .collapse.in').collapse('hide');

		if($('#secondary-block .panel-group .panel-collapse.in').length > 0){
			$('#secondary-block .panel-group .panel-collapse.in').collapse('hide');
		}

		// DELIVERY
		if($(this).parents('#home-delivery-details').length > 0){
			$(this).parents('div.panel-heading').next('div.panel-collapse').find('div.panel-body').append($('.ua-content'));
		}

		// REPLACE BUBBLE INFO ON ELEMENT CHECKED
		if(leftToPay){
			panelFirst.find('.panel-heading label:first').append($('#left-to-pay'));
		}
	}

	// Clone value on input visible
	$('#pick-up-details').on('shown.bs.collapse', function(e) {
		
		var _inputs = $('#pick-up-details .friend-pick-up'),
		_this = $(e.target);

		for(var i = 0; i < _inputs.length; i++){
			if(_inputs[i].value !== ''){
				_this.find('.friend-pick-up').val($(_inputs[i]).val());
				$('#pick-up-details .panel-collapse').not(_this).find('.friend-pick-up').val('');
				return false;
			}
		}
	});

	$('#secondary-block').on('hide.bs.collapse', function(e) {

		if($(e.target).attr('id') === 'card-payment') {
			$('#secondary-block h2').append($('#left-to-pay'));
		}
		
	});

	$('#secondary-block').on('show.bs.collapse', function(e) {
		$('#secondary-block input:checked').parent('label').append($('#left-to-pay'));
	});
};

$(function(){
	if($('body').hasClass('checkout-login')){
		$('html').addClass('html_login-page');
	}

	if($('body').hasClass('login-page')){
		if($('.modal').length > 0){
			$('body').append($('.modal'));
		}
	}
});


if($('body').hasClass('checkout-cart') || $('.account-wrapper .product-return-container').length > 0){
  	$(function(){
    
	    decathlon.tools.init();
	    
	    var selector = $('select.management-amount');
	    for(var i=0,selectorLength=selector.length; i<selectorLength;i++){
	        decathlon.tools.selectQuantity($(selector[i]));
	    }

	});
}

if($('body').hasClass('checkout-delivery') || $('body').hasClass('checkout-payment')){
	$(function(){
		decathlon.tools.init();
		decathlon.checkout.init();
	});

	$(window).on('load', function(){
		
		if($('#modal-nodata.onload').length > 0){
			$('#modal-nodata.onload').modal('show');
		}

		if($('#modal-nodata.onload').length === 0){
			if($('#secondary-block').length === 1){
				
				if($('#amount-used').length === 1 && $('#amount-used #total-amount-used').text() > 0){
					$('#secondary-payment-block .panel-heading:first').click();
				}
			}
		}
	});
}


$('body #delivery-informations [type=radio]:checked, body #payment-informations [type=radio]:checked').parents('fieldset.panel').addClass('selected');

// Click on radio button
$('body').on('change', '#payment-informations [type=radio]', function() {
	if($(this).is(':checked')) {
		$(this).parents('fieldset.panel').addClass('selected');
	}
});

$('body').on('change', '#delivery-informations [type=radio]', function() {
	if($(this).is(':checked')) {
		$(this).parents('fieldset.panel').addClass('selected');
		$(this).parents('fieldset.panel').siblings().removeClass('selected');
	}
});
;(function (window, $, document, undefined) {

  var prototypeMethods = prototypeMethods || {};


  prototypeMethods.slickExtra = function(){

    var _this = this;
    var $currentCategory;
    var gotoNumberOnstart;

    var setNewArrowNextClickEvent = function(){

      $nextArrow = _this.$categoriesList.find('.slick-next');

      $nextArrow.on('click', function(e){
        e.preventDefault();
        e.stopPropagation();
        console.log("next");

      });

      // _this.$categoriesList.on('beforeChange', function(event, slick, currentSlide, nextSlide){

      //   if(currentSlide < nextSlide){

      //     _this.$categoriesList.slick('slickSetOption', 'slidesToScroll', slick.slideCount - nextSlide, false);
      //   }
        
      // });

    };

    var startOnTheSelectedCategory = function(){
      
      $currentCategory = _this.$categoriesList.find('.current');
      slickOptionSpeed = _this.$categoriesList.slick('slickGetOption', 'speed');

      if($currentCategory.length === 1){

        _this.$categoriesList.addClass('slick-has-current');

        gotoNumberOnstart = $currentCategory.data('slick-index');

        _this.$categoriesList.slick('slickSetOption', 'speed', 0, false);
        _this.$categoriesList.slick('slickGoTo', gotoNumberOnstart);
        _this.$categoriesList.slick('slickSetOption', 'speed', slickOptionSpeed, false);
      }

    };

    if(_this.$categoriesList[0].slick !== undefined){
      startOnTheSelectedCategory();
      setNewArrowNextClickEvent();
    }


  };

  prototypeMethods.setSlick = function(){

    var _this = this;

    _this.$categoriesList.slick({
      dots: false,
      infinite: false,
      speed: 500,
      slidesToScroll: 1,
      slidesToShow: 1,
      variableWidth: true,
      useCSS:true,
      useTransform:false,
      focusOnSelect: false,
      responsive: [
        {
          breakpoint: 1770,
          settings: {
            // variableWidth: false,
            slidesToShow: 4,
            slidesToScroll: 1,
            swipe:false
          }
        },
        {
          breakpoint: 1560,
          settings: {
            slidesToShow: 5,
            slidesToScroll: 1,
            swipe:false
          }
        },
        {
          breakpoint: 1310,
          settings: {
            slidesToShow: 4,
            slidesToScroll: 1,
            swipe:false
          }
        },
        {
          breakpoint: decathlon.uxBreakpoints.smMin,
          settings: {
            slidesToShow: 1,
            slidesToScroll: 1,
            swipe:false
          }
        },
        {
          breakpoint: decathlon.uxBreakpoints.xsMin,
          settings: {
            // variableWidth: false,
            slidesToShow: 1,
            slidesToScroll: 1,
            swipe:false
          }
        }
      ]
    });

    _this.slickExtra();

  };

  prototypeMethods.init = function () {
    
    var _this = this;

    _this.$categoriesList = _this.el.find('.product-categories-list');

    _this.setSlick();

  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'uxProductCategoriesFunctions',
    defaultOptions : {
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));


$('#product-list-categories').uxProductCategoriesFunctions();



(function(window, $) {
  $.fn.extend({

    uxProductModalCategoriesFunctions : function(){

      return this.each(function() {
        var $this = $(this);

        if ($this.length > 0 && $this.jquery) {

          $this.modalLinkClick = function(e, $clickedlink, itemIndex){

            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = false;

            $clickedlink.closest('.category').addClass('current');

            $this.uxProductCategories.slick('slickGoTo', itemIndex);

            $this.uxProductCategories.find('.slick-slide').removeClass('current');
            $this.uxProductCategories.find('.slick-slide').eq(itemIndex).addClass('current');

            setTimeout(function(){
              $this.modal('hide');
            },500);
          };

          $this.init = function(){

            $this.uxProductCategories = $('#product-list-categories .product-categories-list');

            /* FIXING THE BOOSTRAP MODAL BEHAVIOUR */
            /* SET THE MODAL BODY HEIGHT AND */
            /* BLOCK THE PAGE SCROLL */

            $this.on('shown.bs.modal', function () {

              $('html').addClass('noscroll');
              
              var categoriesScrollHeight = $this.find('.modal-dialog').height() - 110;
              var categoriesListHeight = $this.find('.product-categories-list').height();

              if (categoriesListHeight > categoriesScrollHeight) {
                $this.find('.modal-body').css({'height' : ($(window).height() - 85) + 'px', 'overflow-y' : 'scroll'});
              }

            });

            $this.on('hide.bs.modal', function () {
              $('html').removeClass('noscroll');
            });


            /* THE CLICK ON THE MOBILE CATEGORIES LIST */
            $this.on('click', 'a:not(.deselect)', function(e){
              $this.modalLinkClick(e, $(this), $(this).parent().index());
            });


            /* SHOWS/HIDES THE MODAL MENU BASED ON THE MEDIA WIDTH */
            /* NOT TESTING IF A CATEGORY IS ALREADY CHOOSEN */

            $(window).on('enter-small-screen', function(){
              if($this.length > 0){
                $this.modal('show');
              }
            });

            $(window).on('exit-small-screen', function(){
              if($this.length > 0){
                $this.modal('hide');
              }
            });

          }(); /* END OF INIT */

        } /* END OF IF */
        
      });

    } /* END OF uxProductModalCategoriesFunctions() */
  });
})(window, jQuery);

$('#onload-category-choose').uxProductModalCategoriesFunctions();




(function(window, $){


  wrapProductsInRows = function($plWrapper){
                    
      var $productRows = $plWrapper.find('.pl-row');
      var $productsArray;
      if(!decathlon.uxBreakpoints.is('small-screen')){
        $productsArray= $plWrapper.find('.pl-element');
      }else{
        $productsArray = $plWrapper.find('.pl-element').not('.PlSeoInsert');
      }

      var reWrapp = function(quantity){

        if($productsArray.length > 0 && quantity > 0){
        
            setTimeout(function(){
              
              $productRows.contents().unwrap();

              for (var i = 0; i < $productsArray.length; i+=quantity) {
                rowArray = $productsArray.slice(i, i+quantity);
                rowArray.wrapAll('<div class="pl-row columns-'+ rowArray.length +'"></div>');
              }

            }, 0);
          }
      };

      if(uxDynamicSizes.windowWidth >= decathlon.uxBreakpoints.mdMin){
          reWrapp(4);
      } else if(uxDynamicSizes.windowWidth >= decathlon.uxBreakpoints.smMin && uxDynamicSizes.windowWidth <= decathlon.uxBreakpoints.smMax){
          reWrapp(3);
      } else if(uxDynamicSizes.windowWidth <= decathlon.uxBreakpoints.xsMax){
          reWrapp(2);
      }
  };

  var wrappProducts = function(){
    $('#in-product-list').each(function(){
        //wrapProductsInRows($(this));
      });
  };

  $(window).on('loadingProducts resize-width.products-list-heights', function(e) {
    //wrappProducts();
  });

  wrappProducts();


  var productListSlickSettings = function (asNavForSettings){

    return {
      infinite: false,
      speed: 300,
      arrows: true,
      variableWidth: false,
      useCSS:true,
      useTransform:false,
      asNavFor: asNavForSettings,
      slidesToShow: 1,
      slidesToScroll: 1
    };

  };

  window.productListSlickSettings = productListSlickSettings;

  var productListSlickThumbsSettings = function (asNavForSettings){

    return {
      infinite: false,
      speed: 300,
      slidesToShow: 3,
      variableWidth: false,
      slidesToScroll: 1,
      useCSS:true,
      useTransform:false,
      asNavFor: asNavForSettings,
      focusOnSelect: true,
      responsive: [
        {
          breakpoint: decathlon.uxBreakpoints.smMin,
          settings: {
            slidesToShow: 1,
            slidesToScroll: 1,
            variableWidth: true
          }
        }
      ]
    };

  };

  window.productListSlickThumbsSettings = productListSlickThumbsSettings;
  decathlon.tools.slickReinitSlider('.pl-element', '.slick-product', '.slick-thumbs', productListSlickSettings, productListSlickThumbsSettings);

  /* REFRESH THE SLICK SLIDERS POSITIONS ON DEVICE ORIENTATION CHANGES */
  $(window).on('orientationchange',function(){
    setTimeout(function(){
      $('#product-list').find('.slick-initialized').each(function(){
        $(this).slick('setPosition');
      });
    },1000);
  });



  var topTgPproductsWrapper  = $('#lpt-tg .pl-wrapper');
  var topTgPproductstags  = $('#lpt-tg .pl-tags');

  if(topTgPproductsWrapper.length > 0 && topTgPproductstags.length > 0) {

      topTgPproductsWrapper.slick({
        dots: false,
        arrows:true,
        infinite: true,
        speed: 500,
        fade:false,
        draggable: false,
        useCSS:true,
        useTransform:false,
        swipe: false,
        asNavFor: topTgPproductstags
      });

      topTgPproductstags.slick({
        dots: false,
        arrows:false,
        infinite: true,
        speed: 500,
        fade:true,
        draggable: false,
        asNavFor: topTgPproductsWrapper
      });

      setTimeout(function(){
        decathlon.tools.refreshAllSlicksInTheContainer(topTgPproductsWrapper);
      },0);

      topTgPproductsWrapper.on('afterChange', function(event, slick, currentSlide){
        decathlon.tools.refreshAllSlicksInTheContainer($(slick.$slides[currentSlide]));
      });

  } /* end of wrapper*/


  

  var $productsHighlightedWrapper  = $('#spotlightFloor .pl-row');

  if($productsHighlightedWrapper.length > 0 && $.fn.slick) {


    var productsHighlightedWrapperSlickActivate = function(){
      
      $productsHighlightedWrapper.slick({
        dots: true,
        arrows: false,
        slidesToShow: 1,
        slidesToScroll: 1,
        variableWidth: false,
        autoplay: true,
        autoplaySpeed: 4000,
        infinite: true,
        useCSS:true,
        useTransform:false,
        draggable: false,
        swipe: false,
        speed : 1000
      });


    };


    $(window).on('enter-small-screen', function(){
      if($productsHighlightedWrapper.length > 0 && $.fn.slick) {
        productsHighlightedWrapperSlickActivate();
      }
    });

    $(window).on('enter-large-screen', function(){
      if($.fn.slick && $productsHighlightedWrapper.hasClass('slick-initialized')){
        $productsHighlightedWrapper.slick('unslick');
      }
    });

    $productsHighlightedWrapper.on('beforeChange', '.slick-product', function(event, slick, currentSlide, nextSlide){
      if($.fn.slick && $productsHighlightedWrapper.hasClass('slick-initialized')){
        $productsHighlightedWrapper.slick('slickPause');
        setTimeout(function(){
          $productsHighlightedWrapper.slick('slickPlay');
        },5000);
      }
    });

  } /* end of wrapper*/






  decathlon.productListTopFloor = {};
  decathlon.productListTopFloor.resizeProductListTop = function() {

      windowWidth = $(window).width();
      windowWidth = windowWidth > decathlon.uxBreakpoints.lgMin ? decathlon.uxBreakpoints.lgMin : windowWidth;

      clearTimeout(timerResize);

      timerResize = setTimeout(function(){
        $('#category-informations').css('width', (windowWidth - 300) + 'px' );
        $('#category-product-top').css('padding-left', (windowWidth - 280) + 'px' );
      }, 75);
    
  };


  if($('body').hasClass('listing-page')){

    var timerResize,
    windowWidth;

    $(function() {

      if($('html').hasClass('no-csscalc') && !$('html').hasClass('ie8')){

        $(window).on('resize-width', function(){
          decathlon.productListTopFloor.resizeProductListTop();
        });

        decathlon.productListTopFloor.resizeProductListTop();
      }

    });

  }

})(window, jQuery);


;(function(window, $){

  var refImage = $('#product-list-bg').find('picture source[media="(min-width: 769px)"]');
  var refHeight = $('#product-list-bg').find('img').height();
  
  /* LOAD FILTER SORT BY IN GUIDED NAVIGATION SECTION */
  $("#sort").selectpicker('show');

  if(refImage.length > 0 && refHeight > 590){

    var imagesrc = refImage.attr('data-srcset') || refImage.attr('srcset') ;

    if(typeof imagesrc !== 'undefined'){
      vimagesrc = imagesrc.replace(/\?f\=.*/g, '?f=50x50');
      $('#main-container').prepend('<div id="pixelcanvasbg" style="background-image:url('+imagesrc+');"></div>');
    }
  }
  
})(window, jQuery);

(function(window, $){

  var myInfiniteScroll = {};



  loadinfinitescroll = function(){
    $('body').css('overflow','hidden');
    myInfiniteScroll.infinite = new Cube.InfiniteScroll();
    myInfiniteScroll.infinite
      .setOptions({
        $nextButton: $('#more_product_a')
      })
      .load();
      $('body').css('overflow','');
    };
	
	// Load infinite scroll (only on mobile)
	if (decathlon.uxBreakpoints.is('small-screen')) {
		//loadinfinitescroll();
	}

  $(window).on('enter-small-screen', function(){
    if(_.isUndefined(myInfiniteScroll.infinite)){
      //loadinfinitescroll();
    }
  });

  $(window).on('enter-large-screen', function(){
    if(!_.isUndefined(myInfiniteScroll.infinite)){
      //myInfiniteScroll.infinite.destroy();
      //delete myInfiniteScroll.infinite;
    }
  });
	
})(window, jQuery);

jQuery(document).ready(function() {
	
	var staticPage = $('.static-content-page').not('.workshop-template');
	var panel = $(staticPage).find('#main-container .panel');
	// Override Bootstrap accordion panel behavior as they were missused here.
	$(panel).on('click', function(event) {
		event.preventDefault();
		event.stopPropagation();
		jQuery(this).find('.panel-heading a').toggleClass('collapsed');
		jQuery(this).find('.panel-collapse').toggle();
	});
	
});
decathlon.userAccount = {};
decathlon.userAccount.init = function () {
	
	var mobile = (($('body').hasClass('mobile')) ? true : false);

    $('.fullscreen-layer').appendTo('body');
    if($('.tracking-modal').length > 0){
      $('body').append($('.tracking-modal'));
    }


    //correctifs probleme de z-index
    $('body').on('shown.bs.modal', '.tracking-modal' ,function(e) {
        $('.fullscreen-layer').show().css({'background': '#000', 'opacity': 0.85, 'z-index': '10000'});
    }).on('hide.bs.modal', function(e) {
        $('.fullscreen-layer').css({'background': '#fff', 'opacity': 1, 'z-index': '7001'});
        $('.fullscreen-layer').hide();
        if(mobile){
            $('#header').css('z-index', '9999');
        }
    });

    /* COUNTDOWN */
    if($('.account .countdown').length && $('#my-purchase-details').length){

        if($('.account .countdown').length === 1){
            decathlon.tools.countdown('.countdown');
        }
        else{
            var countdownTimers = $('.account .countdown');
            for(var u=0;u<countdownTimers.length;u++){
                decathlon.tools.countdown(countdownTimers[u]);
            }
        }
    }

    var productListSlickSettings = function (asNavForSettings){
      return {
        infinite: false,
        arrows: true,
        dots: false,
        speed: 300,
        useCSS:true,
        useTransform:true,
        slidesToShow: 1,
        slidesToScroll: 1
      };
    };

    var slickStoreSettings = function(){
        return {
            infinite: false,
            dots: true,
            speed: 300,
            slidesToShow: 3,
            useCSS:true,
            useTransform:true,
            slidesToScroll: 1,
            responsive: [
              {
                breakpoint: decathlon.uxBreakpoints.smMin,
                settings: {
                  slidesToShow: 1,
                  slidesToScroll: 1
                }
              }
            ]
        };
    };

    $('.slick-openings').slick({
        infinite: false,
        arrows: true,
        dots: true,
        useCSS:true,
        useTransform:true,
        speed: 300,
        slidesToShow: 3,
        slidesToScroll: 1
    });

    $('.slick-offers').slick(slickStoreSettings());
    $('.slick-store-services').slick(slickStoreSettings());

    /* Loyalty */

    $('.slick-vouchers').on('afterChange', function(event, slick, currentSlide, nextSlide){
      var newIndex = currentSlide+1;
      $('#main-container .vouchers-count span').text(newIndex+' ');
    });

    // TOOLTIPS
    $('#main-container .slick-vouchers').tooltip({
      'trigger': 'manual',
      'template': '<div role="tooltip" class="tooltip tooltip-alert info"><div class="container-icon"><span class="animate-icon"><span class="bell"></span><span class="vibe"></span></span></div><div class="tooltip-arrow"></div><div class="tooltip-inner"></div><span class="close icon icon-x"></span></div>'
      }).tooltip('show');

    $('#main-container .slick-vouchers-block .tooltip .close').on('click', function(){
      $('#main-container .slick-vouchers').tooltip('destroy');
    });

    $('#main-container .tooltip-unsubscribe').tooltip({
      'template': '<div role="tooltip" class="tooltip tooltip-unsubscribe tooltip-alert danger"><div class="container-icon"><span class="animate-icon"><span class="bell"></span><span class="vibe"></span></span></div><div class="tooltip-arrow"></div><div class="tooltip-inner"></div><span class="close icon icon-x"></span></div>'
      });

    $('#main-container .tooltip-unsubscribe .close').on('click', function(){
      $('#main-container .tooltip-unsubscribe').tooltip('destroy');
    });

    // Mobile specific product return events
    jQuery('.cart-list .return-line-footer').each(function() {
        var that = jQuery(this);
        that.find('.return-show').on('click', function() {
            that.siblings('.return-line-body').toggle();
            that.find('.open').toggle();
            that.find('.close').toggle();
        });
    });

    // Address selection

    function unselectFavoriteAddress(){
        $('.customer-wrapper').each(function(){
          var find = $(this).find(".favorite");
          find.addClass('is-not-favorite');
          find.html("Select your favorite address");
        });
    }

    function selectFavoriteAddress(element){

      unselectFavoriteAddress();

      $(element).find("input").attr('checked', 'checked');

      var find = $(element).find(".favorite");
      find.removeClass('is-not-favorite');
      find.html("Your favorite address");
    }

      // Call
    $('.customer-wrapper').on('click', function(e){
      selectFavoriteAddress(this);
    });

    // Address deletion
    function deleteAddress(element){
      var cible = $(element).closest('.customer-wrapper');
        cible.slideUp(500, function(){
          cible.remove();
        });
    }

    $('#more-details').on('shown.bs.collapse', function(e) {
        decathlon.tools.slickReinitSlider('.product-item, .product-img-wrapper', '.product-img', '', productListSlickSettings);
    });



    $('#modal-delivery, #modal-delete-address').on('shown.bs.modal', function(e) {
      var element = e.relatedTarget;

      $('.confirm-deletion').on('click', function(e){
        e.preventDefault();
        deleteAddress(element);
        $('.close-modal').trigger('click');
      });

      $('.cancel-deletion').on('click', function(e){
        e.preventDefault();
        $('.close-modal').trigger('click');
      });

    });


    /* Orders Details */
    $('.panel-group').on('click', 'div.panel-heading', function(){

        var _this = $(this),
        _thisParent = _this.parent();

        if(_thisParent.hasClass('panel-open')){
            _thisParent.removeClass('panel-open');
        }
        else{
            _thisParent.addClass('panel-open');
        }
    }).on('dblclick', 'div.panel-heading', function(){
        $(this).trigger('click');
    });

    $('#main-container').on('mouseenter', 'a.order-disabled', function(){
        $(this).popover('show');
    }).on('mouseleave', 'a.order-disabled', function(){
        $(this).popover('hide');
    });

    // $('a.tooltip-link').popover({container: ".purchases"})
    $('#main-container a.tooltip-link').popover('show');

    $('#main-container').on('click', 'a.order-disabled', function(e){
        e.preventDefault();
    });

    // store locator popin
    $('.bt-pop-st-l').on('click', function(e){
        e.preventDefault();
    });
    if($("#purchaseReturns").length > 0) {

        var baidu = document.createElement('script');
        baidu.src = 'https://api.map.baidu.com/api?v=2.0&amp;ak=' + $('#purchaseReturns').attr('data-key') +'&amp;s=1';
        baidu.type = 'text/javascript';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(baidu, s);
        $('#modal-store-locator').on('shown.bs.modal', function(e) {
            $('.modal-backdrop').css('z-index', '7000');

            var modalStoreLocator = $(e.currentTarget);

            if(modalStoreLocator.find('#map').children().length === 0) {
                var data = $('#default-lat').val()+","+ $('#default-long').val()+","+ $('#default-zoom').val();
                var callURL = $('#call-url').val();
                var storeLocatorMap = new UX_MapObject({
                    mapObject: 'map',
                    typeMap: 'bmap',
                    storesData: data,
                    callURL: callURL,
                    localisator: $('.locate-me'),
                    formAddress: $('.search-address'),
                    offCentered: false,
                    panel: $('#map-panel'),
                    showStore: false
                });
            }

            $(document).on('click', '.info-store .store-name', function(e){
                e.preventDefault();
                var storeId = $(this).closest('.content').attr('data-store-id');
                $('#selected-store').val(storeId);
                modalStoreLocator.find('.row.actions').show();
            });

            modalStoreLocator.find('.validate-store').on('click', function(e){
                e.preventDefault();
                modalStoreLocator.modal('hide');
            });
        });
    }
};

(function() {
    
    $(document).ready(function() {
        
        $(".locate-me").click(function() {
            $('html,body').animate({
                scrollTop: $(".localisate-wrapper").offset().top},
                'slow');
        });

            
    	if ($('#notifications-updated').val() === "false") {
            setTimeout(function() {               
                reloadCartridgeContentCollection(
                    $(this), 
                    'header-my-account',
                    {},
                    function() {
                        $('#dropdown-account').uxHeaderDropdownFunctions();
                    }
                );                
            }, 10000);
    	 }
    });
    
})();

if($('body').hasClass('account')){
    $(function(){

        decathlon.tools.init();
        decathlon.userAccount.init();

        var resizeEffect;
        $(window).resize(function() {
            clearTimeout(resizeEffect);
            resizeEffect = setTimeout(function(){
                $('#main-container a.tooltip-link').popover('show');
                /* COUNTDOWN */
                if($('.account .countdown').length > 0){

                    if($('.account .countdown').length === 1){
                        decathlon.tools.countdown('.countdown');
                    }
                    else{
                        var countdownTimers = $('.account .countdown');
                        for(var i=0;i<countdownTimers.length;i++){
                            decathlon.tools.countdown(countdownTimers[i]);
                        }
                    }
                }
            }, 400);
        });
    });

    $(window).on('load', function(){

        /* MY PURCHASE COUNTDOWN */
        if($('.account .countdown').length && $('#my-purchase').length){
            $('[data-toggle="popover"]').each(function() {
                var $this = $(this);
                var id = $($this.data('content')).attr('id');
                var countDownFinishedCallBack = function() {
                    $this.popover('destroy');
                    $this.remove();
                };
                decathlon.tools.countdown("#"+ id, countDownFinishedCallBack);
            });
        }

        if($('#user-profil').length > 0){
            var userValue = $('#user-profil').attr('data-value') / 100;
            $('#user-profil').show();
            var circle = new ProgressBar.Circle('#user-profil', {
                width: 1,
                color: '#00c38a',
                trailColor: '#e8e7e7',
                strokeWidth: 4,
                trailWidth: 4,
                duration: 1600,
                easing: 'easeOut',
                text: {
                    value: '0'
                },
                step: function(state, bar) {
                    bar.setText((bar.value() * 100).toFixed(0)+'%');
                }
            });

            circle.animate(userValue);
            
            setTimeout(function(){
            	$('#user-profil').css({'margin-top': '10px'});      
            }, 100);

        }
        
        $('.slick-notification').slick({
            infinite: true,
            arrows: true,
            dots: true,
            speed: 300,
            slidesToShow: 1,
            slidesToScroll: 1
        });
        
        var matchDashboardCardHeights = function() {
          if (decathlon.tools.isViewportOfSize('xs')) {
            $('.sheight').matchHeight({ remove: true });
            $('.has-picture .dash-card-header').matchHeight({ remove: true });  
          } else {
            $('.has-picture .dash-card-header').matchHeight({ property: 'height' });
            $('.sheight').matchHeight({ property: 'height', byRow: false });
            $.fn.matchHeight._update();
          }
        };
        
        if($('body').hasClass('dashboard')) {
          matchDashboardCardHeights();
          decathlon.tools.onResize(matchDashboardCardHeights);
        }
        
        $('.close-notification').on('click', function(){
            var notificationId = $('.dash-card-notification-item.slick-current').attr('id');
            var cardIndex = $('.slick-notification').slick('slickCurrentSlide');
            ajaxCall(
                $(this),
                "account/deleteNotification",
                { notificationId: notificationId },
                function() {
                    // ALWAYS SUCCESS
                    removeNotificationsCard(cardIndex);
                    reloadCartridgeContentCollection(
                        $(this), 
                        'header-my-account',
                        {},
                        function() { $('#dropdown-account').uxHeaderDropdownFunctions(); }
                    );
                    
                },
                function() {}
            );
        });
        
        $('.notification-link').on('click', function(e) {
            var $notification = $('.dash-card-notification-item.slick-current');
            var notificationId = $notification.attr('id');
            var isRead = $notification.data('is-read');
            if (!isRead) {
                e.preventDefault();
                ajaxCall(
                    $(this).closest('a'),
                    "account/readNotification",
                    { notificationId: notificationId },
                    function($anchor) {
                        window.location = $anchor.attr('href');
                    },
                    function() {}
                );
            }
        });
        
        var removeNotificationsCard = function(cardNo) {
            $('.slick-notification').slick('slickRemove', cardNo);
            if ($('.slick-notification').slick('getSlick').slideCount === 0) {
                $('.slick-notification').closest('[class*="col-"]').fadeOut({
                    complete: function(){
                        $(this).remove();
                        $('.has-picture .dash-card-header').matchHeight({ property: 'min-height' });
                        $('.sheight').matchHeight({ property: 'height' });
                    }
                });
            }
        };
        
        
        $('.notification-red').slick({
            infinite: true,
            arrows: true,
            dots: true,
            speed: 300,
            slidesToShow: 1,
            slidesToScroll: 1
        });
        
        
        var showResponseTOErrors = function(errors) {
            var text = Messages("error");
            for (var i in errors) {
                var error = errors[i];
                text += '<br>' + error.message;
            }        
            $('body').pushAlert({ type: "danger", text: text, icon: "bell" });
        };
        
        $('#bill-ticket').find('.form-control').each(function() {
        	$(this).on('focus', function(){
        		var data = $(this).closest('.form-group').find('.badge-number').text();
        		$(this).closest('.form-group').find('.badge-number').addClass('active');
        		$(this).closest('#bill-ticket').find('.bill-ticket').find("li[data-badge='" + data + "']").addClass('active');
        	}).on('blur', function() {
        		var data = $(this).closest('.form-group').find('.badge-number').text();
        		$(this).closest('.form-group').find('.badge-number').removeClass('active');
        		$(this).closest('#bill-ticket').find('.bill-ticket').find("li[data-badge='" + data + "']").removeClass('active');
        	});
        });
        
        $('#bill-ticket').find('.form-group').each(function() {
        	$(this).find('.modal-helper').on('click touchstart touchcancel', function() {
        		var data_num  = $(this).prev().text();
        		$(this).closest('#bill-ticket').find('.bill-ticket').find('li').removeClass('active').parent().find("li[data-badge='" + data_num + "']").addClass('active');
        	});
        });
        
        if($('#bill-ticket #date-ticket').length !== 0) {
	        $('#bill-ticket #date-ticket').datetimepicker();
	        $('#bill-ticket #date-ticket').data("DateTimePicker").maxDate(new Date());
        }
        
        $('#bill-ticket #date-ticket').on('dp.change', function(e) {
            var value = e.date.format("DD/MM/YYYY");
            $('#date-input').val(value);
        });
        
        $('.badge-number').on('click', function(e) {
            e.preventDefault();
            $(this).closest('.form-group').find('input').trigger('focus');
        });

        var ticketSuccessCb = function($form, result) {
            var data = result.responseTO.data;
            if (data) {
                $('#ticket-validated-container').fadeIn();
                $('#ticket-form-container').hide();
            }
        };
        
        var ticketValidationOpts = {
            rules: {
                amount: "ticketamount",
                tillNumber: {
                    digits: true,
                    maxlength: 4
                },
                transactionId: {
                    digits: true,
                    maxlength: 16
                },
                storeId: {
                    digits: true,
                    maxlength: 6
                }
            }
        };
        
        $('#ticket-form').validate( $.extend(null, $.validator.cubeOptions, ticketValidationOpts) );
        $('#ticket-form').handleform('init', { successCb: ticketSuccessCb });
        
    });

}

(function(namespace) {
    
    var Countdown = function($btn, timer) {
        
        this.$btn = $btn;
        this.content =  $btn.html();
        this.timer = timer;
        this.$counter = $('' +
            '<div class="counter-container">' + '<span class="disabled-action cta-link-disabled">' + this.content + '</span>'+
                '<img class="loader" src="/assets/images/loading.gif" alt="Loading" /> ' + Messages("createAccount.pleasewait", "<span class=\"counter\"></span>") +
            '</div>');
        this.interval = false;
    };
    
    Countdown.prototype.go = function() {

        var count = this.timer;
        var $current = this.$counter.find('.counter');
        var self = this;
        
        self.stop();
        
        $current.text(count);
        this.$btn.hide();
        this.$btn.after(this.$counter);
        
        this.interval = setInterval(function() {
            count--;
            if (count === 0) {
                self.stop();
            }
            else {
                $current.text(count);
            }
        }, 1000);
    };

    Countdown.prototype.stop = function() {
        this.$counter.remove();
        this.$btn.show();
        clearInterval(this.interval);
        this.interval = false;
    };
    
    Countdown.prototype.isRunning = function() {
        return this.interval !== false;
    };
    
    namespace.Countdown = Countdown;
    
})(decathlon.userAccount = decathlon.userAccount || {});

if (document.getElementsByClassName('workshop-template').length)
{
    $(function()
    {
        $('.workshop-detail-link').on('click', function () {
            $(this).closest('tr').nextAll('.toggle-row').first().slideToggle();
        });

        $('.panel-menu-bar').on('click', function () {
            $(this).toggleClass('opened');
            $('#menuNav').stop().slideToggle('fast');
        });

        $('.has-dropdown').on('click', function () {
            var self = $(this);
            self.toggleClass('active').next('.list-dropdown').stop().slideToggle('fast');
            self.children('span').first().toggleClass('icon-plus icon-minus');
        });
    });
}


;(function (window, $, document, undefined) {

  var prototypeMethods = prototypeMethods || {};

  prototypeMethods.init = function () {

    var _this = this,
        productID,
        modelID;

    var hideTheWholeBlockIfEmpty = function(){
      setTimeout(function(){
        if(_this.el.siblings('.cs-product').not('.added-to-cart').length === 0){
          $('#cart-cross-sell-right').fadeOut('fast');
        }
      },300);
    };

    _this.el.on('confirm', '.csp__cta a', function(){
      _this.el.addClass('added-to-cart');
      hideTheWholeBlockIfEmpty();
    });

    _this.el.on('click', '.csp__cta a', _.debounce(function(e){

      productID = _this.el.data('productid');
      modelID = _this.el.data('modelid');

      if(productID !== '' && modelID !== ''){
        throwEvent(Events.CART_ITEM_ADDED, modelID, productID, 1, $(this));
      } else {
        console.error('no product or model id');
      }

    },300));

    _this.el.on('click', '.csp__cta a', function(e){
      e.preventDefault();
    });

  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'CartCrossSellProductMethods',
    defaultOptions : {
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));

$('#cart-cross-sell-right .cs-product').CartCrossSellProductMethods();

decathlon.productListFloor = {};

decathlon.productListFloor.init = function() {


  var slickAddExtraClasses = function(target){
    var currentSlide = $(target).find('.slick-product').slick('slickCurrentSlide');
    $(target).find('.slick-thumbs').find('.slick-current').removeClass('slick-current');
    $(target).find('.slick-thumbs [data-slick-index='+currentSlide+']').addClass('slick-current');
  };
  
  // Select current thumbnail when no scroll (slick bug)
  $('body').on('swipe', '.pl-element', function(){
    slickAddExtraClasses(this);
  });

};


if($('body').hasClass('listing-page')){
  $(function() {
    decathlon.productListFloor.init();
  });
}
;(function (window, $) {

  var prototypeMethods = prototypeMethods || {};


  prototypeMethods.initImageCarousel = function($imageCarousel, $imageCarouselNav){

    var _this = this;

      $imageCarousel.on('afterChange', function(event, slick, currentSlide){
        _this.updateSizesCarouselContent($imageCarousel.find('[data-slick-index="'+currentSlide+'"]').data('modelid'));
      });

      $imageCarousel.on('init', function(){
        _this.updateSizesCarouselContent($imageCarousel.closest('.plv2-el__images').data('lowest-model-id'));
      });

      $imageCarousel.not('.slick-initialized').slick({
        slidesToShow: 1,
        dots: false,
        arrows:false,
        infinite: false,
        speed: 500,
        fade: true,
        cssEase: 'linear',
        useCSS:true,
        draggable: false,
        zIndex: 0,
        asNavFor: $imageCarouselNav
      });
      
      $imageCarouselNav.not('.slick-initialized').slick({
        slidesToShow: 5,
        slidesToScroll: 1,
        dots: false,
        arrows:true,
        infinite: false,
        speed: 500,
        draggable: true,
        variableWidth: true,
        focusOnSelect: true,
        centerMode: false,
        asNavFor: $imageCarousel
      });

  };

  prototypeMethods.updateProductImagesContent = function(){

    var _this = this;

    var name = '',
    imagesCarouselContent = '',
    colorsCarouselContent = '',
    imagesCounter = 0,
    targetAttr = '';

    if(_this.el.find('.plv2-el__image a[target="_blank"]').length > 0){
      targetAttr='target="_blank"';
    }

    $.each(_this.el[0].productData, function(idx, model) {

      if (model.media !== null) {

        imagesCounter ++;

        var url = '';

        if (model.media.images !== null) {
          name = model.media.images[0].name;
          url = model.media.images[0].url;
        }

        if(imagesCounter === 1){
          var $onlyImage = _this.el.find('.plv2-el__image');
          if($onlyImage.length === 1){
            $onlyImage.attr('data-modelid', model.id);
          }
        }

        /* Don't take the first image for the images carousel, it is already loaded */
        if(imagesCounter !== 1){
          imagesCarouselContent += '' +
          '<div class="plv2-el__image" data-modelid="'+model.id+'">' +
            '<a href="' + $('#modelBaseUrl-'+ model.skus[0].productId).val() + '?' + model.modelUrl + '" '+targetAttr+'>' +
              '<picture alt="' + name + '" aria-hidden="true">' +
                   '<!--[if IE 9]><video style="display: none;"><![endif]-->' +
                   '<source data-srcset="' + url + '?f=250x250" media="(min-width: 801px)">' +
                   '<source data-srcset="' + url +'?f=250x250" media="(min-width: 481px)">' +
                   '<source data-srcset="' + url +'?f=250x250" media="(max-width: 480px)">' +
                   '<!--[if IE 9]></video><![endif]-->' +
                   '<img class="lazyload"  src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="' + name + '">' +
                   '</picture>' +
             '</a>' +
          '</div>';
        }
      

        colorsCarouselContent += '<div class="plv2-el__color" data-model-id="' + model.id + '" data-selected-model-index="' + idx + '" role="radio">' +
            '<picture alt="' + name + '" aria-hidden="true">' +
                 '<!--[if IE 9]><video style="display: none;"><![endif]-->' +
                 '<source data-srcset="' + url + '?f=250x250" media="(min-width: 801px)">' +
                 '<source data-srcset="' + url + '?f=250x250" media="(min-width: 481px)">' +
                 '<source data-srcset="' + url + '?f=250x250" media="(max-width: 480px)">' +
                 '<!--[if IE 9]></video><![endif]-->' +
                 '<img class="lazyload"  src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="' + name + '">' +
                 '</picture>' +
              '</div>';
        
      }

    });

    /* END OF EACH */

    if(imagesCounter === 1){
      _this.el.addClass('single-color');
    } else {
      _this.el.addClass('multiple-colors');
      _this.el.find('.plv2-el__colors-carousel').empty().append(colorsCarouselContent);
      _this.el.find('.plv2-el__images-carousel').append(imagesCarouselContent);
    }
  };


  prototypeMethods.getSelectedmodelID = function(currentSlide){
    var _this = this;

    var $currentSize = _this.$sizesCarousel.find('[data-slick-index="'+currentSlide+'"]');

    if(!$currentSize.is('.disabled')){
      var skuPrice = $currentSize.data("price");
      var skuSticker = $currentSize.data("sticker");
      
      _this.el.find('.plv2-el__price').html(skuPrice);
      _this.el.find('.plv2-el__sticker').html(skuSticker);
      
      _this.el.selectedmodelID = $currentSize.data('skuid');
      _this.enableAddtoCartButton();
    } else {
      delete _this.el.selectedmodelID;
      _this.disableAddtoCartButton();
    }

  };

  prototypeMethods.initSizesCarousel = function(){

    var _this = this;

    _this.$sizesCarousel.on('init', function(){
      
      if(_this.$sizesCarousel.find('.disabled') === 0){
        _this.enableAddtoCartButton();
      }

      _this.getSelectedmodelID(0);

      _this.$sizesCarousel.on('click', '.disabled', function(e){
        e.preventDefault();
      });

    });

    _this.$sizesCarousel.not('.slick-initialized').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      dots: false,
      arrows:true,
      infinite: false,
      speed: 500,
      draggable: true,
      focusOnSelect: true,
      centerMode: false,
      variableWidth: true
    });

    //_this.selectTheFirstSelectableSize();

    _this.$sizesCarousel.on('afterChange', function(event, slick, currentSlide){

      _this.getSelectedmodelID(currentSlide);

    });

  };

  prototypeMethods.selectTheFirstSelectableSize = function(){

    var _this = this;

    if(_this.$sizesCarousel.find('.plv2-el__size.disabled').length > 0){
    
      var $firstSelectableSize = _this.$sizesCarousel.find('.plv2-el__size:not(.disabled)').eq(0);

      if($firstSelectableSize.length > 0){
        _this.$sizesCarousel.slick('slickGoTo', $firstSelectableSize.data('slickIndex'), true);
        _this.enableAddtoCartButton();
      } else {
        _this.$sizesCarousel.find('.slick-current').removeClass('slick-current');
        delete _this.el.selectedmodelID;
        _this.disableAddtoCartButton();
      }
    } else {
      _this.getSelectedmodelID(0);
      _this.enableAddtoCartButton();
    }

  };

  prototypeMethods.enableAddtoCartButton = function(){
    var _this = this;

    var isProductSellableOffline = _this.$addtocart.closest('.plv2-element').data("product-sellable-online");
    if(isProductSellableOffline){
      _this.$addtocart.removeClass('disabled').attr('aria-disabled','false');
    }

  };

  prototypeMethods.disableAddtoCartButton = function(){
    var _this = this;

    _this.$addtocart.addClass('disabled').attr('aria-disabled','true');
    
  };

  prototypeMethods.updateSizesCarouselContent = function(modelid){

  
    
    var _this = this;
    var sizesCarouselContent = '';
    var sizeDisabledEnabled = '';

    var AddSizeElementToTheCarousel = function(id, size, sizeIndex , sizeDisabledEnabled, isSizeLowestPricedSize, skuPrice, skuSticker){
      var encodedSkuSticker = $('<div/>').text(skuSticker).html();
      var encodedSkuPrice = $('<div/>').text(skuPrice).html();
      sizesCarouselContent += '<div class="plv2-el__size'+sizeDisabledEnabled+'" data-selected-size-index="' + sizeIndex + '" data-' + modelid + '-is-size-lowest-priced-size="' + isSizeLowestPricedSize + '" data-skuid="' + id + '" role="radio" data-price=\'' + encodedSkuPrice + '\' data-sticker="' + encodedSkuSticker + '"><span>' + size + '</span></div>';
    };

    var loopThroughSizes = function(model){

      if(model.skus.length > 1){

        if(_this.el.hasClass('single-size')){
          _this.el.removeClass('single-size');
        }

        var lowestPricedSku = 10000000.0;
        var isSizeLowestPricedSize = false;
        var lowestPricedSkuIndex = findModelLowestPricedSkuIndex(model.skus);
        
        for (var i = 0; i < model.skus.length; i++) {
            sizeDisabledEnabled = model.skus[i].available === true ? '' : ' disabled';         
            AddSizeElementToTheCarousel(model.skus[i].id, model.skus[i].size, i, sizeDisabledEnabled, (i == lowestPricedSkuIndex), model.skus[i].displayPriceContainer, model.skus[i].displaySticker);
        }
      } else {
        if(!_this.el.hasClass('single-size')){
          _this.el.addClass('single-size');
        }
        _this.el.selectedmodelID = model.skus[0].id;
        AddSizeElementToTheCarousel(model.skus[0].id, model.skus[0].size, null, sizeDisabledEnabled, null, model.skus[0].displayPriceContainer, model.skus[0].displaySticker);
        _this.enableAddtoCartButton();
      }

    };

    var findModelLowestPricedSkuIndex = function(skus){
      var lowestPrice = 10000000.0;
      var lowestPricedSkuIndex = 0;
      
    $.each(skus, function(index, currentSku) {
        if (lowestPrice > skus[index].price.activePrice) {
          lowestPrice = skus[index].price.activePrice;
          lowestPricedSkuIndex = index;
        }
    });
    
    return lowestPricedSkuIndex;
    };
    
    var addSizeCarouselToElement = function(){
      if(sizesCarouselContent !== ''){

        _this.el.addClass('multiple-sizes');

        if(_.isUndefined(_this.$sizesCarousel[0].slick)){
          _this.$sizesCarousel.empty().append(sizesCarouselContent);
          _this.sizeCarouselDispatcher();
        } else {
          
          _this.$sizesCarousel
          .slick('removeSlide', null, null, true)
          .slick('slickAdd', sizesCarouselContent);

          //_this.selectTheFirstSelectableSize();
        }

      }

    };

    if(modelid) {
    	if(_this.el[0].productData != undefined){
	      for (var i = 0; i < _this.el[0].productData.length; i++) {
	        if(_this.el[0].productData[i].id == modelid){
	          loopThroughSizes(_this.el[0].productData[i]);
	          addSizeCarouselToElement();
	          break;
	        }
	      }
    	}  
    } 
    
    var selectedSizeIndex = $(sizesCarouselContent).filter('div[data-' + modelid + '-is-size-lowest-priced-size="true"]').attr("data-selected-size-index");
    if(!_.isUndefined(selectedSizeIndex)){
      _this.$sizesCarousel.slick('slickGoTo', selectedSizeIndex, true);
      var equivalentModelSlideObj = $('div[data-model-id="' + modelid + '"]');
        setTimeout(function(){
          $(equivalentModelSlideObj).trigger("click");
        }, 10);
    }
  };

  prototypeMethods.sizeCarouselDispatcher = function(){
    var _this = this;

    var sizesLength = _this.$sizesCarousel.find('.plv2-el__size').length;

    if(_this.$sizesCarousel.length > 0 && sizesLength > 1){
      _this.initSizesCarousel();
    }
  };

  prototypeMethods.hideExtraContents = function(){
    var _this = this;
    _this.el.removeClass('open').removeClass('hover');
    _this.$carouselParent.removeClass('cartridge-open');

    $('html').removeClass(_this.options.mobilePopinOpenClass);

    if(decathlon.uxBreakpoints.is('small-screen')){
    	if(_this.$slickTrack != undefined){
    		_this.$slickTrack.attr('style', _this.slickTrackStyle);
    	}	
    }

    _this.el.find(_this.options.extraOptionsSelector).attr('aria-hidden', true);

  };

  /**
   * Called when hovering a cross sell item.
   * It should display colors and size and att to cart button.
   */
  prototypeMethods.showExtraContents = function(){

    var _this = this;

    if(decathlon.uxBreakpoints.is('small-screen')){
      _this.$slickTrack = _this.$carouselParent.find('.slick-track').first();
      _this.slickTrackStyle = _this.$slickTrack.attr('style');
      _this.$slickTrack.removeAttr('style');
    }
    
    _this.$carouselParent.addClass('cartridge-open');

    _this.el.removeClass('hover').addClass('open');

    // Click to CrossSell product on Product Page cross-sell and Add To Cart Page
    _this.$carouselParent.find(".plv2-el__color").off('click.st').on('click.st', function() {
    	CUBE.Analytics.crosssell.clickOnColorama($(this));
  });
    
    _this.el.find(_this.options.extraOptionsSelector).attr('aria-hidden', false);

  };

  prototypeMethods.imageCarouselDispatcher = function(){
    var _this = this;

    var $imageCarousel;
    var $imageCarouselNav;
    var imagesLength;

    $imageCarousel = _this.el.find('.plv2-el__images-carousel');
    $imageCarouselNav = _this.el.find('.plv2-el__colors-carousel');

    imagesLength = $imageCarousel.find('.plv2-el__image').length;

    if($imageCarousel.length > 0 && $imageCarouselNav.length > 0 && imagesLength > 1){
      _this.initImageCarousel($imageCarousel, $imageCarouselNav, imagesLength);
    } else {
      _this.updateSizesCarouselContent($imageCarousel.find('.plv2-el__image').attr('data-modelid'));
    }
  };

  prototypeMethods.initHoverMethods = function(){

    var _this = this;

    var showHideLoadingGifDate = new Date(),
    refreshtimestamp = 0;

    var setLoaded = function(){
      _this.el.removeClass('loading').addClass('loaded');
    };

    _this.el.on('hide-loading', function(){
      if(showHideLoadingGifDate.getTime() - refreshtimestamp < 1000){
        setTimeout(function(){
          setLoaded();
        },500);
      } else {
        setLoaded();
      }
    });


    _this.el.on('ajax-data-loaded', function(){

      _this.updateProductImagesContent();

      _this.el.trigger('hide-loading');

      setTimeout(function(){
        _this.showExtraContents();
        _this.imageCarouselDispatcher();
      },0);

    });


    var hideDispatcher = function(){
      if(!_this.el.hasClass('added-to-cart')){
        _this.hideExtraContents();
      }
    };

    _this.el.on('click', '.'+_this.options.mobilePopinBackdropClass + ', .'+_this.options.mobileCloseButtonClass, function(){
      hideDispatcher();
    });

    _this.el.on('mouseleave', function(){
      hideDispatcher();
    });

    _this.el.on('contextmenu', function(e){
      e.preventDefault();
    });

    _this.el.parent().on('mouseleave', function(){
      if(_this.el.parent().find('.added-to-cart').length === 0){
        _this.el.parent().find('.open').productListV2CartridgesMethods('hideExtraContents');
      }
    });

    var addMobileExtraDivs = function(){
      if(_this.el.find('.'+_this.options.mobilePopinBackdropClass).length === 0 ) {
        _this.el.prepend('<div class="'+_this.options.mobilePopinBackdropClass+'"></div>');
      }

      if(_this.el.find('.'+_this.options.mobileCloseButtonClass).length === 0 ) {
        _this.el.find('.plv2-el__wrapper').prepend('<div class="'+_this.options.mobileCloseButtonClass+'"></div>');
      }
    };

    _this.el.on('mouseenter click', function(e){
      var loadAjaxContentDispatcher = function(){
        _this.$carouselParent.addClass('cartridge-open');
        
        if(decathlon.uxBreakpoints.is('small-screen')){
          $('html').addClass(_this.options.mobilePopinOpenClass);
          e.stopPropagation();
        }
        if(_this.el[0].ajaxDataISLoaded !== true){
          if(decathlon.uxBreakpoints.is('small-screen')){        	  
            addMobileExtraDivs();
          }
          _this.el.addClass('loading');

          refreshtimestamp = showHideLoadingGifDate.getTime();

          _this.el.trigger('load-extra-data');

        }
    	_this.showExtraContents();        
      };

      if(_this.el.find('.'+_this.options.loadingClass).length === 0){
        _this.el.find('.plv2-el__wrapper').append('<div class="'+_this.options.loadingClass+'"></div>');
      }

      if(_this.el.siblings('.added-to-cart').length === 0){
        if(e.type === 'mouseenter'){

          _this.el.siblings().productListV2CartridgesMethods('hideExtraContents');
          _this.el.addClass('hover');
          
          setTimeout(function(){
            if(_this.el.is('.hover')){
              loadAjaxContentDispatcher();
            }
          }, 200);

        } else {
          if(!_this.el.is('.open')){
            e.preventDefault();
          }

          if(!$(e.target).hasClass(_this.options.mobilePopinBackdropClass) && !$(e.target).hasClass(_this.options.mobileCloseButtonClass)){
            loadAjaxContentDispatcher();
          }
        }
      }
    });
    
  };

  prototypeMethods.initAddToCartMethods = function(){

    var _this = this;

    var displayVisualFeedback = function($button){
      _this.el.addClass('added-to-cart');
      $button.addClass('added');
      setTimeout(function(){

        $button.removeClass('added');
        _this.el.removeClass('added-to-cart');

      },2000);
    };

    _this.$addtocart.on('confirm', function(){
      displayVisualFeedback($(this));
      
      //Reload cross sell product info cartridge for updated cart subtotal.
      var modelID = _this.el.selectedmodelID;

      reloadCartridgeContentCollection(
          $(this), 
        'cross_sell_cart', 
        {A:'u-'+ modelID});
    });

    _this.$addtocart.on('click', function(e){
      e.preventDefault();
    });

    _this.$addtocart.on('click', _.debounce(function(){
      _this.addToCart($(this));
    }, 200));
  };

  prototypeMethods.addToCart = function($cta) {

    var _this = this;

    var productID = _this.el.data('productid');
    var modelID = _this.el.selectedmodelID;
    var quantity = 1;

    if(productID && modelID){
      throwEvent(Events.CART_ITEM_ADDED, modelID, productID, quantity, $cta);
    }
  };

  prototypeMethods.init = function () {
    
    var _this = this;

    _this.$carouselParent = _this.el.closest('.product-list-v2');

    _this.$addtocart = _this.el.find('.cta.cart');

    _this.$sizesCarousel = _this.el.find('.plv2-el__sizes-carousel');

    _this.initHoverMethods();

    _this.initAddToCartMethods();

  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'productListV2CartridgesMethods',
    defaultOptions : {
      extraOptionsSelector : '.plv2-el__extra-info',
      productInfosSelector : '.plv2-el__basic-info',
      mobilePopinOpenClass : 'mobile-popin-open',
      mobilePopinBackdropClass : 'plv2-el__mobile-popin-backdrop',
      mobileCloseButtonClass : 'plv2-el__close',
      loadingClass : 'plv2-el__loading'
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));



$('.product-list-v2 .plv2-element').productListV2CartridgesMethods();







/* NOT IN USE FOR THE MOMENT */

;(function (window, $) {

  var prototypeMethods = prototypeMethods || {};

  prototypeMethods.sameHeight = function(){

    var _this = this;

    var productsArray = _this.el.find('.plv2-element'),
    maxProductHeight = 0,
    thisHeight = 0;


    if(productsArray.length > 1){

      _this.el.removeClass('same-height');

      productsArray.each(function(){
        thisHeight = $(this).outerHeight();
        if(thisHeight > maxProductHeight){
          maxProductHeight = thisHeight;
        }
      });

      _this.el.addClass('same-height');

    }
  };

  prototypeMethods.slickOptions = function(mode){

    var _this = this,
        slickOptionsObject = {},
        desktopCarouselOptions = {},
        mobileCarouselOptions = {};

    var basicCarouselSettings = {
      useCSS: true,
      useTransform: true,
      dots: true,
      infinite: false,
      variableWidth: false,
      draggable: false,
      appendArrows: _this.el.next('.slick-custom-nav'),
      appendDots: _this.el.next('.slick-custom-nav').find('.inline__dots')
    };

    _.extend(desktopCarouselOptions, {
      slidesToShow: _this.options.cartridgesPerSlidegt1024,
      slidesToScroll: 1,
      arrows: true
    }, basicCarouselSettings);

    _.extend(mobileCarouselOptions, {
      slidesToShow: _this.options.cartridgesPerSlideMobile,
      slidesToScroll: 2,
      arrows: false,
    }, basicCarouselSettings);

    var desktopCarouselOptionsResponsive1024 = [
      {
        breakpoint: 1024,
        settings: {
          slidesToShow: _this.options.cartridgesPerSlidelt1024,
          slidesToScroll: 1
        }
      }
    ];

    var desktopCarouselOptionsResponsive800 = [
      {
        breakpoint: decathlon.uxBreakpoints.smMin,
        settings: mobileCarouselOptions
      }
    ];

    var responsivesettings = function(_array){
      return {responsive: _array};
    };



    if(mode === 'both'){
      _.extend(slickOptionsObject, desktopCarouselOptions, responsivesettings(_.union(desktopCarouselOptionsResponsive1024, desktopCarouselOptionsResponsive800)));

    } else if(mode === 'desktopOnly'){
      _.extend(slickOptionsObject, desktopCarouselOptions, responsivesettings(desktopCarouselOptionsResponsive1024));

    } else if(mode === 'mobileOnly'){
      slickOptionsObject = mobileCarouselOptions;
    }

    return slickOptionsObject;

  };

  prototypeMethods.deviceIs = function(mode){

    var _this = this;

    if(mode === 'desktopOnly'){
      if(_this.options.desktopCarousel === true && _this.options.mobileCarousel === false) {
        return true;
      }
    } else if(mode === 'mobileOnly'){
      if(_this.options.desktopCarousel === false && _this.options.mobileCarousel === true) {
        return true;
      }
    } else if(mode === 'both'){
      if(_this.options.desktopCarousel === true && _this.options.mobileCarousel === true){
        return true;
      }
    }

  };

  prototypeMethods.initCarousel = function(){

    var _this = this;

    _this.el.on('init reInit', function(){
      _this.el.find('.slick-custom-nav .slick-arrow').css('display', 'inline-block');
    });

    var device = 'both';

    var initSlick = function(device){
      _this.el.slick(_this.slickOptions(device));
    };

    var slickinitDispatcher = function(device){
      if(decathlon.uxBreakpoints.is('small-screen') && _this.numberOfCartridges > _this.options.cartridgesPerSlideMobile){
        initSlick(device);
      } else {
        if($(window).width() < 1024 && _this.numberOfCartridges > _this.options.cartridgesPerSlidelt1024){
          initSlick(device);
        } else if($(window).width() > 1024 && _this.numberOfCartridges > _this.options.cartridgesPerSlidegt1024){          
          initSlick(device);
        }
      }
    };

    if(_this.deviceIs('both')){
      slickinitDispatcher(device);
    } else if(_this.deviceIs('mobileOnly')){
      device = 'mobileOnly';
      if(decathlon.uxBreakpoints.is('small-screen')){
        slickinitDispatcher(device);
      }
      $(window).on('enter-small-screen', function(){
        if(_.isUndefined(_this.el[0].slick)){
          slickinitDispatcher(device);
        }
      });
      $(window).on('enter-large-screen', function(){
        if(!_.isUndefined(_this.el[0].slick)){
          _this.el.slick('unslick');
        }
      });
    } else if(_this.deviceIs('desktopOnly')){
      device = 'desktopOnly';
      if(decathlon.uxBreakpoints.is('large-screen')){
        slickinitDispatcher(device);
      }
      $(window).on('enter-large-screen', function(){
        if(_.isUndefined(_this.el[0].slick)){
          slickinitDispatcher(device);
        }
      });

      $(window).on('enter-small-screen', function(){
        if(!_.isUndefined(_this.el[0].slick)){
          _this.el.slick('unslick');
        }
      });
    }

    $(window).on('resize-width', _.debounce(function(){
      _this.sameHeight();
      _this.updateTargetLink();
    },300));

  };

  prototypeMethods.updateTargetLink = function(){
    if(decathlon.uxBreakpoints.is('small-screen')){
      $('.product-list-v2 a[target="_blank"]').each(function(){
         $(this).attr('target', '_self');
      });
    }else {
      $('.product-list-v2 a[target="_self"]').each(function(){
         $(this).attr('target', '_blank');
      });
    }
  };

  prototypeMethods.init = function () {

    var _this = this;

    var newOptions = _this.el.data('list-options');

    if(newOptions){
      _this.options = $.extend({}, _this.options, newOptions);
    }

    _this.numberOfCartridges = _this.el.find('.plv2-element').length;


    var $slickCustomNav = $('<div class="slick-slider inline slick-custom-nav">' +
                          '<div class="inline__dots"></div>' +
                        '</div>');
    

    _this.el.after($slickCustomNav);

    _this.initCarousel();

    setTimeout(function(){
      _this.sameHeight();
    },0);

    _this.updateTargetLink();

  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'productListV2MainMethods',
    defaultOptions : {
      desktopCarousel : false,
      mobileCarousel : false,
      cartridgesPerSlideMobile : 2,
      cartridgesPerSlidelt1024 : 3,
      cartridgesPerSlidegt1024 : 4
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));



$('.product-list-v2').productListV2MainMethods();

;(function (window, $, document, undefined) {

  var prototypeMethods = prototypeMethods || {};

  prototypeMethods.initSlider = function(){
    var _this = this,
    prevLabel = _this.bundlesCarousel.data('prevarrowtext') ? _this.bundlesCarousel.data('prevarrowtext') : 'previous';
    nextlabel = _this.bundlesCarousel.data('nextarrowtext') ? _this.bundlesCarousel.data('nextarrowtext') : 'next';

    $slickCustomNav = $('<div class="slick-slider inline slick-custom-nav">' +
                          '<div class="inline__dots"></div>' +
                        '</div>');
    

    _this.el.append($slickCustomNav);

    _this.bundlesCarousel.slick({
      useCSS: true,
      useTransform: true,
      dots: true,
      infinite: false,
      variableWidth: false,
      draggable: false,
      appendArrows: _this.el.find('.pb__wrapper'),
      appendDots: _this.el.find('.inline__dots'),
      prevArrow: '<button type="button" class="slick-prev">'+prevLabel+'</button>',
      nextArrow: '<button type="button" class="slick-next">'+nextlabel+'</button>',
      responsive: [
        {
          breakpoint: decathlon.uxBreakpoints.smMin,
          settings: {
            draggable: false,
            swipe: false,
            arrows : false
            //appendArrows: _this.el.parent().find('.slick-custom-nav')
          }
        }
      ]
    });

    _this.bundlesCarousel.on('beforeChange', function(event, slick, currentSlide, nextSlide){
      var newHeading = $(this).find('.pb__element[data-slick-index="'+nextSlide+'"] .pb-el__title').html();
      
      if(newHeading){
    	  $("#bundle-floor-title").html(newHeading);
      }
    });

  };

  prototypeMethods.identifyCompact = function(){
    var _this = this,
    $products = null,
    productInnerWidth = 0,
    productOuterWidth = 0;

    _this.el.removeClass('compact');

    setTimeout(function(){
      _this.bundleSlides.each(function(){
        $products = $(this).find('.pb-el__product');
        productInnerWidth = $products.eq(0).find('.pb-el__image').outerWidth() * 2;

        productOuterWidth = $products.eq(0).outerWidth();

        if(productOuterWidth < productInnerWidth) {
          _this.el.addClass('compact');
        } else {
          _this.el.removeClass('compact');
        }

        // if(product.length > 3 && (decathlon.uxBreakpoints.is('large-screen') && windowWidth <= decathlon.uxBreakpoints.smMax)){

        // }

      });
    },0);
  };

  prototypeMethods.preventNavigationHistory = function(){
    var _this = this;

    _this.bundlesCarousel.on( 'mousewheel', function (e) {
      var e0 = e.originalEvent,
      delta = e0.deltaX || e0.wheelDeltaX;

      if ((this.scrollLeft === 0 && delta < 0) || ((this.scrollLeft + this.offsetWidth) === this.scrollWidth && delta > 0)) {
          e.preventDefault();
      }
                            
    });
  };

  prototypeMethods.init = function () {

    var _this = this;

    _this.bundleSlides = _this.el.find('.pb__element');

    _this.bundlesCarousel = _this.el.find('.pb__content');

    _this.bundlesHeading = _this.el.find('.pb__heading');

    _this.preventNavigationHistory();

    $(window).on('resize-width.bundles', _.debounce(function(){
      _this.identifyCompact();
    },50));

    _this.identifyCompact();

    if(_this.bundleSlides.length > 1){
      _this.initSlider();
    }

  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'bundlesFloorMainMethods',
    defaultOptions : {
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));



$('#product-bundles').bundlesFloorMainMethods();

// Class loading
Cube = (typeof Cube === 'object') ? Cube : {};
Cube.ManageSidebar = (typeof Cube.ManageSidebar === 'object') ? Cube.ManageSidebar : {};

Cube.ManageSidebar = function (selector) {

    this.body = $('body');
    this.wrapper = selector;
    this.modalSidebar = $('.modal-sidebar');

    // SetModalStyles 
    this.websiteHeader = $('#container-header');
    this.ppStickyNav = $('#sticky-product-nav');
};

Cube.ManageSidebar.prototype = {
  loading: function() {
    this.init();
  },
  open : function(target){
    var _this = this;

    /* get where the click comes from */
    _this.$focusedElementBefore = $(':focus');

    /* add the modal backdrop */
    if(_this.modalSidebar.next('.'+_this.options.modalBackdropClass+'').length === 0){
      _this.setBackdropObject();
      _this.modalSidebar.after(_this.$modalBackdrop);
    }

    /* add a global class to the body */
    $('html').addClass('modal-sidebar-open');

    /* get the scroll position before openning the modal - important for mobile */
    _this.scrollPositionBefore = $(window).scrollTop();

    /* si l'option gototop is true, then we scroll the window before opening the modal */
    if(_this.options.gotoTop === true && decathlon.uxBreakpoints.is('large-screen')){
      //$('html, body').scrollTop(0);
    }



    /* finally open the modal (with animation), focus in it and trap the tab focus to the modal's elements */
    _this.modalSidebar.addClass('open').addClass('in').attr('aria-hidden', 'false').attr('tabindex', -1).focus().trap().on('blur', function(){
      _this.modalSidebar.removeAttr('tabindex');
    });

    /* close the modal with the escape key */
    _this.bindWindowCloseModalSidebar();

    _this.bindWindowResizeEvent();

    /* finaly, blocks the scroll on the page */
    setTimeout(function(){
      $('body').addClass('checkout-layer');
      /* set de modal position, height and the modal's body height */
      _this.setModalStyles();
      _this.setModalsBodyMaxHeight();
    }, 300);
  },
  close : function(){
  
    var _this = this;

    /* scroll the window back to its position */
    $('body').removeClass('checkout-layer');

    if(!_.isUndefined(this.scrollPositionBefore)){
      $('html, body').scrollTop(this.scrollPositionBefore);
    }
    
    /* do the animation */
    this.modalSidebar.attr('aria-hidden', 'true').removeClass('in').addClass('closing');
    //this.modalBody.css('height', '');

    /* and finaly put everything back to normal */
    setTimeout(function(){
    
      $('html').removeClass('modal-sidebar-open');
      
      _this.modalSidebar.removeClass('closing').removeClass('open');
      
      _this.modalSidebar.next('.'+_this.options.modalBackdropClass+'').remove();
      
      /* put the focus back to where it was before opening the modal */
/*      if(_this.$focusedElementBefore.length > 0){
        _this.$focusedElementBefore.focus();
      }*/

    }, 300);

    this.unBindWindowResizeEvent();

    // $('body').removeClass('checkout-layer');
    // $('.fullscreen-layer').fadeOut();
  
  },
  
  setModalStyles : function(){
    var _this = this, 
    msTopPosition = 0;

    /* set top and height - it is added to a css injected in the head */
    function setTopAndHeight(){

        if(_this.websiteHeader[0].getBoundingClientRect().top < 0){
          msTopPosition = 0;
        } else {
          msTopPosition = _this.websiteHeader.height() + _this.websiteHeader.offset().top;
        }

      _this.setModalsBodyMaxHeight(msTopPosition);
      uxDynamicStyles.appendCssStylesArrayToHeader({
        uniqueId : 'modalSidebarPositionAndHeight',
        selectors : [
          '.large .modal-sidebar:not(.full-height)'
        ],
        properties : [
          'top: '+msTopPosition+'px;',
          'height: calc(100vh - '+msTopPosition+'px)'
        ]
      });
    }

    if(decathlon.uxBreakpoints.is('large-screen')){
      if(this.options.fullHeight === false){
        if(this.websiteHeader.length > 0 && this.ppStickyNav.length > 0){
          if(this.modalSidebar.hasClass('full-height')){
            this.modalSidebar.removeClass('full-height');
          }
          setTopAndHeight();
        }
      } else {
        this.modalSidebar.addClass('full-height');
      }
    }

  },
  setModalsBodyMaxHeight : function(msTopPosition){
    msTopPosition = msTopPosition || 0;
    var _this = this;

    /* as this isn't a global dimension, apply it directly to the dom element */
    //_this.modalBody.css('height', '').css('height', _this.modalContent.outerHeight() - _this.modalHeader.outerHeight() - _this.modalFooter.outerHeight() - msTopPosition + 'px');
  },
  bindWindowCloseModalSidebar : function(){
    var _this = this;
    $(window).on('keydown.closeModalSidebar', function(e){
        var keycode = (event.keyCode ? event.keyCode : event.which);
        if(keycode === 27){ /* ESC */
          e.preventDefault();
          e.stopPropagation();
          e.cancelBubble = false;
          _this.close();
          $(window).off('keydown.closeModalSidebar');
        }
    });
  },
  bindWindowResizeEvent : function(){

    var _this = this;

    /* RECALCULATE SIZES ON WINDOW RESIZE */
    $(window).on('resize-height.modal-sidebar', _.debounce(function(){
        _this.setModalStyles();
        _this.setModalsBodyMaxHeight();
    }, 100));

  },
  unBindWindowResizeEvent : function(){
    $(window).off('resize-height.modal-sidebar');
  },
  setBackdropObject : function(){
    var _this = this;

    _this.$modalBackdrop = $('<div class="'+_this.options.modalBackdropClass+'"></div>').on('click', function(){
      _this.modalSidebar.trigger('close');
    });

  },
  init : function () {

    var _this = this;

    /* OPTIONS DECLARED IN THE DATA-MODAL-OPTIONS ATTRIBUTE */
    var newOptions = _this.modalSidebar.data('modal-options');
    if(newOptions){
      _this.options = $.extend({}, _this.options, newOptions);
    }

    /* MAIN COMPONENTS */
    _this.modalContent = _this.modalSidebar.find('.ms__content');
    _this.modalHeader = _this.modalSidebar.find('.ms__header');
    _this.modalBody = _this.modalSidebar.find('.ms__body');
    _this.modalFooter = _this.modalSidebar.find('.ms__footer');

    var wrapInput = $('.msb__cta .input-group');
    var inputContent = wrapInput.find('input');
    var btnMoreLess = $('.input-group-btn button');
    var countProduct = inputContent.val();

    // Edit number of products
    btnMoreLess.on('click', function() {
      countProduct = inputContent.val();
      var index = btnMoreLess.index(this);   
      if(index === 0){ // Less
        if(inputContent.val() > 1 )
          countProduct--;
      }else{ // More
          countProduct++;
      }
      inputContent.val(countProduct);
    });

    
    inputContent.on('keypress', function(key) {
        if(key.charCode < 48 || key.charCode > 57)
          return false;
    });
    inputContent.on('focusout', function(key) {
        if(inputContent.val() === '' || inputContent.val() =='0') 
          inputContent.val(1);
    });
    
    /* CLOSE BUTTON */
    $('.ms__close').on('click', function(){
      _this.close();
    });
    
    /* LAUNCHING BUTTONS */
    $('[data-toggle="modal-sidebar"]').on('click', function(e){
      e.preventDefault();
    });

    $('.modal-sidebar--bundles-min').on('click', function(){
    	new bundlesFloorSlider().loading();
    	$().ConversionZonePlugin('delegateMsbColorCarousel');
    	$().ConversionZonePlugin('delegateMSBSizesDropDown');
    	$("#modal-product-bundles").trigger('open');   
    });

    $('[data-toggle="modal-sidebar"]').on('click', function(e){

      modalSidebarTarget = $($(this).data('target'));

      if(!_.isUndefined(modalSidebarTarget)){
    	  if($('#msb-conversionzone-products-list li').length){
    		  _this.open(modalSidebarTarget);
    	  }
      }

    });

    $('body').delegate('.modal-sidebar.open.in', 'click touchstart', function(event){
      if(event.target.id == 'modal-product-bundles' || event.target.id == 'set-sidebar'){
        $('.modal-sidebar').trigger('close');
      }
    });

    /* MAIN EVENTS OPEN/CLOSE */
    _this.modalSidebar.on('close', function(){
      _this.close();
    });

    _this.modalSidebar.on('open', function(){
      _this.open();
      CUBE.Analytics.panoply.sendClickForPanoply('Button');
    });

    $('.modal-sidebar--bundles-min').css('right', '0');
    setTimeout(function(){
      $('.modal-sidebar--bundles-min').removeAttr('style');
    }, 4000);

    $('.open-set-sidebar').on('click', function(){
      $('#set-sidebar').trigger('open');
      CUBE.Analytics.panoply.sendClickForPanoply('Sidebar');
    });
  }
};
new CreateMethod('SetSidebar');
Cube.SetSidebar = function (wrapper) {

    this.body = $('body');
    this.wrapper = $(wrapper);
    this.modalSidebar = $('.modal-sidebar');

    this.products = this.wrapper.find('.tr');
    this.productsItem = this.wrapper.find('.product-item');
    this.skus = this.products.find('.wrap-image');
    this.chooseBefore = this.wrapper.find('.before-choose');
};

Cube.SetSidebar.prototype = {
  loading : function() {
    this.initEvents();
    
    var alreadyMadeSelections = this.wrapper.find('.wrap-images').data('has-selected-skus-by-model-id');
    
    if(!alreadyMadeSelections && $(this.wrapper).hasClass('size')){
      this.setProduct(this.wrapper.find('.wrap-image'));
    }
  },

  initEvents : function() {
    var self = this; 

    this.modalSidebar.on('click', '.color .product-item .product-img', function() {
      var currentProduct = $(this).closest('.product-item');
      if($(currentProduct).hasClass('color-active')){
        self.managePopIn($(this));
      }
    });

    this.wrapper.on('click', '.btn-close', function() {
      self.resetProduct($(this));
    });

    this.chooseBefore.on('click', function() {          
        self.addProduct();
    });

    this.modalSidebar.on('click', '.color .wrap-image', function(event, doNotUpdatePanoplyContextObject) {
    	if(!_.isUndefined(doNotUpdatePanoplyContextObject)){
	      $(this).attr("doNotUpdatePanoplyContext", doNotUpdatePanoplyContextObject.doNotUpdatePanoplyContext);
    	} else{
    		$(this).removeAttr("doNotUpdatePanoplyContext");
    	}
    	self.setProduct($(this));
    });

    this.wrapper.on('change', '.selectpicker', function(event, doNotUpdatePanoplyContextObject) {
  	  var index = $(this).find( "option:selected" ).index();
  	  var unitPrice = $(this).closest('.product-item').find('.product-unit-price');
      var currentProduct = $(this).closest('.tr');

	  	if(!_.isUndefined(doNotUpdatePanoplyContextObject)){
		      $(this).attr("doNotUpdatePanoplyContext", doNotUpdatePanoplyContextObject.doNotUpdatePanoplyContext);
	  	} else{
	  		$(this).removeAttr("doNotUpdatePanoplyContext");
	  	}
  	
  	  self.setSku($(this));

  	  $(this).closest('.product-item').find('.block-unity').css('opacity', 1);
      
  	  self.UpdateCurrentProducts();
  	  $(self.chooseBefore).fadeIn();
	  
  	  if(index === 0){
    		$(self.chooseBefore).fadeOut();
    		//unitPrice.css('opacity', 0);
  	  }else{
    		$(self.chooseBefore).fadeIn();
    		//unitPrice.css('opacity', 1);
  	  }
  	 
  	  self.updateQuantitySelector(currentProduct);
  	  self.UpdateCurrentProducts();
	});

    this.wrapper.on('click change', '#spinnerDecreaser, #spinnerIncreaser, .block-unity input', function() {
      self.manageSpinner($(this));
      self.UpdateCurrentProducts();

      // To update the set selection on server side
      //self.setSku($(this));
      
      var currentProduct = $(this).closest('.tr');
      var currentSpinner = currentProduct.find('.input-number');
      var wrapImages = currentProduct.find('.wrap-images');
      var skuId = wrapImages.attr("sku-id");
      var panoplyId = wrapImages.attr("panoply-id");
      var productGroupId = wrapImages.attr("product-group-id");
      var productId = wrapImages.attr("product-id");
      var modelId = wrapImages.attr("active-color");
      var skuQuantity = currentSpinner.val();
      $().PanoplyContextPlugin('updateSetTypePanoplySelection', panoplyId, productGroupId, productId, skuId, skuQuantity, modelId, "", "");
    });

    this.wrapper.on('click', '.ms__close', function() {
      self.stockData = self.objProducts;
      //self.resetAllProducts();
      //self.setAllProducts(self.stockData);
    });
    
	$('#add-set-panoply-to-cart').on( "click", function(e) {
		
		e.preventDefault();
			
		var itemsSelected = self.getItemsSelected(); // Currently selected skus.

		//Analytics Enhanced Ecommerce AddToCart
		CUBE.Analytics.panoply.sendAddToCartForPanoply(itemsSelected);

		if(typeof itemsSelected !== 'undefined' && itemsSelected.length > 0){ // In Case the selections have made throw an event that conditions to add to cars are meant.
            throwEvent(
            		Events.CART_MULTIPLE_ITEMS_ADDED, 
            		itemsSelected,
	            	$(this));
		} else{ // Do not allow, simply give an error message.
			displayError(Messages('bundle.conversion.zone.select.from.all.products'), csts.MAIN_ERROR, null);
		}
	});
	
	/**
	 * Executed when the load is completed. To build the structure from session.
	 */
	$(document).ready(function(){
		var panoplyTO = $("#modal-product-bundles-title").data("panoply-to");
		var panoplyProductGroups = panoplyTO.panoplyProductGroups;
		var panoplyProductGroup = panoplyProductGroups[0];
		var product = panoplyProductGroup.products[0];
		var selectedSkusByModelId = product.selectedSkusByModelId;
		var models = product.models;
		this.objProducts = {};
		this.objProducts.skus = {};
		this.objProducts.productId = product.id;
		this.objProducts.panoplyId = panoplyTO.id;
		this.objProducts.productGroupId = panoplyProductGroup.id;
		var skus = {};
		var counter = 0;
		var modelIdIndex = 0;
		  $.each(selectedSkusByModelId, function(modelId, panoplySelectedSkuTOs) {
	       	   $.each(panoplySelectedSkuTOs, function (indexOfPanoplySelectedSkuTO, panoplySelectedSkuTO) {
	       	     skus[counter++] = { 
     	 	        'idSku' : panoplySelectedSkuTO.id,
     	 	        'lastSkuId' : "", 
     	 	        'idModel' : modelId,
     	 	        'lastModelId' : "",
                    'indexColor' : self.computeModelIndex(models, modelId),
     	 	        'quantity' : panoplySelectedSkuTO.quantity
	     	 	  };
	    	   });
	       	modelIdIndex++;
		  });
		 
		  this.objProducts.skus = skus;
		  
		if(!_.isUndefined(this.objProducts.skus[0])){  
			self.setProductOnLoad(this.objProducts);
			self.UpdateCurrentProducts();
		}
	});
  },
  
  /**
   * Compute a passed modelId from the list of models.
   */
  computeModelIndex : function(models, modelId) {
	  var foundModelIndex = -1;
	  $.each(models, function(index, model){
		  if(model.id === modelId){
			  foundModelIndex =  index;
		  }
	  });
	  
	  return foundModelIndex;
  },
  
  resetAllProducts : function() {
    for (var i = this.wrapper.find('.product-item').length; i >= 0; i--) {
      var closeCurrentProduct = this.wrapper.find('.btn-close').eq(i);
      this.resetProduct($(closeCurrentProduct), true);
    }
  },

  /**
   * Generates the html structure required when loading selections from session.
   */
  setProductOnLoad : function(data) {
    var self = this;
    $.each(data.skus, function(index, sku){
	      self.addProduct();
	      var newProduct = self.wrapper.find('.product-item').last();
	      var wrapImages = newProduct.find('.wrap-images');
	      var newColors = newProduct.find('.wrap-image');
	      var newSelectpicker = newProduct.find('.selectpicker');
	
//	      $(newColors[sku.indexColor]).trigger('click', [{renderingFromSession : "yes"}]);
	      $(newColors[sku.indexColor]).trigger('click', [{doNotUpdatePanoplyContext : "yes"}]);
	      
	      wrapImages.attr('sku-id', sku.idSku);
	      
	      if(sku.idSku){
		      newProduct.find('.input-number').val(sku.quantity);
		      $(newSelectpicker).find('option[id-sku="'+ sku.idSku +'"]').prop('selected', true);
		      var correctIndex = $(newSelectpicker).find('option').index($(newSelectpicker).find('option[id-sku="'+ sku.idSku +'"]'));
		      newProduct.find("ul li:eq(0)").removeClass("selected");
		      newProduct.find("ul li:eq(" + correctIndex+ ")").addClass("selected");
		      $(newSelectpicker).trigger('change');
	      } 
	  
    });
    this.wrapper.find('.product-item')[0].remove();
    
    this.enableOrDisableAddPanoplyToCartBtnWithInputs(this.getItemsSelected(), this.hasStockForEachSkus());
  },

  setAllProducts : function(data) {
    var self = this;
    $.each(data.skus, function(index, sku){
      self.addProduct();
      var newProduct = self.wrapper.find('.product-item').last();
      var newColors = newProduct.find('.wrap-image');
      var newSelectpicker = newProduct.find('.selectpicker');

      if($(self.wrapper).hasClass('color')){
        $(newColors[sku.indexColor]).trigger('click');
      } else {
        $(newColors[sku.indexColor]).trigger('click');
      }
	  
      newProduct.find('.input-number').val(sku.quantity);
	  newProduct.find('.product-unit-price').html(sku.data.activePrice);
	  
	  $(newSelectpicker).find('option[id-sku="'+ sku.idSku +'"]').prop('selected', true);
	  $(newSelectpicker).trigger('change');
	  
    });
    this.wrapper.find('.product-item')[0].remove();
  },

  manageSpinner : function(self) {
      var currentProduct = $(self).closest('.tr');
      var currentSpinner = currentProduct.find('.input-number');

      if(currentSpinner.val() === '' || currentSpinner.val() < 1)
        currentSpinner.val(1);
      
      if($(self).is('#spinnerDecreaser') && currentSpinner.val() > 1)
          currentSpinner.val(Number(currentSpinner.val()) - 1);

      if($(self).is('#spinnerIncreaser'))
        currentSpinner.val(Number(currentSpinner.val()) + 1);
      
      $(currentProduct).find('.wrap-image.selected').attr('data-quantity', currentSpinner.val());
  },

  getData : function(productSelected) {
    var obj = $(productSelected).attr('data-product');
    this.dataProduct = jQuery.parseJSON(obj); 
  },

  addProduct : function() {
    $(this.chooseBefore).css('display', 'none');
    $('.product-item')
      .last()
      .clone()
      .removeClass('color-active')
      .insertBefore($('.before-choose'));

    var lastProduct = this.wrapper.find('.product-item').last();
    var currentImgSelected = lastProduct.find('.selected');
    
    lastProduct.find('.input-number').val(1);
    lastProduct.find('.product-img img').remove();
    lastProduct.find('.block-selector .bootstrap-select').remove();
    lastProduct.find('.block-unity').removeAttr('style');
    lastProduct.find('.wrap-images').removeAttr('active-color prev-color prev-sku-id');


    if($(this.wrapper).hasClass('color')){
      $('.product-item').removeClass('choosing');
      $(lastProduct).addClass('choosing');
      $(currentImgSelected).removeClass('selected');
    }else if($(this.wrapper).hasClass('size')){
      this.setProduct(lastProduct.find('.wrap-image'));
    }
    lastProduct.find('.product-unit-price').html('');
  },

  resetProduct : function(self, resetAll) {
    if(!$(self).hasClass('.product-item'))
      self = $(self).closest('.product-item');

    var products = this.wrapper.find('.product-item');
    var index = $(products).index(self);
    var currentProduct = $(products[index]);
    //var products = currentProduct.find('.wrap-image');
    var skus = currentProduct.closest('.tr').find('.wrap-image');
    var currentProductWrapImages = currentProduct.find('.wrap-images');
    var skuId = currentProductWrapImages.attr("sku-id");
    currentProductWrapImages.removeAttr("sku-id");
    var currentImg = currentProduct.find('.product-img img');
    
    if($(products).length == 1) {
      var selectpicker = currentProduct.find('.selectpicker');
      currentProduct.find('.input-number').val(1);
      currentProduct.find('.selectpicker ul li:first-child a').trigger('click', [{doNotUpdatePanoplyContext : "yes"}]);
      $(selectpicker).find('option').eq(0).prop('selected', true);
      $(selectpicker).trigger('change', [{doNotUpdatePanoplyContext : "yes"}]);
      
      currentProduct.find('.product-unit-price').html('');
      
      if($(this.wrapper).hasClass('color')){
        this.managePopIn();
        $(skus).removeClass('selected');
        currentImg.remove();
      }
      this.chooseBefore.fadeOut();
      
      this.updateTotalQuantity();
    }else {
      if(resetAll){
        currentProduct.remove();
        this.updateTotalQuantity();
      }else {
    	var afterLineRemoved = function(that, currentProduct) {
    		  currentProduct.remove();
    		  that.updateTotalQuantity();
    	};
    	  
        TweenMax.to($(currentProduct), 0.7 , {height : 0, overflow : 'hidden',
        	onComplete:afterLineRemoved, onCompleteParams:[this, currentProduct]});
        
      }
      
    }

    $(this.chooseBefore).fadeIn();
    
    // Update Selections
    var panoplyId = currentProductWrapImages.attr("panoply-id");
    var productGroupId = currentProductWrapImages.attr("product-group-id");
    var productId = currentProductWrapImages.attr("product-id");
    var modelId = currentProductWrapImages.attr("active-color");
    
    if(_.isUndefined(skuId)){
    	skuId = "";
    }
    
    $().PanoplyContextPlugin('updateSetTypePanoplySelection', panoplyId, productGroupId, productId, "", 0, "", modelId, skuId);
    this.UpdateCurrentProducts();
  },

  setProduct : function(self){
    var currentProduct = self.closest('.tr');
    var skus = currentProduct.find('.wrap-image');
    var index = $(skus).index(self);
    var wrapImages = currentProduct.find('.wrap-images');
    var currentImg = currentProduct.find('.product-img'); 
    var srcImg = $(skus[index]).find('img').attr('src');

    this.getData($(skus[index]));
    
    this.lastColor = $(wrapImages).attr('active-color');
    $(wrapImages).attr('prev-color', this.lastColor);
    this.currentIdColor = $(skus[index]).attr('color-id');
    $(wrapImages).attr('active-color', this.currentIdColor);
    $(wrapImages).attr('prev-sku-id', wrapImages.attr("sku-id"));
    $(wrapImages).removeAttr('sku-id');
    
    // If we are switching model, we need to reinit the sku selected, price and quantity
    $(currentImg).html('<img src="' +srcImg+ '" >');
    $(skus).removeClass('selected');
    $(skus[index]).addClass('selected');
    $(currentProduct).removeClass('choosing').addClass('color-active');
    $(currentProduct).find('.product-unit-price').html('');
    
    this.setDataProduct(currentProduct, i, index);
    
    var panoplyId = wrapImages.attr("panoply-id");
    var productGroupId = wrapImages.attr("product-group-id");
    var productId = wrapImages.attr("product-id");
    var modelId = wrapImages.attr("active-color");
    var previousModelId = wrapImages.attr("prev-color");
    var previousSkuId = wrapImages.attr("prev-sku-id");
    
    if(_.isUndefined(self.attr("doNotUpdatePanoplyContext"))){
	    $().PanoplyContextPlugin('updateSetTypePanoplySelection', panoplyId, productGroupId, productId, "", 0, modelId, previousModelId, previousSkuId);
    }
    
    this.updateQuantitySelector(currentProduct);
    this.updateTotalQuantity();
    
    // The user must select a sku at least to have the button enabled
    $("#add-set-panoply-to-cart").addClass('disabled');
  },

  setDataProduct : function(currentProduct, index, indexProduct) {
    var sizesDropDownObject = $(currentProduct).find('.selectpicker');
    var self = this;

    //SET SELECTPICKER 
    sizesDropDownObject.html('');
    
    var newOption = '<option data-content="">' + Messages('bundle.conversion.zone.size') + '</option>';
    sizesDropDownObject.append(newOption);
    $.each( this.dataProduct, function(index, sku){
        var stockCssClass = (sku.quantity > 0) ? "valgreen" : "valred";
    	
        newOption = "<option id-sku='" + sku.id + 
            "' data-content=\"<div class='size-selected " + sku.quantity + " " + stockCssClass + "'><span class='sortby lib-size'>" + sku.size + 
            "</span><div class='stock-list'><span class='lib-stock'><lang class='lk_pdm-stock'> Stock </lang></span><span class='number-stock'>"+ sku.quantity + 
            "</span></div></div>\">" + sku.size + "</option>";
        
        sizesDropDownObject.append(newOption);
    });
    
    sizesDropDownObject.attr("data-current-model-id", indexProduct);
    sizesDropDownObject.selectpicker('refresh');  
    
    var panoplyId = sizesDropDownObject.data("panoply-id");
    var productGroupId = sizesDropDownObject.data("product-group-id"); 
    var productId = sizesDropDownObject.data('product-id');
  },

  /* Called each time the user change the selected sku (size) */
  setSku : function(self) {
    var currentProduct = $(self).closest('.product-item');
    var currentSpinner = currentProduct.find('.input-number');
    var choices = $(currentProduct).find('ul li');
    var currentChoice = $(currentProduct).find('ul .selected');
    var index = $(choices).index($(currentChoice)) - 1;
    var currentSku = $(currentProduct).eq(index);
    var currentStock = parseInt($(currentProduct).find(".number-stock").html(), 10);
    var currentSelectedWrapImage = $(currentProduct).find('.wrap-image.selected');
    var wrapImages = $(currentProduct).find('.wrap-images');
    var products = $(currentProduct).siblings();
    var skuQuantity = 0;
    $(currentProduct).find('.wrap-image.selected').attr('data-quantity', currentSpinner.val());
    if($(this.wrapper).hasClass('size'))
      this.chooseBefore.fadeIn();
    var selectedSku = $(self).find(":selected");
    this.prevSkuId = this.skuId;
    this.skuId = selectedSku.attr("id-sku");
    for(var i=0; i < products.length; i++) {
      var quantityValue = $(products[i]).find('.block-unity input');
	    if($(products[i]).find('.wrap-images').attr('sku-id') == this.skuId && products.length != 1 && this.skuId !== undefined ){
	        $(products[i]).addClass('already-there');
	        quantityValue.val(parseInt(quantityValue.val()) + parseInt($(currentProduct).find('.block-unity input').val()));
	        skuQuantity =  $(products[i]).find('.block-unity input').get(0).value;
	        this.resetProduct($(currentProduct));
	     }
    }
    
    var previousSkuId = wrapImages.attr("sku-id");
    
    // Data useful to update SET in session
    var panoplyId = wrapImages.attr("panoply-id");
    var productGroupId = wrapImages.attr("product-group-id");
    var productId = wrapImages.attr("product-id");
    var modelId = wrapImages.attr("active-color");
    
    if(index >= 0){
      $(currentProduct).find('.wrap-image.selected').attr('data-quantity', currentSpinner.val());
      
      if($(this.wrapper).hasClass('size')){
        this.chooseBefore.fadeIn();
      }

      // Remember previously selected sku
      var newSkuId = $(self).find(":selected").attr("id-sku");

      // Keep all useful data in wrapimage element
      wrapImages.attr("prev-sku-id", previousSkuId);
      wrapImages.attr("sku-id", newSkuId);
      wrapImages.attr("in-stock", currentStock > 0);
      
      var previousModelId = wrapImages.attr("prev-color");
      
      if(!previousModelId){
    	  previousModelId = modelId;
      }
      
      if(skuQuantity <= 0){
    	  skuQuantity = currentSpinner.val();
      }
      
      if(_.isUndefined(self.attr("doNotUpdatePanoplyContext"))){
	      if (currentStock > 0) {
	    	  $().PanoplyContextPlugin('updateSetTypePanoplySelection', panoplyId, productGroupId, productId, newSkuId, skuQuantity, modelId, previousModelId, previousSkuId);
	      } else {
	    	  $().PanoplyContextPlugin('updateSetTypePanoplySelection', panoplyId, productGroupId, productId, "", 0, "", modelId);
	      }
      }
    } else {
    	// no size selected, we need clean previous sku selection so there is no conflict further
    	if (index < 0) {
    		wrapImages.removeAttr("sku-id");
    	}

    	if(_.isUndefined(self.attr("doNotUpdatePanoplyContext"))){
    		$().PanoplyContextPlugin('updateSetTypePanoplySelection', panoplyId, productGroupId, productId, "", 0, modelId, modelId, previousSkuId);
    	}
    }
    
    this.enableOrDisableAddPanoplyToCartBtnWithInputs(this.getItemsSelected(), this.hasStockForEachSkus());
  },
 


  UpdateCurrentProducts : function() {
    var productsChoosen = this.wrapper.find('.wrap-image.selected');
    var wrapImages = this.wrapper.find('.wrap-images');
    this.objProducts = {};
    this.objProducts.skus = {};
    this.objProducts.productId = wrapImages.attr('product-id');
    this.objProducts.panoplyId = wrapImages.attr('panoply-id');
    this.objProducts.productGroupId = wrapImages.attr('product-group-id');
    
    for (var i = 0; i < productsChoosen.length; i++) {
      this.getData(productsChoosen[i]);
      var currentWrapImages = $(productsChoosen[i]).closest(".wrap-images");
      
      currentWrapImages.data('price', this.dataProduct);

      var currentInputNumber = currentWrapImages.closest(".tr").find('.input-number');
      var quantity = $(currentInputNumber).val();
      var prevColor = currentWrapImages.attr('prev-color');
      var currentColor = currentWrapImages.attr('active-color');
      var prevSku = currentWrapImages.attr('prev-sku-id');
      var currentSku = currentWrapImages.attr('sku-id');
      
      // only update line where a sku is selected (with stock also ? to confirm)
      if (currentSku) {
	      this.objProducts.skus[i] = { 
	        'idSku' : currentSku,
	        'lastSkuId' : prevSku, 
	        'idModel' : currentColor,
	        'lastModelId' : prevColor,
	        'quantity' : quantity
	      };
      } else {
    	  // no selected sku, hide the content in the product unit price block in case a previous model has been selected
    	  currentWrapImages.closest(".tr").find(".product-unit-price").html("");
      }
    }
    
    this.updateProductPrice(this.objProducts, wrapImages.attr("product-id"), "set");
    this.updateTotalQuantity();
  },

  managePopIn : function(self) {
    var index = $('.color .product-item .product-img').index(self);
    var currentSku = this.wrapper.find('.tr').eq(index);
    var products = this.wrapper.find('.product-item');
    var lastProduct = $(products).last();
    var btnCloseLastProduct = $(lastProduct).find('.btn-close');

    if($(lastProduct).hasClass('color-active')){
      if($(currentSku).hasClass('choosing')){
        $(this.chooseBefore).fadeIn();
        $(products).removeClass('choosing');
      }else {
        $(this.chooseBefore).fadeOut();
        $(products).removeClass('choosing');
        $(currentSku).addClass('choosing');
      }
    }else {
      this.resetProduct(btnCloseLastProduct);
      $(products).removeClass('choosing');
      $(currentSku).addClass('choosing');
    }
  },
  
  updateTotalQuantity : function() {
	  var totalQuantity = 0;
	  var products = $(this.wrapper).find('.tr');
	  
	  $.each(products, function(index, product){
		  // only take in consideration lines with sku selected and in stock
		  var wrapImages = $(product).find(".wrap-images");
		  var selectedSkuId = wrapImages.attr("sku-id");
		  var inStock = wrapImages.attr("in-stock") == "true";
		  if (selectedSkuId && inStock) {
			  var quantity = $(product).find(".input-number").val();
			  totalQuantity = totalQuantity + parseInt(quantity);
		  }
	  });
	  
	  if (totalQuantity !== 0) {
		  $(this.wrapper).find(".content-footer .unity").html(Messages("bundle.conversion.zone.totalQuantity", totalQuantity));
	  } else {
		  $(this.wrapper).find(".content-footer .unity").html("");
		  $(this.wrapper).find(".content-footer .price").html("");
	  }
  },
  
  hasStockForEachSkus : function() {
	  var hasStockForAll = true;
	  var products = $(this.wrapper).find('.tr:not(.choosing,.before-choose)');
	  
	  $.each(products, function(index, product){
		  // ignore lines in choosing mode
		  // stock is OK if there is a sku selected and more than 0 in stock...
		  var selectedSkuId = $(product).find(".wrap-images").attr("sku-id");
		  hasStockForAll = hasStockForAll && selectedSkuId && $(product).find(".wrap-images").attr("in-stock") === "true";
	  });
	  	  
	  return hasStockForAll;
  },
  
	/**
	 * Generate an object to send to the Panoply Pricing Service, for a current price.
	 * When one of the dropdown has not been selected, a default sku is used for pricing that product.
	 */
  getProductSkusSelected : function(currentSelectionsObject, productId){
	  if(!currentSelectionsObject || !productId){
		  return;
	  }
	  
	  var selectedSkus = currentSelectionsObject.skus;
	  
	  if(!selectedSkus){
		  return;
	  }
	  
	  var productSkus = [];
	  var item = {};
	  item["@class"] = "com.decathlon.cube.commerce.pricing.api.ProductSkusRequestTO";
	  
	  $.each( selectedSkus, function(index, sku){
		  var skuId = sku.idSku;
		  var skuQuantity = sku.quantity;
		  
		  if(!skuId || !skuQuantity){
			  return;
		  }
		  
			productSkus.push({
				"productId" : productId,
				"skuId" : skuId,
				"quantity" : skuQuantity
		  });
	  });
	  
	  item.pricingCommerceItemInputTOs = productSkus;
	  
	  return item;
  	},

	/**
	 * Generate an array of items {"catalogRefId","productId","quantity"} to send to the CartModifier FormHander.
	 */
	getItemsSelected : function(){
		  var itemsSelected = [];
		  this.UpdateCurrentProducts();
	    var localObjProducts = this.objProducts;
	    
	    if(_.isUndefined(this.objProducts) && _.isNull(this.objProducts)){
	  	  return itemsSelected;
	    }
	    
	    var productId = localObjProducts.productId;
	    
	    if(!productId){
	  	  return itemsSelected;
	    }
	    
		  $.each( localObjProducts.skus, function(index, sku){
			  var skuId = sku.idSku;
			  var skuQuantity = sku.quantity;
			  
			  if(!skuId || !skuQuantity){
				  return;
			  }
			  
			  itemsSelected.push({"catalogRefId" : skuId,
								    "productId" : productId,
								    "quantity": skuQuantity
								});
		  });

		  return itemsSelected;
	},

	/**
	 * Enable or disable the add to cart controls, depending on wether the items have been disabled.
	 * @param itemsSelected array of skus selected.
	 */
	enableOrDisableAddPanoplyToCartBtnWithInputs : function(itemsSelected, allProductsInStock){
		if(allProductsInStock && typeof itemsSelected !== 'undefined' && itemsSelected.length > 0){
			$("#add-set-panoply-to-cart").removeClass('disabled');
			$(".before-choose").show();
		} else{
			$("#add-set-panoply-to-cart").addClass('disabled');
			$(".before-choose").hide();
		}				
	},
	
	updateProductPrice : function(currentSelectionsObject, productId, panoplyType){
		var item = this.getProductSkusSelected(currentSelectionsObject, productId);
		$().PricingPlugin('fetchPanoplyLatestPrice', item, ".product-unit-price", ".content-footer .price", panoplyType);
	},
	
    /**
     * Hide quantity selector if the selected sku is not in stock or if there is no selected sku
     */ 
	updateQuantitySelector : function(currentProduct) {
	  var choices = currentProduct.find('ul li');
      var currentChoice = currentProduct.find('ul .selected');
      var index = $(choices).index($(currentChoice));
      var hasStock = currentProduct.find('.wrap-images').attr("in-stock") == "true";
      
      currentProduct.find(".block-unity").css("opacity", (index === 0 || !hasStock) ? 0 : 1);
   	}
};
/*jshint multistr: true */

// Class loading
Cube = (typeof Cube === 'object') ? Cube : {};
Cube.InitSliderSlick = (typeof Cube.InitSliderSlick === 'object') ? Cube.InitSliderSlick : {};

Cube.InitSliderSlick = function(){};

Cube.InitSliderSlick.prototype = {

  initImageCarousel : function($imageCarousel, $imageCarouselNav){

    var _this = this;

    $imageCarousel.not('.slick-initialized').slick({
      slidesToShow: 1,
      dots: false,
      arrows:false,
      infinite: false,
      speed: 500,
      fade: true,
      cssEase: 'linear',
      useCSS:true,
      draggable: false,
      zIndex: 0,
      asNavFor: $imageCarouselNav
    });
    
    $imageCarouselNav.not('.slick-initialized').slick({
      slidesToShow: 3,
      slidesToScroll: 1,
      dots: false,
      arrows:true,
      infinite: false,
      speed: 500,
      draggable: false,
      variableWidth: true,
      focusOnSelect: true,
      centerMode: false,
      asNavFor: $imageCarousel,
      responsive: [
         {
          breakpoint: decathlon.uxBreakpoints.smMin,
          settings: {
            slidesToShow: 2,
            draggable: true
          }
        }
      ]
    });
  },

/*  multiplyProducts : function(){

    var _this = this;

    $oneProduct = _this.el.find('.msb__product');

    for (var i = 0; i < 10; i++) {
      _this.el.find('.msb__products-list').append($oneProduct.clone());
    }

  },*/


  imageCarouselDispatcher : function($product){
    var _this = this;

    var $imageCarousel;
    var $imageCarouselNav;
    var imagesLength;

    $imageCarousel = $product.find('.msb__images-carousel');
    $imageCarouselNav = $product.find('.msb__colors-carousel');
    imagesLength = $imageCarousel.find('.msb__image').length;

    if($imageCarousel.length > 0 && $imageCarouselNav.length > 0 && imagesLength > 1){  
      _this.initImageCarousel($imageCarousel, $imageCarouselNav);
    }

    $product.find('.msb__color').removeClass('slick-current');
    $product.find('*[data-class="current"]').trigger('click');
  },

  init : function () {
    this.el = $('.modal-sidebar');
    var _this = this;

    //_this.multiplyProducts();

    _this.productsArray = _this.el.find('.msb__product');

    /* uses the open event associated to the .mobile-sidebar methods */
    _this.el.on('open', function(){
      _this.productsArray.each(function(){
        _this.imageCarouselDispatcher($(this));
      });
    });
  },

  loading : function() {
    this.init();
  }
};

(function($) {
  $.fn.extend({
    uxProductFiltersRangeRender: function() {

      var $uxProductFilters = $(this);

      $uxProductFilters.range = $('#range_filter');

      if ($uxProductFilters.range.length > 0 && $.fn.ionRangeSlider) {

        $uxProductFilters.range.slider = $uxProductFilters.range.find('input.range');
        $uxProductFilters.range.minValue = $uxProductFilters.range.find('.min-value');
        $uxProductFilters.range.maxValue = $uxProductFilters.range.find('.max-value');

        $uxProductFilters.range.sliderPrefix = function() {
          if (typeof $uxProductFilters.range.slider.data("currency-prefix") !== 'undefined') {
            $uxProductFilters.range.slider.prefix = $uxProductFilters.range.slider.data("currency-prefix") + '\xa0';
          } else {
            $uxProductFilters.range.slider.prefix = '';
          }
          return $uxProductFilters.range.slider.prefix;
        };

        $uxProductFilters.range.sliderPostfix = function() {
          if (typeof $uxProductFilters.range.slider.data("currency-postfix") !== 'undefined') {
            $uxProductFilters.range.slider.postfix = '\xa0' + $uxProductFilters.range.slider.data("currency-postfix");
          } else {
            $uxProductFilters.range.slider.postfix = '';
          }
          return $uxProductFilters.range.slider.postfix;
        };

        $uxProductFilters.range.printMinMaxValues = function(slider) {
          $uxProductFilters.range.minValue.val($uxProductFilters.range.sliderPrefix() + slider.from.toLocaleString(Cube.Utils.getCurrentLocale()) + $uxProductFilters.range.sliderPostfix());
          $uxProductFilters.range.maxValue.val($uxProductFilters.range.sliderPrefix() + slider.to.toLocaleString(Cube.Utils.getCurrentLocale()) + $uxProductFilters.range.sliderPostfix());
        };

        $uxProductFilters.range.slider.ionRangeSlider({
          type: 'double',
          grid: false,
          hide_from_to: true,
          hide_min_max: true,
          min: $uxProductFilters.range.slider.data("min"),
          max: $uxProductFilters.range.slider.data("max"),
          from: $uxProductFilters.range.slider.data("from"),
          to: $uxProductFilters.range.slider.data("to"),
          prefix: $uxProductFilters.range.sliderPrefix(),
          postfix: $uxProductFilters.range.sliderPostfix(),
          onStart: function(slider) {
            $uxProductFilters.range.printMinMaxValues(slider);
          },
          onChange: function(slider) {
            $uxProductFilters.range.printMinMaxValues(slider);
          },
          onFinish: function(slider) {
        	  // Todo: Delete test after UX integration
        	  if (typeof $uxProductFilters.range.PriceSliderPlugin !== 'undefined') {
        		  $uxProductFilters.range.PriceSliderPlugin('ajaxPriceSliderListing', slider);
        	  }	
        	  $uxProductFilters.range.trigger("rangeChange.Analytics", slider);
          }
        });

        $.fn.extend({
          uxProductFiltersInputChange: function() {
            var $this = $(this);
            $this.slider = $uxProductFilters.range.slider.data("ionRangeSlider");
            if ($this.length > 0 && $this.jquery) {
              $this.on('blur', function() {
                if ($this.hasClass('min-value')) {
                  if ($this.cleanVal() > $this.slider.options.to) {
                    $this.val($uxProductFilters.range.maxValue.cleanVal() + ' €');
                  }
                  $this.slider.update({
                    from: $this.cleanVal()
                  });
                } else {
                  if ($this.cleanVal() < $this.slider.options.from) {
                    $this.val($uxProductFilters.range.minValue.cleanVal() + ' €');
                  }
                  $this.slider.update({
                    to: $this.cleanVal()
                  });
                }
              });
            } /* END OF IF */
          } /* END OF uxProductFiltersInputChange() */
        });


        $uxProductFilters.range.minValue.uxProductFiltersInputChange();
        $uxProductFilters.range.maxValue.uxProductFiltersInputChange();

      } /* end $uxProductFilters.range.length */
    } /* end uxProductFiltersRangeRender */
  });
})(jQuery);

$('#product-filters').uxProductFiltersRangeRender();




;(function ( $, window, document, undefined ) {

    var pluginName = 'uxProductFiltersMethods',

        defaults = {

        };

    var mediumscreen = 1180;
    
    function Plugin( element, options ) {
        this.el = $(element);
        this.options = $.extend( {}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
    }


    Plugin.prototype = {
        
        setTogglerText : function(){
          var _this = this,
              buttonText = "";
          if ($('body').hasClass('filters-open')) {
            if(decathlon.uxBreakpoints.is('large-screen')){
              buttonText = _this.el.toggler.data('closeTextLong');
            } else {
              buttonText = _this.el.toggler.data('openTextShort');
            }
          } else {
            if(decathlon.uxBreakpoints.is('large-screen')){
              buttonText = _this.el.toggler.data('openTextLong');
            } else {
              buttonText = _this.el.toggler.data('openTextShort');
            }
          }

          _this.el.toggler.find('.text').html(buttonText);
        },

        setFilterContentHeight : function(){
          var _this = this;
          if ($('body').hasClass('filters-open')){

              extraHeight = _this.el.cancelButton.outerHeight() + 20;
              _this.el.facetsContent.css({'height':
                $(window).height() - (
                  extraHeight +
                  _this.el.facetsContainer.find('.m-filters-faceting-footer').outerHeight()
                  )
              });
          
          }
        },

        closeFiltersMobile : function(){
          var _this = this;

          TweenMax.set(_this.el.facetsContainer, {zIndex:9999});

          TweenMax.to(_this.el.facetsContainer, 0.5, {scale:0.5, opacity:0, ease:Power4.easeInOut, onStart: function(){
            
            _this.el.css({'height':_this.el.closedHeight});
            
            setTimeout(function(){
              $('body').removeClass('in');
              $('body').removeClass('filters-open');
              // $(window).scrollTop(_this.el.facetsContent.windowScrollTop);
              // _this.el.filtersMainContainer.css({'position':''});
            },300);

          }, onComplete:function(){

            TweenMax.set(_this.el.facetsContainer, {scale:1, opacity:1});

            _this.el.facetsContent.css({'height':0});
            
            if(!_this.el.hasClass('sticky')){
              _this.el.css({'height': ''});
            }

            _this.setTogglerText();

            $(window).trigger('loadingProducts');
            // $(window).trigger('filterpopup-closed');

          }});
        },

        

        setStyleBar : function () {
          var _this = this,
              wrapper = $('.m-filters'),
              seeFilterBtn = $('.m-filters-filtersBtn'),
              nbProducts = $('.m-filters-productsCount'),
              wrapFilter = $('.wrap-filters-tags'),
              filters = $('.wrap-filters-tags .m-filters-tags'),
              resetFilter = $('.m-filters-resetFilter'),
              section = $('.m-filters-settings-item.text-right'),
              widthFilterMaargin = ($('body.filters-open')) ? 30 : 20,
              wrapFilterWidth = wrapper.width() - ( seeFilterBtn.outerWidth() + nbProducts.outerWidth() + section.outerWidth()),
              filtersWidth = wrapFilter.width() - resetFilter.outerWidth() - widthFilterMaargin;

          if(_this.el.find('.wrap-filters-tags .m-filters-tags').length > 0)
            wrapFilter.css('max-width', wrapFilterWidth);
          else
            wrapFilter.css('width', wrapFilterWidth);

          filters.css('max-width', filtersWidth);
        },

        setFiltersScrollbar : function(){
          var _this = this;

          _this.el.find('.m-filters-item-scroll').each(function(){
            if($(this).has_scrollbar()) {
              $(this).addClass('overflow-scroll');
            } else {
              $(this).removeClass('overflow-scroll');
            }
          });
        },

        openFiltersDesktop : function(){
          var _this = this;

          if(window.TweenMax){
            TweenMax.to(_this.el.facetsContent, 0.5, {height:_this.el.facetsContent.heightValue, ease:Power4.easeInOut, onStart: function(){
              
              //$('body').addClass('filters-open');
              _this.setTogglerText();
             // _this.setFiltersScrollbar();

            }, onComplete:function(){

              _this.el.facetsContent.css({'height':''});

              $('body').addClass('in');

            }});
          } else {
            /* fallback to the tweenmax plugin*/
          }

          this.setStyleBar();
        },

        openFiltersMobile : function(){
          var _this = this;
            
          _this.el.facetsContent.windowScrollTop = $(window).scrollTop();
          $(window).scrollTop(0);
          _this.el.css({'height':_this.el.outerHeight()});

          if(window.TweenMax){

            TweenMax.from(_this.el.facetsContainer, 0.5, {scale:0.9, opacity:0, ease:Power4.easeInOut, onStart: function(){
              $('body').addClass('filters-open');
              _this.setFilterContentHeight();
              _this.setTogglerText();
              _this.setFiltersScrollbar();
            }, onComplete:function(){
              $('body').addClass('in');
            }});

          } else {
            /* fallback to the tweenmax plugin*/
          }
        },


        openFilters : function(){
          var _this = this;
              if ($(window).width() > mediumscreen){
                 _this.openFiltersDesktop();

              }  else {
                _this.openFiltersMobile();
              }
        },

        stickyFiltersMobile : function(){
          var _this = this;

          if(_this.el[0].getBoundingClientRect().top <= 0){

            if(!_this.el.hasClass('sticky')){
              _this.el.css({'height':_this.el.outerHeight()});
              // _this.el.css({ 'height' : _this.el.closedHeight});
              // _this.el.find('.m-filters').css({ 'height' : _this.el.closedHeight});
              _this.el.addClass('sticky');
            }

          } else {
            if (!$('body').hasClass('filters-open')) {
              _this.el.css({ 'height' : ''});
              // _this.el.find('.m-filters').css({ 'height' : ''});
             // _this.el.addClass('sticky');
            }
            _this.el.removeClass('sticky');
          }
          _this.setTogglerText();
        },

        updateTotalSelectedFilters : function(){
          if ($('.wrap-filters-tags .m-filters-tags .list-inline li').length !== 0) {
            $('.titlefilterbloc .nbfilter').html($('.wrap-filters-tags .m-filters-tags .list-inline li').length); 
            $('.filtersTotal').html($('.wrap-filters-tags .m-filters-tags .list-inline li').length);
            $('.wrap-filters-tags').addClass('filterb');
            
          }else{
            $('.wrap-filters-tags .nbfilter').hide();
            $('.m-filters-filtersBtn .filtersTotal').hide();
            $('.wrap-filters-tags').removeClass('filterb');
          }

          if($('.wrap-filters-tags-mobile .m-filters-tags .list-inline li').length !== 0){
              $('.m-filters-filtersBtn').addClass('filterb');
          }else{
              $('.m-filters-filtersBtn').removeClass('filterb');
          }

        },


        calculateSelectedFiltersWidth : function(){

          var filtersActions = $('.m-filters-actions'),
              filtersTags = $('.wrap-filters-tags .m-filters-tags'),
              wrapFilter = $('.wrap-filters-tags'),
              resetFilterButton = $('.m-filters-resetFilter'),
              list = $('.wrap-filters-tags .m-filters-tags').find('.list-inline'),
              ulWidth = list.outerWidth(),
              listLi = list.find('li'),
              liWidth = 0;

          listLi.each(function(){
            liWidth += $(this).outerWidth();
          });

          var widthMax = $('.list-inline li').length * $('.list-inline li').outerWidth();
          var filtersTagsWidth = filtersTags.outerWidth();
          if(liWidth > filtersTagsWidth){
            
            $('#product-filters').addClass('limiterWidth');
            $('.js-filtersDrag').width(liWidth + 10);
            filtersTags.width('auto');
            Draggable.create(
              $('.js-filtersDrag-container'),{
                type:"scrollLeft",
                dragClickables:"true",
                cursor:"pointer",
                edgeResistance:1,
                throwProps:true,
                lockAxis:true,
                onDrag:function(){
                  if(filtersTags.scrollLeft() > 0 && filtersTags[0].scrollWidth - filtersTags.scrollLeft() != filtersTags[0].offsetWidth){
                    filtersActions.addClass('filtersStartUnreached filtersEndUnreached');
                  }
                  if(filtersTags.scrollLeft() === 0 ){
                    filtersActions.removeClass('filtersStartUnreached');
                  }
                  if(filtersTags[0].scrollWidth - filtersTags.scrollLeft() == filtersTags[0].offsetWidth){
                    filtersActions.removeClass('filtersEndUnreached');
                  }
                }
              }
            );
            filtersTags.css('overflowX', 'hidden');
            filtersActions.addClass('filtersEndUnreached');
          }else {
            $('#product-filters').removeClass('limiterWidth');
            filtersTags.removeAttr('style');
            filtersActions.removeClass('filtersStartUnreached filtersEndUnreached');
          }
          this.centerSelectedFilters();
        },

        centerSelectedFilters : function(){
          var totalWidth = $('.wrap-filters-tags .m-filters-tags').outerWidth() + $('.m-filters-resetFilter').outerWidth(),
              filtersWidth = 0,
              resetWidth = $('.m-filters-resetFilter').find('.reset-filters').outerWidth();
          $('.wrap-filters-tags .m-filters-tags .list-inline > li').each(function(){
            filtersWidth += $(this).outerWidth();
          });
        },

        setOutOfStock : function (self) {

          // Show message out-of-stock
          this.wrapperPorductList = $('#product-list');
          this.wrapperProduct = this.wrapperPorductList.find('.inner-element');
          this.productActive = $(self).find('.slick-current');
          this.outOfStockMessage = $(self).find('.message-out-of-stock');
          if(!self){
            for(i = 0; i < this.wrapperProduct.length; i++){
              var firstChildProduct = $(this.wrapperProduct[i]).find('.product-result-thumbnail').first();
              if( firstChildProduct.hasClass('unavailable'))
                $(this.wrapperProduct[i]).find('.message-out-of-stock').addClass('active');
            }
          }

          if(self && $(self.context).hasClass('unavailable') || $(this.productActive).hasClass('unavailable'))
            $(this.outOfStockMessage).addClass('active');
          else
            $(this.outOfStockMessage).removeClass('active');

        },

        getCancelButtonValues : function(){
        	var originalFilterDimension = location.pathname.split("N-")[1];
        	$("#base-url-for-filters").data("original-filter-dimension", originalFilterDimension);
        	$("#base-url-for-filters").data("original-url", location.href);
        },
        init : function(){
          var _this = this;
          var switchScreen = false; 

          window.uxProductFiltersValues = window.uxProductFiltersValues || {};

          $(window).on('scroll', function() {
            //$(window).width() > mediumscreen
            if($(window).width() < mediumscreen){
              _this.stickyFiltersMobile();
            }
          });
          
          _this.el.toggler = _this.el.find('.m-filters-toggler');
          _this.el.validateButton = _this.el.find('#validate-filters');
          _this.el.cancelButton = _this.el.find('#cancel-filters');
          _this.el.filtersMainContainer = _this.el.find('.m-filters');
          _this.el.facetsContainer = _this.el.find('.m-filters-faceting');
          _this.el.facetsContent = _this.el.find('.m-filters-faceting-content');
          _this.el.facetsContent.heightValue = _this.el.facetsContent.height();
          _this.theOtherElements = $('#top-message-bar, #container-header, .m-breadcrumbs, #product-list-bg, #product-list-top, #listing-product, #spotlightFloor, #globalAverageRating, .block-footer');
          _this.selectedMobile = $('.wrap-filters-tags.mobile');

          var filterReinit = function(){
            _this.setTogglerText();
            _this.setFilterContentHeight();
            _this.el.closedHeight = _this.el.height();
            _this.setFiltersScrollbar();
            _this.setStyleBar();
          };
          var radioVisualFilters = $('.visual-categories input[type="radio"]');
          $(window).on('resize.filter-reinit', function(){
            filterReinit();
          });
          filterReinit();

          $('body').on('click','.m-filters-toggler', function(){

              if ($('body').hasClass('filters-open')) {
                _this.closeFiltersMobile();
              } else {
                _this.getCancelButtonValues();
                _this.openFilters();
              } 
              _this.updateTotalSelectedFilters();
          });

          $('body').on('click', '#validate-filters', function(e){
            _this.closeFiltersMobile();
            _this.updateTotalSelectedFilters();
          });

          $('body').on('click', '#cancel-filters', function(e){
            //e.preventDefault();
            _this.closeFiltersMobile();
            _this.updateTotalSelectedFilters();
          }); 


          $('.reset-filters').on('click', function() {
            //$('.m-filters-resetFilter').css('width', 'auto');
            //_this.closeFilters();
          });

          /* END OF CLICK */
          
          $('body').delegate('.slick-slide, .slick-arrow', 'click drop', function () {
            var selfFocus  = CUBE.Analytics.utils.pagelist.getProduct(this);
            _this.setOutOfStock(selfFocus);
          });

          $('body').delegate('#more_product_a', 'click', function () {
            setTimeout(function(){
              _this.setOutOfStock();
            }, 2000);
          });

          $('body').delegate('.slick-product', 'swipe', function () {
              var selfFocus  = CUBE.Analytics.utils.pagelist.getProduct(this);
              _this.setOutOfStock(selfFocus);
          });

          $('.wrap-visual-filter.visual-links h2').on('click', function(){
            $(this).closest('.visual-links').toggleClass('open');
          });

          radioVisualFilters.on('click',function() { 
            radioVisualFilters.each(function(){
              this.checked = false;
            });
            this.checked = true; 
          });

          $( window ).resize(function(e) {
            if(decathlon.uxBreakpoints.is('large-screen')){
              _this.updateTotalSelectedFilters();
              _this.calculateSelectedFiltersWidth();
              _this.centerSelectedFilters();
              _this.openFiltersDesktop();
              switchScreen = true; 

            }else if (switchScreen === true ){
                _this.closeFiltersMobile();
                switchScreen = false;
            }
            
          });


          setTimeout(function(){
            _this.setOutOfStock();
          }, 2000);
          this.updateTotalSelectedFilters();
        }
    };

    $.fn[pluginName] = function ( options ) {

        var args = arguments;

        var createPluginInstance = function(_this){
          if (!$.data(_this, 'plugin_' + pluginName)) {
              $.data(_this, 'plugin_' + pluginName, new Plugin( _this, options ));
          }
        };

        if (options === undefined || typeof options === 'object') {

            return this.each(function () {
                
                createPluginInstance(this);

            });

        } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
            
            var returns;

            this.each(function () {

                createPluginInstance(this);

                var instance = $.data(this, 'plugin_' + pluginName);

                if (instance instanceof Plugin && typeof instance[options] === 'function') {
                    returns = instance[options].apply( instance, Array.prototype.slice.call( args, 1 ) );
                }

                if (options === 'destroy') {
                  $.data(this, 'plugin_' + pluginName, null);
                }
            });

            return returns !== undefined ? returns : this;
        }
    };

}(jQuery, window, document));

$("#product-filters").uxProductFiltersMethods();
var categoryIntro = $('#category-intro');

if(categoryIntro.length > 0) {

  var truncatedBlock = $('.mobile-truncated');
  var truncatedBlockHeight = parseInt($('.mobile-truncated').outerHeight(), 10);
  var truncatedBlockLineHeight = parseInt(truncatedBlock.css('line-height').replace('px',''), 10);

  if(truncatedBlock.length > 0){
    var mobileTruncatedCollapseBlock = function () {
      truncatedBlock.attr('aria-expanded', 'false');
      truncatedBlock.removeClass('expanded');
    };

    var mobileTruncatedExpandBlock = function () {
      truncatedBlock.attr('aria-expanded', 'true');
      truncatedBlock.addClass('expanded');
    };

    $(document).on('click touchend', '.read-more', function(){
      mobileTruncatedExpandBlock();
    });

    $(window).on('enter-small-screen', function(){
      mobileTruncatedCollapseBlock();
    });

    $(window).on('exit-small-screen', function(){
      mobileTruncatedExpandBlock();
    });

  }

}
var categoryTabs = $('#category-tabs .category-tabs-nav .categories');

if(categoryTabs.length > 0 && $.fn.slick) {

	var categoryTabsSlickActivate = function(){
      var numberSlideLarge = (($('.category.current.static').length > 0) ? 4 : 5 );
      var numberSlide1080 = (($('.category.current.static').length > 0) ? 3 : 4 );
      var numberSlide960 = (($('.category.current.static').length > 0) ? 2 : 3 );

      categoryTabs.slick({
        dots: false,
        infinite: false,
        speed: 500,
        slidesToShow: numberSlideLarge,
        slidesToScroll: 1,
        variableWidth:false,
        edgeFriction:0,
        focusOnSelect:false,
        useCSS:true,
        useTransform:true,
        responsive: [
          {
            breakpoint: decathlon.uxBreakpoints.mdMin,
            settings: {
              slidesToShow: numberSlide1080,
              slidesToScroll: 1
            }
          },
          {
            breakpoint: 960,
            settings: {
              slidesToShow: numberSlide960,
              slidesToScroll: 1
            }
          }
        ]
      });
    };

    var categoryTabsSlickDesactivate = function(){
      // categoryTabs.slick('unslick');
    };

    $(window).on('enter-small-screen', function(){
      categoryTabsSlickDesactivate();
    });

    $(window).on('enter-large-screen', function(){
      categoryTabsSlickActivate();
    });

} /* ! IF */
;(function (window, $, document, undefined) {

  var prototypeMethods = prototypeMethods || {};


  prototypeMethods.zhDictionary = function(){
    return [
    {
      "zh": "æ»‘é›ªã€æ»‘é›ªæ¿ã€æ— èˆµé›ªæ©‡",
      "pingying": "Hua xue, Hua xue ban, Wu tuo xue qiao"
    },
    {
      "zh": "æŽ’çƒå’Œæ²™æ»©æŽ’çƒ",
      "pingying": "Pai qiu, Sha tan pai qiu"
    },
    {
      "zh": "èˆªæµ·è¿åŠ¨",
      "pingying": "Hang hai yun dong"
    },
    {
      "zh": "é£Žç­å†²æµªæ¿å’Œä¾§ç¿¼",
      "pingying": "Feng zheng chong lang ban, Ce yi"
    },
    {
      "zh": "å¥æ­¥èµ°è¿åŠ¨",
      "pingying": "Jian bu zou yun dong"
    },
    {
      "zh": "ç©ºæ‰‹é“",
      "pingying": "Kong shou dao"
    },
    {
      "zh": "è·†æ‹³é“",
      "pingying": "Tai quan dao"
    },
    {
      "zh": "ä¹’ä¹“çƒè¿åŠ¨",
      "pingying": "Ping Pang qiu yun dong"
    },
    {
      "zh": "è½®æ»‘",
      "pingying": "Lun hua"
    },
    {
      "zh": "æ½œæ°´ã€æµ®æ½œ",
      "pingying": "Qian shui, Fu qian"
    },
    {
      "zh": "æˆ·å¤–å±±åœ°è¿åŠ¨",
      "pingying": "Hu wai shan di yun dong"
    },
    {
      "zh": "èˆžè¹ˆ",
      "pingying": "Wu dao"
    },
    {
      "zh": "ç¯®çƒè¿åŠ¨",
      "pingying": "Lan qiu yun dong"
    },
    {
      "zh": "æ¸¸æ³³ã€æ°´ä¸Šå¥èº«ã€æ°´çƒ",
      "pingying": "You yong, Shui shang jian shen, Shui qiu"
    },
    {
      "zh": "å¼“ç®­",
      "pingying": "Gong jian"
    },
    {
      "zh": "é©¬æœ¯è¿åŠ¨",
      "pingying": "Ma shu yun dong"
    },
    {
      "zh": "é«˜å°”å¤«",
      "pingying": "Gao er fu"
    },
    {
      "zh": "å†²æµªã€èº«ä½“å†²æµªæ¿ã€æ»‘æ°´",
      "pingying": "Chong lang, Shen ti chong lang ban, Hua shui"
    },
    {
      "zh": "è·‘æ­¥ã€è¶Šé‡Žè·‘ã€ç”°å¾„",
      "pingying": "Pao bu, Yue ye pao, Tian jin"
    },
    {
      "zh": "ç½‘çƒè¿åŠ¨",
      "pingying": "Wang qiu yun dong"
    },
    {
      "zh": "è¶³çƒ",
      "pingying": "Zu qiu"
    },
    {
      "zh": "å¥èº«è¿åŠ¨",
      "pingying": "Jian shen yun dong"
    },
    {
      "zh": "ç¾½æ¯›çƒè¿åŠ¨",
      "pingying": "Yu mao qiu yun dong"
    },
    {
      "zh": "è‡ªè¡Œè½¦è¿åŠ¨",
      "pingying": "Zi xing che yun dong"
    },
    {
      "zh": "åž‚é’“",
      "pingying": "Chui diao"
    },
    {
      "zh": "æ”€å²©ã€é«˜å±±æ”€ç™»è¿åŠ¨",
      "pingying": "Pan yan, Gao shan pan deng yun dong"
    },
    {
      "zh": "ç‘œä¼½ã€æ™®æ‹‰æ",
      "pingying": "Yujiaã€Pu la ti"
    },
    {
      "zh": "æ³•å¼æ»šçƒ",
      "pingying": "Fa shi gun qiu"
    }
  ];
  };

  prototypeMethods.getPronunciationZh = function(name) {

    var _this = this;

    var pingying = '' + $.map(_this.zhDictionary(), function(e,i){
      if( e.zh === name ) {
        return e.pingying;
      }
    });

    return pingying;
  };

  prototypeMethods.initJqueryFilter = function(){

    /*https://gist.github.com/oziks/3664787*/
    $.expr[':'].containsChar = function(a, i, m) {

      var element = $(a).text().removeDiacritics();
      var search = m[3].removeDiacritics();

      if (!search) return false;
      return new RegExp(search,"i").test(element);
    };
  };

  prototypeMethods.wrappSports = function(){

    var _this = this;

    var i;

    var orderingText, pingying;

    var $sportsArray = _this.$sportsCarousel.find('a');

    $sportsArray.each(function(){

      originalText = $(this).find('.text').text();

      if($('html').attr('lang') === 'zh'){
        pingying = _this.getPronunciationZh(originalText);
        orderingText = pingying !== "" ? pingying : 'Pingying not provided';
      } else {
        orderingText = originalText;
      }
      
      $(this).attr('data-ordering-text', orderingText);

    });

    var aText, bText;

    groupedArrayofSports = {};

    _this.orderedSportsArray = $sportsArray.sort(function(a, b){
      aText = $(a).data('ordering-text');
      bText = $(b).data('ordering-text');
      if(aText < bText) return -1;
      if(aText > bText) return 1;
      return 0;
    });

    _this.orderedSportsArray.each(function(){
      var firstChar = $(this).data('ordering-text').charAt(0).removeDiacritics();
      groupedArrayofSports[firstChar] = groupedArrayofSports[firstChar] || [];
      groupedArrayofSports[firstChar].push($(this));

    });
    

    var carouselOutput = "";
    

    if($('html').attr('lang') !== 'zh'){

      carouselOutput = '<div class="sport-groups-wrapper alpha">';

      for (var k in groupedArrayofSports){
          if (groupedArrayofSports.hasOwnProperty(k)) {

            carouselOutput += '<div class="sports-group">';
            carouselOutput +=   '<div class="sports-wrapper">';
            carouselOutput +=     '<div class="letter"><span>' + k + '</span></div>';
            carouselOutput +=     '<div class="sports">';

            var sportsLength = groupedArrayofSports[k].length;
            var midpoint = sportsLength%2 === 0 ? sportsLength/2 : (sportsLength/2) + 1;

            var firstLineOfSports = [];
            var secondLineOfSports = [];

            if(sportsLength > 1){
              firstLineOfSports = groupedArrayofSports[k].slice(0, midpoint);
              secondLineOfSports = groupedArrayofSports[k].slice(midpoint, sportsLength);

              if(firstLineOfSports.length > 0){
                carouselOutput +=    '<div class="line">';
                                for(i in firstLineOfSports){
                                  carouselOutput += firstLineOfSports[i][0].outerHTML;
                                }
                carouselOutput +=   '</div>';
              }

              if(secondLineOfSports.length > 0){
                carouselOutput +=   '<div class="line">';
                              for(var j in secondLineOfSports){
                                carouselOutput += secondLineOfSports[j][0].outerHTML;
                              }
                carouselOutput +=   '</div>';
              }

            } else {
              carouselOutput +=     '<div class="line">';
              carouselOutput +=       groupedArrayofSports[k][0][0].outerHTML;
              carouselOutput +=     '</div>';
            }

            carouselOutput +=     '</div>';
            carouselOutput +=   '</div>';
            carouselOutput += '</div>';
          }
      }

      carouselOutput +=     '</div>';

      _this.$sportsCarousel.empty().append($(carouselOutput));

    } else {


      _this.$sportsCarousel.addClass('sbs').slick({
        dots: true,
        arrows:true,
        infinite: false,
        speed: 300,
        rows:2,
        slidesPerRow: 5,
        slidesToScroll: 1,
        useCSS:true,
        useTransform:true,
        variableWidth:false,
        responsive: [
          {
            breakpoint: decathlon.uxBreakpoints.lgMin,
            settings: {
              slidesPerRow: 5
            }
          },
          {
            breakpoint: 961,
            settings: {
              slidesPerRow: 4
            }
          },
          {
            breakpoint: decathlon.uxBreakpoints.smMin,
            settings: {
              arrows: false,
              slidesPerRow: 3
            }
          },
          {
            breakpoint: decathlon.uxBreakpoints.xsMin,
            settings: {
              arrows: false,
              slidesPerRow: 2
            }
          }
        ]
      });

    }



    // _this.$sportsCarousel.empty().append($(carouselOutput));

    if($('html').attr('lang') !== 'zh'){
      var draggableSportsCarouselOptions = {
          type:"scrollLeft",
          dragClickables:"true",
          edgeResistance:0.9,
          throwProps:true,
          lockAxis:true
      };


      Draggable.create(_this.$sportsCarousel, draggableSportsCarouselOptions);
    }


    
  };

  prototypeMethods.createListOfSports = function(){

    var _this = this;

    if(_this.$filteredList.length > 0){
      var sportsAdviceFilteredList = '<ul>';

      _this.orderedSportsArray.each(function(){
        
        // $(this).find('.image').remove();

        sportsAdviceFilteredList += '<li>';
        sportsAdviceFilteredList += $(this)[0].outerHTML;
        sportsAdviceFilteredList += '</li>';
      });

      _this.$filteredList.append(sportsAdviceFilteredList).addClass('hidden');
    }
  };

  prototypeMethods.getSportGroupXposition = function(sportGroup){
    var _this = this;
    return sportGroup[0].getBoundingClientRect().left - _this.$sportsCarousel[0].getBoundingClientRect().left;
  };

  prototypeMethods.createCarouselNav = function(){

    var _this = this;
    var sportsGroupsArray = _this.el.find('.sports-group');

    if(_this.$carouselNav.length > 0 && sportsGroupsArray.length > 0){

      var sportsAdviceCarouseNav = '';
      var groupLetter = '';
      var groupXPos;

      sportsGroupsArray.each(function(){
        groupLetter = $(this).find('.letter').text().charAt(0);
        sportsAdviceCarouseNav += '<div class="bullet" data-value="'+groupLetter+'" data-scroll-position="'+_this.getSportGroupXposition($(this))+'">' + groupLetter + '</div>';
        
      });

      _this.$carouselNav.append(sportsAdviceCarouseNav);


      setActiveNav = function(){

        sportsGroupsArray.each(function(){

          groupXPos = _this.getSportGroupXposition($(this));
          var carouselRight = _this.$sportsCarousel[0].getBoundingClientRect().right;
          groupLetter = $(this).find('.letter').text();

          if(groupXPos >= 0 && groupXPos < carouselRight && (groupXPos + $(this).outerWidth()) < carouselRight){

            $(this).addClass('active');
            _this.$carouselNav.find('.bullet[data-value="'+groupLetter+'"]').addClass('active');

          } else {

            $(this).removeClass('active');
            _this.$carouselNav.find('.bullet[data-value="'+groupLetter+'"]').removeClass('active');

          }

        });

      };

      _this.$sportsCarousel.on('scroll', function(){
        setActiveNav();
      });

      setActiveNav();

      _this.$carouselNav.on('click', '.bullet:not(.active)', function(){
        _this.$sportsCarousel.animate({scrollLeft: $(this).data('scroll-position') - 100}, 700, 'swing');
      });
    }
  };

  prototypeMethods.setWrapperHeight = function(){

    var _this = this;

    setTimeout(function(){

      var sportsCarouselWrapperHeight = _this.$sportsCarousel.find('.sport-groups-wrapper').outerHeight();

      uxDynamicStyles.appendCssStylesArrayToHeader({
          uniqueId : 'sportsCarouselDynStyles1',
          selectors : [
          '.floor-sports-advice .sports-advice-carousel-wrapper'
          ],
          properties : [
            'height: '+ (sportsCarouselWrapperHeight) + 'px;'
          ]
        }
      );

      uxDynamicStyles.appendCssStylesArrayToHeader({
          uniqueId : 'sportsCarouselDynStyles2',
          selectors : [
          '.floor-sports-advice .sports a'
          ],
          properties : [
            'height: '+ (sportsCarouselWrapperHeight/2) + 'px;'
          ]
        }

      );

    },0);
  };

  prototypeMethods.highlightSearch = function(string, phrase) {
    return string.replace(new RegExp("(" + phrase + ")", "gi") , "<b>$1</b>");
  };

  prototypeMethods.attachSportsFilterMethods = function(){
    var _this = this, search, $target;

    _this.initJqueryFilter();

    var charCount = $('html').attr('lang') === 'zh' ? _this.options.charCountZh : _this.options.charCountEn;

    _this.$sportsAdviceFilter.on("focus keyup",function () {

        search = $(this).val();

        $target = _this.$filteredList.find('li');

        $(document).on('click.close-sports-filter-list', function(){
          if(!_this.$sportsAdviceFilter.is(':focus')){
            _this.$filteredList.addClass('hidden').attr('aria-hidden', 'true');
          }
        });

        if (search && search.length >= charCount) {

          /* show list */

          _this.$filteredList.removeClass('hidden').attr('aria-hidden', 'false');
          $target.removeClass('last-child').addClass('hidden').attr('aria-hidden', 'true');

          var matchingSportsArray = $target.find('.text:containsChar("' + search + '")');

          if(matchingSportsArray.length > 0){

            _this.$filteredList.find('#'+_this.options.noSportsContainerID).remove();

            matchingSportsArray.each(function(index){
              if( index+1 === matchingSportsArray.length){
                $(this).closest('li').addClass('last-child');
              }
              $(this).closest('li').removeClass('hidden').attr('aria-hidden', 'false');
              $(this).html(_this.highlightSearch($(this).text(), search));
            });

          } else {

            if(_this.$filteredList.find('#'+_this.options.noSportsContainerID).length === 0) {
              _this.$filteredList.append('<div id="'+_this.options.noSportsContainerID+'">'+_this.nothingFoundPhrase+'</div>');
            }
          }

        } else {

          /* hide list */

          $target.find('.text').each(function(){
            $(this).html($(this).text());
          });

          $target.removeClass('hidden').attr('aria-hidden', 'false');
          _this.$filteredList.addClass('hidden').attr('aria-hidden', 'true');

          $(document).off('click.close-sports-filter-list');

        }
    });

  };

  prototypeMethods.init = function () {
    
    var _this = this;

    _this.$sportsCarousel = _this.el.find('.sports-advice-carousel');

 /*   _this.nothingFoundPhrase = _this.$sportsCarousel.data('nothing-found-text') || 'there is no result'; */

    _this.$sportsAdviceFilter = _this.el.find('#sportsAdviceFilter');

    _this.nothingFoundPhrase = _this.$sportsAdviceFilter.data('nothing-found-text') || 'there is no result';
    
    _this.$sportsAdviceFilter.closest('form').attr('autocomplete', 'false');

    _this.$filteredList = $(_this.options.filteredList);
    _this.$carouselNav = $(_this.options.carouselNav);

    _this.$filteredList.on( 'mousewheel DOMMouseScroll', function (e) {

        var e0 = e.originalEvent,
        delta = e0.wheelDelta || -e0.detail;

        if ((this.scrollTop === 0 && delta > 0) || ((this.scrollTop + this.offsetHeight) >= this.scrollHeight && delta < 0)) {
            e.preventDefault();
        }
      
    });

    _this.$sportsCarousel.on( 'mousewheel', function (e) {
      var e0 = e.originalEvent,
      delta = e0.deltaX || e0.wheelDeltaX;

      if ((this.scrollLeft === 0 && delta < 0) || ((this.scrollLeft + this.offsetWidth) === this.scrollWidth && delta > 0)) {
          e.preventDefault();
      }
    });

    
      _this.wrappSports();
    

    _this.createListOfSports();
    _this.createCarouselNav();

    $(function(){
      _this.$sportsCarousel.scrollLeft(0);

      if($('html').attr('lang') !== 'zh'){
        _this.setWrapperHeight();
      }
      
      _this.attachSportsFilterMethods();
    });

  };

  decathlon.tools.createJqueryPlugin({
    pluginName : 'sportsAdviceMainMethods',
    defaultOptions : {
      filteredList: "#sportsAdviceFilteredList",
      carouselNav: "#sportsAdviceCarouselNav",
      charCountEn: 3,
      charCountZh: 1,
      noSportsContainerID: 'no-sports'
    },
    prototypeMethods :  prototypeMethods
  });

}(window, jQuery, document));


$('#sports-advice').sportsAdviceMainMethods();
/* CODE COMMENTED BY BIRA - NEEDED FOR THE ENHANCEMENT 17587 - A BETTER SOLUTION WILL BE TAKEN SHORTLY */
// $( ".floor-push div.product" ).each(function( ) {
//     $(this).on('click', function(e) {
//    var cible = $(this).find('a').attr('href');
//    window.location = cible;
//    e.preventDefault();
//     });
// });
;(function(window, $){

  UxCollapsibleText = (typeof UxCollapsibleText === 'object') ? UxCollapsibleText : {};

  UxCollapsibleText.getLineHeight = function (obj){
      UxCollapsibleText.lineHeight = parseInt(obj.css('line-height').replace('px',''), 10);
      if (UxCollapsibleText.lineHeight === 1) {
        UxCollapsibleText.lineHeight = parseInt(obj.css('font-size').replace('px',''), 10) * 1.4; /* IE 8 ?? */
      }
      return UxCollapsibleText.lineHeight;
    };

  UxCollapsibleText.setCollapsedHeight = function(){

    hasMobileOnly = $('.collapsible-mobile-only').length > 0 ? true : false;

    $collapsibleRef = $('.collapsible:first');
    UxCollapsibleText.lineHeight = UxCollapsibleText.getLineHeight($collapsibleRef);
    UxCollapsibleText.paddingTop = parseInt($collapsibleRef.css('padding-top').replace('px',''), 10);

    $('.collapsible').each(function(){
      
      UxCollapsibleText.dataLinesToDisplay = $(this).attr('data-show');
      if(UxCollapsibleText.dataLinesToDisplay && UxCollapsibleText.dataLinesToDisplay !== ''){
        UxCollapsibleText.linesToShow = UxCollapsibleText.dataLinesToDisplay;
      }

      UxCollapsibleText.dataTrigger = $(this).attr('data-trigger');
      if(UxCollapsibleText.dataTrigger && UxCollapsibleText.dataTrigger !== ''){
        UxCollapsibleText.linesTrigger = UxCollapsibleText.dataTrigger;
      }
      
      isCollapsible = true;

      if(hasMobileOnly){
        if ($(this).hasClass('collapsible-mobile-only') && decathlon.uxBreakpoints.is('large-screen')) {
          isCollapsible = false;
        }
      }

      // This is used if we want to keep seeing some lines of text
      var collapseText = UxCollapsibleText.lineHeight * UxCollapsibleText.linesToShow; 
      if($(this).closest('.review-info').length){
        // In store reviews, we only want to see the first line of the title
        collapseText = UxCollapsibleText.lineHeight;
      }
      if ($(this)[0].scrollHeight > (UxCollapsibleText.lineHeight * UxCollapsibleText.linesTrigger) && isCollapsible){
        $(this).addClass('in').css('max-height', (collapseText + UxCollapsibleText.paddingTop)+'px');
      } else {
        $(this).removeClass('in').css('max-height', '');
      }
    });
  };

  UxCollapsibleText.init = function(){

    if($('.collapsible').length > 0) {

      var $this,
      _thisText,
      _thisIco,
      _thisMoreText,
      _thisLessText,
      hasMobileOnly,
      isCollapsible;

      UxCollapsibleText.lineHeight = 0;
      UxCollapsibleText.paddingTop = 0;
      UxCollapsibleText.linesToShow = 2;
      UxCollapsibleText.linesTrigger = 4;
      UxCollapsibleText.dataLinesToDisplay = null;
      UxCollapsibleText.dataTrigger = null;

      $('.view-full-review, .view-full-text').each(function(){
        $this = $(this);
        _thisMoreText = $this.data('toggler-more-text') ? $this.data('toggler-more-text') : Messages('more');
        $this.html(_thisMoreText + '<span aria-hidden="true" class="ico ico-11 ico-more"></span>');
      });

      $(document).on('click touchend', '.view-full-review, .view-full-text', function(e){
        e.preventDefault();
      });

      $(document).on('click touchend', '.view-full-review, .view-full-text', _.debounce(function(e){
        $this = $(this);
        _thisMoreText = $this.data('toggler-more-text') ? $this.data('toggler-more-text') : Messages('more');
        _thisLessText = $this.data('toggler-less-text') ? $this.data('toggler-less-text') : Messages('less');
        _thisText = $this.siblings('.text');
        _thisIco = $this.children('.ico');

        UxCollapsibleText.dataLinesToDisplay = _thisText.attr('data-show');
        if(UxCollapsibleText.dataLinesToDisplay && UxCollapsibleText.dataLinesToDisplay !== ''){
          UxCollapsibleText.linesToShow = UxCollapsibleText.dataLinesToDisplay;
        }

        UxCollapsibleText.dataTrigger = _thisText.attr('data-trigger');
        if(UxCollapsibleText.dataTrigger && UxCollapsibleText.dataTrigger !== ''){
          UxCollapsibleText.linesTrigger = UxCollapsibleText.dataTrigger;
        }
        // This is used if we want to keep seeing some lines of text
        var collapseText = UxCollapsibleText.getLineHeight(_thisText) * UxCollapsibleText.linesToShow; 
        if($(this).closest('.review-info').length){
          // In store reviews, we only want to see the first line of the title
          collapseText = UxCollapsibleText.getLineHeight(_thisText);
        }
        if(_thisText.hasClass('active')){
          
          _thisText.removeClass('active').stop().animate({
            maxHeight : collapseText + UxCollapsibleText.paddingTop
          }, {
            duration:400,
            specialEasing: "easeInOutQuart",
            complete: function(){
              // _thisIco.removeClass('ico-less');
            }
          });
          setTimeout(function(){
            $this.html(_thisMoreText + '<span aria-hidden="true" class="ico ico-11 ico-more"></span>');
          },200);
        } else {
          // _thisIco.addClass('ico-less');
          
          _thisText.addClass('active').stop().animate({
            maxHeight : _thisText[0].scrollHeight
          }, {
              duration: 400,
              specialEasing: "easeInOutQuart"
          });
          setTimeout(function(){
            $this.html(_thisLessText + '<span aria-hidden="true" class="ico ico-11 ico-more ico-less"></span>');
          },200);
        }

      },300, true));

      UxCollapsibleText.setCollapsedHeight();

      $(window).load(function() {
        UxCollapsibleText.setCollapsedHeight();
      });

      $(window).bind('resize-width.uxCollapsibleText', _.debounce(function() {
        UxCollapsibleText.setCollapsedHeight();
      },300));
      
    }
  };

  UxCollapsibleText.init();

})(window, jQuery);

/* SECOND TYPE OF COLLAPSSIBLE TEXT - USED IN THE PRODUCT.HTML PAGE */


$.fn.extend({

  uxCollapsibleBlock : function(){

    var $this = this;

    if ($this.length > 0 && $this.jquery) {

      $this.height = $this.height();
      $this.minHeight = $this.data('min-height') !== undefined ? $this.data('min-height') : 400;

      $this.expandContractHeight = function(e){

        if(window.TweenMax){

          $this.animationSpeed = uxGAP.speed($this.height - $this.minHeight);

          if(this.hasClass('collapsed')){

            TweenMax.to($this, $this.animationSpeed, {height:$this.height, onStart : function(){
              
              setTimeout(function(){
                $this.readMoreLink.find('.text').text($this.readLessLinkText());
              }, ($this.animationSpeed / 2) * 1000);

              TweenMax.to($this.readMoreLink.find('.icon'), $this.animationSpeed, {rotation:-90});

            }, ease: Power4.easeInOut, onComplete : function(){
              
              $this.removeClass('collapsed');
              $this.attr('aria-expanded', 'true');
              $this.readMoreLink.find('a').attr('aria-expanded', 'true');

            }});

          } else {

            TweenMax.to($this, $this.animationSpeed, {height:$this.minHeight, onStart : function(){
              
              $this.addClass('collapsed');
              $this.attr('aria-expanded', 'false');
              $this.readMoreLink.find('a').attr('aria-expanded', 'false');
              
              setTimeout(function(){
                $this.readMoreLink.find('.text').text($this.readMoreLinkText());
              }, ($this.animationSpeed / 2) * 1000);

              TweenMax.to($this.readMoreLink.find('.icon'), $this.animationSpeed, {rotation:90});

            }, ease: Power4.easeInOut});

          }

        } /* END OF IF TWEENMAX */

      };

      $this.addReadMoreLink = function(){

        $this.readMoreLink = $('<div class="toggler"><a href="#" role="button" aria-expanded="false" data-role="toggle"><span class="text">'+$this.readMoreLinkText()+'</span><span class="icon icon-arrow5-r" aria-hidden="true"></span></a></div>');

        $this.readMoreLink.on('click', 'a', function(e){
          e.preventDefault();
        });

        $this.readMoreLink.on('click', _.debounce(function(){
          $this.expandContractHeight();
        }, 300, true));

        if($this.next().find('a[data-role="toggle"]').length === 0){
          $this.after($this.readMoreLink);
          TweenMax.to($this.readMoreLink.find('.icon'), 0, {rotation:90});
        }

      };

      $this.readMoreLinkText = function(){
        return $this.data('toggler-more-text') ? $this.data('toggler-more-text') : 'More';
      };

      $this.readLessLinkText = function(){
        return $this.data('toggler-less-text') ? $this.data('toggler-less-text') : 'Less';
      };

      $this.init = function(){
        
          if($('body').width() > 769){
            $this.addClass('collapsed');
            $this.addReadMoreLink();
            $this.css({'height':$this.minHeight+'px'});
          }

      }();

    } /* END OF IF */

  } /* END OF EXTEND */
});

$('.collapsible-block').uxCollapsibleBlock();
(function(window, $){

  $.fn.extend({
    
    uxNavGoToBottom : function(){

      return this.each(function() {

        var $this = $(this);

        $this.scrollToTarget = function(){

          $this.targetAnchor = $('a[data-dynamic-nav="'+$this.attr('href').replace("#","")+'"]');

          if($this.targetAnchor.length > 0){
            $this.targetAnchorY = $this.targetAnchor[0].getBoundingClientRect().top + $(window).scrollTop() - $('#header').height();
            $('html,body').animate({scrollTop: $this.targetAnchorY}, 700, 'swing');
          }
        }; /* END OF scrollToTarget() */

        $this.animateArrow = function(){
          if(!$this.hasClass('animate')){

            $this.addClass('animate');

            setTimeout(function(){
              $this.removeClass('animate');
            },4000);
            
          }
        };

        $this.init = function(){

          $this.attr('tabindex','-1');

          var isTouch = false;

          $this.on('touchstart', function(e){
            e.stopPropagation();
            e.preventDefault();
            isTouch = true;
          });

          $this.on('click', function(e){
            e.stopPropagation();
            e.preventDefault();

            if (!isTouch){
              $this.scrollToTarget();
            }
          });
          
          $this.on('touchend', function(e){
            e.stopPropagation();
            e.preventDefault();
            if (isTouch){
              $this.scrollToTarget();
            }
          });

          var showHideArrow = function(){

            var changingPoint = decathlon.uxBreakpoints.is('small-screen') ? 400 : 550;

            if($(window).scrollTop() === 0){
                $this.animateArrow();
            }

            if($(window).scrollTop() > changingPoint){

              if($('body').hasClass('homepage')){
                $this.hide();
              } else {
                $this.fadeOut(300);
              }

            } else {
              if($('body').hasClass('homepage')){
                $this.show();
              } else {
                $this.fadeIn(300);
              }
            }
          };

          $(window).on('scroll', function(){
            showHideArrow();
          });

          showHideArrow();

        }();

      });
    
    }, /* END OF uxNavGoToBottom() */


    uxNavGoToTop : function(){

      return this.each(function() {

        var $this = $(this);

        $this.animateArrow = function(){
          if(!$this.hasClass('animate')){

            $this.addClass('animate');

            setTimeout(function(){
              $this.removeClass('animate');
            },4000);
            
          }
        };


        $this.scrollToTop = function(){
          $this.scrollSpeed = 400;
          $this.maxSpeed = 900;
          $this.minSpeed = 300;
          $this.animationSpeed = ($(window).scrollTop() / $this.scrollSpeed * 100);
          $this.animationSpeed = $this.animationSpeed > $this.maxSpeed ? $this.maxSpeed : $this.animationSpeed;
          $this.animationSpeed = $this.animationSpeed < $this.minSpeed ? $this.minSpeed : $this.animationSpeed;
          $('html,body').animate({scrollTop: 0}, $this.animationSpeed, 'swing');
        };

        

        $this.init = function(){

          $this.attr('tabindex','-1');


          var isTouch = false;

          $this.on('touchstart', function(e){
            e.stopPropagation();
            e.preventDefault();
            isTouch = true;
          });

          $this.on('click', function(e){
            e.stopPropagation();
            e.preventDefault();

            if (!isTouch){
              $this.scrollToTop();
            }
          });
          
          $this.on('touchend', function(e){
            e.stopPropagation();
            e.preventDefault();
            if (isTouch){
              $this.scrollToTop();
            }
          });

          var showHideArrow = function(){

            var changingPoint = decathlon.uxBreakpoints.is('small-screen') ? 400 : 550;

            if($(window).scrollTop() > changingPoint){
              $this.animateArrow();
            }

            if($(window).scrollTop() > changingPoint){

              if($('body').hasClass('homepage')){
                $this.show();
              } else {
                $this.fadeIn(300);
              }

            } else {
              if($('body').hasClass('homepage')){
                $this.hide();
              } else {
                $this.fadeOut(300);
              }

            }
          };

          $(window).on('scroll', function(){
            showHideArrow();
          });

          showHideArrow();
          
        }();

      });

    }

  }); /* END OF EXTEND */

})(window, jQuery);

$('.go-to-bottom').uxNavGoToBottom();
$('.go-to-top').uxNavGoToTop();

// Class loading
Cube = (typeof Cube === 'object') ? Cube : {};
Cube.Parallax = (typeof Cube.Parallax === 'object') ? Cube.Parallax : {};
Cube.Parallax.Parallax = (typeof Cube.Parallax.Parallax === 'object') ? Cube.Parallax.Parallax : {};


// Object parameters
Cube.Parallax.Parallax = function (selector) {
	this.selector = selector;
	this.cropRatio = 0.6;
	this.easing = 'linear';
};


// Object methods
Cube.Parallax.Parallax.prototype = {

	init: function()
	{
		// Calculate desired sizes, depending on this crop ratio
		this.calculateSize();

		// Parallax box initialization
		this.boxCrop();

		// Add events
		this.addEvents();
	},

	getParallaxBox: function()
	{
		return jQuery(this.selector);
	},

	getParallaxContent: function()
	{
		return this.getParallaxBox().find('.parallax-inner');
	},

	getParallaxTools: function()
	{
		return this.getParallaxBox().find('.parallax-control');
	},

	calculateSize: function() {
		this.contentHeight = this.getParallaxContent().height();
		this.cropHeight = Math.round(this.contentHeight * (1 - this.cropRatio));
		this.boxHeight = this.contentHeight - this.cropHeight;
	},

	boxCrop: function() {
		var that = this;

		// Crop box
		this.getParallaxBox().css('height', '-=' + that.cropHeight);

		// Align content & tools
		this.getParallaxContent().css('top', '-' + (that.cropHeight / 2));
		this.getParallaxTools().find('.middle').each(function() {
			var navTop = (that.boxHeight / 2) - (jQuery(this).height() / 2);
			jQuery(this).css('top', navTop);
		});
	},

	addEvents: function() {
		var that = this;

		// Update on load
		that.updatePosition();

		// Add "update on scroll" event
		jQuery(window).on('scroll', function() {
			that.updatePosition();
		});
	},

	calculateRatio: function(scrollTop, parallaxStart, parallaxStop) {
		var ratio = (scrollTop - parallaxStart) / (parallaxStop - parallaxStart);
		ratio = this.ratioEasing(ratio);

		// Secure ratio value
		ratio = ratio < 0 ? 0 : ratio;
		ratio = ratio > 1 ? 1 : ratio;

		return ratio;
	},

	ratioEasing: function(ratio) {

		// Linear easing > Do nothing
		if (this.easing === 'linear') {
			easingRatio = ratio;
		}

		// Cubic easing
		else if (this.easing === 'cubic') {
			if (ratio < 0.5) {
				easingRatio = (2 * 2) * (ratio * ratio * ratio);
			} else {
				easingRatio = 1 - ((2 * 2) * ((1 - ratio) * (1 - ratio) * (1 - ratio)));
			}
		}

		// Easing not found > Do nothing
		else {
			easingRatio = ratio;
		}

		return easingRatio;
	},

	updatePosition: function()
	{
		// Document
		var scrollTop = jQuery(window).scrollTop();
		var windowHeight = jQuery(window).height();

		// Box
		var boxOffset = this.getParallaxBox().offset();
		var boxTop = boxOffset.top;

		// Parallax effect
		var parallaxStart = boxTop - windowHeight;
		var parallaxStop = boxTop + this.boxHeight;

		// Ratio and new top
		var ratio = this.calculateRatio(scrollTop, parallaxStart, parallaxStop);
		var newTop = ratio * (this.boxHeight - this.contentHeight);

		// Update position
		this.getParallaxContent().css('top', newTop);
	}

};

/* https://github.com/twitter/typeahead.js */

var uxSearchTypeAhead = {
  activeInput : null,
  localizeUrl : $("#search-autocomplete").data("localeurl"),
  searchLocalizeUrl : $("#search-autocomplete").data("searchlocaleurl"),
  contentCollection : $("#search-autocomplete").data("content"),
  wildcards : $("#search-autocomplete").data('wildcards'),
  globalTool: new UX_Global(),
  minLength: $("#search-autocomplete").data("min-lenght"),
  maxLength: $("#search-autocomplete").data("max-lenght")
};

/* RETURNS THE LOCAL JSON IF THE UX ENVIRONMENT IS "LOCAL" */
/* THIS FLAG => uxEnvironment IS SET BY THE UX TEAM TO IDENTIFY THE ENVIRONMENTS WHERE THE JS IS RUNNING */
uxSearchTypeAhead.localData = function(localFile){
  if(this.globalTool.defineEnvironment() === 'local' && localFile){
    return { url: localFile};
  }
};

uxSearchTypeAhead.setUrl = function(type){
  _this = this;
  _this.url = '';
  if(type === 0) {
    _this.url = window.location.protocol + "//" + window.location.host + uxSearchTypeAhead.localizeUrl + '?type='+type+'&wildcards='+uxSearchTypeAhead.wildcards+'&query=';
  } else {
    _this.url = window.location.protocol + "//" + window.location.host + uxSearchTypeAhead.localizeUrl + '?query=%QUERY&type='+type+'&wildcards='+uxSearchTypeAhead.wildcards;
  }
  return _this.url;
};

/* RETURNS THE REMOTE OBJECT IF THE UX ENVIRONMENT ISN'T "LOCAL" */
uxSearchTypeAhead.remoteData = function(type){
  if(this.globalTool.defineEnvironment() !== 'local'){
    return {
      url: uxSearchTypeAhead.setUrl(type),
      replace: function () {
            var q = window.location.protocol + "//" + window.location.host + uxSearchTypeAhead.localizeUrl + '?minLength='+uxSearchTypeAhead.minLength+'&maxLength='+uxSearchTypeAhead.maxLength+'&type='+type+'&wildcards='+uxSearchTypeAhead.wildcards+'&query=';
            if (uxSearchTypeAhead.activeInput.val()) {
                q += encodeURIComponent(uxSearchTypeAhead.activeInput.val());
            }
            if (uxSearchTypeAhead.contentCollection) {
                q += '&contentCollection=';
                q += encodeURIComponent(uxSearchTypeAhead.contentCollection);
            }
            return q;
        },
        filter: function (data) {
            
            if (data.hasOwnProperty('pages') && data.hasOwnProperty('products')) {
              return _.union(data.pages, data.products);
            } else {
              return data;
            }

        }
    };
  }/* END OF TEST WHICH ENVIRONMENT */
};


uxSearchTypeAhead.pagesAndProducts = new Bloodhound({
  initialize: false,
  datumTokenizer: Bloodhound.tokenizers.obj.whitespace('name'),
  queryTokenizer: Bloodhound.tokenizers.whitespace,
  prefetch: uxSearchTypeAhead.localData('../mock/autocomplete/exempleProducts.json'),
  remote: uxSearchTypeAhead.remoteData(1)
});

uxSearchTypeAhead.sports = new Bloodhound({
  initialize: false,
  datumTokenizer: Bloodhound.tokenizers.obj.whitespace('name'),
  queryTokenizer: Bloodhound.tokenizers.whitespace,
  prefetch: uxSearchTypeAhead.localData('../mock/autocomplete/exempleSports.json'),
  remote: uxSearchTypeAhead.remoteData(1)
});

uxSearchTypeAhead.searchInput = $('form[role="search"] .autocomplete');



if($.fn.typeahead && uxSearchTypeAhead.searchInput.length > 0){
    
    /* INITIALIZES DATA */
    // uxSearchTypeAhead.categories.initialize();
    uxSearchTypeAhead.pagesAndProducts.initialize();
    uxSearchTypeAhead.sports.initialize();


    uxSearchTypeAhead.searchInput.each(function(){
      this.ttminsuggestedProductWidth = 0;
      this.ttDatasetProductsWidth = 0;
      this.ttallProductsWidth = 0;
      this.ttoptimalProductsperLine = 0;
      this.ttoptimalsuggestedProductWidth = 0;
      this.ttProductsLineNumber = 0;
      this.ttsuggestedProducts = [];
      this.tttargetSearchContainer = null;

      $(this).focus(function(){
        uxSearchTypeAhead.activeInput = $(this);
      });

    });

    /* THE PRODUCT TEMPLATE */
    uxSearchTypeAhead.pagesAndProductsTemplate = function(el){

      t = '';

      if((uxSearchTypeAhead.pagesLength + uxSearchTypeAhead.pagesAndProductsLength) === 0){

      } else {
    	// Use type to create template for categories and products.
        if(el.type === "page"){
          t += '<a href="'+el.url+'" class="tt-category">'+el.name+'</a>';
        } else {
          t += '<a href="'+el.url+'" class="tt-product" data-id="'+el.repositoryId+'">';
          t +=    '<div class="image">';
          t +=        '<img src="'+el.picture+'" />';
          t +=    '</div>';
          t +=    '<div class="text">';
          t +=        el.name;
          t +=    '</div>';
          t += '</a>';
        }

      }

      return t;
      
    };

    uxSearchTypeAhead.sportTemplate = function(el){
      t = '';
      t += '<a href="category-sport.html" class="'+el.class+'">';
      t +=   '<div class="wrapper">';
      t +=     '<div class="image">';
      t +=       '<div class="after"></div>';
      t +=     '</div>';
      t +=     '<div class="text">';
      t +=        el.name;
      t +=     '</div>';
      t +=   '</div>';
      t += '</a>';
      return t;
    };


  




    /* FUNCTION THAT CALCULATES THE OPTIMAL NUMBER OF PRODUCTS PER LINE AND ITS WIDTHS */
    uxSearchTypeAhead.calcProductsPerLine = function(target){

      obj = target[0];

      obj.tttargetSearchContainer = target.closest('.twitter-typeahead');
      
      ttMenu = obj.tttargetSearchContainer.find('.tt-menu');

      if(obj.tttargetSearchContainer.find('.tt-menu').is(":visible")){
        
        obj.ttsuggestedProducts = obj.tttargetSearchContainer.find('.tt-product');
        
          if(obj.ttsuggestedProducts.length > 0) {

            obj.tttargetSearchContainer.find('.tt-dataset-products').removeClass('empty');

            obj.ttminsuggestedProductWidth = obj.ttsuggestedProducts.eq(0).outerWidth();
            obj.ttDatasetProductsWidth = ttMenu.width();

            obj.ttallProductsWidth = obj.ttminsuggestedProductWidth * obj.ttsuggestedProducts.length;

            if(obj.ttallProductsWidth > obj.ttDatasetProductsWidth){

              obj.ttoptimalProductsperLine = Math.floor(obj.ttDatasetProductsWidth / 120);
              obj.ttoptimalsuggestedProductWidth = (obj.ttDatasetProductsWidth / obj.ttoptimalProductsperLine);

              obj.ttsuggestedProducts.each(function(index){

                  $(this).removeClass('first-child').removeClass(function (indexx, css) {
                      return (css.match (/(^|\s)line-\S+/g) || []).join(' ');
                  });

                  obj.ttProductsLineNumber = Math.floor(index / obj.ttoptimalProductsperLine) + 1;

                  $(this).css('width', obj.ttoptimalsuggestedProductWidth);
                  $(this).addClass('line-'+obj.ttProductsLineNumber);

                  if( index === (obj.ttoptimalProductsperLine * (obj.ttProductsLineNumber - 1) )) {
                    $(this).addClass('first-child');
                  }
              });
            }
          } else {

            obj.tttargetSearchContainer.find('.tt-dataset-products').addClass('empty');

          }/* END OF IF THERE ARE PRODUCTS */
        
      }
    };

    /* ALSO ON WINDOW RESIZE */
    $(window).on('resize-width', _.debounce(
      function() {
        uxSearchTypeAhead.searchInput.each(function(){
          uxSearchTypeAhead.calcProductsPerLine($(this));
        });
    },100));

    /* AND ON WINDOW SCROLL - BECAUSE OF THE STICKY HEADER - NOT THE BEST WAY TO TRIGGER THIS FUNCTION */
    $(window).on('scroll', function() {
      uxSearchTypeAhead.searchInput.each(function(){
        uxSearchTypeAhead.calcProductsPerLine($(this));
      });
    });

    






    /* INITIALIZES TYPEAHEAD */
    uxSearchTypeAhead.initTypeahead = function(){

      uxSearchTypeAhead.searchInput.each(function(){
        
        /* IF IT WAS ALREADY INITIALYZED, WE GOT TO DESTROY IT TO CHANGE ITS VALUES */
        if($(this).closest('.twitter-typeahead').attr('class') === 'twitter-typeahead'){
          $(this).typeahead('destroy');
        }

        var sources = [];

        var stamp = new Date();

        var output= '';

        var sourcePagesAndProducts = {
          name: 'pandp',
          displayKey: 'name',
          limit: Infinity,
          source: uxSearchTypeAhead.pagesAndProducts.ttAdapter(),
          templates: {
            suggestion: function(el){
              return uxSearchTypeAhead.pagesAndProductsTemplate(el);
            },
            empty: function(query){
              var url = window.location.protocol + "//" + window.location.host + uxSearchTypeAhead.searchLocalizeUrl + '?Ntt=' + query.query;
              return '<a href="' + url + '" class="tt-category tt-empty">Search for <strong>'+query.query+'</strong>&nbsp;<span class="icon icon-arrow3-r"></span></a>';
            }
          }
        };

        var sourceSports = {
          name: 'sports',
          displayKey: 'name',
          limit: 20,
          source: uxSearchTypeAhead.sports.ttAdapter(),
          templates: {
            suggestion: function(el){
              return uxSearchTypeAhead.sportTemplate(el);
            }
          }
        };

        

        if($(this).closest('.menu-search').hasClass('sports')){
          sources.push(sourceSports);
        } else {
          sources.push(sourcePagesAndProducts);
        }

        $(this).typeahead(
            {
                hint: true,
                highlight: true,
                minLength: this.minLength /* THIS VALUE IS SET ABOVE*/
            },
            sources
        );

        this.targetSearchInput = $(this);

        /* TO FIX A CSS PROPERTY THAT IS APPLYED TO THE INPUT PARENT WHEN IT IS CREATED BY TYPEAHEAD */
        $(this).parent().css('display','block');

        
        /* EVERY TIME THERE ARE PRODUCTS IN THE AUTOCOMPLETE RESULTS, IT CALCULATES THE OPTIMAL NUMBER OF PRODUCTS PER LINE */
        $(this).on('typeahead:render', function() {

          $typeaheadWrapper = $(this).closest('.twitter-typeahead');
          $typeaheadWrapper.find('.tt-category').wrapAll('<div class="tt-dataset tt-dataset-categories" />');
          $typeaheadWrapper.find('.tt-product').wrapAll('<div class="tt-dataset tt-dataset-products" />');

          if (window.decathlon.uxBreakpoints.is('small-screen')) {
            var $ttMenu = $(this).closest('.twitter-typeahead').find('.tt-menu');
            $ttMenu.css('max-height', $(window).height() - ($ttMenu[0].getBoundingClientRect().top));
          }

            maxLength = $(this).data('max-lenght') ? $(this).data('max-lenght') : 10;
            userInputValueLength = uxSearchTypeAhead.activeInput.val().length;
            
            if(userInputValueLength < this.minLength || userInputValueLength > maxLength){
              //$(this).typeahead('close');
            } else{
              uxSearchTypeAhead.calcProductsPerLine(this.targetSearchInput);
            }
        });

        $(this).on('typeahead:beforeclose', function(e) {
          if (Modernizr.ios) {
            e.preventDefault();
          }
        });

      });
    };



    /* SET DIFFERENT MINLENGTHS TO EACH INPUT DESKTOP AND MOBILE */
    uxSearchTypeAhead.setTypeaheadMinValue = function(min){
      uxSearchTypeAhead.searchInput.each(function(){
        this.minLength = $(this).data('min-lenght');
      });
    };




    /* LAUNCHES TYPEAHEAD */
    uxSearchTypeAhead.setInitialTypeahead = function(){
      uxSearchTypeAhead.setTypeaheadMinValue(3);
      uxSearchTypeAhead.initTypeahead();
    }();

    
    

    /* I TEMPORALILLY ATTACHED AN EVENT TO THE LANGUAGE SELECTION DROPDOWN, 
    IN ORDER TO TEST THE EFFECTIVENESS ALL THESE FUNCTIONS */

    /* IF YOU CHANGE THE LANGUAGE ON THE HEADER DROPDOWN, THE LENGTHS ARE RENEWED */
    $('.drop-lang-list').on('click', 'a', function(){
      if($(this).parent().attr('class').indexOf("-en") > -1){
        /* ENGLISH */
        uxSearchTypeAhead.setTypeaheadMinValue(10);
        uxSearchTypeAhead.initTypeahead();
      } else {
        /* CHINESE */
        uxSearchTypeAhead.setTypeaheadMinValue(4);
        uxSearchTypeAhead.initTypeahead();
      }
    });


    /* FOR THE MOBILE SEARCH */
    uxSearchTypeAhead.searchMaskId = 'search-mask';

    uxSearchTypeAhead.mobileSearchHeader = '';
    uxSearchTypeAhead.mobileSearchHeader += '<div id="'+uxSearchTypeAhead.searchMaskId+'">';
    uxSearchTypeAhead.mobileSearchHeader +=    '<div class="menu-top-buttons">';
    uxSearchTypeAhead.mobileSearchHeader +=        '<div class="back">';
    uxSearchTypeAhead.mobileSearchHeader +=          '<div class="arrow"></div>';
    uxSearchTypeAhead.mobileSearchHeader +=          '<div class="text">back</div>';
    uxSearchTypeAhead.mobileSearchHeader +=        '</div>';
    uxSearchTypeAhead.mobileSearchHeader +=        '<div class="title">';
    uxSearchTypeAhead.mobileSearchHeader +=          '<span class="text"></span>';
    uxSearchTypeAhead.mobileSearchHeader +=        '</div>';
    uxSearchTypeAhead.mobileSearchHeader +=    '</div>';
    uxSearchTypeAhead.mobileSearchHeader += '</div>';
    uxSearchTypeAhead.mobileSearchHeader = $(uxSearchTypeAhead.mobileSearchHeader);

    
    var $menuContainer = $('#menu-global');

    /* ON FOCUS, ADDS THE MOBILE SEARCH HEADER */
    $('.menu-search form[role="search"] input').on('focus', function(){

      $menuContainer.addClass('search');

      if($(this).closest('.menu-search').hasClass('sports')){
        $menuContainer.addClass('sports');
      }

      $('html').addClass('mobile-autocomplete-open');

      uxSearchTypeAhead.mobileSearchHeader.find('.title .text').text($(this).attr('placeholder'));
      

      $(this).closest('.menu-search').before(uxSearchTypeAhead.mobileSearchHeader);

      setTimeout(function(){
        uxSearchTypeAhead.mobileSearchHeader.addClass('active');
      }, 0);


    });  /* END OF INPUT FOCUS */


    uxSearchTypeAhead.isTouch = false;

    $(document).on('touchstart', '#'+uxSearchTypeAhead.searchMaskId+' .back', function(e){
      uxSearchTypeAhead.isTouch = true;
    });

    $(document).on('click', '#'+uxSearchTypeAhead.searchMaskId+' .back', function(e){
      
      e.stopPropagation();

      if (Modernizr.ios && uxSearchTypeAhead.isTouch) {
        e.preventDefault();
      } else {
        closeTTmenu();
      }
    });

    $(document).on('touchend', '#'+uxSearchTypeAhead.searchMaskId+' .back', function(e){

        e.stopPropagation();
        e.preventDefault();

        $(this).attr('tabindex','0').focus();
        closeTTmenu();
      });

    var closeTTmenu = function(inputField){
      uxSearchTypeAhead.mobileSearchHeader.removeClass('active');
      $menuContainer.removeClass('search').removeClass('sports');

      uxSearchTypeAhead.searchInput.filter(':visible').each(function(){
        $(this).typeahead('val', '');
      });

      setTimeout(function(){
        uxSearchTypeAhead.mobileSearchHeader.remove();
        $('html').removeClass('mobile-autocomplete-open');
      }, 200);
    };


    $('.menu-search form[role="search"] input').on('blur', function(){
      if (Modernizr.ios) {
        if($(this).closest('.twitter-typeahead').find('.tt-menu:not(:visible)').length > 0) {
          closeTTmenu();
        }
      } else {
        closeTTmenu();
      }

    });  /* END OF INPUT FOCUS */
  
  } /* END OF IF TYPEAHEAD */

if ($('.m-subnav').length > 0) {
	
	// On Mobile, we go to the page title directly
	if($('body').hasClass('mobile')){
		TweenMax.to($(window), 1, {scrollTo:{y: $(".page-header").offset().top-70 }, ease:Power4.easeInOut});
	}
	
  var subnav = $('.m-subnav'),
      subnavLink = subnav.children('.list-group').children('.has-dropdown');

  subnav.find('ul.list-group').each(function() {
    $(this).hide();
  });

  subnavLink.on('click', function(e) {
    e.preventDefault();
    $(this).toggleClass('is_active').next('ul').stop().slideToggle('fast');
  });
}
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(["jquery"], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    factory(jQuery);
  }
}(this, function (jQuery) {

(function ($) {
  'use strict';

  //<editor-fold desc="Shims">
  if (!String.prototype.includes) {
    (function () {
      //'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
      var toString = {}.toString;
      var defineProperty = (function () {
        // IE 8 only supports `Object.defineProperty` on DOM elements
        var result;
        try {
          var object = {};
          var $defineProperty = Object.defineProperty;
          result = $defineProperty(object, object, object) && $defineProperty;
        } catch (error) {
        }
        return result;
      }());
      var indexOf = ''.indexOf;
      var includes = function (search) {
        if (this === null) {
          throw new TypeError();
        }
        var string = String(this);
        if (search && toString.call(search) == '[object RegExp]') {
          throw new TypeError();
        }
        var stringLength = string.length;
        var searchString = String(search);
        var searchLength = searchString.length;
        var position = arguments.length > 1 ? arguments[1] : undefined;
        // `ToInteger`
        var pos = position ? Number(position) : 0;
        if (pos != pos) { // better `isNaN`
          pos = 0;
        }
        var start = Math.min(Math.max(pos, 0), stringLength);
        // Avoid the `indexOf` call if no match is possible
        if (searchLength + start > stringLength) {
          return false;
        }
        return indexOf.call(string, searchString, pos) != -1;
      };
      if (defineProperty) {
        defineProperty(String.prototype, 'includes', {
          'value': includes,
          'configurable': true,
          'writable': true
        });
      } else {
        String.prototype.includes = includes;
      }
    }());
  }

  if (!String.prototype.startsWith) {
    (function () {
      //'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
      var defineProperty = (function () {
        // IE 8 only supports `Object.defineProperty` on DOM elements
        var result;
        try {
          var object = {};
          var $defineProperty = Object.defineProperty;
          result = $defineProperty(object, object, object) && $defineProperty;
        } catch (error) {
        }
        return result;
      }());
      var toString = {}.toString;
      var startsWith = function (search) {
        if (this === null) {
          throw new TypeError();
        }
        var string = String(this);
        if (search && toString.call(search) == '[object RegExp]') {
          throw new TypeError();
        }
        var stringLength = string.length;
        var searchString = String(search);
        var searchLength = searchString.length;
        var position = arguments.length > 1 ? arguments[1] : undefined;
        // `ToInteger`
        var pos = position ? Number(position) : 0;
        if (pos != pos) { // better `isNaN`
          pos = 0;
        }
        var start = Math.min(Math.max(pos, 0), stringLength);
        // Avoid the `indexOf` call if no match is possible
        if (searchLength + start > stringLength) {
          return false;
        }
        var index = -1;
        while (++index < searchLength) {
          if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
            return false;
          }
        }
        return true;
      };
      if (defineProperty) {
        defineProperty(String.prototype, 'startsWith', {
          'value': startsWith,
          'configurable': true,
          'writable': true
        });
      } else {
        String.prototype.startsWith = startsWith;
      }
    }());
  }

  if (!Object.keys) {
    Object.keys = function (
      o, // object
      k, // key
      r  // result array
      ){
      // initialize object and result
      r=[];
      // iterate over object keys
      for (k in o) 
          // fill result array with non-prototypical keys
        if (r.hasOwnProperty.call(o, k)) r.push(k);
      // return result
      return r;
    };
  }

  $.fn.triggerNative = function (eventName) {
    var el = this[0],
        event;

    if (el.dispatchEvent) {
      if (typeof Event === 'function') {
        // For modern browsers
        event = new Event(eventName, {
          bubbles: true
        });
      } else {
        // For IE since it doesn't support Event constructor
        event = document.createEvent('Event');
        event.initEvent(eventName, true, false);
      }

      el.dispatchEvent(event);
    } else {
      if (el.fireEvent) {
        event = document.createEventObject();
        event.eventType = eventName;
        el.fireEvent('on' + eventName, event);
      }

      this.trigger(eventName);
    }
  };
  //</editor-fold>

  // Case insensitive contains search
  $.expr[':'].icontains = function (obj, index, meta) {
    var $obj = $(obj);
    var haystack = ($obj.data('tokens') || $obj.text()).toUpperCase();
    return haystack.includes(meta[3].toUpperCase());
  };

  // Case insensitive begins search
  $.expr[':'].ibegins = function (obj, index, meta) {
    var $obj = $(obj);
    var haystack = ($obj.data('tokens') || $obj.text()).toUpperCase();
    return haystack.startsWith(meta[3].toUpperCase());
  };

  // Case and accent insensitive contains search
  $.expr[':'].aicontains = function (obj, index, meta) {
    var $obj = $(obj);
    var haystack = ($obj.data('tokens') || $obj.data('normalizedText') || $obj.text()).toUpperCase();
    return haystack.includes(meta[3].toUpperCase());
  };

  // Case and accent insensitive begins search
  $.expr[':'].aibegins = function (obj, index, meta) {
    var $obj = $(obj);
    var haystack = ($obj.data('tokens') || $obj.data('normalizedText') || $obj.text()).toUpperCase();
    return haystack.startsWith(meta[3].toUpperCase());
  };

  /**
   * Remove all diatrics from the given text.
   * @access private
   * @param {String} text
   * @returns {String}
   */
  function normalizeToBase(text) {
    var rExps = [
      {re: /[\xC0-\xC6]/g, ch: "A"},
      {re: /[\xE0-\xE6]/g, ch: "a"},
      {re: /[\xC8-\xCB]/g, ch: "E"},
      {re: /[\xE8-\xEB]/g, ch: "e"},
      {re: /[\xCC-\xCF]/g, ch: "I"},
      {re: /[\xEC-\xEF]/g, ch: "i"},
      {re: /[\xD2-\xD6]/g, ch: "O"},
      {re: /[\xF2-\xF6]/g, ch: "o"},
      {re: /[\xD9-\xDC]/g, ch: "U"},
      {re: /[\xF9-\xFC]/g, ch: "u"},
      {re: /[\xC7-\xE7]/g, ch: "c"},
      {re: /[\xD1]/g, ch: "N"},
      {re: /[\xF1]/g, ch: "n"}
    ];
    $.each(rExps, function () {
      text = text.replace(this.re, this.ch);
    });
    return text;
  }


  function htmlEscape(html) {
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var source = '(?:' + Object.keys(escapeMap).join('|') + ')',
        testRegexp = new RegExp(source),
        replaceRegexp = new RegExp(source, 'g'),
        string = html === null ? '' : '' + html;
    return testRegexp.test(string) ? string.replace(replaceRegexp, function (match) {
      return escapeMap[match];
    }) : string;
  }

  var Selectpicker = function (element, options, e) {
    if (e) {
      e.stopPropagation();
      e.preventDefault();
    }

    this.$element = $(element);
    this.$newElement = null;
    this.$button = null;
    this.$menu = null;
    this.$lis = null;
    this.options = options;

    // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a
    // data-attribute)
    if (this.options.title === null) {
      this.options.title = this.$element.attr('title');
    }

    //Expose public methods
    this.val = Selectpicker.prototype.val;
    this.render = Selectpicker.prototype.render;
    this.refresh = Selectpicker.prototype.refresh;
    this.setStyle = Selectpicker.prototype.setStyle;
    this.selectAll = Selectpicker.prototype.selectAll;
    this.deselectAll = Selectpicker.prototype.deselectAll;
    this.destroy = Selectpicker.prototype.remove;
    this.remove = Selectpicker.prototype.remove;
    this.show = Selectpicker.prototype.show;
    this.hide = Selectpicker.prototype.hide;

    this.init();
  };

  Selectpicker.VERSION = '1.7.2';

  // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.
  Selectpicker.DEFAULTS = {
    noneSelectedText: 'Nothing selected',
    noneResultsText: 'No results matched {0}',
    countSelectedText: function (numSelected, numTotal) {
      return (numSelected == 1) ? "{0} item selected" : "{0} items selected";
    },
    maxOptionsText: function (numAll, numGroup) {
      return [
        (numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',
        (numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'
      ];
    },
    selectAllText: 'Select All',
    deselectAllText: 'Deselect All',
    doneButton: false,
    doneButtonText: 'Close',
    multipleSeparator: ', ',
    styleBase: 'btn',
    style: 'btn-default',
    size: 'auto',
    title: null,
    selectedTextFormat: 'values',
    width: false,
    container: false,
    hideDisabled: false,
    showSubtext: false,
    showIcon: true,
    showContent: true,
    dropupAuto: false,
    header: false,
    liveSearch: false,
    liveSearchPlaceholder: null,
    liveSearchNormalize: false,
    liveSearchStyle: 'contains',
    actionsBox: false,
    iconBase: 'glyphicon',
    tickIcon: 'glyphicon-ok',
    template: {
      caret: '<span class="caret"></span>'
    },
    maxOptions: false,
    mobile: false,
    selectOnTab: false,
    dropdownAlignRight: false
  };

  Selectpicker.prototype = {

    constructor: Selectpicker,

    init: function () {
      var that = this,
          id = this.$element.attr('id');

      this.$element.addClass('bs-select-hidden');
      // store originalIndex (key) and newIndex (value) in this.liObj for fast accessibility
      // allows us to do this.$lis.eq(that.liObj[index]) instead of this.$lis.filter('[data-original-index="' + index + '"]')
      this.liObj = {};
      this.multiple = this.$element.prop('multiple');
      this.autofocus = this.$element.prop('autofocus');
      this.$newElement = this.createView();
      this.$element.after(this.$newElement);
      this.$button = this.$newElement.children('button');
      this.$menu = this.$newElement.children('.dropdown-menu');
      this.$menuInner = this.$menu.children('.inner');
      this.$searchbox = this.$menu.find('input');

      if (this.options.dropdownAlignRight)
        this.$menu.addClass('dropdown-menu-right');

      if (typeof id !== 'undefined') {
        this.$button.attr('data-id', id);
        $('label[for="' + id + '"]').click(function (e) {
          e.preventDefault();
          that.$button.focus();
        });
      }

      this.checkDisabled();
      this.clickListener();
      if (this.options.liveSearch) this.liveSearchListener();
      this.render();
      this.setStyle();
      this.setWidth();
      if (this.options.container) this.selectPosition();
      this.$menu.data('this', this);
      this.$newElement.data('this', this);
      if (this.options.mobile) this.mobile();

      this.$newElement.on({
        'hide.bs.dropdown': function (e) {
          that.$element.trigger('hide.bs.select', e);
        },
        'hidden.bs.dropdown': function (e) {
          that.$element.trigger('hidden.bs.select', e);
        },
        'show.bs.dropdown': function (e) {
          that.$element.trigger('show.bs.select', e);
        },
        'shown.bs.dropdown': function (e) {
          that.$element.trigger('shown.bs.select', e);
        }
      });

      setTimeout(function () {
        that.$element.trigger('loaded.bs.select');
      });
    },

    createDropdown: function () {
      // Options
      // If we are multiple, then add the show-tick class by default
      var multiple = this.multiple ? ' show-tick' : '',
          inputGroup = this.$element.parent().hasClass('input-group') ? ' input-group-btn' : '',
          autofocus = this.autofocus ? ' autofocus' : '';
      // Elements
      var header = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>' : '';
      var searchbox = this.options.liveSearch ?
      '<div class="bs-searchbox">' +
      '<input type="text" class="form-control" autocomplete="off"' +
      (null === this.options.liveSearchPlaceholder ? '' : ' placeholder="' + htmlEscape(this.options.liveSearchPlaceholder) + '"') + '>' +
      '</div>'
          : '';
      var actionsbox = this.multiple && this.options.actionsBox ?
      '<div class="bs-actionsbox">' +
      '<div class="btn-group btn-group-sm btn-block">' +
      '<button type="button" class="actions-btn bs-select-all btn btn-default">' +
      this.options.selectAllText +
      '</button>' +
      '<button type="button" class="actions-btn bs-deselect-all btn btn-default">' +
      this.options.deselectAllText +
      '</button>' +
      '</div>' +
      '</div>'
          : '';
      var donebutton = this.multiple && this.options.doneButton ?
      '<div class="bs-donebutton">' +
      '<div class="btn-group btn-block">' +
      '<button type="button" class="btn btn-sm btn-default">' +
      this.options.doneButtonText +
      '</button>' +
      '</div>' +
      '</div>'
          : '';
      var drop =
          '<div class="btn-group bootstrap-select' + multiple + inputGroup + '">' +
          '<button type="button" class="' + this.options.styleBase + ' dropdown-toggle" data-toggle="dropdown"' + autofocus + '>' +
          '<span class="filter-option pull-left"></span>&nbsp;' +
          '<span class="bs-caret">' +
          this.options.template.caret +
          '</span>' +
          '</button>' +
          '<div class="dropdown-menu open">' +
          header +
          searchbox +
          actionsbox +
          '<ul class="dropdown-menu inner" role="menu">' +
          '</ul>' +
          donebutton +
          '</div>' +
          '</div>';

      return $(drop);
    },

    createView: function () {
      var $drop = this.createDropdown(),
          li = this.createLi();

      $drop.find('ul')[0].innerHTML = li;
      return $drop;
    },

    reloadLi: function () {
      //Remove all children.
      this.destroyLi();
      //Re build
      var li = this.createLi();
      this.$menuInner[0].innerHTML = li;
    },

    destroyLi: function () {
      this.$menu.find('li').remove();
    },

    createLi: function () {
      var that = this,
          _li = [],
          optID = 0,
          titleOption = document.createElement('option'),
          liIndex = -1; // increment liIndex whenever a new <li> element is created to ensure liObj is correct

      // Helper functions
      /**
       * @param content
       * @param [index]
       * @param [classes]
       * @param [optgroup]
       * @returns {string}
       */
      var generateLI = function (content, index, classes, optgroup) {
        return '<li' +
            ((typeof classes !== 'undefined' & '' !== classes) ? ' class="' + classes + '"' : '') +
            ((typeof index !== 'undefined' & null !== index) ? ' data-original-index="' + index + '"' : '') +
            ((typeof optgroup !== 'undefined' & null !== optgroup) ? 'data-optgroup="' + optgroup + '"' : '') +
            '>' + content + '</li>';
      };

      /**
       * @param text
       * @param [classes]
       * @param [inline]
       * @param [tokens]
       * @returns {string}
       */
      var generateA = function (text, classes, inline, tokens) {
        return '<a tabindex="0"' +
            (typeof classes !== 'undefined' ? ' class="' + classes + '"' : '') +
            (typeof inline !== 'undefined' ? ' style="' + inline + '"' : '') +
            (that.options.liveSearchNormalize ? ' data-normalized-text="' + normalizeToBase(htmlEscape(text)) + '"' : '') +
            (typeof tokens !== 'undefined' || tokens !== null ? ' data-tokens="' + tokens + '"' : '') +
            '>' + text +
            '<span class="' + that.options.iconBase + ' ' + that.options.tickIcon + ' check-mark"></span>' +
            '</a>';
      };

      if (this.options.title && !this.multiple) {
        // this option doesn't create a new <li> element, but does add a new option, so liIndex is decreased
        // since liObj is recalculated on every refresh, liIndex needs to be decreased even if the titleOption is already appended
        liIndex--;

        if (!this.$element.find('.bs-title-option').length) {
          // Use native JS to prepend option (faster)
          var element = this.$element[0];
          titleOption.className = 'bs-title-option';
          titleOption.appendChild(document.createTextNode(this.options.title));
          titleOption.value = '';
          element.insertBefore(titleOption, element.firstChild);
          // Check if selected attribute is already set on an option. If not, select the titleOption option.
          if ($(element.options[element.selectedIndex]).attr('selected') === undefined){
            titleOption.selected = true;
          }
        }
      }

      this.$element.find('option').each(function (index) {
        var $this = $(this);

        liIndex++;

        if ($this.hasClass('bs-title-option')) return;

        // Get the class and text for the option
        var optionClass = this.className || '',
            inline = this.style.cssText,
            text = $this.data('content') ? $this.data('content') : $this.html(),
            tokens = $this.data('tokens') ? $this.data('tokens') : null,
            subtext = typeof $this.data('subtext') !== 'undefined' ? '<small class="text-muted">' + $this.data('subtext') + '</small>' : '',
            icon = typeof $this.data('icon') !== 'undefined' ? '<span class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></span> ' : '',
            isDisabled = this.disabled || (this.parentElement.tagName === 'OPTGROUP' && this.parentElement.disabled);

        if (icon !== '' && isDisabled) {
          icon = '<span>' + icon + '</span>';
        }

        if (that.options.hideDisabled && isDisabled) {
          liIndex--;
          return;
        }

        if (!$this.data('content')) {
          // Prepend any icon and append any subtext to the main text.
          text = icon + '<span class="text">' + text + subtext + '</span>';
        }

        if (this.parentElement.tagName === 'OPTGROUP' && $this.data('divider') !== true) {
          var optGroupClass = ' ' + this.parentElement.className || '';

          if ($this.index() === 0) { // Is it the first option of the optgroup?
            optID += 1;

            // Get the opt group label
            var label = this.parentElement.label,
                labelSubtext = typeof $this.parent().data('subtext') !== 'undefined' ? '<small class="text-muted">' + $this.parent().data('subtext') + '</small>' : '',
                labelIcon = $this.parent().data('icon') ? '<span class="' + that.options.iconBase + ' ' + $this.parent().data('icon') + '"></span> ' : '';

            label = labelIcon + '<span class="text">' + label + labelSubtext + '</span>';

            if (index !== 0 && _li.length > 0) { // Is it NOT the first option of the select && are there elements in the dropdown?
              liIndex++;
              _li.push(generateLI('', null, 'divider', optID + 'div'));
            }
            liIndex++;
            _li.push(generateLI(label, null, 'dropdown-header' + optGroupClass, optID));
          }
          _li.push(generateLI(generateA(text, 'opt ' + optionClass + optGroupClass, inline, tokens), index, '', optID));
        } else if ($this.data('divider') === true) {
          _li.push(generateLI('', index, 'divider'));
        } else if ($this.data('hidden') === true) {
          _li.push(generateLI(generateA(text, optionClass, inline, tokens), index, 'hidden is-hidden'));
        } else {
          if (this.previousElementSibling && this.previousElementSibling.tagName === 'OPTGROUP') {
            liIndex++;
            _li.push(generateLI('', null, 'divider', optID + 'div'));
          }
          _li.push(generateLI(generateA(text, optionClass, inline, tokens), index));
        }

        that.liObj[index] = liIndex;
      });

      //If we are not multiple, we don't have a selected item, and we don't have a title, select the first element so something is set in the button
      if (!this.multiple && this.$element.find('option:selected').length === 0 && !this.options.title) {
        this.$element.find('option').eq(0).prop('selected', true).attr('selected', 'selected');
      }

      return _li.join('');
    },

    findLis: function () {
      if (this.$lis === null) this.$lis = this.$menu.find('li');
      return this.$lis;
    },

    /**
     * @param [updateLi] defaults to true
     */
    render: function (updateLi) {
      var that = this,
          notDisabled;

      //Update the LI to match the SELECT
      if (updateLi !== false) {
        this.$element.find('option').each(function (index) {
          var $lis = that.findLis().eq(that.liObj[index]);

          that.setDisabled(index, this.disabled || this.parentElement.tagName === 'OPTGROUP' && this.parentElement.disabled, $lis);
          that.setSelected(index, this.selected, $lis);
        });
      }

      this.tabIndex();

      var selectedItems = this.$element.find('option').map(function () {
        if (this.selected) {
          if (that.options.hideDisabled && (this.disabled || this.parentElement.tagName === 'OPTGROUP' && this.parentElement.disabled)) return;

          var $this = $(this),
              icon = $this.data('icon') && that.options.showIcon ? '<i class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></i> ' : '',
              subtext;

          if (that.options.showSubtext && $this.data('subtext') && !that.multiple) {
            subtext = ' <small class="text-muted">' + $this.data('subtext') + '</small>';
          } else {
            subtext = '';
          }
          if (typeof $this.attr('title') !== 'undefined') {
            return $this.attr('title');
          } else if ($this.data('content') && that.options.showContent) {
            return $this.data('content');
          } else {
            return icon + $this.html() + subtext;
          }
        }
      }).toArray();

      //Fixes issue in IE10 occurring when no default option is selected and at least one option is disabled
      //Convert all the values into a comma delimited string
      var title = !this.multiple ? selectedItems[0] : selectedItems.join(this.options.multipleSeparator);

      //If this is multi select, and the selectText type is count, the show 1 of 2 selected etc..
      if (this.multiple && this.options.selectedTextFormat.indexOf('count') > -1) {
        var max = this.options.selectedTextFormat.split('>');
        if ((max.length > 1 && selectedItems.length > max[1]) || (max.length == 1 && selectedItems.length >= 2)) {
          notDisabled = this.options.hideDisabled ? ', [disabled]' : '';
          var totalCount = this.$element.find('option').not('[data-divider="true"], [data-hidden="true"]' + notDisabled).length,
              tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedItems.length, totalCount) : this.options.countSelectedText;
          title = tr8nText.replace('{0}', selectedItems.length.toString()).replace('{1}', totalCount.toString());
        }
      }

      if (this.options.title === undefined) {
        this.options.title = this.$element.attr('title');
      }

      if (this.options.selectedTextFormat == 'static') {
        title = this.options.title;
      }

      //If we dont have a title, then use the default, or if nothing is set at all, use the not selected text
      if (!title) {
        title = typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText;
      }
      
      //strip all html-tags and trim the result
      this.$button.attr('title', $.trim(title.replace(/<[^>]*>?/g, '')));
      this.$button.parent().find('.filter-option').val(title);
      this.$button.children('.filter-option').html(title);
      this.$element.trigger('rendered.bs.select');
    },

    /**
     * @param [style]
     * @param [status]
     */
    setStyle: function (style, status) {
      if (this.$element.attr('class')) {
        this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ''));
      }

      var buttonClass = style ? style : this.options.style;

      if (status == 'add') {
        this.$button.addClass(buttonClass);
      } else if (status == 'remove') {
        this.$button.removeClass(buttonClass);
      } else {
        this.$button.removeClass(this.options.style);
        this.$button.addClass(buttonClass);
      }
    },

    liHeight: function (refresh) {
      if (!refresh && (this.options.size === false || this.sizeInfo)) return;

      var newElement = document.createElement('div'),
          menu = document.createElement('div'),
          menuInner = document.createElement('ul'),
          divider = document.createElement('li'),
          li = document.createElement('li'),
          a = document.createElement('a'),
          text = document.createElement('span'),
          header = this.options.header ? this.$menu.find('.popover-title')[0].cloneNode(true) : null,
          search = this.options.liveSearch ? document.createElement('div') : null,
          actions = this.options.actionsBox && this.multiple ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,
          doneButton = this.options.doneButton && this.multiple ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null;

      text.className = 'text';
      newElement.className = this.$menu[0].parentNode.className + ' open';
      menu.className = 'dropdown-menu open';
      menuInner.className = 'dropdown-menu inner';
      divider.className = 'divider';

      text.appendChild(document.createTextNode('Inner text'));
      a.appendChild(text);
      li.appendChild(a);
      menuInner.appendChild(li);
      menuInner.appendChild(divider);
      if (header) menu.appendChild(header);
      if (search) {
        // create a span instead of input as creating an input element is slower
        var input = document.createElement('span');
        search.className = 'bs-searchbox';
        input.className = 'form-control';
        search.appendChild(input);
        menu.appendChild(search);
      }
      if (actions) menu.appendChild(actions);
      menu.appendChild(menuInner);
      if (doneButton) menu.appendChild(doneButton);
      newElement.appendChild(menu);

      document.body.appendChild(newElement);

      var liHeight = a.offsetHeight,
          headerHeight = header ? header.offsetHeight : 0,
          searchHeight = search ? search.offsetHeight : 0,
          actionsHeight = actions ? actions.offsetHeight : 0,
          doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,
          dividerHeight = $(divider).outerHeight(true),
          // fall back to jQuery if getComputedStyle is not supported
          menuStyle = typeof getComputedStyle === 'function' ? getComputedStyle(menu) : false,
          $menu = menuStyle ? null : $(menu),
          menuPadding = parseInt(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) +
                        parseInt(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) +
                        parseInt(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) +
                        parseInt(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),
          menuExtras =  menuPadding + 
                        parseInt(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) + 
                        parseInt(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2;

      document.body.removeChild(newElement);

      this.sizeInfo = {
        liHeight: liHeight,
        headerHeight: headerHeight,
        searchHeight: searchHeight,
        actionsHeight: actionsHeight,
        doneButtonHeight: doneButtonHeight,
        dividerHeight: dividerHeight,
        menuPadding: menuPadding,
        menuExtras: menuExtras
      };
    },

    setSize: function () {
      this.findLis();
      this.liHeight();

      if (this.options.header) this.$menu.css('padding-top', 0);
      if (this.options.size === false) return;

      var that = this,
          $menu = this.$menu,
          $menuInner = this.$menuInner,
          $window = $(window),
          selectHeight = this.$newElement[0].offsetHeight,
          liHeight = this.sizeInfo.liHeight,
          headerHeight = this.sizeInfo.headerHeight,
          searchHeight = this.sizeInfo.searchHeight,
          actionsHeight = this.sizeInfo.actionsHeight,
          doneButtonHeight = this.sizeInfo.doneButtonHeight,
          divHeight = this.sizeInfo.dividerHeight,
          menuPadding = this.sizeInfo.menuPadding,
          menuExtras = this.sizeInfo.menuExtras,
          notDisabled = this.options.hideDisabled ? '.disabled' : '',
          menuHeight,
          getHeight,
          selectOffsetTop,
          selectOffsetBot,
          posVert = function () {
            selectOffsetTop = that.$newElement.offset().top - $window.scrollTop();
            selectOffsetBot = $window.height() - selectOffsetTop - selectHeight;
          };

      posVert();

      if (this.options.size === 'auto') {
        var getSize = function () {
          var minHeight,
              hasClass = function (className, include) {
                return function (element) {
                    if (include) {
                        return (element.classList ? element.classList.contains(className) : $(element).hasClass(className));
                    } else {
                        return !(element.classList ? element.classList.contains(className) : $(element).hasClass(className));
                    }
                };
              },
              lis = that.$menuInner[0].getElementsByTagName('li'),
              lisVisible = Array.prototype.filter ? Array.prototype.filter.call(lis, hasClass('hidden', false)) : that.$lis.not('.hidden'),
              optGroup = Array.prototype.filter ? Array.prototype.filter.call(lisVisible, hasClass('dropdown-header', true)) : lisVisible.filter('.dropdown-header');

          posVert();
          menuHeight = selectOffsetBot - menuExtras;

          if (that.options.container) {
            if (!$menu.data('height')) $menu.data('height', $menu.height());
            getHeight = $menu.data('height');
          } else {
            getHeight = $menu.height();
          }

          if (that.options.dropupAuto) {
            that.$newElement.toggleClass('dropup', selectOffsetTop > selectOffsetBot && (menuHeight - menuExtras) < getHeight);
          }
          if (that.$newElement.hasClass('dropup')) {
            menuHeight = selectOffsetTop - menuExtras;
          }

          if ((lisVisible.length + optGroup.length) > 3) {
            minHeight = liHeight * 3 + menuExtras - 2;
          } else {
            minHeight = 0;
          }

          $menu.css({
            'max-height': menuHeight + 'px',
            'overflow': 'hidden',
            'min-height': minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight + 'px'
          });
          $menuInner.css({
            'max-height': menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding + 'px',
            'overflow-y': 'auto',
            'min-height': Math.max(minHeight - menuPadding, 0) + 'px'
          });
        };
        getSize();
        this.$searchbox.off('input.getSize propertychange.getSize').on('input.getSize propertychange.getSize', getSize);
        $window.off('resize.getSize scroll.getSize').on('resize.getSize scroll.getSize', getSize);
      } else if (this.options.size && this.options.size != 'auto' && this.$lis.not(notDisabled).length > this.options.size) {
        var optIndex = this.$lis.not('.divider').not(notDisabled).children().slice(0, this.options.size).last().parent().index(),
            divLength = this.$lis.slice(0, optIndex + 1).filter('.divider').length;
        menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding;

        if (that.options.container) {
          if (!$menu.data('height')) $menu.data('height', $menu.height());
          getHeight = $menu.data('height');
        } else {
          getHeight = $menu.height();
        }

        if (that.options.dropupAuto) {
          //noinspection JSUnusedAssignment
          this.$newElement.toggleClass('dropup', selectOffsetTop > selectOffsetBot && (menuHeight - menuExtras) < getHeight);
        }
        $menu.css({
          'max-height': menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight + 'px',
          'overflow': 'hidden',
          'min-height': ''
        });
        $menuInner.css({
          'max-height': menuHeight - menuPadding + 'px',
          'overflow-y': 'auto',
          'min-height': ''
        });
      }
    },

    setWidth: function () {
      if (this.options.width === 'auto') {
        this.$menu.css('min-width', '0');

        // Get correct width if element is hidden
        var $selectClone = this.$menu.parent().clone().appendTo('body'),
            $selectClone2 = this.options.container ? this.$newElement.clone().appendTo('body') : $selectClone,
            ulWidth = $selectClone.children('.dropdown-menu').outerWidth(),
            btnWidth = $selectClone2.css('width', 'auto').children('button').outerWidth();

        $selectClone.remove();
        $selectClone2.remove();

        // Set width to whatever's larger, button title or longest option
        this.$newElement.css('width', Math.max(ulWidth, btnWidth) + 'px');
      } else if (this.options.width === 'fit') {
        // Remove inline min-width so width can be changed from 'auto'
        this.$menu.css('min-width', '');
        this.$newElement.css('width', '').addClass('fit-width');
      } else if (this.options.width) {
        // Remove inline min-width so width can be changed from 'auto'
        this.$menu.css('min-width', '');
        this.$newElement.css('width', this.options.width);
      } else {
        // Remove inline min-width/width so width can be changed
        this.$menu.css('min-width', '');
        this.$newElement.css('width', '');
      }
      // Remove fit-width class if width is changed programmatically
      if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
        this.$newElement.removeClass('fit-width');
      }
    },

    selectPosition: function () {
      var that = this,
          $drop = $('<div class="bs-container" />'),
          pos,
          actualHeight,
          getPlacement = function ($element) {
            $drop.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass('dropup', $element.hasClass('dropup'));
            pos = $element.offset();
            actualHeight = $element.hasClass('dropup') ? 0 : $element[0].offsetHeight;
            $drop.css({
              'top': pos.top + actualHeight,
              'left': pos.left,
              'width': $element[0].offsetWidth
            });
          };

      this.$newElement.on('click', function () {
        if (that.isDisabled()) {
          return;
        }
        getPlacement($(this));
        $drop.appendTo(that.options.container);
        $drop.toggleClass('open', !$(this).hasClass('open'));
        $drop.append(that.$menu);
      });

      $(window).on('resize scroll', function () {
        getPlacement(that.$newElement);
      });

      this.$element.on('hide.bs.select', function () {
        that.$menu.data('height', that.$menu.height());
        $drop.detach();
      });
    },

    setSelected: function (index, selected, $lis) {
      if (!$lis) {
        $lis = this.findLis().eq(this.liObj[index]);
      }

      $lis.toggleClass('selected', selected);
    },

    setDisabled: function (index, disabled, $lis) {
      if (!$lis) {
        $lis = this.findLis().eq(this.liObj[index]);
      }

      if (disabled) {
        $lis.addClass('disabled').children('a').attr('href', '#').attr('tabindex', -1);
      } else {
        $lis.removeClass('disabled').children('a').removeAttr('href').attr('tabindex', 0);
      }
    },

    isDisabled: function () {
      return this.$element[0].disabled;
    },

    checkDisabled: function () {
      var that = this;

      if (this.isDisabled()) {
        this.$newElement.addClass('disabled');
        this.$button.addClass('disabled').attr('tabindex', -1);
      } else {
        if (this.$button.hasClass('disabled')) {
          this.$newElement.removeClass('disabled');
          this.$button.removeClass('disabled');
        }

        if (this.$button.attr('tabindex') == -1 && !this.$element.data('tabindex')) {
          this.$button.removeAttr('tabindex');
        }
      }

      this.$button.click(function () {
        return !that.isDisabled();
      });
    },

    tabIndex: function () {
      if (this.$element.is('[tabindex]')) {
        this.$element.data('tabindex', this.$element.attr('tabindex'));
        this.$button.attr('tabindex', this.$element.data('tabindex'));
      }
    },

    clickListener: function () {
      var that = this,
          $document = $(document);

      this.$newElement.on('touchstart.dropdown', '.dropdown-menu', function (e) {
        e.stopPropagation();
      });

      $document.data('spaceSelect', false);

      this.$button.on('keyup', function (e) {
        if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {
            e.preventDefault();
            $document.data('spaceSelect', false);
        }
      });

      this.$newElement.on('click', function () {
        that.setSize();
        that.$element.on('shown.bs.select', function () {
          if (!that.options.liveSearch && !that.multiple) {
            that.$menuInner.find('.selected a').focus();
          } else if (!that.multiple) {
            var selectedIndex = that.liObj[that.$element[0].selectedIndex];

            if (typeof selectedIndex !== 'number' || that.options.size === false) return;

            // scroll to selected option
            var offset = that.$lis.eq(selectedIndex)[0].offsetTop - that.$menuInner[0].offsetTop;
            offset = offset - that.$menuInner[0].offsetHeight/2 + that.sizeInfo.liHeight/2;
            that.$menuInner[0].scrollTop = offset;
          }
        });
      });

      this.$menuInner.on('click', 'li a', function (e) {
        var $this = $(this),
            clickedIndex = $this.parent().data('originalIndex'),
            prevValue = that.$element.val(),
            prevIndex = that.$element.prop('selectedIndex');

        // Don't close on multi choice menu
        if (that.multiple) {
          e.stopPropagation();
        }

        e.preventDefault();

        //Don't run if we have been disabled
        if (!that.isDisabled() && !$this.parent().hasClass('disabled')) {
          var $options = that.$element.find('option'),
              $option = $options.eq(clickedIndex),
              state = $option.prop('selected'),
              $optgroup = $option.parent('optgroup'),
              maxOptions = that.options.maxOptions,
              maxOptionsGrp = $optgroup.data('maxOptions') || false;

          if (!that.multiple) { // Deselect all others if not multi select box
            $options.prop('selected', false);
            $option.prop('selected', true);
            that.$menuInner.find('.selected').removeClass('selected');
            that.setSelected(clickedIndex, true);
          } else { // Toggle the one we have chosen if we are multi select.
            $option.prop('selected', !state);
            that.setSelected(clickedIndex, !state);
            $this.blur();

            if (maxOptions !== false || maxOptionsGrp !== false) {
              var maxReached = maxOptions < $options.filter(':selected').length,
                  maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;

              if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {
                if (maxOptions && maxOptions == 1) {
                  $options.prop('selected', false);
                  $option.prop('selected', true);
                  that.$menuInner.find('.selected').removeClass('selected');
                  that.setSelected(clickedIndex, true);
                } else if (maxOptionsGrp && maxOptionsGrp == 1) {
                  $optgroup.find('option:selected').prop('selected', false);
                  $option.prop('selected', true);
                  var optgroupID = $this.parent().data('optgroup');
                  that.$menuInner.find('[data-optgroup="' + optgroupID + '"]').removeClass('selected');
                  that.setSelected(clickedIndex, true);
                } else {
                  var maxOptionsArr = (typeof that.options.maxOptionsText === 'function') ?
                          that.options.maxOptionsText(maxOptions, maxOptionsGrp) : that.options.maxOptionsText,
                      maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
                      maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
                      $notify = $('<div class="notify"></div>');
                  // If {var} is set in array, replace it
                  /** @deprecated */
                  if (maxOptionsArr[2]) {
                    maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
                    maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
                  }

                  $option.prop('selected', false);

                  that.$menu.append($notify);

                  if (maxOptions && maxReached) {
                    $notify.append($('<div>' + maxTxt + '</div>'));
                    that.$element.trigger('maxReached.bs.select');
                  }

                  if (maxOptionsGrp && maxReachedGrp) {
                    $notify.append($('<div>' + maxTxtGrp + '</div>'));
                    that.$element.trigger('maxReachedGrp.bs.select');
                  }

                  setTimeout(function () {
                    that.setSelected(clickedIndex, false);
                  }, 10);

                  $notify.delay(750).fadeOut(300, function () {
                    $(this).remove();
                  });
                }
              }
            }
          }

          if (!that.multiple) {
            that.$button.focus();
          } else if (that.options.liveSearch) {
            that.$searchbox.focus();
          }

          // Trigger select 'change'
          if ((prevValue != that.$element.val() && that.multiple) || (prevIndex != that.$element.prop('selectedIndex') && !that.multiple)) {
            that.$element.triggerNative('change');
            // $option.prop('selected') is current option state (selected/unselected). state is previous option state.
            that.$element.trigger('changed.bs.select', [clickedIndex, $option.prop('selected'), state]);
          }
        }
      });

      this.$menu.on('click', 'li.disabled a, .popover-title, .popover-title :not(.close)', function (e) {
        if (e.currentTarget == this) {
          e.preventDefault();
          e.stopPropagation();
          if (that.options.liveSearch && !$(e.target).hasClass('close')) {
            that.$searchbox.focus();
          } else {
            that.$button.focus();
          }
        }
      });

      this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (that.options.liveSearch) {
          that.$searchbox.focus();
        } else {
          that.$button.focus();
        }
      });

      this.$menu.on('click', '.popover-title .close', function () {
        that.$button.click();
      });

      this.$searchbox.on('click', function (e) {
        e.stopPropagation();
      });

      this.$menu.on('click', '.actions-btn', function (e) {
        if (that.options.liveSearch) {
          that.$searchbox.focus();
        } else {
          that.$button.focus();
        }

        e.preventDefault();
        e.stopPropagation();

        if ($(this).hasClass('bs-select-all')) {
          that.selectAll();
        } else {
          that.deselectAll();
        }
        that.$element.triggerNative('change');
      });

      this.$element.change(function () {
        that.render(false);
      });
    },

    liveSearchListener: function () {
      var that = this,
          $no_results = $('<li class="no-results"></li>');

      this.$newElement.on('click.dropdown.data-api touchstart.dropdown.data-api', function () {
        that.$menuInner.find('.active').removeClass('active');
        if (!!that.$searchbox.val()) {
          that.$searchbox.val('');
          that.$lis.not('.is-hidden').removeClass('hidden');
          if (!!$no_results.parent().length) $no_results.remove();
        }
        if (!that.multiple) that.$menuInner.find('.selected').addClass('active');
        setTimeout(function () {
          that.$searchbox.focus();
        }, 10);
      });

      this.$searchbox.on('click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api', function (e) {
        e.stopPropagation();
      });

      this.$searchbox.on('input propertychange', function () {
        if (that.$searchbox.val()) {
          var $searchBase = that.$lis.not('.is-hidden').removeClass('hidden').children('a');
          if (that.options.liveSearchNormalize) {
            $searchBase = $searchBase.not(':a' + that._searchStyle() + '("' + normalizeToBase(that.$searchbox.val()) + '")');
          } else {
            $searchBase = $searchBase.not(':' + that._searchStyle() + '("' + that.$searchbox.val() + '")');
          }
          $searchBase.parent().addClass('hidden');

          that.$lis.filter('.dropdown-header').each(function () {
            var $this = $(this),
                optgroup = $this.data('optgroup');

            if (that.$lis.filter('[data-optgroup=' + optgroup + ']').not($this).not('.hidden').length === 0) {
              $this.addClass('hidden');
              that.$lis.filter('[data-optgroup=' + optgroup + 'div]').addClass('hidden');
            }
          });

          var $lisVisible = that.$lis.not('.hidden');

          // hide divider if first or last visible, or if followed by another divider
          $lisVisible.each(function (index) {
            var $this = $(this);

            if ($this.hasClass('divider') && (
              $this.index() === $lisVisible.first().index() ||
              $this.index() === $lisVisible.last().index() ||
              $lisVisible.eq(index + 1).hasClass('divider'))) {
              $this.addClass('hidden');
            }
          });

          if (!that.$lis.not('.hidden, .no-results').length) {
            if (!!$no_results.parent().length) {
              $no_results.remove();
            }
            $no_results.html(that.options.noneResultsText.replace('{0}', '"' + htmlEscape(that.$searchbox.val()) + '"')).show();
            that.$menuInner.append($no_results);
          } else if (!!$no_results.parent().length) {
            $no_results.remove();
          }
        } else {
          that.$lis.not('.is-hidden').removeClass('hidden');
          if (!!$no_results.parent().length) {
            $no_results.remove();
          }
        }

        that.$lis.filter('.active').removeClass('active');
        if (that.$searchbox.val()) that.$lis.not('.hidden, .divider, .dropdown-header').eq(0).addClass('active').children('a').focus();
        $(this).focus();
      });
    },

    _searchStyle: function () {
      var style = 'icontains';
      switch (this.options.liveSearchStyle) {
        case 'begins':
        case 'startsWith':
          style = 'ibegins';
          break;
        case 'contains':
          break;
        default:
          break; //no need to change the default
      }

      return style;
    },

    val: function (value) {
      if (typeof value !== 'undefined') {
        this.$element.val(value);
        this.render();

        return this.$element;
      } else {
        return this.$element.val();
      }
    },

    selectAll: function () {
      this.findLis();
      this.$element.find('option:enabled').not('[data-divider], [data-hidden]').prop('selected', true);
      this.$lis.not('.divider, .dropdown-header, .disabled, .hidden').addClass('selected');
      this.render(false);
    },

    deselectAll: function () {
      this.findLis();
      this.$element.find('option:enabled').not('[data-divider], [data-hidden]').prop('selected', false);
      this.$lis.not('.divider, .dropdown-header, .disabled, .hidden').removeClass('selected');
      this.render(false);
    },

    keydown: function (e) {
      var $this = $(this),
          $parent = $this.is('input') ? $this.parent().parent() : $this.parent(),
          $items,
          that = $parent.data('this'),
          index,
          next,
          first,
          last,
          prev,
          nextPrev,
          prevIndex,
          isActive,
          selector = ':not(.disabled, .hidden, .dropdown-header, .divider)',
          keyCodeMap = {
            32: ' ',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            59: ';',
            65: 'a',
            66: 'b',
            67: 'c',
            68: 'd',
            69: 'e',
            70: 'f',
            71: 'g',
            72: 'h',
            73: 'i',
            74: 'j',
            75: 'k',
            76: 'l',
            77: 'm',
            78: 'n',
            79: 'o',
            80: 'p',
            81: 'q',
            82: 'r',
            83: 's',
            84: 't',
            85: 'u',
            86: 'v',
            87: 'w',
            88: 'x',
            89: 'y',
            90: 'z',
            96: '0',
            97: '1',
            98: '2',
            99: '3',
            100: '4',
            101: '5',
            102: '6',
            103: '7',
            104: '8',
            105: '9'
          };

      if (that.options.liveSearch) $parent = $this.parent().parent();

      if (that.options.container) $parent = that.$menu;

      $items = $('[role=menu] li', $parent);

      isActive = that.$menu.parent().hasClass('open');

      if (!isActive && (e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 65 && e.keyCode <= 90)) {
        if (!that.options.container) {
          that.setSize();
          that.$menu.parent().addClass('open');
          isActive = true;
        } else {
          that.$newElement.trigger('click');
        }
        that.$searchbox.focus();
      }

      if (that.options.liveSearch) {
        if (/(^9$|27)/.test(e.keyCode.toString(10)) && isActive && that.$menu.find('.active').length === 0) {
          e.preventDefault();
          that.$menu.parent().removeClass('open');
          if (that.options.container) that.$newElement.removeClass('open');
          that.$button.focus();
        }
        // $items contains li elements when liveSearch is enabled
        $items = $('[role=menu] li' + selector, $parent);
        if (!$this.val() && !/(38|40)/.test(e.keyCode.toString(10))) {
          if ($items.filter('.active').length === 0) {
            $items = that.$menuInner.find('li');
            if (that.options.liveSearchNormalize) {
              $items = $items.filter(':a' + that._searchStyle() + '(' + normalizeToBase(keyCodeMap[e.keyCode]) + ')');
            } else {
              $items = $items.filter(':' + that._searchStyle() + '(' + keyCodeMap[e.keyCode] + ')');
            }
          }
        }
      }

      if (!$items.length) return;

      if (/(38|40)/.test(e.keyCode.toString(10))) {
        index = $items.index($items.find('a').filter(':focus').parent());
        first = $items.filter(selector).first().index();
        last = $items.filter(selector).last().index();
        next = $items.eq(index).nextAll(selector).eq(0).index();
        prev = $items.eq(index).prevAll(selector).eq(0).index();
        nextPrev = $items.eq(next).prevAll(selector).eq(0).index(); 

        if (that.options.liveSearch) {
          $items.each(function (i) {
            if (!$(this).hasClass('disabled')) {
              $(this).data('index', i);
            }
          });
          index = $items.index($items.filter('.active'));
          first = $items.first().data('index');
          last = $items.last().data('index');
          next = $items.eq(index).nextAll().eq(0).data('index');
          prev = $items.eq(index).prevAll().eq(0).data('index');
          nextPrev = $items.eq(next).prevAll().eq(0).data('index');
        }

        prevIndex = $this.data('prevIndex');

        if (e.keyCode == 38) {
          if (that.options.liveSearch) index--;
          if (index != nextPrev && index > prev) index = prev;
          if (index < first) index = first;
          if (index == prevIndex) index = last;
        } else if (e.keyCode == 40) {
          if (that.options.liveSearch) index++;
          if (index == -1) index = 0;
          if (index != nextPrev && index < next) index = next;
          if (index > last) index = last;
          if (index == prevIndex) index = first;
        }

        $this.data('prevIndex', index);

        if (!that.options.liveSearch) {
          $items.eq(index).children('a').focus();
        } else {
          e.preventDefault();
          if (!$this.hasClass('dropdown-toggle')) {
            $items.removeClass('active').eq(index).addClass('active').children('a').focus();
            $this.focus();
          }
        }

      } else if (!$this.is('input')) {
        var keyIndex = [],
            count,
            prevKey;

        $items.each(function () {
          if (!$(this).hasClass('disabled')) {
            if ($.trim($(this).children('a').text().toLowerCase()).substring(0, 1) == keyCodeMap[e.keyCode]) {
              keyIndex.push($(this).index());
            }
          }
        });

        count = $(document).data('keycount');
        count++;
        $(document).data('keycount', count);

        prevKey = $.trim($(':focus').text().toLowerCase()).substring(0, 1);

        if (prevKey != keyCodeMap[e.keyCode]) {
          count = 1;
          $(document).data('keycount', count);
        } else if (count >= keyIndex.length) {
          $(document).data('keycount', 0);
          if (count > keyIndex.length) count = 1;
        }

        $items.eq(keyIndex[count - 1]).children('a').focus();
      }

      // Select focused option if "Enter", "Spacebar" or "Tab" (when selectOnTab is true) are pressed inside the menu.
      if ((/(13|32)/.test(e.keyCode.toString(10)) || (/(^9$)/.test(e.keyCode.toString(10)) && that.options.selectOnTab)) && isActive) {
        if (!/(32)/.test(e.keyCode.toString(10))) e.preventDefault();
        if (!that.options.liveSearch) {
          var elem = $(':focus');
          elem.click();
          // Bring back focus for multiselects
          elem.focus();
          // Prevent screen from scrolling if the user hit the spacebar
          e.preventDefault();
          // Fixes spacebar selection of dropdown items in FF & IE
          $(document).data('spaceSelect', true);
        } else if (!/(32)/.test(e.keyCode.toString(10))) {
          that.$menuInner.find('.active a').click();
          $this.focus();
        }
        $(document).data('keycount', 0);
      }

      if ((/(^9$|27)/.test(e.keyCode.toString(10)) && isActive && (that.multiple || that.options.liveSearch)) || (/(27)/.test(e.keyCode.toString(10)) && !isActive)) {
        that.$menu.parent().removeClass('open');
        if (that.options.container) that.$newElement.removeClass('open');
        that.$button.focus();
      }
    },

    mobile: function () {
      this.$element.addClass('mobile-device').appendTo(this.$newElement);
      if (this.options.container) this.$menu.hide();
    },

    refresh: function () {
      this.$lis = null;
      this.liObj = {};
      this.reloadLi();
      this.render();
      this.checkDisabled();
      this.liHeight(true);
      this.setStyle();
      this.setWidth();
      if (this.$lis) this.$searchbox.trigger('propertychange');

      this.$element.trigger('refreshed.bs.select');
    },

    hide: function () {
      this.$newElement.hide();
    },

    show: function () {
      this.$newElement.show();
    },

    remove: function () {
      this.$newElement.remove();
      this.$element.remove();
    }
  };

  // SELECTPICKER PLUGIN DEFINITION
  // ==============================
  function Plugin(option, event) {
    // get the args of the outer function..
    var args = arguments;
    // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them
    // to get lost/corrupted in android 2.3 and IE9 #715 #775
    var _option = option,
        _event = event;
    [].shift.apply(args);

    var value;
    var chain = this.each(function () {
      var $this = $(this);
      if ($this.is('select')) {
        var data = $this.data('selectpicker'),
            options = typeof _option == 'object' && _option;

        if (!data) {
          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, $this.data(), options);
          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), $this.data().template, options.template);
          $this.data('selectpicker', (data = new Selectpicker(this, config, _event)));
        } else if (options) {
          for (var i in options) {
            if (options.hasOwnProperty(i)) {
              data.options[i] = options[i];
            }
          }
        }

        if (typeof _option == 'string') {
          if (data[_option] instanceof Function) {
            value = data[_option].apply(data, args);
          } else {
            value = data.options[_option];
          }
        }
      }
    });

    if (typeof value !== 'undefined') {
      //noinspection JSUnusedAssignment
      return value;
    } else {
      return chain;
    }
  }

  var old = $.fn.selectpicker;
  $.fn.selectpicker = Plugin;
  $.fn.selectpicker.Constructor = Selectpicker;

  // SELECTPICKER NO CONFLICT
  // ========================
  $.fn.selectpicker.noConflict = function () {
    $.fn.selectpicker = old;
    return this;
  };

  $(document)
      .data('keycount', 0)
      .on('keydown', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="menu"], .bs-searchbox input', Selectpicker.prototype.keydown)
      .on('focusin.modal', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="menu"], .bs-searchbox input', function (e) {
        e.stopPropagation();
      });

  // SELECTPICKER DATA-API
  // =====================
  $(window).on('load.bs.select.data-api', function () {
    $('.selectpicker').each(function () {
      var $selectpicker = $(this);
      Plugin.call($selectpicker, $selectpicker.data());
    });
  });
})(jQuery);


}));
/**
 * Resolve URL for an image served by Pixl.
 * 
 * @param imageId
 * @param size
 * @return
 */
var resolve = function(imageId, imageFormatParameter, size){
	if(!imageId){
		return "";
	}
	
	return appendSize(imageId, imageFormatParameter, size);
};

/**
 * Append the size to the end of the given url.
 * 
 * @param imageId
 * @param size
 * @return
 */
var appendSize = function(imageId, imageFormatParameter, size){
	if(!imageId){
		return "";
	}
	
	if(!size && !imageFormatParameter){
		return imageId;
	}
	
	return imageId + "?" + imageFormatParameter + "=" + size;
};

/* 
 * the code will add the class to hide the breadcrumb current and home options when the page 
 * is on mobile mode     
 * 
 */

var showBreadCrumbMobile = function () {
	$(".breadcrumbs").each(function(key){
		var $this = $(this);
		if(key === 0){
			//$this.parent().css("width", "auto");
			$this.find(".home").addClass("hidden-xs");
			$this.find(".related").addClass("hidden-xs");
			$this.find(".current").addClass("hidden-xs");
			if($this.find(".parent a").hasClass("right")){
				$this.find(".parent a").removeClass("right"); 
			}
			// Add a class to put the arrow pointing out to the left
			$this.find(".parent a").addClass("left"); 
		}
		if(key == 1){
			$(".breadcrumbs-mobile").css("height", $this.parent().css("height"));
		}
	});	
};
var showBreadCrumb = function () {
	$(".breadcrumbs").each(function(key){
		var $this = $(this);
		if(key === 0){
			if($this.find(".parent a").hasClass("left")){
				$this.find(".parent a").addClass("right");
			}
		}
	});	
};

$(window).resize(function(){
	checkModeScreen();
});

// Function to check the screen mode
var checkModeScreen = function(){
	if(decathlon.uxBreakpoints.xsMax > $(window).width()){
		showBreadCrumbMobile();
	}
	else{
		showBreadCrumb();
	}
};

checkModeScreen();



/**
 * Creates the picture tag on the javaScript side.
 */
var createPictureTag = function(smallImage, mediumImage, bigImage, imageAltText){
	var pictureOpeningTag = '<picture alt="' + imageAltText + '" aria-hidden="true">';
	var bigImageSource = createSourceTag(getFirstNonEmptyValue(smallImage, mediumImage, bigImage),"(min-width: 769px)");
	var mediumImageSource = createSourceTag(getFirstNonEmptyValue(smallImage, mediumImage, bigImage),"(min-width: 481px)");
	var smallImageSource = createSourceTag(getFirstNonEmptyValue(smallImage, mediumImage, bigImage),"(max-width: 480px)");
	var imageTag = '<img @available src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="' + imageAltText + '">';
	var bigImageimg = createPictureImgTag(bigImage, imageAltText, "hidden-xs");
	var mediumImageimg = createPictureImgTag(getFirstNonEmptyValue("",mediumImage,bigImage), imageAltText, "visible-480-xs");
	var smallImageimg = createPictureImgTag(getFirstNonEmptyValue(smallImage,mediumImage,bigImage), imageAltText, "visible-480");
	return pictureOpeningTag + bigImageSource + mediumImageSource + smallImageSource + imageTag + '<!--[if lt IE 9]>' + bigImageimg + mediumImageimg + smallImageimg + '<![endif]-->' + '</picture>';
};

/**
 * Creates a source tag that is part of the picture tag.
 */
var createSourceTag = function(srcsetValue, mediaValue){
	return '<source srcset="' + srcsetValue + '" media="' + mediaValue + '">';
};

/**
 * Creates an image tag that is part of the picture tag.
 */
var createPictureImgTag = function(srcValue, altValue, cssClassValue){
	return '<img src="' + srcValue + '" alt="' + altValue + '" class="' + cssClassValue + '">';
};

/**
 * Updates an existing picture tag links.
 * <picture>
 * 	  <source>
 *    <source>
 *    <source>
 *    <img>
 */
var updateImagePictureFromUrlsFormat = function(smallImage, mediumImage, bigImage, imageAltTextpictureFragmentObj, pictureFragmentObj){
	if(pictureFragmentObj){
		var pictureFragmentObjChildren = pictureFragmentObj.children();
		if(pictureFragmentObjChildren){
			pictureFragmentObj.attr('alt', imageAltTextpictureFragmentObj);
			pictureFragmentObjChildren.eq(0).attr('srcset', getFirstNonEmptyValue(smallImage, mediumImage, bigImage));
			pictureFragmentObjChildren.eq(1).attr('srcset', getFirstNonEmptyValue(smallImage, mediumImage, bigImage));
			pictureFragmentObjChildren.eq(2).attr('srcset', getFirstNonEmptyValue(smallImage, mediumImage, bigImage));
			pictureFragmentObjChildren.eq(3).attr('alt', imageAltTextpictureFragmentObj);
		}
	}
};

/**
 * Returns the first available value.
 */
var getFirstNonEmptyValue = function(smallImage, mediumImage, bigImage){
	if(smallImage){
		return smallImage;
	} else if(mediumImage) {
		return mediumImage;
	}
	
	return bigImage;
};
// ProgressBar.js 0.9.0
// https://kimmobrunfeldt.github.io/progressbar.js
// License: MIT

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ProgressBar = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*! shifty - v1.5.0 - 2015-05-31 - http://jeremyckahn.github.io/shifty */
;(function () {
  var root = this;

/*!
 * Shifty Core
 * By Jeremy Kahn - jeremyckahn@gmail.com
 */

var Tweenable = (function () {

  'use strict';

  // Aliases that get defined later in this function
  var formula;

  // CONSTANTS
  var DEFAULT_SCHEDULE_FUNCTION;
  var DEFAULT_EASING = 'linear';
  var DEFAULT_DURATION = 500;
  var UPDATE_TIME = 1000 / 60;

  var _now = Date.now
       ? Date.now
       : function () {return +new Date();};

  var now = typeof SHIFTY_DEBUG_NOW !== 'undefined' ? SHIFTY_DEBUG_NOW : _now;

  if (typeof window !== 'undefined') {
    // requestAnimationFrame() shim by Paul Irish (modified for Shifty)
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    DEFAULT_SCHEDULE_FUNCTION = window.requestAnimationFrame
       || window.webkitRequestAnimationFrame
       || window.oRequestAnimationFrame
       || window.msRequestAnimationFrame
       || (window.mozCancelRequestAnimationFrame
       && window.mozRequestAnimationFrame)
       || setTimeout;
  } else {
    DEFAULT_SCHEDULE_FUNCTION = setTimeout;
  }

  function noop () {
    // NOOP!
  }

  /*!
   * Handy shortcut for doing a for-in loop. This is not a "normal" each
   * function, it is optimized for Shifty.  The iterator function only receives
   * the property name, not the value.
   * @param {Object} obj
   * @param {Function(string)} fn
   */
  function each (obj, fn) {
    var key;
    for (key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        fn(key);
      }
    }
  }

  /*!
   * Perform a shallow copy of Object properties.
   * @param {Object} targetObject The object to copy into
   * @param {Object} srcObject The object to copy from
   * @return {Object} A reference to the augmented `targetObj` Object
   */
  function shallowCopy (targetObj, srcObj) {
    each(srcObj, function (prop) {
      targetObj[prop] = srcObj[prop];
    });

    return targetObj;
  }

  /*!
   * Copies each property from src onto target, but only if the property to
   * copy to target is undefined.
   * @param {Object} target Missing properties in this Object are filled in
   * @param {Object} src
   */
  function defaults (target, src) {
    each(src, function (prop) {
      if (typeof target[prop] === 'undefined') {
        target[prop] = src[prop];
      }
    });
  }

  /*!
   * Calculates the interpolated tween values of an Object for a given
   * timestamp.
   * @param {Number} forPosition The position to compute the state for.
   * @param {Object} currentState Current state properties.
   * @param {Object} originalState: The original state properties the Object is
   * tweening from.
   * @param {Object} targetState: The destination state properties the Object
   * is tweening to.
   * @param {number} duration: The length of the tween in milliseconds.
   * @param {number} timestamp: The UNIX epoch time at which the tween began.
   * @param {Object} easing: This Object's keys must correspond to the keys in
   * targetState.
   */
  function tweenProps (forPosition, currentState, originalState, targetState,
    duration, timestamp, easing) {
    var normalizedPosition =
        forPosition < timestamp ? 0 : (forPosition - timestamp) / duration;


    var prop;
    var easingObjectProp;
    var easingFn;
    for (prop in currentState) {
      if (currentState.hasOwnProperty(prop)) {
        easingObjectProp = easing[prop];
        easingFn = typeof easingObjectProp === 'function'
          ? easingObjectProp
          : formula[easingObjectProp];

        currentState[prop] = tweenProp(
          originalState[prop],
          targetState[prop],
          easingFn,
          normalizedPosition
        );
      }
    }

    return currentState;
  }

  /*!
   * Tweens a single property.
   * @param {number} start The value that the tween started from.
   * @param {number} end The value that the tween should end at.
   * @param {Function} easingFunc The easing curve to apply to the tween.
   * @param {number} position The normalized position (between 0.0 and 1.0) to
   * calculate the midpoint of 'start' and 'end' against.
   * @return {number} The tweened value.
   */
  function tweenProp (start, end, easingFunc, position) {
    return start + (end - start) * easingFunc(position);
  }

  /*!
   * Applies a filter to Tweenable instance.
   * @param {Tweenable} tweenable The `Tweenable` instance to call the filter
   * upon.
   * @param {String} filterName The name of the filter to apply.
   */
  function applyFilter (tweenable, filterName) {
    var filters = Tweenable.prototype.filter;
    var args = tweenable._filterArgs;

    each(filters, function (name) {
      if (typeof filters[name][filterName] !== 'undefined') {
        filters[name][filterName].apply(tweenable, args);
      }
    });
  }

  var timeoutHandler_endTime;
  var timeoutHandler_currentTime;
  var timeoutHandler_isEnded;
  var timeoutHandler_offset;
  /*!
   * Handles the update logic for one step of a tween.
   * @param {Tweenable} tweenable
   * @param {number} timestamp
   * @param {number} delay
   * @param {number} duration
   * @param {Object} currentState
   * @param {Object} originalState
   * @param {Object} targetState
   * @param {Object} easing
   * @param {Function(Object, *, number)} step
   * @param {Function(Function,number)}} schedule
   * @param {number=} opt_currentTimeOverride Needed for accurate timestamp in
   * Tweenable#seek.
   */
  function timeoutHandler (tweenable, timestamp, delay, duration, currentState,
    originalState, targetState, easing, step, schedule,
    opt_currentTimeOverride) {

    timeoutHandler_endTime = timestamp + delay + duration;

    timeoutHandler_currentTime =
    Math.min(opt_currentTimeOverride || now(), timeoutHandler_endTime);

    timeoutHandler_isEnded =
      timeoutHandler_currentTime >= timeoutHandler_endTime;

    timeoutHandler_offset = duration - (
      timeoutHandler_endTime - timeoutHandler_currentTime);

    if (tweenable.isPlaying() && !timeoutHandler_isEnded) {
      tweenable._scheduleId = schedule(tweenable._timeoutHandler, UPDATE_TIME);

      applyFilter(tweenable, 'beforeTween');

      // If the animation has not yet reached the start point (e.g., there was
      // delay that has not yet completed), just interpolate the starting
      // position of the tween.
      if (timeoutHandler_currentTime < (timestamp + delay)) {
        tweenProps(1, currentState, originalState, targetState, 1, 1, easing);
      } else {
        tweenProps(timeoutHandler_currentTime, currentState, originalState,
          targetState, duration, timestamp + delay, easing);
      }

      applyFilter(tweenable, 'afterTween');

      step(currentState, tweenable._attachment, timeoutHandler_offset);
    } else if (tweenable.isPlaying() && timeoutHandler_isEnded) {
      step(targetState, tweenable._attachment, timeoutHandler_offset);
      tweenable.stop(true);
    }
  }


  /*!
   * Creates a usable easing Object from a string, a function or another easing
   * Object.  If `easing` is an Object, then this function clones it and fills
   * in the missing properties with `"linear"`.
   * @param {Object.<string|Function>} fromTweenParams
   * @param {Object|string|Function} easing
   * @return {Object.<string|Function>}
   */
  function composeEasingObject (fromTweenParams, easing) {
    var composedEasing = {};
    var typeofEasing = typeof easing;

    if (typeofEasing === 'string' || typeofEasing === 'function') {
      each(fromTweenParams, function (prop) {
        composedEasing[prop] = easing;
      });
    } else {
      each(fromTweenParams, function (prop) {
        if (!composedEasing[prop]) {
          composedEasing[prop] = easing[prop] || DEFAULT_EASING;
        }
      });
    }

    return composedEasing;
  }

  /**
   * Tweenable constructor.
   * @class Tweenable
   * @param {Object=} opt_initialState The values that the initial tween should
   * start at if a `from` object is not provided to `{{#crossLink
   * "Tweenable/tween:method"}}{{/crossLink}}` or `{{#crossLink
   * "Tweenable/setConfig:method"}}{{/crossLink}}`.
   * @param {Object=} opt_config Configuration object to be passed to
   * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
   * @module Tweenable
   * @constructor
   */
  function Tweenable (opt_initialState, opt_config) {
    this._currentState = opt_initialState || {};
    this._configured = false;
    this._scheduleFunction = DEFAULT_SCHEDULE_FUNCTION;

    // To prevent unnecessary calls to setConfig do not set default
    // configuration here.  Only set default configuration immediately before
    // tweening if none has been set.
    if (typeof opt_config !== 'undefined') {
      this.setConfig(opt_config);
    }
  }

  /**
   * Configure and start a tween.
   * @method tween
   * @param {Object=} opt_config Configuration object to be passed to
   * `{{#crossLink "Tweenable/setConfig:method"}}{{/crossLink}}`.
   * @chainable
   */
  Tweenable.prototype.tween = function (opt_config) {
    if (this._isTweening) {
      return this;
    }

    // Only set default config if no configuration has been set previously and
    // none is provided now.
    if (opt_config !== undefined || !this._configured) {
      this.setConfig(opt_config);
    }

    this._timestamp = now();
    this._start(this.get(), this._attachment);
    return this.resume();
  };

  /**
   * Configure a tween that will start at some point in the future.
   *
   * @method setConfig
   * @param {Object} config The following values are valid:
   * - __from__ (_Object=_): Starting position.  If omitted, `{{#crossLink
   *   "Tweenable/get:method"}}get(){{/crossLink}}` is used.
   * - __to__ (_Object=_): Ending position.
   * - __duration__ (_number=_): How many milliseconds to animate for.
   * - __delay__ (_delay=_): How many milliseconds to wait before starting the
   *   tween.
   * - __start__ (_Function(Object, *)_): Function to execute when the tween
   *   begins.  Receives the state of the tween as the first parameter and
   *   `attachment` as the second parameter.
   * - __step__ (_Function(Object, *, number)_): Function to execute on every
   *   tick.  Receives `{{#crossLink
   *   "Tweenable/get:method"}}get(){{/crossLink}}` as the first parameter,
   *   `attachment` as the second parameter, and the time elapsed since the
   *   start of the tween as the third. This function is not called on the
   *   final step of the animation, but `finish` is.
   * - __finish__ (_Function(Object, *)_): Function to execute upon tween
   *   completion.  Receives the state of the tween as the first parameter and
   *   `attachment` as the second parameter.
   * - __easing__ (_Object.<string|Function>|string|Function=_): Easing curve
   *   name(s) or function(s) to use for the tween.
   * - __attachment__ (_*_): Cached value that is passed to the
   *   `step`/`start`/`finish` methods.
   * @chainable
   */
  Tweenable.prototype.setConfig = function (config) {
    config = config || {};
    this._configured = true;

    // Attach something to this Tweenable instance (e.g.: a DOM element, an
    // object, a string, etc.);
    this._attachment = config.attachment;

    // Init the internal state
    this._pausedAtTime = null;
    this._scheduleId = null;
    this._delay = config.delay || 0;
    this._start = config.start || noop;
    this._step = config.step || noop;
    this._finish = config.finish || noop;
    this._duration = config.duration || DEFAULT_DURATION;
    this._currentState = shallowCopy({}, config.from) || this.get();
    this._originalState = this.get();
    this._targetState = shallowCopy({}, config.to) || this.get();

    var self = this;
    this._timeoutHandler = function () {
      timeoutHandler(self,
        self._timestamp,
        self._delay,
        self._duration,
        self._currentState,
        self._originalState,
        self._targetState,
        self._easing,
        self._step,
        self._scheduleFunction
      );
    };

    // Aliases used below
    var currentState = this._currentState;
    var targetState = this._targetState;

    // Ensure that there is always something to tween to.
    defaults(targetState, currentState);

    this._easing = composeEasingObject(
      currentState, config.easing || DEFAULT_EASING);

    this._filterArgs =
      [currentState, this._originalState, targetState, this._easing];

    applyFilter(this, 'tweenCreated');
    return this;
  };

  /**
   * @method get
   * @return {Object} The current state.
   */
  Tweenable.prototype.get = function () {
    return shallowCopy({}, this._currentState);
  };

  /**
   * @method set
   * @param {Object} state The current state.
   */
  Tweenable.prototype.set = function (state) {
    this._currentState = state;
  };

  /**
   * Pause a tween.  Paused tweens can be resumed from the point at which they
   * were paused.  This is different from `{{#crossLink
   * "Tweenable/stop:method"}}{{/crossLink}}`, as that method
   * causes a tween to start over when it is resumed.
   * @method pause
   * @chainable
   */
  Tweenable.prototype.pause = function () {
    this._pausedAtTime = now();
    this._isPaused = true;
    return this;
  };

  /**
   * Resume a paused tween.
   * @method resume
   * @chainable
   */
  Tweenable.prototype.resume = function () {
    if (this._isPaused) {
      this._timestamp += now() - this._pausedAtTime;
    }

    this._isPaused = false;
    this._isTweening = true;

    this._timeoutHandler();

    return this;
  };

  /**
   * Move the state of the animation to a specific point in the tween's
   * timeline.  If the animation is not running, this will cause the `step`
   * handlers to be called.
   * @method seek
   * @param {millisecond} millisecond The millisecond of the animation to seek
   * to.  This must not be less than `0`.
   * @chainable
   */
  Tweenable.prototype.seek = function (millisecond) {
    millisecond = Math.max(millisecond, 0);
    var currentTime = now();

    if ((this._timestamp + millisecond) === 0) {
      return this;
    }

    this._timestamp = currentTime - millisecond;

    if (!this.isPlaying()) {
      this._isTweening = true;
      this._isPaused = false;

      // If the animation is not running, call timeoutHandler to make sure that
      // any step handlers are run.
      timeoutHandler(this,
        this._timestamp,
        this._delay,
        this._duration,
        this._currentState,
        this._originalState,
        this._targetState,
        this._easing,
        this._step,
        this._scheduleFunction,
        currentTime
      );

      this.pause();
    }

    return this;
  };

  /**
   * Stops and cancels a tween.
   * @param {boolean=} gotoEnd If `false` or omitted, the tween just stops at
   * its current state, and the `finish` handler is not invoked.  If `true`,
   * the tweened object's values are instantly set to the target values, and
   * `finish` is invoked.
   * @method stop
   * @chainable
   */
  Tweenable.prototype.stop = function (gotoEnd) {
    this._isTweening = false;
    this._isPaused = false;
    this._timeoutHandler = noop;

    (root.cancelAnimationFrame            ||
    root.webkitCancelAnimationFrame     ||
    root.oCancelAnimationFrame          ||
    root.msCancelAnimationFrame         ||
    root.mozCancelRequestAnimationFrame ||
    root.clearTimeout)(this._scheduleId);

    if (gotoEnd) {
      applyFilter(this, 'beforeTween');
      tweenProps(
        1,
        this._currentState,
        this._originalState,
        this._targetState,
        1,
        0,
        this._easing
      );
      applyFilter(this, 'afterTween');
      applyFilter(this, 'afterTweenEnd');
      this._finish.call(this, this._currentState, this._attachment);
    }

    return this;
  };

  /**
   * @method isPlaying
   * @return {boolean} Whether or not a tween is running.
   */
  Tweenable.prototype.isPlaying = function () {
    return this._isTweening && !this._isPaused;
  };

  /**
   * Set a custom schedule function.
   *
   * If a custom function is not set,
   * [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window.requestAnimationFrame)
   * is used if available, otherwise
   * [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/Window.setTimeout)
   * is used.
   * @method setScheduleFunction
   * @param {Function(Function,number)} scheduleFunction The function to be
   * used to schedule the next frame to be rendered.
   */
  Tweenable.prototype.setScheduleFunction = function (scheduleFunction) {
    this._scheduleFunction = scheduleFunction;
  };

  /**
   * `delete` all "own" properties.  Call this when the `Tweenable` instance
   * is no longer needed to free memory.
   * @method dispose
   */
  Tweenable.prototype.dispose = function () {
    var prop;
    for (prop in this) {
      if (this.hasOwnProperty(prop)) {
        delete this[prop];
      }
    }
  };

  /*!
   * Filters are used for transforming the properties of a tween at various
   * points in a Tweenable's life cycle.  See the README for more info on this.
   */
  Tweenable.prototype.filter = {};

  /**
   * This object contains all of the tweens available to Shifty.  It is
   * extensible - simply attach properties to the `Tweenable.prototype.formula`
   * Object following the same format as `linear`.
   *
   * `pos` should be a normalized `number` (between 0 and 1).
   * @property formula
   * @type {Object(function)}
   */
  Tweenable.prototype.formula = {
    linear: function (pos) {
      return pos;
    }
  };

  formula = Tweenable.prototype.formula;

  shallowCopy(Tweenable, {
    'now': now
    ,'each': each
    ,'tweenProps': tweenProps
    ,'tweenProp': tweenProp
    ,'applyFilter': applyFilter
    ,'shallowCopy': shallowCopy
    ,'defaults': defaults
    ,'composeEasingObject': composeEasingObject
  });

  // `root` is provided in the intro/outro files.

  // A hook used for unit testing.
  if (typeof SHIFTY_DEBUG_NOW === 'function') {
    root.timeoutHandler = timeoutHandler;
  }

  // Bootstrap Tweenable appropriately for the environment.
  if (typeof exports === 'object') {
    // CommonJS
    module.exports = Tweenable;
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(function () {return Tweenable;});
  } else if (typeof root.Tweenable === 'undefined') {
    // Browser: Make `Tweenable` globally accessible.
    root.Tweenable = Tweenable;
  }

  return Tweenable;

} ());

/*!
 * All equations are adapted from Thomas Fuchs'
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/penner.js).
 *
 * Based on Easing Equations (c) 2003 [Robert
 * Penner](http://www.robertpenner.com/), all rights reserved. This work is
 * [subject to terms](http://www.robertpenner.com/easing_terms_of_use.html).
 */

/*!
 *  TERMS OF USE - EASING EQUATIONS
 *  Open source under the BSD License.
 *  Easing Equations (c) 2003 Robert Penner, all rights reserved.
 */

;(function () {

  Tweenable.shallowCopy(Tweenable.prototype.formula, {
    easeInQuad: function (pos) {
      return Math.pow(pos, 2);
    },

    easeOutQuad: function (pos) {
      return -(Math.pow((pos - 1), 2) - 1);
    },

    easeInOutQuad: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,2);}
      return -0.5 * ((pos -= 2) * pos - 2);
    },

    easeInCubic: function (pos) {
      return Math.pow(pos, 3);
    },

    easeOutCubic: function (pos) {
      return (Math.pow((pos - 1), 3) + 1);
    },

    easeInOutCubic: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,3);}
      return 0.5 * (Math.pow((pos - 2),3) + 2);
    },

    easeInQuart: function (pos) {
      return Math.pow(pos, 4);
    },

    easeOutQuart: function (pos) {
      return -(Math.pow((pos - 1), 4) - 1);
    },

    easeInOutQuart: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
      return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
    },

    easeInQuint: function (pos) {
      return Math.pow(pos, 5);
    },

    easeOutQuint: function (pos) {
      return (Math.pow((pos - 1), 5) + 1);
    },

    easeInOutQuint: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,5);}
      return 0.5 * (Math.pow((pos - 2),5) + 2);
    },

    easeInSine: function (pos) {
      return -Math.cos(pos * (Math.PI / 2)) + 1;
    },

    easeOutSine: function (pos) {
      return Math.sin(pos * (Math.PI / 2));
    },

    easeInOutSine: function (pos) {
      return (-0.5 * (Math.cos(Math.PI * pos) - 1));
    },

    easeInExpo: function (pos) {
      return (pos === 0) ? 0 : Math.pow(2, 10 * (pos - 1));
    },

    easeOutExpo: function (pos) {
      return (pos === 1) ? 1 : -Math.pow(2, -10 * pos) + 1;
    },

    easeInOutExpo: function (pos) {
      if (pos === 0) {return 0;}
      if (pos === 1) {return 1;}
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(2,10 * (pos - 1));}
      return 0.5 * (-Math.pow(2, -10 * --pos) + 2);
    },

    easeInCirc: function (pos) {
      return -(Math.sqrt(1 - (pos * pos)) - 1);
    },

    easeOutCirc: function (pos) {
      return Math.sqrt(1 - Math.pow((pos - 1), 2));
    },

    easeInOutCirc: function (pos) {
      if ((pos /= 0.5) < 1) {return -0.5 * (Math.sqrt(1 - pos * pos) - 1);}
      return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
    },

    easeOutBounce: function (pos) {
      if ((pos) < (1 / 2.75)) {
        return (7.5625 * pos * pos);
      } else if (pos < (2 / 2.75)) {
        return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
      } else if (pos < (2.5 / 2.75)) {
        return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
      } else {
        return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
      }
    },

    easeInBack: function (pos) {
      var s = 1.70158;
      return (pos) * pos * ((s + 1) * pos - s);
    },

    easeOutBack: function (pos) {
      var s = 1.70158;
      return (pos = pos - 1) * pos * ((s + 1) * pos + s) + 1;
    },

    easeInOutBack: function (pos) {
      var s = 1.70158;
      if ((pos /= 0.5) < 1) {
        return 0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s));
      }
      return 0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },

    elastic: function (pos) {
      // jshint maxlen:90
      return -1 * Math.pow(4,-8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
    },

    swingFromTo: function (pos) {
      var s = 1.70158;
      return ((pos /= 0.5) < 1) ?
          0.5 * (pos * pos * (((s *= (1.525)) + 1) * pos - s)) :
          0.5 * ((pos -= 2) * pos * (((s *= (1.525)) + 1) * pos + s) + 2);
    },

    swingFrom: function (pos) {
      var s = 1.70158;
      return pos * pos * ((s + 1) * pos - s);
    },

    swingTo: function (pos) {
      var s = 1.70158;
      return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
    },

    bounce: function (pos) {
      if (pos < (1 / 2.75)) {
        return (7.5625 * pos * pos);
      } else if (pos < (2 / 2.75)) {
        return (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
      } else if (pos < (2.5 / 2.75)) {
        return (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
      } else {
        return (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
      }
    },

    bouncePast: function (pos) {
      if (pos < (1 / 2.75)) {
        return (7.5625 * pos * pos);
      } else if (pos < (2 / 2.75)) {
        return 2 - (7.5625 * (pos -= (1.5 / 2.75)) * pos + 0.75);
      } else if (pos < (2.5 / 2.75)) {
        return 2 - (7.5625 * (pos -= (2.25 / 2.75)) * pos + 0.9375);
      } else {
        return 2 - (7.5625 * (pos -= (2.625 / 2.75)) * pos + 0.984375);
      }
    },

    easeFromTo: function (pos) {
      if ((pos /= 0.5) < 1) {return 0.5 * Math.pow(pos,4);}
      return -0.5 * ((pos -= 2) * Math.pow(pos,3) - 2);
    },

    easeFrom: function (pos) {
      return Math.pow(pos,4);
    },

    easeTo: function (pos) {
      return Math.pow(pos,0.25);
    }
  });

}());

// jshint maxlen:100
/*!
 * The Bezier magic in this file is adapted/copied almost wholesale from
 * [Scripty2](https://github.com/madrobby/scripty2/blob/master/src/effects/transitions/cubic-bezier.js),
 * which was adapted from Apple code (which probably came from
 * [here](http://opensource.apple.com/source/WebCore/WebCore-955.66/platform/graphics/UnitBezier.h)).
 * Special thanks to Apple and Thomas Fuchs for much of this code.
 */

/*!
 *  Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *  this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation
 *  and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder(s) nor the names of any
 *  contributors may be used to endorse or promote products derived from
 *  this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
;(function () {
  // port of webkit cubic bezier handling by http://www.netzgesta.de/dev/
  function cubicBezierAtTime(t,p1x,p1y,p2x,p2y,duration) {
    var ax = 0,bx = 0,cx = 0,ay = 0,by = 0,cy = 0;
    function sampleCurveX(t) {
      return ((ax * t + bx) * t + cx) * t;
    }
    function sampleCurveY(t) {
      return ((ay * t + by) * t + cy) * t;
    }
    function sampleCurveDerivativeX(t) {
      return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }
    function solveEpsilon(duration) {
      return 1.0 / (200.0 * duration);
    }
    function solve(x,epsilon) {
      return sampleCurveY(solveCurveX(x, epsilon));
    }
    function fabs(n) {
      if (n >= 0) {
        return n;
      } else {
        return 0 - n;
      }
    }
    function solveCurveX(x, epsilon) {
      var t0,t1,t2,x2,d2,i;
      for (t2 = x, i = 0; i < 8; i++) {
        x2 = sampleCurveX(t2) - x;
        if (fabs(x2) < epsilon) {
          return t2;
        }
        d2 = sampleCurveDerivativeX(t2);
        if (fabs(d2) < 1e-6) {
          break;
        }
        t2 = t2 - x2 / d2;
      }
      t0 = 0.0;
      t1 = 1.0;
      t2 = x;
      if (t2 < t0) {
        return t0;
      }
      if (t2 > t1) {
        return t1;
      }
      while (t0 < t1) {
        x2 = sampleCurveX(t2);
        if (fabs(x2 - x) < epsilon) {
          return t2;
        }
        if (x > x2) {
          t0 = t2;
        }else {
          t1 = t2;
        }
        t2 = (t1 - t0) * 0.5 + t0;
      }
      return t2; // Failure.
    }
    cx = 3.0 * p1x;
    bx = 3.0 * (p2x - p1x) - cx;
    ax = 1.0 - cx - bx;
    cy = 3.0 * p1y;
    by = 3.0 * (p2y - p1y) - cy;
    ay = 1.0 - cy - by;
    return solve(t, solveEpsilon(duration));
  }
  /*!
   *  getCubicBezierTransition(x1, y1, x2, y2) -> Function
   *
   *  Generates a transition easing function that is compatible
   *  with WebKit's CSS transitions `-webkit-transition-timing-function`
   *  CSS property.
   *
   *  The W3C has more information about CSS3 transition timing functions:
   *  http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
   *
   *  @param {number} x1
   *  @param {number} y1
   *  @param {number} x2
   *  @param {number} y2
   *  @return {function}
   */
  function getCubicBezierTransition (x1, y1, x2, y2) {
    return function (pos) {
      return cubicBezierAtTime(pos,x1,y1,x2,y2,1);
    };
  }
  // End ported code

  /**
   * Create a Bezier easing function and attach it to `{{#crossLink
   * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  This
   * function gives you total control over the easing curve.  Matthew Lein's
   * [Ceaser](http://matthewlein.com/ceaser/) is a useful tool for visualizing
   * the curves you can make with this function.
   * @method setBezierFunction
   * @param {string} name The name of the easing curve.  Overwrites the old
   * easing function on `{{#crossLink
   * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}` if it
   * exists.
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @return {function} The easing function that was attached to
   * Tweenable.prototype.formula.
   */
  Tweenable.setBezierFunction = function (name, x1, y1, x2, y2) {
    var cubicBezierTransition = getCubicBezierTransition(x1, y1, x2, y2);
    cubicBezierTransition.displayName = name;
    cubicBezierTransition.x1 = x1;
    cubicBezierTransition.y1 = y1;
    cubicBezierTransition.x2 = x2;
    cubicBezierTransition.y2 = y2;

    return Tweenable.prototype.formula[name] = cubicBezierTransition;
  };


  /**
   * `delete` an easing function from `{{#crossLink
   * "Tweenable/formula:property"}}Tweenable#formula{{/crossLink}}`.  Be
   * careful with this method, as it `delete`s whatever easing formula matches
   * `name` (which means you can delete standard Shifty easing functions).
   * @method unsetBezierFunction
   * @param {string} name The name of the easing function to delete.
   * @return {function}
   */
  Tweenable.unsetBezierFunction = function (name) {
    delete Tweenable.prototype.formula[name];
  };

})();

;(function () {

  function getInterpolatedValues (
    from, current, targetState, position, easing, delay) {
    return Tweenable.tweenProps(
      position, current, from, targetState, 1, delay, easing);
  }

  // Fake a Tweenable and patch some internals.  This approach allows us to
  // skip uneccessary processing and object recreation, cutting down on garbage
  // collection pauses.
  var mockTweenable = new Tweenable();
  mockTweenable._filterArgs = [];

  /**
   * Compute the midpoint of two Objects.  This method effectively calculates a
   * specific frame of animation that `{{#crossLink
   * "Tweenable/tween:method"}}{{/crossLink}}` does many times over the course
   * of a full tween.
   *
   *     var interpolatedValues = Tweenable.interpolate({
   *       width: '100px',
   *       opacity: 0,
   *       color: '#fff'
   *     }, {
   *       width: '200px',
   *       opacity: 1,
   *       color: '#000'
   *     }, 0.5);
   *
   *     console.log(interpolatedValues);
   *     // {opacity: 0.5, width: "150px", color: "rgb(127,127,127)"}
   *
   * @static
   * @method interpolate
   * @param {Object} from The starting values to tween from.
   * @param {Object} targetState The ending values to tween to.
   * @param {number} position The normalized position value (between `0.0` and
   * `1.0`) to interpolate the values between `from` and `to` for.  `from`
   * represents `0` and `to` represents `1`.
   * @param {Object.<string|Function>|string|Function} easing The easing
   * curve(s) to calculate the midpoint against.  You can reference any easing
   * function attached to `Tweenable.prototype.formula`, or provide the easing
   * function(s) directly.  If omitted, this defaults to "linear".
   * @param {number=} opt_delay Optional delay to pad the beginning of the
   * interpolated tween with.  This increases the range of `position` from (`0`
   * through `1`) to (`0` through `1 + opt_delay`).  So, a delay of `0.5` would
   * increase all valid values of `position` to numbers between `0` and `1.5`.
   * @return {Object}
   */
  Tweenable.interpolate = function (
    from, targetState, position, easing, opt_delay) {

    var current = Tweenable.shallowCopy({}, from);
    var delay = opt_delay || 0;
    var easingObject = Tweenable.composeEasingObject(
      from, easing || 'linear');

    mockTweenable.set({});

    // Alias and reuse the _filterArgs array instead of recreating it.
    var filterArgs = mockTweenable._filterArgs;
    filterArgs.length = 0;
    filterArgs[0] = current;
    filterArgs[1] = from;
    filterArgs[2] = targetState;
    filterArgs[3] = easingObject;

    // Any defined value transformation must be applied
    Tweenable.applyFilter(mockTweenable, 'tweenCreated');
    Tweenable.applyFilter(mockTweenable, 'beforeTween');

    var interpolatedValues = getInterpolatedValues(
      from, current, targetState, position, easingObject, delay);

    // Transform values back into their original format
    Tweenable.applyFilter(mockTweenable, 'afterTween');

    return interpolatedValues;
  };

}());

/**
 * This module adds string interpolation support to Shifty.
 *
 * The Token extension allows Shifty to tween numbers inside of strings.  Among
 * other things, this allows you to animate CSS properties.  For example, you
 * can do this:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(45px)' },
 *       to: { transform: 'translateX(90xp)' }
 *     });
 *
 * `translateX(45)` will be tweened to `translateX(90)`.  To demonstrate:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(45px)' },
 *       to: { transform: 'translateX(90px)' },
 *       step: function (state) {
 *         console.log(state.transform);
 *       }
 *     });
 *
 * The above snippet will log something like this in the console:
 *
 *     translateX(60.3px)
 *     ...
 *     translateX(76.05px)
 *     ...
 *     translateX(90px)
 *
 * Another use for this is animating colors:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { color: 'rgb(0,255,0)' },
 *       to: { color: 'rgb(255,0,255)' },
 *       step: function (state) {
 *         console.log(state.color);
 *       }
 *     });
 *
 * The above snippet will log something like this:
 *
 *     rgb(84,170,84)
 *     ...
 *     rgb(170,84,170)
 *     ...
 *     rgb(255,0,255)
 *
 * This extension also supports hexadecimal colors, in both long (`#ff00ff`)
 * and short (`#f0f`) forms.  Be aware that hexadecimal input values will be
 * converted into the equivalent RGB output values.  This is done to optimize
 * for performance.
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { color: '#0f0' },
 *       to: { color: '#f0f' },
 *       step: function (state) {
 *         console.log(state.color);
 *       }
 *     });
 *
 * This snippet will generate the same output as the one before it because
 * equivalent values were supplied (just in hexadecimal form rather than RGB):
 *
 *     rgb(84,170,84)
 *     ...
 *     rgb(170,84,170)
 *     ...
 *     rgb(255,0,255)
 *
 * ## Easing support
 *
 * Easing works somewhat differently in the Token extension.  This is because
 * some CSS properties have multiple values in them, and you might need to
 * tween each value along its own easing curve.  A basic example:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(0px) translateY(0px)' },
 *       to: { transform:   'translateX(100px) translateY(100px)' },
 *       easing: { transform: 'easeInQuad' },
 *       step: function (state) {
 *         console.log(state.transform);
 *       }
 *     });
 *
 * The above snippet will create values like this:
 *
 *     translateX(11.56px) translateY(11.56px)
 *     ...
 *     translateX(46.24px) translateY(46.24px)
 *     ...
 *     translateX(100px) translateY(100px)
 *
 * In this case, the values for `translateX` and `translateY` are always the
 * same for each step of the tween, because they have the same start and end
 * points and both use the same easing curve.  We can also tween `translateX`
 * and `translateY` along independent curves:
 *
 *     var tweenable = new Tweenable();
 *     tweenable.tween({
 *       from: { transform: 'translateX(0px) translateY(0px)' },
 *       to: { transform:   'translateX(100px) translateY(100px)' },
 *       easing: { transform: 'easeInQuad bounce' },
 *       step: function (state) {
 *         console.log(state.transform);
 *       }
 *     });
 *
 * The above snippet will create values like this:
 *
 *     translateX(10.89px) translateY(82.35px)
 *     ...
 *     translateX(44.89px) translateY(86.73px)
 *     ...
 *     translateX(100px) translateY(100px)
 *
 * `translateX` and `translateY` are not in sync anymore, because `easeInQuad`
 * was specified for `translateX` and `bounce` for `translateY`.  Mixing and
 * matching easing curves can make for some interesting motion in your
 * animations.
 *
 * The order of the space-separated easing curves correspond the token values
 * they apply to.  If there are more token values than easing curves listed,
 * the last easing curve listed is used.
 * @submodule Tweenable.token
 */

// token function is defined above only so that dox-foundation sees it as
// documentation and renders it.  It is never used, and is optimized away at
// build time.

;(function (Tweenable) {

  /*!
   * @typedef {{
   *   formatString: string
   *   chunkNames: Array.<string>
   * }}
   */
  var formatManifest;

  // CONSTANTS

  var R_NUMBER_COMPONENT = /(\d|\-|\.)/;
  var R_FORMAT_CHUNKS = /([^\-0-9\.]+)/g;
  var R_UNFORMATTED_VALUES = /[0-9.\-]+/g;
  var R_RGB = new RegExp(
    'rgb\\(' + R_UNFORMATTED_VALUES.source +
    (/,\s*/.source) + R_UNFORMATTED_VALUES.source +
    (/,\s*/.source) + R_UNFORMATTED_VALUES.source + '\\)', 'g');
  var R_RGB_PREFIX = /^.*\(/;
  var R_HEX = /#([0-9]|[a-f]){3,6}/gi;
  var VALUE_PLACEHOLDER = 'VAL';

  // HELPERS

  /*!
   * @param {Array.number} rawValues
   * @param {string} prefix
   *
   * @return {Array.<string>}
   */
  function getFormatChunksFrom (rawValues, prefix) {
    var accumulator = [];

    var rawValuesLength = rawValues.length;
    var i;

    for (i = 0; i < rawValuesLength; i++) {
      accumulator.push('_' + prefix + '_' + i);
    }

    return accumulator;
  }

  /*!
   * @param {string} formattedString
   *
   * @return {string}
   */
  function getFormatStringFrom (formattedString) {
    var chunks = formattedString.match(R_FORMAT_CHUNKS);

    if (!chunks) {
      // chunks will be null if there were no tokens to parse in
      // formattedString (for example, if formattedString is '2').  Coerce
      // chunks to be useful here.
      chunks = ['', ''];

      // If there is only one chunk, assume that the string is a number
      // followed by a token...
      // NOTE: This may be an unwise assumption.
    } else if (chunks.length === 1 ||
      // ...or if the string starts with a number component (".", "-", or a
      // digit)...
    formattedString[0].match(R_NUMBER_COMPONENT)) {
      // ...prepend an empty string here to make sure that the formatted number
      // is properly replaced by VALUE_PLACEHOLDER
      chunks.unshift('');
    }

    return chunks.join(VALUE_PLACEHOLDER);
  }

  /*!
   * Convert all hex color values within a string to an rgb string.
   *
   * @param {Object} stateObject
   *
   * @return {Object} The modified obj
   */
  function sanitizeObjectForHexProps (stateObject) {
    Tweenable.each(stateObject, function (prop) {
      var currentProp = stateObject[prop];

      if (typeof currentProp === 'string' && currentProp.match(R_HEX)) {
        stateObject[prop] = sanitizeHexChunksToRGB(currentProp);
      }
    });
  }

  /*!
   * @param {string} str
   *
   * @return {string}
   */
  function  sanitizeHexChunksToRGB (str) {
    return filterStringChunks(R_HEX, str, convertHexToRGB);
  }

  /*!
   * @param {string} hexString
   *
   * @return {string}
   */
  function convertHexToRGB (hexString) {
    var rgbArr = hexToRGBArray(hexString);
    return 'rgb(' + rgbArr[0] + ',' + rgbArr[1] + ',' + rgbArr[2] + ')';
  }

  var hexToRGBArray_returnArray = [];
  /*!
   * Convert a hexadecimal string to an array with three items, one each for
   * the red, blue, and green decimal values.
   *
   * @param {string} hex A hexadecimal string.
   *
   * @returns {Array.<number>} The converted Array of RGB values if `hex` is a
   * valid string, or an Array of three 0's.
   */
  function hexToRGBArray (hex) {

    hex = hex.replace(/#/, '');

    // If the string is a shorthand three digit hex notation, normalize it to
    // the standard six digit notation
    if (hex.length === 3) {
      hex = hex.split('');
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    hexToRGBArray_returnArray[0] = hexToDec(hex.substr(0, 2));
    hexToRGBArray_returnArray[1] = hexToDec(hex.substr(2, 2));
    hexToRGBArray_returnArray[2] = hexToDec(hex.substr(4, 2));

    return hexToRGBArray_returnArray;
  }

  /*!
   * Convert a base-16 number to base-10.
   *
   * @param {Number|String} hex The value to convert
   *
   * @returns {Number} The base-10 equivalent of `hex`.
   */
  function hexToDec (hex) {
    return parseInt(hex, 16);
  }

  /*!
   * Runs a filter operation on all chunks of a string that match a RegExp
   *
   * @param {RegExp} pattern
   * @param {string} unfilteredString
   * @param {function(string)} filter
   *
   * @return {string}
   */
  function filterStringChunks (pattern, unfilteredString, filter) {
    var pattenMatches = unfilteredString.match(pattern);
    var filteredString = unfilteredString.replace(pattern, VALUE_PLACEHOLDER);

    if (pattenMatches) {
      var pattenMatchesLength = pattenMatches.length;
      var currentChunk;

      for (var i = 0; i < pattenMatchesLength; i++) {
        currentChunk = pattenMatches.shift();
        filteredString = filteredString.replace(
          VALUE_PLACEHOLDER, filter(currentChunk));
      }
    }

    return filteredString;
  }

  /*!
   * Check for floating point values within rgb strings and rounds them.
   *
   * @param {string} formattedString
   *
   * @return {string}
   */
  function sanitizeRGBChunks (formattedString) {
    return filterStringChunks(R_RGB, formattedString, sanitizeRGBChunk);
  }

  /*!
   * @param {string} rgbChunk
   *
   * @return {string}
   */
  function sanitizeRGBChunk (rgbChunk) {
    var numbers = rgbChunk.match(R_UNFORMATTED_VALUES);
    var numbersLength = numbers.length;
    var sanitizedString = rgbChunk.match(R_RGB_PREFIX)[0];

    for (var i = 0; i < numbersLength; i++) {
      sanitizedString += parseInt(numbers[i], 10) + ',';
    }

    sanitizedString = sanitizedString.slice(0, -1) + ')';

    return sanitizedString;
  }

  /*!
   * @param {Object} stateObject
   *
   * @return {Object} An Object of formatManifests that correspond to
   * the string properties of stateObject
   */
  function getFormatManifests (stateObject) {
    var manifestAccumulator = {};

    Tweenable.each(stateObject, function (prop) {
      var currentProp = stateObject[prop];

      if (typeof currentProp === 'string') {
        var rawValues = getValuesFrom(currentProp);

        manifestAccumulator[prop] = {
          'formatString': getFormatStringFrom(currentProp)
          ,'chunkNames': getFormatChunksFrom(rawValues, prop)
        };
      }
    });

    return manifestAccumulator;
  }

  /*!
   * @param {Object} stateObject
   * @param {Object} formatManifests
   */
  function expandFormattedProperties (stateObject, formatManifests) {
    Tweenable.each(formatManifests, function (prop) {
      var currentProp = stateObject[prop];
      var rawValues = getValuesFrom(currentProp);
      var rawValuesLength = rawValues.length;

      for (var i = 0; i < rawValuesLength; i++) {
        stateObject[formatManifests[prop].chunkNames[i]] = +rawValues[i];
      }

      delete stateObject[prop];
    });
  }

  /*!
   * @param {Object} stateObject
   * @param {Object} formatManifests
   */
  function collapseFormattedProperties (stateObject, formatManifests) {
    Tweenable.each(formatManifests, function (prop) {
      var currentProp = stateObject[prop];
      var formatChunks = extractPropertyChunks(
        stateObject, formatManifests[prop].chunkNames);
      var valuesList = getValuesList(
        formatChunks, formatManifests[prop].chunkNames);
      currentProp = getFormattedValues(
        formatManifests[prop].formatString, valuesList);
      stateObject[prop] = sanitizeRGBChunks(currentProp);
    });
  }

  /*!
   * @param {Object} stateObject
   * @param {Array.<string>} chunkNames
   *
   * @return {Object} The extracted value chunks.
   */
  function extractPropertyChunks (stateObject, chunkNames) {
    var extractedValues = {};
    var currentChunkName, chunkNamesLength = chunkNames.length;

    for (var i = 0; i < chunkNamesLength; i++) {
      currentChunkName = chunkNames[i];
      extractedValues[currentChunkName] = stateObject[currentChunkName];
      delete stateObject[currentChunkName];
    }

    return extractedValues;
  }

  var getValuesList_accumulator = [];
  /*!
   * @param {Object} stateObject
   * @param {Array.<string>} chunkNames
   *
   * @return {Array.<number>}
   */
  function getValuesList (stateObject, chunkNames) {
    getValuesList_accumulator.length = 0;
    var chunkNamesLength = chunkNames.length;

    for (var i = 0; i < chunkNamesLength; i++) {
      getValuesList_accumulator.push(stateObject[chunkNames[i]]);
    }

    return getValuesList_accumulator;
  }

  /*!
   * @param {string} formatString
   * @param {Array.<number>} rawValues
   *
   * @return {string}
   */
  function getFormattedValues (formatString, rawValues) {
    var formattedValueString = formatString;
    var rawValuesLength = rawValues.length;

    for (var i = 0; i < rawValuesLength; i++) {
      formattedValueString = formattedValueString.replace(
        VALUE_PLACEHOLDER, +rawValues[i].toFixed(4));
    }

    return formattedValueString;
  }

  /*!
   * Note: It's the duty of the caller to convert the Array elements of the
   * return value into numbers.  This is a performance optimization.
   *
   * @param {string} formattedString
   *
   * @return {Array.<string>|null}
   */
  function getValuesFrom (formattedString) {
    return formattedString.match(R_UNFORMATTED_VALUES);
  }

  /*!
   * @param {Object} easingObject
   * @param {Object} tokenData
   */
  function expandEasingObject (easingObject, tokenData) {
    Tweenable.each(tokenData, function (prop) {
      var currentProp = tokenData[prop];
      var chunkNames = currentProp.chunkNames;
      var chunkLength = chunkNames.length;

      var easing = easingObject[prop];
      var i;

      if (typeof easing === 'string') {
        var easingChunks = easing.split(' ');
        var lastEasingChunk = easingChunks[easingChunks.length - 1];

        for (i = 0; i < chunkLength; i++) {
          easingObject[chunkNames[i]] = easingChunks[i] || lastEasingChunk;
        }

      } else {
        for (i = 0; i < chunkLength; i++) {
          easingObject[chunkNames[i]] = easing;
        }
      }

      delete easingObject[prop];
    });
  }

  /*!
   * @param {Object} easingObject
   * @param {Object} tokenData
   */
  function collapseEasingObject (easingObject, tokenData) {
    Tweenable.each(tokenData, function (prop) {
      var currentProp = tokenData[prop];
      var chunkNames = currentProp.chunkNames;
      var chunkLength = chunkNames.length;

      var firstEasing = easingObject[chunkNames[0]];
      var typeofEasings = typeof firstEasing;

      if (typeofEasings === 'string') {
        var composedEasingString = '';

        for (var i = 0; i < chunkLength; i++) {
          composedEasingString += ' ' + easingObject[chunkNames[i]];
          delete easingObject[chunkNames[i]];
        }

        easingObject[prop] = composedEasingString.substr(1);
      } else {
        easingObject[prop] = firstEasing;
      }
    });
  }

  Tweenable.prototype.filter.token = {
    'tweenCreated': function (currentState, fromState, toState, easingObject) {
      sanitizeObjectForHexProps(currentState);
      sanitizeObjectForHexProps(fromState);
      sanitizeObjectForHexProps(toState);
      this._tokenData = getFormatManifests(currentState);
    },

    'beforeTween': function (currentState, fromState, toState, easingObject) {
      expandEasingObject(easingObject, this._tokenData);
      expandFormattedProperties(currentState, this._tokenData);
      expandFormattedProperties(fromState, this._tokenData);
      expandFormattedProperties(toState, this._tokenData);
    },

    'afterTween': function (currentState, fromState, toState, easingObject) {
      collapseFormattedProperties(currentState, this._tokenData);
      collapseFormattedProperties(fromState, this._tokenData);
      collapseFormattedProperties(toState, this._tokenData);
      collapseEasingObject(easingObject, this._tokenData);
    }
  };

} (Tweenable));

}).call(null);

},{}],2:[function(require,module,exports){
// Circle shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Circle = function Circle(container, options) {
    // Use two arcs to form a circle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m 0,-{radius}' +
        ' a {radius},{radius} 0 1 1 0,{2radius}' +
        ' a {radius},{radius} 0 1 1 0,-{2radius}';

    Shape.apply(this, arguments);
};

Circle.prototype = new Shape();
Circle.prototype.constructor = Circle;

Circle.prototype._pathString = function _pathString(opts) {
    var widthOfWider = opts.strokeWidth;
    if (opts.trailWidth && opts.trailWidth > opts.strokeWidth) {
        widthOfWider = opts.trailWidth;
    }

    var r = 50 - widthOfWider / 2;

    return utils.render(this._pathTemplate, {
        radius: r,
        '2radius': r * 2
    });
};

Circle.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Circle;

},{"./shape":7,"./utils":8}],3:[function(require,module,exports){
// Line shaped progress bar

var Shape = require('./shape');
var utils = require('./utils');

var Line = function Line(container, options) {
    this._pathTemplate = 'M 0,{center} L 100,{center}';
    Shape.apply(this, arguments);
};

Line.prototype = new Shape();
Line.prototype.constructor = Line;

Line.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 ' + opts.strokeWidth);
    svg.setAttribute('preserveAspectRatio', 'none');
};

Line.prototype._pathString = function _pathString(opts) {
    return utils.render(this._pathTemplate, {
        center: opts.strokeWidth / 2
    });
};

Line.prototype._trailString = function _trailString(opts) {
    return this._pathString(opts);
};

module.exports = Line;

},{"./shape":7,"./utils":8}],4:[function(require,module,exports){
module.exports = {
    // Higher level API, different shaped progress bars
    Line: require('./line'),
    Circle: require('./circle'),
    SemiCircle: require('./semicircle'),

    // Lower level API to use any SVG path
    Path: require('./path'),

    // Base-class for creating new custom shapes
    // to be in line with the API of built-in shapes
    // Undocumented.
    Shape: require('./shape'),

    // Internal utils, undocumented.
    utils: require('./utils')
};

},{"./circle":2,"./line":3,"./path":5,"./semicircle":6,"./shape":7,"./utils":8}],5:[function(require,module,exports){
// Lower level API to animate any kind of svg path

var Tweenable = require('shifty');
var utils = require('./utils');

var EASING_ALIASES = {
    easeIn: 'easeInCubic',
    easeOut: 'easeOutCubic',
    easeInOut: 'easeInOutCubic'
};

var Path = function Path(path, opts) {
    // Default parameters for animation
    opts = utils.extend({
        duration: 800,
        easing: 'linear',
        from: {},
        to: {},
        step: function() {}
    }, opts);

    var element;
    if (utils.isString(path)) {
        element = document.querySelector(path);
    } else {
        element = path;
    }

    // Reveal .path as public attribute
    this.path = element;
    this._opts = opts;
    this._tweenable = null;

    // Set up the starting positions
    var length = this.path.getTotalLength();
    this.path.style.strokeDasharray = length + ' ' + length;
    this.set(0);
};

Path.prototype.value = function value() {
    var offset = this._getComputedDashOffset();
    var length = this.path.getTotalLength();

    var progress = 1 - offset / length;
    // Round number to prevent returning very small number like 1e-30, which
    // is practically 0
    return parseFloat(progress.toFixed(6), 10);
};

Path.prototype.set = function set(progress) {
    this.stop();

    this.path.style.strokeDashoffset = this._progressToOffset(progress);

    var step = this._opts.step;
    if (utils.isFunction(step)) {
        var easing = this._easing(this._opts.easing);
        var values = this._calculateTo(progress, easing);
        var reference = this._opts.shape || this;
        step(values, reference, this._opts.attachment);
    }
};

Path.prototype.stop = function stop() {
    this._stopTween();
    this.path.style.strokeDashoffset = this._getComputedDashOffset();
};

// Method introduced here:
// http://jakearchibald.com/2013/animated-line-drawing-svg/
Path.prototype.animate = function animate(progress, opts, cb) {
    opts = opts || {};

    if (utils.isFunction(opts)) {
        cb = opts;
        opts = {};
    }

    var passedOpts = utils.extend({}, opts);

    // Copy default opts to new object so defaults are not modified
    var defaultOpts = utils.extend({}, this._opts);
    opts = utils.extend(defaultOpts, opts);

    var shiftyEasing = this._easing(opts.easing);
    var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);

    this.stop();

    // Trigger a layout so styles are calculated & the browser
    // picks up the starting position before animating
    this.path.getBoundingClientRect();

    var offset = this._getComputedDashOffset();
    var newOffset = this._progressToOffset(progress);

    var self = this;
    this._tweenable = new Tweenable();
    this._tweenable.tween({
        from: utils.extend({ offset: offset }, values.from),
        to: utils.extend({ offset: newOffset }, values.to),
        duration: opts.duration,
        easing: shiftyEasing,
        step: function(state) {
            self.path.style.strokeDashoffset = state.offset;
            var reference = opts.shape || self;
            opts.step(state, reference, opts.attachment);
        },
        finish: function(state) {
            if (utils.isFunction(cb)) {
                cb();
            }
        }
    });
};

Path.prototype._getComputedDashOffset = function _getComputedDashOffset() {
    var computedStyle = window.getComputedStyle(this.path, null);
    return parseFloat(computedStyle.getPropertyValue('stroke-dashoffset'), 10);
};

Path.prototype._progressToOffset = function _progressToOffset(progress) {
    var length = this.path.getTotalLength();
    return length - progress * length;
};

// Resolves from and to values for animation.
Path.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {
    if (opts.from && opts.to) {
        return {
            from: opts.from,
            to: opts.to
        };
    }

    return {
        from: this._calculateFrom(easing),
        to: this._calculateTo(progress, easing)
    };
};

// Calculate `from` values from options passed at initialization
Path.prototype._calculateFrom = function _calculateFrom(easing) {
    return Tweenable.interpolate(this._opts.from, this._opts.to, this.value(), easing);
};

// Calculate `to` values from options passed at initialization
Path.prototype._calculateTo = function _calculateTo(progress, easing) {
    return Tweenable.interpolate(this._opts.from, this._opts.to, progress, easing);
};

Path.prototype._stopTween = function _stopTween() {
    if (this._tweenable !== null) {
        this._tweenable.stop();
        this._tweenable.dispose();
        this._tweenable = null;
    }
};

Path.prototype._easing = function _easing(easing) {
    if (EASING_ALIASES.hasOwnProperty(easing)) {
        return EASING_ALIASES[easing];
    }

    return easing;
};

module.exports = Path;

},{"./utils":8,"shifty":1}],6:[function(require,module,exports){
// Semi-SemiCircle shaped progress bar

var Shape = require('./shape');
var Circle = require('./circle');
var utils = require('./utils');

var SemiCircle = function SemiCircle(container, options) {
    // Use one arc to form a SemiCircle
    // See this answer http://stackoverflow.com/a/10477334/1446092
    this._pathTemplate =
        'M 50,50 m -{radius},0' +
        ' a {radius},{radius} 0 1 1 {2radius},0';

    Shape.apply(this, arguments);
};

SemiCircle.prototype = new Shape();
SemiCircle.prototype.constructor = SemiCircle;

SemiCircle.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 50');
};

SemiCircle.prototype._initializeTextElement = function _initializeTextElement(
    opts,
    container,
    element
) {
    if (opts.text.style) {
        // Reset top style
        element.style.top = 'auto';

        element.style.bottom = '0';
        if (opts.text.alignToBottom) {
            utils.setStyle(element, 'transform', 'translate(-50%, 0)');
        } else {
            utils.setStyle(element, 'transform', 'translate(-50%, 50%)');
        }
    }
};

// Share functionality with Circle, just have different path
SemiCircle.prototype._pathString = Circle.prototype._pathString;
SemiCircle.prototype._trailString = Circle.prototype._trailString;

module.exports = SemiCircle;

},{"./circle":2,"./shape":7,"./utils":8}],7:[function(require,module,exports){
// Base object for different progress bar shapes

var Path = require('./path');
var utils = require('./utils');

var DESTROYED_ERROR = 'Object is destroyed';

var Shape = function Shape(container, opts) {
    // Throw a better error if progress bars are not initialized with `new`
    // keyword
    if (!(this instanceof Shape)) {
        throw new Error('Constructor was called without new keyword');
    }

    // Prevent calling constructor without parameters so inheritance
    // works correctly. To understand, this is how Shape is inherited:
    //
    //   Line.prototype = new Shape();
    //
    // We just want to set the prototype for Line.
    if (arguments.length === 0) {
        return;
    }

    // Default parameters for progress bar creation
    this._opts = utils.extend({
        color: '#555',
        strokeWidth: 1.0,
        trailColor: null,
        trailWidth: null,
        fill: null,
        text: {
            style: {
                color: null,
                position: 'absolute',
                left: '50%',
                top: '50%',
                padding: 0,
                margin: 0,
                transform: {
                    prefix: true,
                    value: 'translate(-50%, -50%)'
                }
            },
            alignToBottom: true,
            value: '',
            className: 'progressbar-text'
        },
        svgStyle: {
            display: 'block',
            width: '100%'
        }
    }, opts, true);  // Use recursive extend

    var svgView = this._createSvgView(this._opts);

    var element;
    if (utils.isString(container)) {
        element = document.querySelector(container);
    } else {
        element = container;
    }

    if (!element) {
        throw new Error('Container does not exist: ' + container);
    }

    this._container = element;
    this._container.appendChild(svgView.svg);

    if (this._opts.svgStyle) {
        utils.setStyles(svgView.svg, this._opts.svgStyle);
    }

    this.text = null;
    if (this._opts.text.value) {
        this.text = this._createTextElement(this._opts, this._container);
        this._container.appendChild(this.text);
    }

    // Expose public attributes before Path initialization
    this.svg = svgView.svg;
    this.path = svgView.path;
    this.trail = svgView.trail;
    // this.text is also a public attribute

    var newOpts = utils.extend({
        attachment: undefined,
        shape: this
    }, this._opts);
    this._progressPath = new Path(svgView.path, newOpts);
};

Shape.prototype.animate = function animate(progress, opts, cb) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.animate(progress, opts, cb);
};

Shape.prototype.stop = function stop() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    // Don't crash if stop is called inside step function
    if (this._progressPath === undefined) {
        return;
    }

    this._progressPath.stop();
};

Shape.prototype.destroy = function destroy() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this.stop();
    this.svg.parentNode.removeChild(this.svg);
    this.svg = null;
    this.path = null;
    this.trail = null;
    this._progressPath = null;

    if (this.text !== null) {
        this.text.parentNode.removeChild(this.text);
        this.text = null;
    }
};

Shape.prototype.set = function set(progress) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    this._progressPath.set(progress);
};

Shape.prototype.value = function value() {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this._progressPath === undefined) {
        return 0;
    }

    return this._progressPath.value();
};

Shape.prototype.setText = function setText(text) {
    if (this._progressPath === null) {
        throw new Error(DESTROYED_ERROR);
    }

    if (this.text === null) {
        // Create new text node
        this.text = this._createTextElement(this._opts, this._container);
        this._container.appendChild(this.text);
    }

    // Remove previous text node and add new
    this.text.removeChild(this.text.firstChild);
    this.text.appendChild(document.createTextNode(text));
};

Shape.prototype._createSvgView = function _createSvgView(opts) {
    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this._initializeSvg(svg, opts);

    var trailPath = null;
    // Each option listed in the if condition are 'triggers' for creating
    // the trail path
    if (opts.trailColor || opts.trailWidth) {
        trailPath = this._createTrail(opts);
        svg.appendChild(trailPath);
    }

    var path = this._createPath(opts);
    svg.appendChild(path);

    return {
        svg: svg,
        path: path,
        trail: trailPath
    };
};

Shape.prototype._initializeSvg = function _initializeSvg(svg, opts) {
    svg.setAttribute('viewBox', '0 0 100 100');
};

Shape.prototype._createPath = function _createPath(opts) {
    var pathString = this._pathString(opts);
    return this._createPathElement(pathString, opts);
};

Shape.prototype._createTrail = function _createTrail(opts) {
    // Create path string with original passed options
    var pathString = this._trailString(opts);

    // Prevent modifying original
    var newOpts = utils.extend({}, opts);

    // Defaults for parameters which modify trail path
    if (!newOpts.trailColor) {
        newOpts.trailColor = '#eee';
    }
    if (!newOpts.trailWidth) {
        newOpts.trailWidth = newOpts.strokeWidth;
    }

    newOpts.color = newOpts.trailColor;
    newOpts.strokeWidth = newOpts.trailWidth;

    // When trail path is set, fill must be set for it instead of the
    // actual path to prevent trail stroke from clipping
    newOpts.fill = null;

    return this._createPathElement(pathString, newOpts);
};

Shape.prototype._createPathElement = function _createPathElement(pathString, opts) {
    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathString);
    path.setAttribute('stroke', opts.color);
    path.setAttribute('stroke-width', opts.strokeWidth);

    if (opts.fill) {
        path.setAttribute('fill', opts.fill);
    } else {
        path.setAttribute('fill-opacity', '0');
    }

    return path;
};

Shape.prototype._createTextElement = function _createTextElement(opts, container) {
    var element = document.createElement('p');
    element.appendChild(document.createTextNode(opts.text.value));

    var textStyle = opts.text.style;
    if (textStyle) {
        container.style.position = 'relative';

        utils.setStyles(element, textStyle);

        // Default text color to progress bar's color
        if (!textStyle.color) {
            element.style.color = opts.color;
        }
    }

    element.className = opts.text.className;

    this._initializeTextElement(opts, container, element);
    return element;
};

// Give custom shapes possibility to modify text element
Shape.prototype._initializeTextElement = function _initializeTextElement(opts, container, element) {
    // By default, no-op
    // Custom shapes should respect API options, such as text.style
};

Shape.prototype._pathString = function _pathString(opts) {
    throw new Error('Override this function for each progress bar');
};

Shape.prototype._trailString = function _trailString(opts) {
    throw new Error('Override this function for each progress bar');
};

module.exports = Shape;

},{"./path":5,"./utils":8}],8:[function(require,module,exports){
// Utility functions

var PREFIXES = 'Webkit Moz O ms'.split(' ');

// Copy all attributes from source object to destination object.
// destination object is mutated.
function extend(destination, source, recursive) {
    destination = destination || {};
    source = source || {};
    recursive = recursive || false;

    for (var attrName in source) {
        if (source.hasOwnProperty(attrName)) {
            var destVal = destination[attrName];
            var sourceVal = source[attrName];
            if (recursive && isObject(destVal) && isObject(sourceVal)) {
                destination[attrName] = extend(destVal, sourceVal, recursive);
            } else {
                destination[attrName] = sourceVal;
            }
        }
    }

    return destination;
}

// Renders templates with given variables. Variables must be surrounded with
// braces without any spaces, e.g. {variable}
// All instances of variable placeholders will be replaced with given content
// Example:
// render('Hello, {message}!', {message: 'world'})
function render(template, vars) {
    var rendered = template;

    for (var key in vars) {
        if (vars.hasOwnProperty(key)) {
            var val = vars[key];
            var regExpString = '\\{' + key + '\\}';
            var regExp = new RegExp(regExpString, 'g');

            rendered = rendered.replace(regExp, val);
        }
    }

    return rendered;
}

function setStyle(element, style, value) {
    for (var i = 0; i < PREFIXES.length; ++i) {
        var prefix = PREFIXES[i];
        element.style[prefix + capitalize(style)] = value;
    }

    element.style[style] = value;
}

function setStyles(element, styles) {
    forEachObject(styles, function(styleValue, styleName) {
        // Allow disabling some individual styles by setting them
        // to null or undefined
        if (styleValue === null || styleValue === undefined) {
            return;
        }

        // If style's value is {prefix: true, value: '50%'},
        // Set also browser prefixed styles
        if (isObject(styleValue) && styleValue.prefix === true) {
            setStyle(element, styleName, styleValue.value);
        } else {
            element.style[styleName] = styleValue;
        }
    });
}

function capitalize(text) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}

function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}

function isFunction(obj) {
    return typeof obj === 'function';
}

function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}

// Returns true if `obj` is object as in {a: 1, b: 2}, not if it's function or
// array
function isObject(obj) {
    if (isArray(obj)) {
        return false;
    }

    var type = typeof obj;
    return type === 'object' && !!obj;
}

function forEachObject(object, callback) {
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            var val = object[key];
            callback(val, key);
        }
    }
}

module.exports = {
    extend: extend,
    render: render,
    setStyle: setStyle,
    setStyles: setStyles,
    capitalize: capitalize,
    isString: isString,
    isFunction: isFunction,
    isObject: isObject,
    forEachObject: forEachObject
};

},{}]},{},[4])(4)
});
Plugins.register('CreateReturn', function($required) {
	// --------------------------------------------------------------------
	// Plugin definition
	// --------------------------------------------------------------------
	(function($) {
		var csts = {
			NAME: 'CreateReturnPlugin'
		};
		
		var settings = {
			CREATE_RETURN_BT: '#makeReturnButton',
			ORDER_ID: 'order-id'
		};
		
		var actors = {
			CREATE_RETURN: 'rest/model/atg/commerce/custsvc/returns/ReturnsActor/createReturn'
		};

		var methods = {
			init: function() {
				return this.each(function() {
				    $(this).parent()
						.on('click', settings.CREATE_RETURN_BT, function(event) {
						    methods._createReturnFromOrderId($(this).data(settings.ORDER_ID), event);
						});					
				    
					// Event binding
				    listenForEvent(Events.CREATE_RETURN, function(event, orderId) {
				    	methods._createReturnFromOrderId(orderId);
				    });
				});
			},
			
			// Invoke create return actor.
			// 
			// @param orderId Order identifier.
			// @param event Triggered event.
			_createReturnFromOrderId: function(orderId, event) {
				if (undefined !== event) {
					event.preventDefault();
				}

				getAjaxHandler()
					.withUrl(actors.CREATE_RETURN)
					.withParameter('returnOrderId', orderId)
					.call();
			}
		};
		$.fn.CreateReturnPlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	// --------------------------------------------------------------------
	// End of plugin definition
	// --------------------------------------------------------------------
	$required.CreateReturnPlugin();
});

Plugins.register('SelectAndConfirmReturn', function($required) {

	// Amount format method. Formatting is based on Number.prototype.toLocaleString() browser implementation.
	// Currency is never modified.
	//
	// @param $holder jQuery container reference.
	// @param amount Amount to format.
	var amountFormat = function($holder, amount) {
		if (0 !== $holder.length && undefined !== amount) {
			$holder.text($holder.text().replace(/[0-9,\.]/g, '') + amount.toFixed(2).toLocaleString());
		}
	};
	
	// --------------------------------------------------------------------
	// Plugin definitions
	// --------------------------------------------------------------------

	// Manage one line in the return Item list: detect quantity and reason changes.
	(function($) {
		var csts = {
			NAME: 'ReturnLinePlugin'
		};
		var settings = {
			ITEM_QUANTITY_INPUT: '.quantity-selector .quantity-input',
			ITEM_RETURN_REASON_LIST: 'select[name="returnReason"]',
			ITEM_QTY_SELECT: 'select.management-amount',
			DIV_REASON: '.col.reason, .col.price',
			LI: 'li[data-id]',
			DISABLED: 'disabled',
			SHIP_ID: 'input[name="shippingGroupId"]',
			LI_ID:'data-id',
			QTY_LESS: '.quantity-less',
			QTY_MORE: '.quantity-more'
		};
		
		var actors = {
			SELECT_ITEM: 'rest/model/atg/commerce/custsvc/returns/ReturnsActor/selectItems'
		};
		
		var methods = {
			init: function() {
				return this.each(function() {
					var $this = $(this),
						data = $this.data(csts.NAME);
					
					if (undefined === data) {
						data = {
							lines: $this.find(settings.LI),
							returnItems: {}
						};
						
						$this.data(csts.NAME, data);
					}

					var qtyInputs = $('.quantity-input');
					for(var i=0;i<qtyInputs.length;i++){
						
						var qtyInput = qtyInputs[i];

						if($(qtyInput).val() === '0') {
							$(qtyInput).siblings('.quantity-less').attr('disabled', 'disabled');
						} else if($(qtyInput).val() === $(qtyInput).attr('data-maxquantity')) {
							 $(qtyInput).siblings('.quantity-more').attr('disabled', 'disabled');
						}
					}

					data.lines.each(function() {
						var $li = $(this);
						
						// Building data.returnItems
						data.returnItems[$li.attr(settings.LI_ID)] = { 
							id: $li.attr(settings.LI_ID),
							quantityToExchange: '0', 
							quantityToReturn: '0', 
							returnReason:$li.find(settings.ITEM_RETURN_REASON_LIST).val(),
							shippingGroupId: $li.find(settings.SHIP_ID).val()
						};
						// Events management

						$li
							.on('change', [ settings.ITEM_QUANTITY_INPUT ].join(','), function() {
								console.clear();
								console.log("this =>", $this);
								console.log("data =>", data);
								console.log("$li =>", $li);
								var _t = $(this);

								methods._qtyChanged($this, data, $li, _t);
								if(_t.val() > _t.attr('data-maxquantity')){
									_t.val(_t.attr('data-maxquantity'));
									_t.siblings('.quantity-more').attr('disabled', 'disabled');
									_t.siblings('.quantity-less').removeAttr('disabled');
								}
								else if(_t.val() === _t.attr('data-maxquantity')) {
									_t.siblings('.quantity-more').attr('disabled', 'disabled');
								} else if(_t.val() === '0') {
									_t.siblings('.quantity-more').removeAttr('disabled');
									_t.siblings('.quantity-less').attr('disabled', 'disabled');
								} else{
									_t.siblings('.quantity-less').removeAttr('disabled');
									_t.siblings('.quantity-more').removeAttr('disabled');
								}

							})
							.on('change', settings.ITEM_RETURN_REASON_LIST, function() {
								methods._reasonChanged($this, data, $li, $(this));
							})
							.on('click', settings.QTY_MORE, function(e){
								decathlon.tools.selectorQuantity($(this));
								methods._qtyChanged($this, data, $li, $(this).siblings('input.quantity-input'));

								if($(this).siblings('input.quantity-input').val() === $(this).siblings('input.quantity-input').attr('data-maxquantity')) {
									$(this).attr('disabled', 'disabled');
								}
								
							})
							.on('click', settings.QTY_LESS, function(e){
								decathlon.tools.selectorQuantity($(this));
								methods._qtyChanged($this, data, $li, $(this).siblings('input.quantity-input'));
								
								if($(this).siblings('input.quantity-input').val() === '0') {
									$(this).attr('disabled', 'disabled');
								}
								$(this).siblings('.quantity-more').removeAttr('disabled');
							});
						
						// Check if quantity selector can be updated or not. If length === 1, means only one quantity that is 0, line should be disabled.
						if (1 === $li.find([settings.ITEM_QTY_SELECT, 'option'].join('')).length) {
							$li.find('.col.quantity').addClass(settings.DISABLED);
						}
					});
				});
			},
			
			// Method invoked when quantity is changed for a return item.
			//
			// @param $this Plugin reference.
			// @param data Plugin data.
			// @param $li Current line reference.
			// @param $input Input or select used.
			_qtyChanged:function($this, data, $li, $input) {
				var value = $input.val();
				
				if (isNaN(parseInt(value))) {
					value = '0';
				}

				methods._getReturnItem(data, $li).quantityToReturn = value;
				
				if (/input/i.test($input.prop('tagName'))) {
					var $select = $li.find(settings.ITEM_QTY_SELECT);
					
					// Check if typed value is in option list. If it is, update select, if not, just keep typed value.
					if (0 !== $.grep($select.find('option'), function(n) { return n.innerText === value; }).length) {
						$select.selectpicker('val', value);
					}
					else { 
						$select.val('');
					}
				}
				methods._selectItems($this, data, $li);
			},
			
			// Method invoked when reason is changed for a return item.
			//
			// @param $this Plugin reference.
			// @param data Plugin data.
			// @param $li Current line reference.
			// @param $input Input or select used.
			_reasonChanged: function($this, data, $li, $input) {
				methods._getReturnItem(data, $li).returnReason = $input.val();
				methods._selectItems($this, data, $li);
			},

			// Method called when changing quantity or return reason for an item.
			//
			// @param $this Plugin reference.
			// @param data Plugin data.
			// @param $li Current line reference.
			_selectItems: function($this, data, $li, param) {
				// Enable/disable reason selector
				methods._toggleReason($li, '0' === methods._getReturnItem(data, $li).quantityToReturn);
				
				// Building return items Array from data.returnItems Map.
				var returnItems = $.map(data.returnItems, function(v, k) { return v; });
				
				// If all quantities are equals to 0, no call
				if (0 === $.grep(returnItems, function(n) { return '0' !== n.quantityToReturn; }).length) {
					// Sets all prices to 0 and disable confirmation button
					methods._reset(data);
				}
				else {
					// Ajax call
					getAjaxHandler()
						.withCaller($this)
						.withUrl(actors.SELECT_ITEM)
						.withParameter(
							'jsonReturnRequest', 
							JSON.stringify({ 'returnRequest':{ 'shippingGroupList':[ { 'itemList': returnItems } ] } }))
						.withSuccess(methods._doSelectItemSuccess)
						.call();
				}
			},

			// Select items actor success callback method.
			// 
			// @param $this Plugin reference.
			// @param result Call result.
			// @param params Call input parameters.
			_doSelectItemSuccess: function($this, result, params) {
				if (resultNotEmpty(result)) {
						
					var data = result.responseTO.data,
						pluginData = $this.data(csts.NAME);
					
					if(!isNull(data) && !isNull(data.prices)) {
						
						// Item price management
						$.each(data.prices, function(k, v) {
							methods._updatePrice(pluginData, k , v.amount, v.currency);
						});
						
						// Total management
						throwEvent(
							Events.RETURN_TOTAL_UPDATED, 
							data.totalQuantityToreturn, 
							data.totalAmount.amount);
					}
					else if(resultHasErrors(result)) {
						$.each(result.responseTO.errors, function(index, valueArray) {
							displayError(valueArray.message, Consts.MAIN_ERROR);
						});
						
						// Resets everything
						methods._reset(pluginData);
					}
				} else {
					displayError(Messages('TECH_0001'), Consts.MAIN_ERROR);
				}
			},
			
			// Gets return item for the given line.
			// 
			// @param data Plugin data.
			// @param $li Current line.
			_getReturnItem: function(data, $li) {
				return data.returnItems[$li.attr(settings.LI_ID)];
			},

			// Changes return reason activation.
			//
			// @param $li Concerned line.
			// @param active true if must enabled, false otherwise.
			_toggleReason:function($li, active) {
				var $reason = $li.find(settings.DIV_REASON);
				
				if (0 !== $reason.length) {
					if (false === active) {
						$reason.removeClass(settings.DISABLED);
					}
					else {
						if (!$reason.hasClass(settings.DISABLED)) {
							$reason.addClass(settings.DISABLED);
						}
					}
				}
			},
			
			// Updates line price.
			//
			// @param data Plugin data.
			// @param rId Return item id to change.
			// @param amount New amount.
			// @param currency New currency.
			_updatePrice:function(data, rId, amount, currency) {
				if (undefined !== data) {
					amountFormat(
						data.lines
							.filter('[{0}="{1}"]'.format(settings.LI_ID, rId))
								.find('.price .subtotal '), 
						amount);
				}
			},
				
			// Resets all amount and total return quantity to 0.
			//
			// @param $data Plugin data.
			_reset:function(data) {
				// Updates all prices.
				if (undefined !== data) {
					data.lines.each(function() {
						methods._updatePrice(data, $(this).attr(settings.LI_ID), 0);
					});
				}
				// Updates footer.
				throwEvent(Events.RETURN_TOTAL_UPDATED, 0, 0);
			}
		};
		$.fn.ReturnLinePlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	
	// SelectAndConfirmReturnPlugin: global return page management plugin.
	(function($) {
		var csts = {
			NAME: 'SelectAndConfirmReturnPlugin',
			DISABLED: 'disabled'
		};
		
		var settings = {
			VALIDATE_BT:'#validateReturnButton',
			RETURN_ITEM_LIST: '#cartList .clearfix',
			FOOTER: '.return-footer',
			FOOTER_PRICE: '.price .value',
			FOOTER_QTY: '.count'
		};
		
		var actors = {
			CONFIRM_RETURN: 'rest/model/atg/commerce/custsvc/returns/ReturnsActor/confirmReturn',
		};

		var methods = {
			init: function() {
				return this.each(function() {
					var $this = $(this),
						data = $this.data(csts.NAME);
					
					if (undefined === data) {
						data = {
							footer: $(settings.FOOTER),
							confirmBt: $(settings.VALIDATE_BT),
							enabled: false,
						};
						
						$this.data(csts.NAME, data);
					}

					 $this

						.on('click', settings.VALIDATE_BT, function(e) {
							methods._confirm(e, data);
						})
						// Return item lines management, dedicated plugin.
						.find(settings.RETURN_ITEM_LIST).ReturnLinePlugin();
					
					// Event management
					listenForEvent(Events.RETURN_TOTAL_UPDATED, function(event, quantity, amount) {
						methods._updateFooter($this, quantity, amount);
					});
					
					// Disable confirmation button
					methods._toggleConfirmBt(data, false);
				});
			},
			
			// Call confirm return actor method.
			//
			// @param event Triggered event.
			// @param data Plugin data.
			_confirm:function(event, data) {
				event.preventDefault();
				
				if (true === data.enabled) {
					getAjaxHandler()
						.withCaller($(this))
						.withUrl(actors.CONFIRM_RETURN)
						.withSuccess(methods._confirmReturnSuccess)
						.call();
				}
			},
			
			// Success callback function for confirm method.
			//
			// @param $this Plugin reference.
			// @param jsonCallbackData
			// @param ajaxParameters
			_confirmReturnSuccess:function($this, jsonCallbackData, ajaxParameters) {	
				var errorCodes = {
					NOT_AUTHENTICATED : 'AUTHENTICATION_001',
					TECH_ERROR : 'TECH_0001'
				};

				if (resultNotEmpty(jsonCallbackData)) {
					
					if (resultHasErrors(jsonCallbackData)) {
		        		decathlon.tools.displayLoader(false, false);
						$.each(jsonCallbackData.responseTO.errors, function(id, error) {
							var errorCode = JSON.stringify(error.code).replace(/"/g, "");
							if (errorCode === errorCodes.NOT_AUTHENTICATED) {
								window.location.replace(Cube.Utils.localizeUri('/account/myPurchase/'));
							} else {
								displayError(error.message, Consts.MAIN_ERROR);
							}
						});
					} else {
						checkRedirect(jsonCallbackData);
					}
					
				} else {
					console.log(this);
					console.log($this);
					console.log(jsonCallbackData);
					console.log(ajaxParameters);
					displayError(Messages(errorCodes.TECH_ERROR), Consts.MAIN_ERROR);
				}
			},
			
			// Footer update method.
			//
			// @param $this Plugin reference.
			// @param quantity Total return quantity.
			// @param amount Total return amount.
			_updateFooter:function($this, quantity, amount) {
				var data = $this.data(csts.NAME);
				
				if (undefined !== data) {
					// Display total
					amountFormat(data.footer.find(settings.FOOTER_PRICE), amount);
					// Change quantity
					data.footer.find(settings.FOOTER_QTY).text(quantity);
					// Enable/disable confirm button	
					methods._toggleConfirmBt(data, 0 !== quantity);
				}
			},
			
			// Enable/disable confirm button.
			//
			// @param data Plugin data.
			// @param active Tells if we need to enable or disable confirm button.
			_toggleConfirmBt:function(data, active) {
				data.enabled = active;
				
				if (true === data.enabled) {
					data.confirmBt.removeClass(csts.DISABLED);
				}
				else {
					if (!data.confirmBt.hasClass(csts.DISABLED)) {
						data.confirmBt.addClass(csts.DISABLED);
					}
				}
			}
		};
		$.fn.SelectAndConfirmReturnPlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	// --------------------------------------------------------------------
	// End of plugin definition
	// --------------------------------------------------------------------
	$required.SelectAndConfirmReturnPlugin();
});



///////////////////

Plugins.register('SelectAndConfirmReturnExchange', function($required) {

	// Amount format method. Formatting is based on Number.prototype.toLocaleString() browser implementation.
	// Currency is never modified.
	//
	// @param $holder jQuery container reference.
	// @param amount Amount to format.
	var amountFormat = function($holder, amount) {
		if (0 !== $holder.length && undefined !== amount) {
			$holder.text($holder.text().replace(/[0-9,\.]/g, '') + amount.toFixed(2).toLocaleString());
		}
	};
	
	// --------------------------------------------------------------------
	// Plugin definitions
	// --------------------------------------------------------------------

	// Manage one line in the return Item list: detect quantity and reason changes.
	(function($) {
		var csts = {
			NAME: 'ReturnLinePlugin'
		};
		var settings = {
			ITEM_QUANTITY_INPUT: '.quantity-selector .quantity-input',
			ITEM_RETURN_REASON_LIST: 'select[name="returnReason"]',
			ITEM_QTY_SELECT: 'select.management-amount',
			DIV_REASON: '.col.reason, .col.price',
			LI: 'li[data-id]',
			DISABLED: 'disabled',
			SHIP_ID: 'input[name="shippingGroupId"]',
			LI_ID:'data-id',
			QTY_LESS: '.quantity-less',
			QTY_MORE: '.quantity-more'
		};
		
		var actors = {
			SELECT_ITEM: 'rest/model/atg/commerce/custsvc/returns/ReturnsActor/selectItems'
		};
		
		var methods = {
			init: function() {
				return this.each(function() {
					var $this = $(this),
						data = $this.data(csts.NAME);
					
					if (undefined === data) {
						data = {
							lines: $this.find(settings.LI),
							returnItems: {}
						};
						
						$this.data(csts.NAME, data);
					}

					var qtyInputs = $('.quantity-input');
					for(var i=0;i<qtyInputs.length;i++){
						
						var qtyInput = qtyInputs[i];

						if($(qtyInput).val() === '0') {
							$(qtyInput).siblings('.quantity-less').attr('disabled', 'disabled');
						} else if($(qtyInput).val() === $(qtyInput).attr('data-maxquantity')) {
							 $(qtyInput).siblings('.quantity-more').attr('disabled', 'disabled');
						}
					}

					data.lines.each(function() {
						var $li = $(this);
						
						// Building data.returnItems
						data.returnItems[$li.attr(settings.LI_ID)] = { 
							id: $li.attr(settings.LI_ID),
							quantityToExchange: '0', 
							quantityToReturn: '0', 
							returnReason:$li.find(settings.ITEM_RETURN_REASON_LIST).val(),
							shippingGroupId: $li.find(settings.SHIP_ID).val()
						};
						
						// Events management

						$li
							.on('change', [ settings.ITEM_QUANTITY_INPUT ].join(','), function() {

								var _t = $(this);

								methods._qtyChanged($this, data, $li, _t);
								if(_t.val() > _t.attr('data-maxquantity')){
									_t.val(_t.attr('data-maxquantity'));
									_t.siblings('.quantity-more').attr('disabled', 'disabled');
									_t.siblings('.quantity-less').removeAttr('disabled');
								}
								else if(_t.val() === _t.attr('data-maxquantity')) {
									_t.siblings('.quantity-more').attr('disabled', 'disabled');
								} else if(_t.val() === '0') {
									_t.siblings('.quantity-more').removeAttr('disabled');
									_t.siblings('.quantity-less').attr('disabled', 'disabled');
								} else{
									_t.siblings('.quantity-less').removeAttr('disabled');
									_t.siblings('.quantity-more').removeAttr('disabled');
								}

							})
							.on('change', settings.ITEM_RETURN_REASON_LIST, function() {
								methods._reasonChanged($this, data, $li, $(this));
							})
							.on('click', settings.QTY_MORE, function(e){
								decathlon.tools.selectorQuantity($(this));
								methods._qtyChanged($this, data, $li, $(this).siblings('input.quantity-input'));

								if($(this).siblings('input.quantity-input').val() === $(this).siblings('input.quantity-input').attr('data-maxquantity')) {
									$(this).attr('disabled', 'disabled');
								}
								
							})
							.on('click', settings.QTY_LESS, function(e){
								decathlon.tools.selectorQuantity($(this));
								methods._qtyChanged($this, data, $li, $(this).siblings('input.quantity-input'));
								
								if($(this).siblings('input.quantity-input').val() === '0') {
									$(this).attr('disabled', 'disabled');
								}
								$(this).siblings('.quantity-more').removeAttr('disabled');
							});
						
						// Check if quantity selector can be updated or not. If length === 1, means only one quantity that is 0, line should be disabled.
						if (1 === $li.find([settings.ITEM_QTY_SELECT, 'option'].join('')).length) {
							$li.find('.col.quantity').addClass(settings.DISABLED);
						}
					});
				});
			},
			
			// Method invoked when quantity is changed for a return item.
			//
			// @param $this Plugin reference.
			// @param data Plugin data.
			// @param $li Current line reference.
			// @param $input Input or select used.
			_qtyChanged:function($this, data, $li, $input) {
				var value = $input.val();
				
				if (isNaN(parseInt(value))) {
					value = '0';
				}

				methods._getReturnItem(data, $li).quantityToReturn = value;
				
				if (/input/i.test($input.prop('tagName'))) {
					var $select = $li.find(settings.ITEM_QTY_SELECT);
					
					// Check if typed value is in option list. If it is, update select, if not, just keep typed value.
					if (0 !== $.grep($select.find('option'), function(n) { return n.innerText === value; }).length) {
						$select.selectpicker('val', value);
					}
					else { 
						$select.val('');
					}
				}
				methods._selectItems($this, data, $li);
			},
			
			// Method invoked when reason is changed for a return item.
			//
			// @param $this Plugin reference.
			// @param data Plugin data.
			// @param $li Current line reference.
			// @param $input Input or select used.
			_reasonChanged: function($this, data, $li, $input) {
				methods._getReturnItem(data, $li).returnReason = $input.val();
				methods._selectItems($this, data, $li);
			},

			// Method called when changing quantity or return reason for an item.
			//
			// @param $this Plugin reference.
			// @param data Plugin data.
			// @param $li Current line reference.
			_selectItems: function($this, data, $li, param) {
				// Enable/disable reason selector
				methods._toggleReason($li, '0' === methods._getReturnItem(data, $li).quantityToReturn);
				
				// Building return items Array from data.returnItems Map.
				var returnItems = $.map(data.returnItems, function(v, k) { return v; });
				
				// If all quantities are equals to 0, no call
				if (0 === $.grep(returnItems, function(n) { return '0' !== n.quantityToReturn; }).length) {
					// Sets all prices to 0 and disable confirmation button
					methods._reset(data);
				}
				else {
					// Ajax call
					getAjaxHandler()
						.withCaller($this)
						.withUrl(actors.SELECT_ITEM)
						.withParameter(
							'jsonReturnRequest', 
							JSON.stringify({ 'returnRequest':{ 'shippingGroupList':[ { 'itemList': returnItems } ] } }))
						.withSuccess(methods._doSelectItemSuccess)
						.call();
				}
			},

			// Select items actor success callback method.
			// 
			// @param $this Plugin reference.
			// @param result Call result.
			// @param params Call input parameters.
			_doSelectItemSuccess: function($this, result, params) {
				if (resultNotEmpty(result)) {
						
					var data = result.responseTO.data,
						pluginData = $this.data(csts.NAME);
					
					if(!isNull(data) && !isNull(data.prices)) {
						
						// Item price management
						$.each(data.prices, function(k, v) {
							methods._updatePrice(pluginData, k , v.amount, v.currency);
						});
						
						// Total management
						throwEvent(
							Events.RETURN_TOTAL_UPDATED, 
							data.totalQuantityToreturn, 
							data.totalAmount.amount);
					}
					else if(resultHasErrors(result)) {
						$.each(result.responseTO.errors, function(index, valueArray) {
							displayError(valueArray.message, Consts.MAIN_ERROR);
						});
						
						// Resets everything
						methods._reset(pluginData);
					}
				} else {
					displayError(Messages('TECH_0001'), Consts.MAIN_ERROR);
				}
			},
			
			// Gets return item for the given line.
			// 
			// @param data Plugin data.
			// @param $li Current line.
			_getReturnItem: function(data, $li) {
				return data.returnItems[$li.attr(settings.LI_ID)];
			},

			// Changes return reason activation.
			//
			// @param $li Concerned line.
			// @param active true if must enabled, false otherwise.
			_toggleReason:function($li, active) {
				var $reason = $li.find(settings.DIV_REASON);
				
				if (0 !== $reason.length) {
					if (false === active) {
						$reason.removeClass(settings.DISABLED);
					}
					else {
						if (!$reason.hasClass(settings.DISABLED)) {
							$reason.addClass(settings.DISABLED);
						}
					}
				}
			},
			
			// Updates line price.
			//
			// @param data Plugin data.
			// @param rId Return item id to change.
			// @param amount New amount.
			// @param currency New currency.
			_updatePrice:function(data, rId, amount, currency) {
				if (undefined !== data) {
					amountFormat(
						data.lines
							.filter('[{0}="{1}"]'.format(settings.LI_ID, rId))
								.find('.price .subtotal '), 
						amount);
				}
			},
				
			// Resets all amount and total return quantity to 0.
			//
			// @param $data Plugin data.
			_reset:function(data) {
				// Updates all prices.
				if (undefined !== data) {
					data.lines.each(function() {
						methods._updatePrice(data, $(this).attr(settings.LI_ID), 0);
					});
				}
				// Updates footer.
				throwEvent(Events.RETURN_TOTAL_UPDATED, 0, 0);
			}
		};
		$.fn.ReturnLinePlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	
	// SelectAndConfirmReturnPlugin: global return page management plugin.
	(function($) {
		var csts = {
			NAME: 'SelectAndConfirmReturnExchangePlugin',
			DISABLED: 'enabled'
		};
		
		var settings = {
			VALIDATE_BT:'#validateReturnExchangeButton',
			RETURN_ITEM_LIST: '#cartList .clearfix',
			FOOTER: '.return-footer',
			FOOTER_PRICE: '.price .value',
			FOOTER_QTY: '.count'
		};
		
		var actors = {
			CONFIRM_RETURN: 'rest/model/atg/commerce/custsvc/returns/ReturnsActor/confirmReturn',
		};

		var methods = {
			init: function() {
				return this.each(function() {
					var $this = $(this),
						data = $this.data(csts.NAME);
					
					if (undefined === data) {
						data = {
							footer: $(settings.FOOTER),
							confirmBt: $(settings.VALIDATE_BT),
							enabled: false,
						};
						
						$this.data(csts.NAME, data);
					}

					 $this

						.on('click', settings.VALIDATE_BT, function(e) {
							
							methods._confirm(e, data);
						})
						// Return item lines management, dedicated plugin.
						.find(settings.RETURN_ITEM_LIST).ReturnLinePlugin();
					
					// Event management
					listenForEvent(Events.RETURN_TOTAL_UPDATED, function(event, quantity, amount) {
						methods._updateFooter($this, quantity, amount);
					});
					
					// Disable confirmation button
					methods._toggleConfirmBt(data, false);
				});
			},
			
			// Call confirm return actor method.
			//
			// @param event Triggered event.
			// @param data Plugin data.
			_confirm:function(event, data) {
				event.preventDefault();
				
				//if (true === data.enabled) {
					getAjaxHandler()
						.withCaller($(this))
						.withUrl(actors.CONFIRM_RETURN)
						.withSuccess(methods._confirmReturnSuccess)
						.call();
				//}
			},
			
			// Success callback function for confirm method.
			//
			// @param $this Plugin reference.
			// @param jsonCallbackData
			// @param ajaxParameters
			_confirmReturnSuccess:function($this, jsonCallbackData, ajaxParameters) {	
				var errorCodes = {
					NOT_AUTHENTICATED : 'AUTHENTICATION_001',
					TECH_ERROR : 'TECH_0001'
				};
				
				if (resultNotEmpty(jsonCallbackData)) {
					
					if (resultHasErrors(jsonCallbackData)) {
		        		decathlon.tools.displayLoader(false, false);
						$.each(jsonCallbackData.responseTO.errors, function(id, error) {
							var errorCode = JSON.stringify(error.code).replace(/"/g, "");
							if (errorCode === errorCodes.NOT_AUTHENTICATED) {
								window.location.replace(Cube.Utils.localizeUri('/account/myPurchase/'));
							} else {
								displayError(error.message, Consts.MAIN_ERROR);
							}
						});
					} else {
						checkRedirect(jsonCallbackData);
					}
					
				} else {
					console.log(this);
					console.log($this);
					console.log(jsonCallbackData);
					console.log(ajaxParameters);
					displayError(Messages(errorCodes.TECH_ERROR), Consts.MAIN_ERROR);
				}
			},
			
			// Footer update method.
			//
			// @param $this Plugin reference.
			// @param quantity Total return quantity.
			// @param amount Total return amount.
			_updateFooter:function($this, quantity, amount) {
				var data = $this.data(csts.NAME);
				
				if (undefined !== data) {
					// Display total
					amountFormat(data.footer.find(settings.FOOTER_PRICE), amount);
					// Change quantity
					data.footer.find(settings.FOOTER_QTY).text(quantity);
					// Enable/disable confirm button	
					methods._toggleConfirmBt(data, 0 !== quantity);
				}
			},
			
			// Enable/disable confirm button.
			//
			// @param data Plugin data.
			// @param active Tells if we need to enable or disable confirm button.
			_toggleConfirmBt:function(data, active) {
				data.enabled = active;
				
				if (true === data.enabled) {
					data.confirmBt.removeClass(csts.DISABLED);
				}
				else {
					if (!data.confirmBt.hasClass(csts.DISABLED)) {
						data.confirmBt.addClass(csts.DISABLED);
					}
				}
			}
		};
		$.fn.SelectAndConfirmReturnExchangePlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	// --------------------------------------------------------------------
	// End of plugin definition
	// --------------------------------------------------------------------
	$required.SelectAndConfirmReturnExchangePlugin();
});
/**
 * 
 * ----------- Filtering Plugin -----------
 * Manage Ajax call to load the MC_GuidedNavigation cartridge
 */
(function($) {
  // Plugin constants
  var csts = {
    // Plugin identifier
    NAME : 'GuidedNavigationPlugin',
    AJAX_GUIDED_NAVIGATION : 'ajaxGuidedNavigation'
  };

  var methods = {
    // Initialize function, i.e plugin constructor.
    init : function(options) {
      return this.each(function() {
      });
    },

    

    ajaxGuidedNavigation : function(cartridgeId, nParameterValue, paramUrl) {
      reloadCartridgeContentCollection(
          $(this),
          cartridgeId,
          {'N' : nParameterValue},
          methods._ajaxGuidedNavigationSuccess,
          methods._ajaxGuidedNavigationError);
      
	      //change url
	      var baseUrl = $('#base-url-for-filters').val();
	      if(history.pushState && paramUrl){
	        history.pushState(null,null, baseUrl+paramUrl);
	      }
    },

    _ajaxGuidedNavigationSuccess : function($this, result) {
      $('.selectpicker').selectpicker('refresh');
      
      $('#product-filters').uxProductFiltersRangeRender();
      $("#product-filters").uxProductFiltersMethods();
      
      $(window).trigger('loadingProducts');

      decathlon.tools.slickReinitSlider('.pl-element', '.slick-product', '.slick-thumbs', productListSlickSettings, productListSlickThumbsSettings);
      
    },

    _ajaxGuidedNavigationError : function($this, jqXHR, textStatus,
        errorThrown) {
      logError('ajaxGuidedNavigation error !');
    },
    
    ajaxLoadGlobalAverageRating : function(cartridgeId, nParameterValue, paramUrl) {
      // update the replaced cartridge with data stored in the reloadable slot
      $("#" + cartridgeId).attr("t-url", $("#ajax-MC_GlobalAverageRating").attr("t-url"));
      $("#" + cartridgeId).attr("t-path", $("#ajax-MC_GlobalAverageRating").attr("t-path"));

      reloadCartridgeContentCollection(
          $(this),
          cartridgeId,
          {'N' : nParameterValue},
          methods.ajaxLoadGlobalAverageRatingSuccess,
          methods.ajaxLoadGlobalAverageRatingError);
    },
    
    ajaxLoadGlobalAverageRatingSuccess : function($this, result) {
    },

    ajaxLoadGlobalAverageRatingError : function($this, jqXHR, textStatus,
        errorThrown) {
      logError('ajaxLoadGlobalAverageRating error !');
    }
  };

  // Plugin entry point
  $.fn.GuidedNavigationPlugin = basePlugin(methods, csts.NAME);
})(jQuery);

//Plug to reload the filter and the listing
(function($) {
  // Plugin constants
  var csts = {
    // Plugin identifier
    NAME : 'FilterAndListingPlugin',
    AJAX_GUIDED_NAVIGATION : 'ajaxFilterAndListing'
  };

  var methods = {
    // Initialize function, i.e plugin constructor.
    init : function(options) {
      return this.each(function() {
      });
    },

    

    ajaxFilterAndListing : function(nParameterValue, paramUrl, extraparameter) {

      var collection = createCartridgeCollection();
        collection.add('product-filters-ajax-reload', {'N' : nParameterValue});
        reloadManyCartridgeWithCollection(
            $(this),
          collection,
          true,
          methods._ajaxFilterAndListingSuccess,
          methods._ajaxFilterAndListingError);
        
        var collectionList = createCartridgeCollection();
        collectionList.add('listing-product', {'N' : nParameterValue});
        reloadManyCartridgeWithCollection(
            $(this),
            collectionList,
          true,
          methods._ajaxProductListingSuccess,
          methods._ajaxFilterAndListingError);

        decathlon.tools.showHideLoadingGif('show');

      //change url
      var baseUrl = $('#base-url-for-filters').val();
      if(history.pushState && paramUrl){
        history.pushState(null,null, baseUrl+paramUrl);
      }
    },

    _ajaxFilterAndListingSuccess : function($this, result) {

      $('.selectpicker').selectpicker('refresh');
      
      $('#product-filters').uxProductFiltersRangeRender();
      $("#product-filters").uxProductFiltersMethods();

      //hide spotlight floor if filters selected
      if ($('#breadCrumbsFilters')[0]){
        $(('#spotlightFloor')).addClass('hidden');
      }else{
        $(('#spotlightFloor')).addClass('hidden');
      }
    },
    
    _ajaxProductListingSuccess : function($this, result) {

      if($this.attr('id') === 'cancel-filters'){
        setTimeout(function(){
          $("#product-filters").uxProductFiltersMethods('closeFilters');
        },500);
      }

      $(window).trigger('loadingProducts');
      decathlon.tools.slickReinitSlider('.pl-element', '.slick-product', '.slick-thumbs', productListSlickSettings, productListSlickThumbsSettings);
      decathlon.tools.showHideLoadingGif('hide');

    },

    _ajaxFilterAndListingError : function($this, jqXHR, textStatus,
        errorThrown) {
      logError('ajaxFilterAndListing error !');
    }
  };

  // Plugin entry point
  $.fn.FilterAndListingPlugin = basePlugin(methods, csts.NAME);
})(jQuery);

//Plug to reload the filter and the listing after modifying the slider
(function($) {
  // Plugin constants
  var csts = {
    // Plugin identifier
    NAME : 'PriceSliderPlugin',
    AJAX_GUIDED_NAVIGATION : 'ajaxPriceSliderListing'
  };

  var methods = {
    // Initialize function, i.e plugin constructor.
    init : function(options) {

      return this.each(function() {
      });
    },

    ajaxPriceSliderListing : function(slider) {
      var collection = createCartridgeCollection();
      var nParameterValue = $('#price-url').val();
          var property = $('#price-property').val();
          var rangeValue = property + '|BTWN' + '+' + slider.from + '+' + slider.to;
        collection.add('product-filters-ajax-reload', {'N': nParameterValue,'Nf': rangeValue});
        reloadManyCartridgeWithCollection(
            $(this),
          collection,
          true,
          methods._ajaxPriceSliderListingSuccess,
          methods._ajaxPriceSliderListingError);
        
        var collectionList = createCartridgeCollection();
        collectionList.add('listing-product', {'N': nParameterValue,'Nf': rangeValue});
        reloadManyCartridgeWithCollection(
            $(this),
          collectionList,
          true,
          methods._ajaxProductListingSuccess,
          methods._ajaxPriceSliderListingError);
      
        decathlon.tools.showHideLoadingGif('show');

        
      //change url
      var baseUrl = $('#base-url-for-filters').val();
      var path=$('#range_filter_input').data("path");
      if(history.pushState){
        history.pushState(null,null, baseUrl+path+'Nf='+rangeValue);
      }
    },
  
    
    _ajaxPriceSliderListingSuccess : function($this, result) {

      $('.selectpicker').selectpicker('refresh');
      
      $('#product-filters').uxProductFiltersRangeRender();
      $("#product-filters").uxProductFiltersMethods();

      //hide spotlight floor if filters selected
      if ($('#breadCrumbsFilters')[0]){
        $(('#spotlightFloor')).addClass('hidden');
      }else{
        $(('#spotlightFloor')).addClass('hidden');
      }
    },
    
    _ajaxProductListingSuccess : function($this, result) {
      $(window).trigger('loadingProducts');
      decathlon.tools.slickReinitSlider('.pl-element', '.slick-product', '.slick-thumbs', productListSlickSettings, productListSlickThumbsSettings);
      
      decathlon.tools.showHideLoadingGif('hide');

    },

    _ajaxPriceSliderListingError : function($this, jqXHR, textStatus,
        errorThrown) {
      logError('ajaxPriceSliderListing error !');
    }
  };

  // Plugin entry point
  $.fn.PriceSliderPlugin = basePlugin(methods, csts.NAME);
})(jQuery);





;(function(window, $){
      
  jQuery('body').GuidedNavigationPlugin().on('click','#linkRefreshListing',function(event) {
    event.preventDefault();
      (function($this) {
          
          $this.GuidedNavigationPlugin('ajaxGuidedNavigation',
              'listing-product',
                  $this.attr('name')
          );
          
          
          $this.GuidedNavigationPlugin('ajaxLoadGlobalAverageRating',
              'globalAverageRating',
                  $this.attr('name')
          );
          
      })(jQuery(this));
      if ($('#breadCrumbsFilters')[0]){
        $(('#spotlightFloor')).addClass('hidden');
      }else{
        $(('#spotlightFloor')).addClass('hidden');
      }
  });

  jQuery('body').FilterAndListingPlugin().on('change','.selectSortOption',function() {
      (function($this) {
        var selected = $this.find('option:selected');
        
          $this.FilterAndListingPlugin('ajaxFilterAndListing',$this.val(), selected.data('url'));
          
          $this.GuidedNavigationPlugin('ajaxLoadGlobalAverageRating','globalAverageRating', $this.val());
      })(jQuery(this));
  });
  
  jQuery('body').GuidedNavigationPlugin().on('change','.selectOptionFilter',function() {
     (function($this) {
         var selected = $this.find('option:selected');
         $this.FilterAndListingPlugin('ajaxFilterAndListing', $this.val(), selected.data('url'));
         
         $this.GuidedNavigationPlugin('ajaxLoadGlobalAverageRating','globalAverageRating', $this.val());
     })(jQuery(this));
  });
 
 jQuery('body').GuidedNavigationPlugin().on('click', '.removeFilter', function(event) {
    event.preventDefault();
    (function($this) {
        $this.FilterAndListingPlugin('ajaxFilterAndListing', $this.data('nvalue'), $this.data('url'));
        
       $this.GuidedNavigationPlugin('ajaxLoadGlobalAverageRating','globalAverageRating', $this.data('nvalue'));
   })(jQuery(this));
 });

 jQuery('body').GuidedNavigationPlugin().on('click',  '#cancel-filters', function(event) {
    event.preventDefault();
    (function($this) {
	    var nValueBeforeOpeningFilters = $("#base-url-for-filters").data("original-filter-dimension");
	    var urlBeforeOpeningFilters = $("#base-url-for-filters").data("original-url");
	    
	      if(history.pushState && urlBeforeOpeningFilters){
	    	  history.pushState(null,null, urlBeforeOpeningFilters);
	      }
	    
	    $this.FilterAndListingPlugin('ajaxFilterAndListing', nValueBeforeOpeningFilters, "");
        $this.GuidedNavigationPlugin('ajaxLoadGlobalAverageRating','globalAverageRating', nValueBeforeOpeningFilters);
        $("#base-url-for-filters").data("original-filter-dimension", "");
        $("#base-url-for-filters").data("original-url", "");
    })(jQuery(this));
   
    $("#product-filters").uxProductFiltersMethods('closeFilters');
 });
 
 jQuery('body').GuidedNavigationPlugin().on('click','.checkboxFilter, .categoryFilter',function() {
      (function($this) {
          $this.FilterAndListingPlugin('ajaxFilterAndListing', $this.val(), $this.data('url'));
          
          $this.GuidedNavigationPlugin('ajaxLoadGlobalAverageRating','globalAverageRating', $this.val());
      })(jQuery(this));
  });

 })(window, jQuery);



 ;(function(window, $){

  decathlon.tools = decathlon.tools || {};

  var showHideLoadingGifDate = new Date(),
  refreshtimestamp = 0;
    
  decathlon.tools.showHideLoadingGif = function(showHide) {
    
    var show = function(){
      
      //$('html').addClass('noscroll');

      $('#refresh-loading').css({
          'top': $(window).scrollTop(),
          'width': $(window).width(),
          'height': $(window).height()
        }).removeClass('hidden');
       //$('.m-filters-faceting-footer').hide();
    };

    var hide = function(){
      //$('html').removeClass('noscroll');
      $('#refresh-loading').addClass('hidden');
    };

    if (showHide === 'show') {
      $('.m-filters-faceting-footer').show();
      refreshtimestamp = showHideLoadingGifDate.getTime();
      show();

    } else {
      
      if(showHideLoadingGifDate.getTime() - refreshtimestamp < 1000){
        setTimeout(function(){
          hide();
        },700);
      } else {
        hide();
      }
    }
  };

 })(window, jQuery);
$("#search-autocomplete").keyup(function(event){
    if(event.keyCode == 13){
        $("#search-button").click();
    }
});
   
function redirect(url) {
    var searchFor = document.getElementById('search-autocomplete').value;
    searchFor = searchFor.replace(/%/g,"");
    if (searchFor.length > 0) {
        location.href = url + "?Ntt=" + encodeURIComponent(searchFor);
    }
}

$("#search-autocomplete-mobile").keyup(function(event){
    if(event.keyCode == 13){
        $("#search-button-mobile").click();
    }
});
   
function redirectMobile(url) {
    var searchFor = document.getElementById('search-autocomplete-mobile').value;
    searchFor = searchFor.replace(/%/g,"");
    if (searchFor.length > 0) {
        location.href = url + "?Ntt=" + encodeURIComponent(searchFor);
    }
}
	

////////////////// IS IT USED ANYMORE ??????

/**
 * 
 * ----------- Sports Category Page Plugin -----------
 * Manage Ajax call to load the MC_CategoryMosaic cartridge
 */
(function($) {
	// Plugin constants
	var csts = {
		// Plugin identifier
		NAME : 'CategoryPlugin',
		AJAX_GET_CARTRIDGE_MORE_CONTENT : 'ajaxGetCartridgeMoreContent'
	};

	var methods = {
		// Initialize function, i.e plugin constructor.
		init : function(options) {

			return this.each(function() {
			});
		},

		ajaxGetCartridgeMoreContent : function(cartridgeId, containerId, pageNo, nParameterValue) {
			loadCartridge(
					$(this), 
					'category-mosaic',
					'inner-category-mosaic',
					{'No' : pageNo, 'N' : nParameterValue}, function(){
						$(this).trigger('new-lines-loaded');
					});
		},

		_ajaxGetCartridgeMoreContentSuccess : function($this, result) {
		},

		_ajaxGetCartridgeMoreContentError : function($this, jqXHR, textStatus,
				errorThrown) {
			logError('ajaxGetCartridgeMoreContent error !');
		}
	};

	// Plugin entry point
	$.fn.CategoryPlugin = basePlugin(methods, csts.NAME);
})(jQuery);
//! moment.js
//! version : 2.11.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             if (this.isValid() && other.isValid()) {
                 return other < this ? this : other;
             } else {
                 return valid__createInvalid();
             }
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return +this > +localInput;
        } else {
            return +localInput < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return +this < +localInput;
        } else {
            return +this.clone().endOf(units) < +localInput;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return +this === +localInput;
        } else {
            inputMs = +localInput;
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // JSON.stringify(new Date(NaN)) === 'null'
        return this.isValid() ? this.toISOString() : 'null';
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        // console.log("got", weekYear, week, weekday, "set", date.toISOString());
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = local__createLocal([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = getSet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = getSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto._months           = defaultLocaleMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto._monthsRegex      = defaultMonthsRegex;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.11.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
//! moment.js locale configuration
//! locale : chinese (zh-cn)
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var zh_cn = moment.defineLocale('zh-cn', {
        months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
        monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
        longDateFormat : {
            LT : 'Ah点mm分',
            LTS : 'Ah点m分s秒',
            L : 'YYYY-MM-DD',
            LL : 'YYYY年MMMD日',
            LLL : 'YYYY年MMMD日Ah点mm分',
            LLLL : 'YYYY年MMMD日ddddAh点mm分',
            l : 'YYYY-MM-DD',
            ll : 'YYYY年MMMD日',
            lll : 'YYYY年MMMD日Ah点mm分',
            llll : 'YYYY年MMMD日ddddAh点mm分'
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' ||
                    meridiem === '上午') {
                return hour;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            } else {
                // '中午'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[今天]Ah[点整]' : '[今天]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[明天]Ah[点整]' : '[明天]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[昨天]Ah[点整]' : '[昨天]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[下]' : '[本]';
                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = moment().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[上]' : '[本]';
                return this.minutes() === 0 ? prefix + 'dddAh点整' : prefix + 'dddAh点mm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(日|月|周)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '日';
            case 'M':
                return number + '月';
            case 'w':
            case 'W':
                return number + '周';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s内',
            past : '%s前',
            s : '几秒',
            m : '1 分钟',
            mm : '%d 分钟',
            h : '1 小时',
            hh : '%d 小时',
            d : '1 天',
            dd : '%d 天',
            M : '1 个月',
            MM : '%d 个月',
            y : '1 年',
            yy : '%d 年'
        },
        week : {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return zh_cn;

}));
//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Röling : https://github.com/jjupiter

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';


    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = moment.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact : true,
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        weekdaysParseExact : true,
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : 'één minuut',
            mm : '%d minuten',
            h : 'één uur',
            hh : '%d uur',
            d : 'één dag',
            dd : '%d dagen',
            M : 'één maand',
            MM : '%d maanden',
            y : 'één jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    return nl;

}));
/*! version : 4.17.37
 =========================================================
 bootstrap-datetimejs
 https://github.com/Eonasdan/bootstrap-datetimepicker
 Copyright (c) 2015 Jonathan Peterson
 =========================================================
 */
/*
 The MIT License (MIT)

 Copyright (c) 2015 Jonathan Peterson

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */
/*global define:false */
/*global exports:false */
/*global require:false */
/*global jQuery:false */
/*global moment:false */
(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD is used - Register as an anonymous module.
        define(['jquery', 'moment'], factory);
    } else if (typeof exports === 'object') {
        factory(require('jquery'), require('moment'));
    } else {
        // Neither AMD nor CommonJS used. Use global variables.
        if (typeof jQuery === 'undefined') {
            throw 'bootstrap-datetimepicker requires jQuery to be loaded first';
        }
        if (typeof moment === 'undefined') {
            throw 'bootstrap-datetimepicker requires Moment.js to be loaded first';
        }
        factory(jQuery, moment);
    }
}(function ($, moment) {
    'use strict';
    if (!moment) {
        throw new Error('bootstrap-datetimepicker requires Moment.js to be loaded first');
    }

    var dateTimePicker = function (element, options) {
        var picker = {},
            date,
            viewDate,
            unset = true,
            input,
            component = false,
            widget = false,
            use24Hours,
            minViewModeNumber = 0,
            actualFormat,
            parseFormats,
            currentViewMode,
            datePickerModes = [
                {
                    clsName: 'days',
                    navFnc: 'M',
                    navStep: 1
                },
                {
                    clsName: 'months',
                    navFnc: 'y',
                    navStep: 1
                },
                {
                    clsName: 'years',
                    navFnc: 'y',
                    navStep: 10
                },
                {
                    clsName: 'decades',
                    navFnc: 'y',
                    navStep: 100
                }
            ],
            viewModes = ['days', 'months', 'years', 'decades'],
            verticalModes = ['top', 'bottom', 'auto'],
            horizontalModes = ['left', 'right', 'auto'],
            toolbarPlacements = ['default', 'top', 'bottom'],
            keyMap = {
                'up': 38,
                38: 'up',
                'down': 40,
                40: 'down',
                'left': 37,
                37: 'left',
                'right': 39,
                39: 'right',
                'tab': 9,
                9: 'tab',
                'escape': 27,
                27: 'escape',
                'enter': 13,
                13: 'enter',
                'pageUp': 33,
                33: 'pageUp',
                'pageDown': 34,
                34: 'pageDown',
                'shift': 16,
                16: 'shift',
                'control': 17,
                17: 'control',
                'space': 32,
                32: 'space',
                't': 84,
                84: 't',
                'delete': 46,
                46: 'delete'
            },
            keyState = {},

            /********************************************************************************
             *
             * Private functions
             *
             ********************************************************************************/
            getMoment = function (d) {
                var tzEnabled = false,
                    returnMoment,
                    currentZoneOffset,
                    incomingZoneOffset,
                    timeZoneIndicator,
                    dateWithTimeZoneInfo;

                if (moment.tz !== undefined && options.timeZone !== undefined && options.timeZone !== null && options.timeZone !== '') {
                    tzEnabled = true;
                }
                if (d === undefined || d === null) {
                    if (tzEnabled) {
                        returnMoment = moment().tz(options.timeZone).startOf('d');
                    } else {
                        returnMoment = moment().startOf('d');
                    }
                } else {
                    if (tzEnabled) {
                        currentZoneOffset = moment().tz(options.timeZone).utcOffset();
                        incomingZoneOffset = moment(d, parseFormats, options.useStrict).utcOffset();
                        if (incomingZoneOffset !== currentZoneOffset) {
                            timeZoneIndicator = moment().tz(options.timeZone).format('Z');
                            dateWithTimeZoneInfo = moment(d, parseFormats, options.useStrict).format('YYYY-MM-DD[T]HH:mm:ss') + timeZoneIndicator;
                            returnMoment = moment(dateWithTimeZoneInfo, parseFormats, options.useStrict).tz(options.timeZone);
                        } else {
                            returnMoment = moment(d, parseFormats, options.useStrict).tz(options.timeZone);
                        }
                    } else {
                        returnMoment = moment(d, parseFormats, options.useStrict);
                    }
                }
                return returnMoment;
            },
            isEnabled = function (granularity) {
                if (typeof granularity !== 'string' || granularity.length > 1) {
                    throw new TypeError('isEnabled expects a single character string parameter');
                }
                switch (granularity) {
                    case 'y':
                        return actualFormat.indexOf('Y') !== -1;
                    case 'M':
                        return actualFormat.indexOf('M') !== -1;
                    case 'd':
                        return actualFormat.toLowerCase().indexOf('d') !== -1;
                    case 'h':
                    case 'H':
                        return actualFormat.toLowerCase().indexOf('h') !== -1;
                    case 'm':
                        return actualFormat.indexOf('m') !== -1;
                    case 's':
                        return actualFormat.indexOf('s') !== -1;
                    default:
                        return false;
                }
            },
            hasTime = function () {
                return (isEnabled('h') || isEnabled('m') || isEnabled('s'));
            },

            hasDate = function () {
                return (isEnabled('y') || isEnabled('M') || isEnabled('d'));
            },

            getDatePickerTemplate = function () {
                var headTemplate = $('<thead>')
                        .append($('<tr>')
                            .append($('<th>').addClass('prev').attr('data-action', 'previous')
                                .append($('<span>').addClass(options.icons.previous))
                                )
                            .append($('<th>').addClass('picker-switch').attr('data-action', 'pickerSwitch').attr('colspan', (options.calendarWeeks ? '6' : '5')))
                            .append($('<th>').addClass('next').attr('data-action', 'next')
                                .append($('<span>').addClass(options.icons.next))
                                )
                            ),
                    contTemplate = $('<tbody>')
                        .append($('<tr>')
                            .append($('<td>').attr('colspan', (options.calendarWeeks ? '8' : '7')))
                            );

                return [
                    $('<div>').addClass('datepicker-days')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate)
                            .append($('<tbody>'))
                            ),
                    $('<div>').addClass('datepicker-months')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate.clone())
                            .append(contTemplate.clone())
                            ),
                    $('<div>').addClass('datepicker-years')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate.clone())
                            .append(contTemplate.clone())
                            ),
                    $('<div>').addClass('datepicker-decades')
                        .append($('<table>').addClass('table-condensed')
                            .append(headTemplate.clone())
                            .append(contTemplate.clone())
                            )
                ];
            },

            getTimePickerMainTemplate = function () {
                var topRow = $('<tr>'),
                    middleRow = $('<tr>'),
                    bottomRow = $('<tr>');

                if (isEnabled('h')) {
                    topRow.append($('<td>')
                        .append($('<a>').attr({href: '#', tabindex: '-1', 'title': options.tooltips.incrementHour}).addClass('btn').attr('data-action', 'incrementHours')
                            .append($('<span>').addClass(options.icons.up))));
                    middleRow.append($('<td>')
                        .append($('<span>').addClass('timepicker-hour').attr({'data-time-component':'hours', 'title': options.tooltips.pickHour}).attr('data-action', 'showHours')));
                    bottomRow.append($('<td>')
                        .append($('<a>').attr({href: '#', tabindex: '-1', 'title': options.tooltips.decrementHour}).addClass('btn').attr('data-action', 'decrementHours')
                            .append($('<span>').addClass(options.icons.down))));
                }
                if (isEnabled('m')) {
                    if (isEnabled('h')) {
                        topRow.append($('<td>').addClass('separator'));
                        middleRow.append($('<td>').addClass('separator').html(':'));
                        bottomRow.append($('<td>').addClass('separator'));
                    }
                    topRow.append($('<td>')
                        .append($('<a>').attr({href: '#', tabindex: '-1', 'title': options.tooltips.incrementMinute}).addClass('btn').attr('data-action', 'incrementMinutes')
                            .append($('<span>').addClass(options.icons.up))));
                    middleRow.append($('<td>')
                        .append($('<span>').addClass('timepicker-minute').attr({'data-time-component': 'minutes', 'title': options.tooltips.pickMinute}).attr('data-action', 'showMinutes')));
                    bottomRow.append($('<td>')
                        .append($('<a>').attr({href: '#', tabindex: '-1', 'title': options.tooltips.decrementMinute}).addClass('btn').attr('data-action', 'decrementMinutes')
                            .append($('<span>').addClass(options.icons.down))));
                }
                if (isEnabled('s')) {
                    if (isEnabled('m')) {
                        topRow.append($('<td>').addClass('separator'));
                        middleRow.append($('<td>').addClass('separator').html(':'));
                        bottomRow.append($('<td>').addClass('separator'));
                    }
                    topRow.append($('<td>')
                        .append($('<a>').attr({href: '#', tabindex: '-1', 'title': options.tooltips.incrementSecond}).addClass('btn').attr('data-action', 'incrementSeconds')
                            .append($('<span>').addClass(options.icons.up))));
                    middleRow.append($('<td>')
                        .append($('<span>').addClass('timepicker-second').attr({'data-time-component': 'seconds', 'title': options.tooltips.pickSecond}).attr('data-action', 'showSeconds')));
                    bottomRow.append($('<td>')
                        .append($('<a>').attr({href: '#', tabindex: '-1', 'title': options.tooltips.decrementSecond}).addClass('btn').attr('data-action', 'decrementSeconds')
                            .append($('<span>').addClass(options.icons.down))));
                }

                if (!use24Hours) {
                    topRow.append($('<td>').addClass('separator'));
                    middleRow.append($('<td>')
                        .append($('<button>').addClass('btn btn-primary').attr({'data-action': 'togglePeriod', tabindex: '-1', 'title': options.tooltips.togglePeriod})));
                    bottomRow.append($('<td>').addClass('separator'));
                }

                return $('<div>').addClass('timepicker-picker')
                    .append($('<table>').addClass('table-condensed')
                        .append([topRow, middleRow, bottomRow]));
            },

            getTimePickerTemplate = function () {
                var hoursView = $('<div>').addClass('timepicker-hours')
                        .append($('<table>').addClass('table-condensed')),
                    minutesView = $('<div>').addClass('timepicker-minutes')
                        .append($('<table>').addClass('table-condensed')),
                    secondsView = $('<div>').addClass('timepicker-seconds')
                        .append($('<table>').addClass('table-condensed')),
                    ret = [getTimePickerMainTemplate()];

                if (isEnabled('h')) {
                    ret.push(hoursView);
                }
                if (isEnabled('m')) {
                    ret.push(minutesView);
                }
                if (isEnabled('s')) {
                    ret.push(secondsView);
                }

                return ret;
            },

            getToolbar = function () {
                var row = [];
                if (options.showTodayButton) {
                    row.push($('<td>').append($('<a>').attr({'data-action':'today', 'title': options.tooltips.today}).append($('<span>').addClass(options.icons.today))));
                }
                if (!options.sideBySide && hasDate() && hasTime()) {
                    row.push($('<td>').append($('<a>').attr({'data-action':'togglePicker', 'title': options.tooltips.selectTime}).append($('<span>').addClass(options.icons.time))));
                }
                if (options.showClear) {
                    row.push($('<td>').append($('<a>').attr({'data-action':'clear', 'title': options.tooltips.clear}).append($('<span>').addClass(options.icons.clear))));
                }
                if (options.showClose) {
                    row.push($('<td>').append($('<a>').attr({'data-action':'close', 'title': options.tooltips.close}).append($('<span>').addClass(options.icons.close))));
                }
                return $('<table>').addClass('table-condensed').append($('<tbody>').append($('<tr>').append(row)));
            },

            getTemplate = function () {
                var template = $('<div>').addClass('bootstrap-datetimepicker-widget dropdown-menu'),
                    dateView = $('<div>').addClass('datepicker').append(getDatePickerTemplate()),
                    timeView = $('<div>').addClass('timepicker').append(getTimePickerTemplate()),
                    content = $('<ul>').addClass('list-unstyled'),
                    toolbar = $('<li>').addClass('picker-switch' + (options.collapse ? ' accordion-toggle' : '')).append(getToolbar());

                if (options.inline) {
                    template.removeClass('dropdown-menu');
                }

                if (use24Hours) {
                    template.addClass('usetwentyfour');
                }
                if (isEnabled('s') && !use24Hours) {
                    template.addClass('wider');
                }

                if (options.sideBySide && hasDate() && hasTime()) {
                    template.addClass('timepicker-sbs');
                    if (options.toolbarPlacement === 'top') {
                        template.append(toolbar);
                    }
                    template.append(
                        $('<div>').addClass('row')
                            .append(dateView.addClass('col-md-6'))
                            .append(timeView.addClass('col-md-6'))
                    );
                    if (options.toolbarPlacement === 'bottom') {
                        template.append(toolbar);
                    }
                    return template;
                }

                if (options.toolbarPlacement === 'top') {
                    content.append(toolbar);
                }
                if (hasDate()) {
                    content.append($('<li>').addClass((options.collapse && hasTime() ? 'collapse in' : '')).append(dateView));
                }
                if (options.toolbarPlacement === 'default') {
                    content.append(toolbar);
                }
                if (hasTime()) {
                    content.append($('<li>').addClass((options.collapse && hasDate() ? 'collapse' : '')).append(timeView));
                }
                if (options.toolbarPlacement === 'bottom') {
                    content.append(toolbar);
                }
                return template.append(content);
            },

            dataToOptions = function () {
                var eData,
                    dataOptions = {};

                if (element.is('input') || options.inline) {
                    eData = element.data();
                } else {
                    eData = element.find('input').data();
                }

                if (eData.dateOptions && eData.dateOptions instanceof Object) {
                    dataOptions = $.extend(true, dataOptions, eData.dateOptions);
                }

                $.each(options, function (key) {
                    var attributeName = 'date' + key.charAt(0).toUpperCase() + key.slice(1);
                    if (eData[attributeName] !== undefined) {
                        dataOptions[key] = eData[attributeName];
                    }
                });
                return dataOptions;
            },

            place = function () {
                var position = (component || element).position(),
                    offset = (component || element).offset(),
                    vertical = options.widgetPositioning.vertical,
                    horizontal = options.widgetPositioning.horizontal,
                    parent;

                if (options.widgetParent) {
                    parent = options.widgetParent.append(widget);
                } else if (element.is('input')) {
                    parent = element.after(widget).parent();
                } else if (options.inline) {
                    parent = element.append(widget);
                    return;
                } else {
                    parent = element;
                    element.children().first().after(widget);
                }

                // Top and bottom logic
                if (vertical === 'auto') {
                    if (offset.top + widget.height() * 1.5 >= $(window).height() + $(window).scrollTop() &&
                        widget.height() + element.outerHeight() < offset.top) {
                        vertical = 'top';
                    } else {
                        vertical = 'bottom';
                    }
                }

                // Left and right logic
                if (horizontal === 'auto') {
                    if (parent.width() < offset.left + widget.outerWidth() / 2 &&
                        offset.left + widget.outerWidth() > $(window).width()) {
                        horizontal = 'right';
                    } else {
                        horizontal = 'left';
                    }
                }

                if (vertical === 'top') {
                    widget.addClass('top').removeClass('bottom');
                } else {
                    widget.addClass('bottom').removeClass('top');
                }

                if (horizontal === 'right') {
                    widget.addClass('pull-right');
                } else {
                    widget.removeClass('pull-right');
                }

                // find the first parent element that has a relative css positioning
                if (parent.css('position') !== 'relative') {
                    parent = parent.parents().filter(function () {
                        return $(this).css('position') === 'relative';
                    }).first();
                }

                if (parent.length === 0) {
                    throw new Error('datetimepicker component should be placed within a relative positioned container');
                }

                widget.css({
                    top: vertical === 'top' ? 'auto' : position.top + element.outerHeight(),
                    bottom: vertical === 'top' ? position.top + element.outerHeight() : 'auto',
                    left: horizontal === 'left' ? (parent === element ? 0 : position.left) : 'auto',
                    right: horizontal === 'left' ? 'auto' : parent.outerWidth() - element.outerWidth() - (parent === element ? 0 : position.left)
                });
            },

            notifyEvent = function (e) {
                if (e.type === 'dp.change' && ((e.date && e.date.isSame(e.oldDate)) || (!e.date && !e.oldDate))) {
                    return;
                }
                element.trigger(e);
            },

            viewUpdate = function (e) {
                if (e === 'y') {
                    e = 'YYYY';
                }
                notifyEvent({
                    type: 'dp.update',
                    change: e,
                    viewDate: viewDate.clone()
                });
            },

            showMode = function (dir) {
                if (!widget) {
                    return;
                }
                if (dir) {
                    currentViewMode = Math.max(minViewModeNumber, Math.min(3, currentViewMode + dir));
                }
                widget.find('.datepicker > div').hide().filter('.datepicker-' + datePickerModes[currentViewMode].clsName).show();
            },

            fillDow = function () {
                var row = $('<tr>'),
                    currentDate = viewDate.clone().startOf('w').startOf('d');

                if (options.calendarWeeks === true) {
                    row.append($('<th>').addClass('cw').text('#'));
                }

                while (currentDate.isBefore(viewDate.clone().endOf('w'))) {
                    row.append($('<th>').addClass('dow').text(currentDate.format('dd')));
                    currentDate.add(1, 'd');
                }
                widget.find('.datepicker-days thead').append(row);
            },

            isInDisabledDates = function (testDate) {
                return options.disabledDates[testDate.format('YYYY-MM-DD')] === true;
            },

            isInEnabledDates = function (testDate) {
                return options.enabledDates[testDate.format('YYYY-MM-DD')] === true;
            },

            isInDisabledHours = function (testDate) {
                return options.disabledHours[testDate.format('H')] === true;
            },

            isInEnabledHours = function (testDate) {
                return options.enabledHours[testDate.format('H')] === true;
            },

            isValid = function (targetMoment, granularity) {
                if (!targetMoment.isValid()) {
                    return false;
                }
                if (options.disabledDates && granularity === 'd' && isInDisabledDates(targetMoment)) {
                    return false;
                }
                if (options.enabledDates && granularity === 'd' && !isInEnabledDates(targetMoment)) {
                    return false;
                }
                if (options.minDate && targetMoment.isBefore(options.minDate, granularity)) {
                    return false;
                }
                if (options.maxDate && targetMoment.isAfter(options.maxDate, granularity)) {
                    return false;
                }
                if (options.daysOfWeekDisabled && granularity === 'd' && options.daysOfWeekDisabled.indexOf(targetMoment.day()) !== -1) {
                    return false;
                }
                if (options.disabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && isInDisabledHours(targetMoment)) {
                    return false;
                }
                if (options.enabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && !isInEnabledHours(targetMoment)) {
                    return false;
                }
                if (options.disabledTimeIntervals && (granularity === 'h' || granularity === 'm' || granularity === 's')) {
                    var found = false;
                    $.each(options.disabledTimeIntervals, function () {
                        if (targetMoment.isBetween(this[0], this[1])) {
                            found = true;
                            return false;
                        }
                    });
                    if (found) {
                        return false;
                    }
                }
                return true;
            },

            fillMonths = function () {
                var spans = [],
                    monthsShort = viewDate.clone().startOf('y').startOf('d');
                while (monthsShort.isSame(viewDate, 'y')) {
                    spans.push($('<span>').attr('data-action', 'selectMonth').addClass('month').text(monthsShort.format('MMM')));
                    monthsShort.add(1, 'M');
                }
                widget.find('.datepicker-months td').empty().append(spans);
            },

            updateMonths = function () {
                var monthsView = widget.find('.datepicker-months'),
                    monthsViewHeader = monthsView.find('th'),
                    months = monthsView.find('tbody').find('span');

                monthsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevYear);
                monthsViewHeader.eq(1).attr('title', options.tooltips.selectYear);
                monthsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextYear);

                monthsView.find('.disabled').removeClass('disabled');

                if (!isValid(viewDate.clone().subtract(1, 'y'), 'y')) {
                    monthsViewHeader.eq(0).addClass('disabled');
                }

                monthsViewHeader.eq(1).text(viewDate.year());

                if (!isValid(viewDate.clone().add(1, 'y'), 'y')) {
                    monthsViewHeader.eq(2).addClass('disabled');
                }

                months.removeClass('active');
                if (date.isSame(viewDate, 'y') && !unset) {
                    months.eq(date.month()).addClass('active');
                }

                months.each(function (index) {
                    if (!isValid(viewDate.clone().month(index), 'M')) {
                        $(this).addClass('disabled');
                    }
                });
            },

            updateYears = function () {
                var yearsView = widget.find('.datepicker-years'),
                    yearsViewHeader = yearsView.find('th'),
                    startYear = viewDate.clone().subtract(5, 'y'),
                    endYear = viewDate.clone().add(6, 'y'),
                    html = '';

                yearsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevDecade);
                yearsViewHeader.eq(1).attr('title', options.tooltips.selectDecade);
                yearsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextDecade);

                yearsView.find('.disabled').removeClass('disabled');

                if (options.minDate && options.minDate.isAfter(startYear, 'y')) {
                    yearsViewHeader.eq(0).addClass('disabled');
                }

                yearsViewHeader.eq(1).text(startYear.year() + '-' + endYear.year());

                if (options.maxDate && options.maxDate.isBefore(endYear, 'y')) {
                    yearsViewHeader.eq(2).addClass('disabled');
                }

                while (!startYear.isAfter(endYear, 'y')) {
                    html += '<span data-action="selectYear" class="year' + (startYear.isSame(date, 'y') && !unset ? ' active' : '') + (!isValid(startYear, 'y') ? ' disabled' : '') + '">' + startYear.year() + '</span>';
                    startYear.add(1, 'y');
                }

                yearsView.find('td').html(html);
            },

            updateDecades = function () {
                var decadesView = widget.find('.datepicker-decades'),
                    decadesViewHeader = decadesView.find('th'),
                    startDecade = moment({y: viewDate.year() - (viewDate.year() % 100) - 1}),
                    endDecade = startDecade.clone().add(100, 'y'),
                    startedAt = startDecade.clone(),
                    html = '';

                decadesViewHeader.eq(0).find('span').attr('title', options.tooltips.prevCentury);
                decadesViewHeader.eq(2).find('span').attr('title', options.tooltips.nextCentury);

                decadesView.find('.disabled').removeClass('disabled');

                if (startDecade.isSame(moment({y: 1900})) || (options.minDate && options.minDate.isAfter(startDecade, 'y'))) {
                    decadesViewHeader.eq(0).addClass('disabled');
                }

                decadesViewHeader.eq(1).text(startDecade.year() + '-' + endDecade.year());

                if (startDecade.isSame(moment({y: 2000})) || (options.maxDate && options.maxDate.isBefore(endDecade, 'y'))) {
                    decadesViewHeader.eq(2).addClass('disabled');
                }

                while (!startDecade.isAfter(endDecade, 'y')) {
                    html += '<span data-action="selectDecade" class="decade' + (startDecade.isSame(date, 'y') ? ' active' : '') +
                        (!isValid(startDecade, 'y') ? ' disabled' : '') + '" data-selection="' + (startDecade.year() + 6) + '">' + (startDecade.year() + 1) + ' - ' + (startDecade.year() + 12) + '</span>';
                    startDecade.add(12, 'y');
                }
                html += '<span></span><span></span><span></span>'; //push the dangling block over, at least this way it's even

                decadesView.find('td').html(html);
                decadesViewHeader.eq(1).text((startedAt.year() + 1) + '-' + (startDecade.year()));
            },

            fillDate = function () {
                var daysView = widget.find('.datepicker-days'),
                    daysViewHeader = daysView.find('th'),
                    currentDate,
                    html = [],
                    row,
                    clsName,
                    i;

                if (!hasDate()) {
                    return;
                }

                daysViewHeader.eq(0).find('span').attr('title', options.tooltips.prevMonth);
                daysViewHeader.eq(1).attr('title', options.tooltips.selectMonth);
                daysViewHeader.eq(2).find('span').attr('title', options.tooltips.nextMonth);

                daysView.find('.disabled').removeClass('disabled');
                daysViewHeader.eq(1).text(viewDate.format(options.dayViewHeaderFormat));

                if (!isValid(viewDate.clone().subtract(1, 'M'), 'M')) {
                    daysViewHeader.eq(0).addClass('disabled');
                }
                if (!isValid(viewDate.clone().add(1, 'M'), 'M')) {
                    daysViewHeader.eq(2).addClass('disabled');
                }

                currentDate = viewDate.clone().startOf('M').startOf('w').startOf('d');

                for (i = 0; i < 42; i++) { //always display 42 days (should show 6 weeks)
                    if (currentDate.weekday() === 0) {
                        row = $('<tr>');
                        if (options.calendarWeeks) {
                            row.append('<td class="cw">' + currentDate.week() + '</td>');
                        }
                        html.push(row);
                    }
                    clsName = '';
                    if (currentDate.isBefore(viewDate, 'M')) {
                        clsName += ' old';
                    }
                    if (currentDate.isAfter(viewDate, 'M')) {
                        clsName += ' new';
                    }
                    if (currentDate.isSame(date, 'd') && !unset) {
                        clsName += ' active';
                    }
                    if (!isValid(currentDate, 'd')) {
                        clsName += ' disabled';
                    }
                    if (currentDate.isSame(getMoment(), 'd')) {
                        clsName += ' today';
                    }
                    if (currentDate.day() === 0 || currentDate.day() === 6) {
                        clsName += ' weekend';
                    }
                    row.append('<td data-action="selectDay" data-day="' + currentDate.format('L') + '" class="day' + clsName + '">' + currentDate.date() + '</td>');
                    currentDate.add(1, 'd');
                }

                daysView.find('tbody').empty().append(html);

                updateMonths();

                updateYears();

                updateDecades();
            },

            fillHours = function () {
                var table = widget.find('.timepicker-hours table'),
                    currentHour = viewDate.clone().startOf('d'),
                    html = [],
                    row = $('<tr>');

                if (viewDate.hour() > 11 && !use24Hours) {
                    currentHour.hour(12);
                }
                while (currentHour.isSame(viewDate, 'd') && (use24Hours || (viewDate.hour() < 12 && currentHour.hour() < 12) || viewDate.hour() > 11)) {
                    if (currentHour.hour() % 4 === 0) {
                        row = $('<tr>');
                        html.push(row);
                    }
                    row.append('<td data-action="selectHour" class="hour' + (!isValid(currentHour, 'h') ? ' disabled' : '') + '">' + currentHour.format(use24Hours ? 'HH' : 'hh') + '</td>');
                    currentHour.add(1, 'h');
                }
                table.empty().append(html);
            },

            fillMinutes = function () {
                var table = widget.find('.timepicker-minutes table'),
                    currentMinute = viewDate.clone().startOf('h'),
                    html = [],
                    row = $('<tr>'),
                    step = options.stepping === 1 ? 5 : options.stepping;

                while (viewDate.isSame(currentMinute, 'h')) {
                    if (currentMinute.minute() % (step * 4) === 0) {
                        row = $('<tr>');
                        html.push(row);
                    }
                    row.append('<td data-action="selectMinute" class="minute' + (!isValid(currentMinute, 'm') ? ' disabled' : '') + '">' + currentMinute.format('mm') + '</td>');
                    currentMinute.add(step, 'm');
                }
                table.empty().append(html);
            },

            fillSeconds = function () {
                var table = widget.find('.timepicker-seconds table'),
                    currentSecond = viewDate.clone().startOf('m'),
                    html = [],
                    row = $('<tr>');

                while (viewDate.isSame(currentSecond, 'm')) {
                    if (currentSecond.second() % 20 === 0) {
                        row = $('<tr>');
                        html.push(row);
                    }
                    row.append('<td data-action="selectSecond" class="second' + (!isValid(currentSecond, 's') ? ' disabled' : '') + '">' + currentSecond.format('ss') + '</td>');
                    currentSecond.add(5, 's');
                }

                table.empty().append(html);
            },

            fillTime = function () {
                var toggle, newDate, timeComponents = widget.find('.timepicker span[data-time-component]');

                if (!use24Hours) {
                    toggle = widget.find('.timepicker [data-action=togglePeriod]');
                    newDate = date.clone().add((date.hours() >= 12) ? -12 : 12, 'h');

                    toggle.text(date.format('A'));

                    if (isValid(newDate, 'h')) {
                        toggle.removeClass('disabled');
                    } else {
                        toggle.addClass('disabled');
                    }
                }
                timeComponents.filter('[data-time-component=hours]').text(date.format(use24Hours ? 'HH' : 'hh'));
                timeComponents.filter('[data-time-component=minutes]').text(date.format('mm'));
                timeComponents.filter('[data-time-component=seconds]').text(date.format('ss'));

                fillHours();
                fillMinutes();
                fillSeconds();
            },

            update = function () {
                if (!widget) {
                    return;
                }
                fillDate();
                fillTime();
            },

            setValue = function (targetMoment) {
                var oldDate = unset ? null : date;

                // case of calling setValue(null or false)
                if (!targetMoment) {
                    unset = true;
                    input.val('');
                    element.data('date', '');
                    notifyEvent({
                        type: 'dp.change',
                        date: false,
                        oldDate: oldDate
                    });
                    update();
                    return;
                }

                targetMoment = targetMoment.clone().locale(options.locale);

                if (options.stepping !== 1) {
                    targetMoment.minutes((Math.round(targetMoment.minutes() / options.stepping) * options.stepping) % 60).seconds(0);
                }

                if (isValid(targetMoment)) {
                    date = targetMoment;
                    viewDate = date.clone();
                    input.val(date.format(actualFormat));
                    element.data('date', date.format(actualFormat));
                    unset = false;
                    update();
                    notifyEvent({
                        type: 'dp.change',
                        date: date.clone(),
                        oldDate: oldDate
                    });
                } else {
                    if (!options.keepInvalid) {
                        input.val(unset ? '' : date.format(actualFormat));
                    }
                    notifyEvent({
                        type: 'dp.error',
                        date: targetMoment
                    });
                }
            },

            hide = function () {
                ///<summary>Hides the widget. Possibly will emit dp.hide</summary>
                var transitioning = false;
                if (!widget) {
                    return picker;
                }
                // Ignore event if in the middle of a picker transition
                widget.find('.collapse').each(function () {
                    var collapseData = $(this).data('collapse');
                    if (collapseData && collapseData.transitioning) {
                        transitioning = true;
                        return false;
                    }
                    return true;
                });
                if (transitioning) {
                    return picker;
                }
                if (component && component.hasClass('btn')) {
                    component.toggleClass('active');
                }
                widget.hide();

                $(window).off('resize', place);
                widget.off('click', '[data-action]');
                widget.off('mousedown', false);

                widget.remove();
                widget = false;

                notifyEvent({
                    type: 'dp.hide',
                    date: date.clone()
                });

                input.blur();

                return picker;
            },

            clear = function () {
                setValue(null);
            },

            /********************************************************************************
             *
             * Widget UI interaction functions
             *
             ********************************************************************************/
            actions = {
                next: function () {
                    var navFnc = datePickerModes[currentViewMode].navFnc;
                    viewDate.add(datePickerModes[currentViewMode].navStep, navFnc);
                    fillDate();
                    viewUpdate(navFnc);
                },

                previous: function () {
                    var navFnc = datePickerModes[currentViewMode].navFnc;
                    viewDate.subtract(datePickerModes[currentViewMode].navStep, navFnc);
                    fillDate();
                    viewUpdate(navFnc);
                },

                pickerSwitch: function () {
                    showMode(1);
                },

                selectMonth: function (e) {
                    var month = $(e.target).closest('tbody').find('span').index($(e.target));
                    viewDate.month(month);
                    if (currentViewMode === minViewModeNumber) {
                        setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
                        if (!options.inline) {
                            hide();
                        }
                    } else {
                        showMode(-1);
                        fillDate();
                    }
                    viewUpdate('M');
                },

                selectYear: function (e) {
                    var year = parseInt($(e.target).text(), 10) || 0;
                    viewDate.year(year);
                    if (currentViewMode === minViewModeNumber) {
                        setValue(date.clone().year(viewDate.year()));
                        if (!options.inline) {
                            hide();
                        }
                    } else {
                        showMode(-1);
                        fillDate();
                    }
                    viewUpdate('YYYY');
                },

                selectDecade: function (e) {
                    var year = parseInt($(e.target).data('selection'), 10) || 0;
                    viewDate.year(year);
                    if (currentViewMode === minViewModeNumber) {
                        setValue(date.clone().year(viewDate.year()));
                        if (!options.inline) {
                            hide();
                        }
                    } else {
                        showMode(-1);
                        fillDate();
                    }
                    viewUpdate('YYYY');
                },

                selectDay: function (e) {
                    var day = viewDate.clone();
                    if ($(e.target).is('.old')) {
                        day.subtract(1, 'M');
                    }
                    if ($(e.target).is('.new')) {
                        day.add(1, 'M');
                    }
                    setValue(day.date(parseInt($(e.target).text(), 10)));
                    if (!hasTime() && !options.keepOpen && !options.inline) {
                        hide();
                    }
                },

                incrementHours: function () {
                    var newDate = date.clone().add(1, 'h');
                    if (isValid(newDate, 'h')) {
                        setValue(newDate);
                    }
                },

                incrementMinutes: function () {
                    var newDate = date.clone().add(options.stepping, 'm');
                    if (isValid(newDate, 'm')) {
                        setValue(newDate);
                    }
                },

                incrementSeconds: function () {
                    var newDate = date.clone().add(1, 's');
                    if (isValid(newDate, 's')) {
                        setValue(newDate);
                    }
                },

                decrementHours: function () {
                    var newDate = date.clone().subtract(1, 'h');
                    if (isValid(newDate, 'h')) {
                        setValue(newDate);
                    }
                },

                decrementMinutes: function () {
                    var newDate = date.clone().subtract(options.stepping, 'm');
                    if (isValid(newDate, 'm')) {
                        setValue(newDate);
                    }
                },

                decrementSeconds: function () {
                    var newDate = date.clone().subtract(1, 's');
                    if (isValid(newDate, 's')) {
                        setValue(newDate);
                    }
                },

                togglePeriod: function () {
                    setValue(date.clone().add((date.hours() >= 12) ? -12 : 12, 'h'));
                },

                togglePicker: function (e) {
                    var $this = $(e.target),
                        $parent = $this.closest('ul'),
                        expanded = $parent.find('.in'),
                        closed = $parent.find('.collapse:not(.in)'),
                        collapseData;

                    if (expanded && expanded.length) {
                        collapseData = expanded.data('collapse');
                        if (collapseData && collapseData.transitioning) {
                            return;
                        }
                        if (expanded.collapse) { // if collapse plugin is available through bootstrap.js then use it
                            expanded.collapse('hide');
                            closed.collapse('show');
                        } else { // otherwise just toggle in class on the two views
                            expanded.removeClass('in');
                            closed.addClass('in');
                        }
                        if ($this.is('span')) {
                            $this.toggleClass(options.icons.time + ' ' + options.icons.date);
                        } else {
                            $this.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
                        }

                        // NOTE: uncomment if toggled state will be restored in show()
                        //if (component) {
                        //    component.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
                        //}
                    }
                },

                showPicker: function () {
                    widget.find('.timepicker > div:not(.timepicker-picker)').hide();
                    widget.find('.timepicker .timepicker-picker').show();
                },

                showHours: function () {
                    widget.find('.timepicker .timepicker-picker').hide();
                    widget.find('.timepicker .timepicker-hours').show();
                },

                showMinutes: function () {
                    widget.find('.timepicker .timepicker-picker').hide();
                    widget.find('.timepicker .timepicker-minutes').show();
                },

                showSeconds: function () {
                    widget.find('.timepicker .timepicker-picker').hide();
                    widget.find('.timepicker .timepicker-seconds').show();
                },

                selectHour: function (e) {
                    var hour = parseInt($(e.target).text(), 10);

                    if (!use24Hours) {
                        if (date.hours() >= 12) {
                            if (hour !== 12) {
                                hour += 12;
                            }
                        } else {
                            if (hour === 12) {
                                hour = 0;
                            }
                        }
                    }
                    setValue(date.clone().hours(hour));
                    actions.showPicker.call(picker);
                },

                selectMinute: function (e) {
                    setValue(date.clone().minutes(parseInt($(e.target).text(), 10)));
                    actions.showPicker.call(picker);
                },

                selectSecond: function (e) {
                    setValue(date.clone().seconds(parseInt($(e.target).text(), 10)));
                    actions.showPicker.call(picker);
                },

                clear: clear,

                today: function () {
                    var todaysDate = getMoment();
                    if (isValid(todaysDate, 'd')) {
                        setValue(todaysDate);
                    }
                },

                close: hide
            },

            doAction = function (e) {
                if ($(e.currentTarget).is('.disabled')) {
                    return false;
                }
                actions[$(e.currentTarget).data('action')].apply(picker, arguments);
                return false;
            },

            show = function () {
                ///<summary>Shows the widget. Possibly will emit dp.show and dp.change</summary>
                var currentMoment,
                    useCurrentGranularity = {
                        'year': function (m) {
                            return m.month(0).date(1).hours(0).seconds(0).minutes(0);
                        },
                        'month': function (m) {
                            return m.date(1).hours(0).seconds(0).minutes(0);
                        },
                        'day': function (m) {
                            return m.hours(0).seconds(0).minutes(0);
                        },
                        'hour': function (m) {
                            return m.seconds(0).minutes(0);
                        },
                        'minute': function (m) {
                            return m.seconds(0);
                        }
                    };

                if (input.prop('disabled') || (!options.ignoreReadonly && input.prop('readonly')) || widget) {
                    return picker;
                }
                if (input.val() !== undefined && input.val().trim().length !== 0) {
                    setValue(parseInputDate(input.val().trim()));
                } else if (options.useCurrent && unset && ((input.is('input') && input.val().trim().length === 0) || options.inline)) {
                    currentMoment = getMoment();
                    if (typeof options.useCurrent === 'string') {
                        currentMoment = useCurrentGranularity[options.useCurrent](currentMoment);
                    }
                    setValue(currentMoment);
                }

                widget = getTemplate();

                fillDow();
                fillMonths();

                widget.find('.timepicker-hours').hide();
                widget.find('.timepicker-minutes').hide();
                widget.find('.timepicker-seconds').hide();

                update();
                showMode();

                $(window).on('resize', place);
                widget.on('click', '[data-action]', doAction); // this handles clicks on the widget
                widget.on('mousedown', false);

                if (component && component.hasClass('btn')) {
                    component.toggleClass('active');
                }
                widget.show();
                place();

                if (options.focusOnShow && !input.is(':focus')) {
                    input.focus();
                }

                notifyEvent({
                    type: 'dp.show'
                });
                return picker;
            },

            toggle = function () {
                /// <summary>Shows or hides the widget</summary>
                return (widget ? hide() : show());
            },

            parseInputDate = function (inputDate) {
                if (options.parseInputDate === undefined) {
                    if (moment.isMoment(inputDate) || inputDate instanceof Date) {
                        inputDate = moment(inputDate);
                    } else {
                        inputDate = getMoment(inputDate);
                    }
                } else {
                    inputDate = options.parseInputDate(inputDate);
                }
                inputDate.locale(options.locale);
                return inputDate;
            },

            keydown = function (e) {
                var handler = null,
                    index,
                    index2,
                    pressedKeys = [],
                    pressedModifiers = {},
                    currentKey = e.which,
                    keyBindKeys,
                    allModifiersPressed,
                    pressed = 'p';

                keyState[currentKey] = pressed;

                for (index in keyState) {
                    if (keyState.hasOwnProperty(index) && keyState[index] === pressed) {
                        pressedKeys.push(index);
                        if (parseInt(index, 10) !== currentKey) {
                            pressedModifiers[index] = true;
                        }
                    }
                }

                for (index in options.keyBinds) {
                    if (options.keyBinds.hasOwnProperty(index) && typeof (options.keyBinds[index]) === 'function') {
                        keyBindKeys = index.split(' ');
                        if (keyBindKeys.length === pressedKeys.length && keyMap[currentKey] === keyBindKeys[keyBindKeys.length - 1]) {
                            allModifiersPressed = true;
                            for (index2 = keyBindKeys.length - 2; index2 >= 0; index2--) {
                                if (!(keyMap[keyBindKeys[index2]] in pressedModifiers)) {
                                    allModifiersPressed = false;
                                    break;
                                }
                            }
                            if (allModifiersPressed) {
                                handler = options.keyBinds[index];
                                break;
                            }
                        }
                    }
                }

                if (handler) {
                    handler.call(picker, widget);
                    e.stopPropagation();
                    e.preventDefault();
                }
            },

            keyup = function (e) {
                keyState[e.which] = 'r';
                e.stopPropagation();
                e.preventDefault();
            },

            change = function (e) {
                var val = $(e.target).val().trim(),
                    parsedDate = val ? parseInputDate(val) : null;
                setValue(parsedDate);
                e.stopImmediatePropagation();
                return false;
            },

            attachDatePickerElementEvents = function () {
                input.on({
                    'change': change,
                    'blur': options.debug ? '' : hide,
                    'keydown': keydown,
                    'keyup': keyup,
                    'focus': options.allowInputToggle ? show : ''
                });

                if (element.is('input')) {
                    input.on({
                        'focus': show
                    });
                } else if (component) {
                    component.on('click', toggle);
                    component.on('mousedown', false);
                }
            },

            detachDatePickerElementEvents = function () {
                input.off({
                    'change': change,
                    'blur': blur,
                    'keydown': keydown,
                    'keyup': keyup,
                    'focus': options.allowInputToggle ? hide : ''
                });

                if (element.is('input')) {
                    input.off({
                        'focus': show
                    });
                } else if (component) {
                    component.off('click', toggle);
                    component.off('mousedown', false);
                }
            },

            indexGivenDates = function (givenDatesArray) {
                // Store given enabledDates and disabledDates as keys.
                // This way we can check their existence in O(1) time instead of looping through whole array.
                // (for example: options.enabledDates['2014-02-27'] === true)
                var givenDatesIndexed = {};
                $.each(givenDatesArray, function () {
                    var dDate = parseInputDate(this);
                    if (dDate.isValid()) {
                        givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
                    }
                });
                return (Object.keys(givenDatesIndexed).length) ? givenDatesIndexed : false;
            },

            indexGivenHours = function (givenHoursArray) {
                // Store given enabledHours and disabledHours as keys.
                // This way we can check their existence in O(1) time instead of looping through whole array.
                // (for example: options.enabledHours['2014-02-27'] === true)
                var givenHoursIndexed = {};
                $.each(givenHoursArray, function () {
                    givenHoursIndexed[this] = true;
                });
                return (Object.keys(givenHoursIndexed).length) ? givenHoursIndexed : false;
            },

            initFormatting = function () {
                var format = options.format || 'L LT';

                actualFormat = format.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (formatInput) {
                    var newinput = date.localeData().longDateFormat(formatInput) || formatInput;
                    return newinput.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function (formatInput2) { //temp fix for #740
                        return date.localeData().longDateFormat(formatInput2) || formatInput2;
                    });
                });


                parseFormats = options.extraFormats ? options.extraFormats.slice() : [];
                if (parseFormats.indexOf(format) < 0 && parseFormats.indexOf(actualFormat) < 0) {
                    parseFormats.push(actualFormat);
                }

                use24Hours = (actualFormat.toLowerCase().indexOf('a') < 1 && actualFormat.replace(/\[.*?\]/g, '').indexOf('h') < 1);

                if (isEnabled('y')) {
                    minViewModeNumber = 2;
                }
                if (isEnabled('M')) {
                    minViewModeNumber = 1;
                }
                if (isEnabled('d')) {
                    minViewModeNumber = 0;
                }

                currentViewMode = Math.max(minViewModeNumber, currentViewMode);

                if (!unset) {
                    setValue(date);
                }
            };

        /********************************************************************************
         *
         * Public API functions
         * =====================
         *
         * Important: Do not expose direct references to private objects or the options
         * object to the outer world. Always return a clone when returning values or make
         * a clone when setting a private variable.
         *
         ********************************************************************************/
        picker.destroy = function () {
            ///<summary>Destroys the widget and removes all attached event listeners</summary>
            hide();
            detachDatePickerElementEvents();
            element.removeData('DateTimePicker');
            element.removeData('date');
        };

        picker.toggle = toggle;

        picker.show = show;

        picker.hide = hide;

        picker.disable = function () {
            ///<summary>Disables the input element, the component is attached to, by adding a disabled="true" attribute to it.
            ///If the widget was visible before that call it is hidden. Possibly emits dp.hide</summary>
            hide();
            if (component && component.hasClass('btn')) {
                component.addClass('disabled');
            }
            input.prop('disabled', true);
            return picker;
        };

        picker.enable = function () {
            ///<summary>Enables the input element, the component is attached to, by removing disabled attribute from it.</summary>
            if (component && component.hasClass('btn')) {
                component.removeClass('disabled');
            }
            input.prop('disabled', false);
            return picker;
        };

        picker.ignoreReadonly = function (ignoreReadonly) {
            if (arguments.length === 0) {
                return options.ignoreReadonly;
            }
            if (typeof ignoreReadonly !== 'boolean') {
                throw new TypeError('ignoreReadonly () expects a boolean parameter');
            }
            options.ignoreReadonly = ignoreReadonly;
            return picker;
        };

        picker.options = function (newOptions) {
            if (arguments.length === 0) {
                return $.extend(true, {}, options);
            }

            if (!(newOptions instanceof Object)) {
                throw new TypeError('options() options parameter should be an object');
            }
            $.extend(true, options, newOptions);
            $.each(options, function (key, value) {
                if (picker[key] !== undefined) {
                    picker[key](value);
                } else {
                    throw new TypeError('option ' + key + ' is not recognized!');
                }
            });
            return picker;
        };

        picker.date = function (newDate) {
            ///<signature helpKeyword="$.fn.datetimepicker.date">
            ///<summary>Returns the component's model current date, a moment object or null if not set.</summary>
            ///<returns type="Moment">date.clone()</returns>
            ///</signature>
            ///<signature>
            ///<summary>Sets the components model current moment to it. Passing a null value unsets the components model current moment. Parsing of the newDate parameter is made using moment library with the options.format and options.useStrict components configuration.</summary>
            ///<param name="newDate" locid="$.fn.datetimepicker.date_p:newDate">Takes string, Date, moment, null parameter.</param>
            ///</signature>
            if (arguments.length === 0) {
                if (unset) {
                    return null;
                }
                return date.clone();
            }

            if (newDate !== null && typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
                throw new TypeError('date() parameter must be one of [null, string, moment or Date]');
            }

            setValue(newDate === null ? null : parseInputDate(newDate));
            return picker;
        };

        picker.format = function (newFormat) {
            ///<summary>test su</summary>
            ///<param name="newFormat">info about para</param>
            ///<returns type="string|boolean">returns foo</returns>
            if (arguments.length === 0) {
                return options.format;
            }

            if ((typeof newFormat !== 'string') && ((typeof newFormat !== 'boolean') || (newFormat !== false))) {
                throw new TypeError('format() expects a sting or boolean:false parameter ' + newFormat);
            }

            options.format = newFormat;
            if (actualFormat) {
                initFormatting(); // reinit formatting
            }
            return picker;
        };

        picker.timeZone = function (newZone) {
            if (arguments.length === 0) {
                return options.timeZone;
            }

            options.timeZone = newZone;

            return picker;
        };

        picker.dayViewHeaderFormat = function (newFormat) {
            if (arguments.length === 0) {
                return options.dayViewHeaderFormat;
            }

            if (typeof newFormat !== 'string') {
                throw new TypeError('dayViewHeaderFormat() expects a string parameter');
            }

            options.dayViewHeaderFormat = newFormat;
            return picker;
        };

        picker.extraFormats = function (formats) {
            if (arguments.length === 0) {
                return options.extraFormats;
            }

            if (formats !== false && !(formats instanceof Array)) {
                throw new TypeError('extraFormats() expects an array or false parameter');
            }

            options.extraFormats = formats;
            if (parseFormats) {
                initFormatting(); // reinit formatting
            }
            return picker;
        };

        picker.disabledDates = function (dates) {
            ///<signature helpKeyword="$.fn.datetimepicker.disabledDates">
            ///<summary>Returns an array with the currently set disabled dates on the component.</summary>
            ///<returns type="array">options.disabledDates</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
            ///options.enabledDates if such exist.</summary>
            ///<param name="dates" locid="$.fn.datetimepicker.disabledDates_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.disabledDates ? $.extend({}, options.disabledDates) : options.disabledDates);
            }

            if (!dates) {
                options.disabledDates = false;
                update();
                return picker;
            }
            if (!(dates instanceof Array)) {
                throw new TypeError('disabledDates() expects an array parameter');
            }
            options.disabledDates = indexGivenDates(dates);
            options.enabledDates = false;
            update();
            return picker;
        };

        picker.enabledDates = function (dates) {
            ///<signature helpKeyword="$.fn.datetimepicker.enabledDates">
            ///<summary>Returns an array with the currently set enabled dates on the component.</summary>
            ///<returns type="array">options.enabledDates</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of options.disabledDates if such exist.</summary>
            ///<param name="dates" locid="$.fn.datetimepicker.enabledDates_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.enabledDates ? $.extend({}, options.enabledDates) : options.enabledDates);
            }

            if (!dates) {
                options.enabledDates = false;
                update();
                return picker;
            }
            if (!(dates instanceof Array)) {
                throw new TypeError('enabledDates() expects an array parameter');
            }
            options.enabledDates = indexGivenDates(dates);
            options.disabledDates = false;
            update();
            return picker;
        };

        picker.daysOfWeekDisabled = function (daysOfWeekDisabled) {
            if (arguments.length === 0) {
                return options.daysOfWeekDisabled.splice(0);
            }

            if ((typeof daysOfWeekDisabled === 'boolean') && !daysOfWeekDisabled) {
                options.daysOfWeekDisabled = false;
                update();
                return picker;
            }

            if (!(daysOfWeekDisabled instanceof Array)) {
                throw new TypeError('daysOfWeekDisabled() expects an array parameter');
            }
            options.daysOfWeekDisabled = daysOfWeekDisabled.reduce(function (previousValue, currentValue) {
                currentValue = parseInt(currentValue, 10);
                if (currentValue > 6 || currentValue < 0 || isNaN(currentValue)) {
                    return previousValue;
                }
                if (previousValue.indexOf(currentValue) === -1) {
                    previousValue.push(currentValue);
                }
                return previousValue;
            }, []).sort();
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, 'd')) {
                    date.add(1, 'd');
                    if (tries === 7) {
                        throw 'Tried 7 times to find a valid date';
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };

        picker.maxDate = function (maxDate) {
            if (arguments.length === 0) {
                return options.maxDate ? options.maxDate.clone() : options.maxDate;
            }

            if ((typeof maxDate === 'boolean') && maxDate === false) {
                options.maxDate = false;
                update();
                return picker;
            }

            if (typeof maxDate === 'string') {
                if (maxDate === 'now' || maxDate === 'moment') {
                    maxDate = getMoment();
                }
            }

            var parsedDate = parseInputDate(maxDate);

            if (!parsedDate.isValid()) {
                throw new TypeError('maxDate() Could not parse date parameter: ' + maxDate);
            }
            if (options.minDate && parsedDate.isBefore(options.minDate)) {
                throw new TypeError('maxDate() date parameter is before options.minDate: ' + parsedDate.format(actualFormat));
            }
            options.maxDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isAfter(maxDate)) {
                setValue(options.maxDate);
            }
            if (viewDate.isAfter(parsedDate)) {
                viewDate = parsedDate.clone().subtract(options.stepping, 'm');
            }
            update();
            return picker;
        };

        picker.minDate = function (minDate) {
            if (arguments.length === 0) {
                return options.minDate ? options.minDate.clone() : options.minDate;
            }

            if ((typeof minDate === 'boolean') && minDate === false) {
                options.minDate = false;
                update();
                return picker;
            }

            if (typeof minDate === 'string') {
                if (minDate === 'now' || minDate === 'moment') {
                    minDate = getMoment();
                }
            }

            var parsedDate = parseInputDate(minDate);

            if (!parsedDate.isValid()) {
                throw new TypeError('minDate() Could not parse date parameter: ' + minDate);
            }
            if (options.maxDate && parsedDate.isAfter(options.maxDate)) {
                throw new TypeError('minDate() date parameter is after options.maxDate: ' + parsedDate.format(actualFormat));
            }
            options.minDate = parsedDate;
            if (options.useCurrent && !options.keepInvalid && date.isBefore(minDate)) {
                setValue(options.minDate);
            }
            if (viewDate.isBefore(parsedDate)) {
                viewDate = parsedDate.clone().add(options.stepping, 'm');
            }
            update();
            return picker;
        };

        picker.defaultDate = function (defaultDate) {
            ///<signature helpKeyword="$.fn.datetimepicker.defaultDate">
            ///<summary>Returns a moment with the options.defaultDate option configuration or false if not set</summary>
            ///<returns type="Moment">date.clone()</returns>
            ///</signature>
            ///<signature>
            ///<summary>Will set the picker's inital date. If a boolean:false value is passed the options.defaultDate parameter is cleared.</summary>
            ///<param name="defaultDate" locid="$.fn.datetimepicker.defaultDate_p:defaultDate">Takes a string, Date, moment, boolean:false</param>
            ///</signature>
            if (arguments.length === 0) {
                return options.defaultDate ? options.defaultDate.clone() : options.defaultDate;
            }
            if (!defaultDate) {
                options.defaultDate = false;
                return picker;
            }

            if (typeof defaultDate === 'string') {
                if (defaultDate === 'now' || defaultDate === 'moment') {
                    defaultDate = getMoment();
                }
            }

            var parsedDate = parseInputDate(defaultDate);
            if (!parsedDate.isValid()) {
                throw new TypeError('defaultDate() Could not parse date parameter: ' + defaultDate);
            }
            if (!isValid(parsedDate)) {
                throw new TypeError('defaultDate() date passed is invalid according to component setup validations');
            }

            options.defaultDate = parsedDate;

            if ((options.defaultDate && options.inline) || input.val().trim() === '') {
                setValue(options.defaultDate);
            }
            return picker;
        };

        picker.locale = function (locale) {
            if (arguments.length === 0) {
                return options.locale;
            }

            if (!moment.localeData(locale)) {
                throw new TypeError('locale() locale ' + locale + ' is not loaded from moment locales!');
            }

            options.locale = locale;
            date.locale(options.locale);
            viewDate.locale(options.locale);

            if (actualFormat) {
                initFormatting(); // reinit formatting
            }
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.stepping = function (stepping) {
            if (arguments.length === 0) {
                return options.stepping;
            }

            stepping = parseInt(stepping, 10);
            if (isNaN(stepping) || stepping < 1) {
                stepping = 1;
            }
            options.stepping = stepping;
            return picker;
        };

        picker.useCurrent = function (useCurrent) {
            var useCurrentOptions = ['year', 'month', 'day', 'hour', 'minute'];
            if (arguments.length === 0) {
                return options.useCurrent;
            }

            if ((typeof useCurrent !== 'boolean') && (typeof useCurrent !== 'string')) {
                throw new TypeError('useCurrent() expects a boolean or string parameter');
            }
            if (typeof useCurrent === 'string' && useCurrentOptions.indexOf(useCurrent.toLowerCase()) === -1) {
                throw new TypeError('useCurrent() expects a string parameter of ' + useCurrentOptions.join(', '));
            }
            options.useCurrent = useCurrent;
            return picker;
        };

        picker.collapse = function (collapse) {
            if (arguments.length === 0) {
                return options.collapse;
            }

            if (typeof collapse !== 'boolean') {
                throw new TypeError('collapse() expects a boolean parameter');
            }
            if (options.collapse === collapse) {
                return picker;
            }
            options.collapse = collapse;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.icons = function (icons) {
            if (arguments.length === 0) {
                return $.extend({}, options.icons);
            }

            if (!(icons instanceof Object)) {
                throw new TypeError('icons() expects parameter to be an Object');
            }
            $.extend(options.icons, icons);
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.tooltips = function (tooltips) {
            if (arguments.length === 0) {
                return $.extend({}, options.tooltips);
            }

            if (!(tooltips instanceof Object)) {
                throw new TypeError('tooltips() expects parameter to be an Object');
            }
            $.extend(options.tooltips, tooltips);
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.useStrict = function (useStrict) {
            if (arguments.length === 0) {
                return options.useStrict;
            }

            if (typeof useStrict !== 'boolean') {
                throw new TypeError('useStrict() expects a boolean parameter');
            }
            options.useStrict = useStrict;
            return picker;
        };

        picker.sideBySide = function (sideBySide) {
            if (arguments.length === 0) {
                return options.sideBySide;
            }

            if (typeof sideBySide !== 'boolean') {
                throw new TypeError('sideBySide() expects a boolean parameter');
            }
            options.sideBySide = sideBySide;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.viewMode = function (viewMode) {
            if (arguments.length === 0) {
                return options.viewMode;
            }

            if (typeof viewMode !== 'string') {
                throw new TypeError('viewMode() expects a string parameter');
            }

            if (viewModes.indexOf(viewMode) === -1) {
                throw new TypeError('viewMode() parameter must be one of (' + viewModes.join(', ') + ') value');
            }

            options.viewMode = viewMode;
            currentViewMode = Math.max(viewModes.indexOf(viewMode), minViewModeNumber);

            showMode();
            return picker;
        };

        picker.toolbarPlacement = function (toolbarPlacement) {
            if (arguments.length === 0) {
                return options.toolbarPlacement;
            }

            if (typeof toolbarPlacement !== 'string') {
                throw new TypeError('toolbarPlacement() expects a string parameter');
            }
            if (toolbarPlacements.indexOf(toolbarPlacement) === -1) {
                throw new TypeError('toolbarPlacement() parameter must be one of (' + toolbarPlacements.join(', ') + ') value');
            }
            options.toolbarPlacement = toolbarPlacement;

            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.widgetPositioning = function (widgetPositioning) {
            if (arguments.length === 0) {
                return $.extend({}, options.widgetPositioning);
            }

            if (({}).toString.call(widgetPositioning) !== '[object Object]') {
                throw new TypeError('widgetPositioning() expects an object variable');
            }
            if (widgetPositioning.horizontal) {
                if (typeof widgetPositioning.horizontal !== 'string') {
                    throw new TypeError('widgetPositioning() horizontal variable must be a string');
                }
                widgetPositioning.horizontal = widgetPositioning.horizontal.toLowerCase();
                if (horizontalModes.indexOf(widgetPositioning.horizontal) === -1) {
                    throw new TypeError('widgetPositioning() expects horizontal parameter to be one of (' + horizontalModes.join(', ') + ')');
                }
                options.widgetPositioning.horizontal = widgetPositioning.horizontal;
            }
            if (widgetPositioning.vertical) {
                if (typeof widgetPositioning.vertical !== 'string') {
                    throw new TypeError('widgetPositioning() vertical variable must be a string');
                }
                widgetPositioning.vertical = widgetPositioning.vertical.toLowerCase();
                if (verticalModes.indexOf(widgetPositioning.vertical) === -1) {
                    throw new TypeError('widgetPositioning() expects vertical parameter to be one of (' + verticalModes.join(', ') + ')');
                }
                options.widgetPositioning.vertical = widgetPositioning.vertical;
            }
            update();
            return picker;
        };

        picker.calendarWeeks = function (calendarWeeks) {
            if (arguments.length === 0) {
                return options.calendarWeeks;
            }

            if (typeof calendarWeeks !== 'boolean') {
                throw new TypeError('calendarWeeks() expects parameter to be a boolean value');
            }

            options.calendarWeeks = calendarWeeks;
            update();
            return picker;
        };

        picker.showTodayButton = function (showTodayButton) {
            if (arguments.length === 0) {
                return options.showTodayButton;
            }

            if (typeof showTodayButton !== 'boolean') {
                throw new TypeError('showTodayButton() expects a boolean parameter');
            }

            options.showTodayButton = showTodayButton;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.showClear = function (showClear) {
            if (arguments.length === 0) {
                return options.showClear;
            }

            if (typeof showClear !== 'boolean') {
                throw new TypeError('showClear() expects a boolean parameter');
            }

            options.showClear = showClear;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.widgetParent = function (widgetParent) {
            if (arguments.length === 0) {
                return options.widgetParent;
            }

            if (typeof widgetParent === 'string') {
                widgetParent = $(widgetParent);
            }

            if (widgetParent !== null && (typeof widgetParent !== 'string' && !(widgetParent instanceof $))) {
                throw new TypeError('widgetParent() expects a string or a jQuery object parameter');
            }

            options.widgetParent = widgetParent;
            if (widget) {
                hide();
                show();
            }
            return picker;
        };

        picker.keepOpen = function (keepOpen) {
            if (arguments.length === 0) {
                return options.keepOpen;
            }

            if (typeof keepOpen !== 'boolean') {
                throw new TypeError('keepOpen() expects a boolean parameter');
            }

            options.keepOpen = keepOpen;
            return picker;
        };

        picker.focusOnShow = function (focusOnShow) {
            if (arguments.length === 0) {
                return options.focusOnShow;
            }

            if (typeof focusOnShow !== 'boolean') {
                throw new TypeError('focusOnShow() expects a boolean parameter');
            }

            options.focusOnShow = focusOnShow;
            return picker;
        };

        picker.inline = function (inline) {
            if (arguments.length === 0) {
                return options.inline;
            }

            if (typeof inline !== 'boolean') {
                throw new TypeError('inline() expects a boolean parameter');
            }

            options.inline = inline;
            return picker;
        };

        picker.clear = function () {
            clear();
            return picker;
        };

        picker.keyBinds = function (keyBinds) {
            options.keyBinds = keyBinds;
            return picker;
        };

        picker.getMoment = function (d) {
            return getMoment(d);
        };

        picker.debug = function (debug) {
            if (typeof debug !== 'boolean') {
                throw new TypeError('debug() expects a boolean parameter');
            }

            options.debug = debug;
            return picker;
        };

        picker.allowInputToggle = function (allowInputToggle) {
            if (arguments.length === 0) {
                return options.allowInputToggle;
            }

            if (typeof allowInputToggle !== 'boolean') {
                throw new TypeError('allowInputToggle() expects a boolean parameter');
            }

            options.allowInputToggle = allowInputToggle;
            return picker;
        };

        picker.showClose = function (showClose) {
            if (arguments.length === 0) {
                return options.showClose;
            }

            if (typeof showClose !== 'boolean') {
                throw new TypeError('showClose() expects a boolean parameter');
            }

            options.showClose = showClose;
            return picker;
        };

        picker.keepInvalid = function (keepInvalid) {
            if (arguments.length === 0) {
                return options.keepInvalid;
            }

            if (typeof keepInvalid !== 'boolean') {
                throw new TypeError('keepInvalid() expects a boolean parameter');
            }
            options.keepInvalid = keepInvalid;
            return picker;
        };

        picker.datepickerInput = function (datepickerInput) {
            if (arguments.length === 0) {
                return options.datepickerInput;
            }

            if (typeof datepickerInput !== 'string') {
                throw new TypeError('datepickerInput() expects a string parameter');
            }

            options.datepickerInput = datepickerInput;
            return picker;
        };

        picker.parseInputDate = function (parseInputDate) {
            if (arguments.length === 0) {
                return options.parseInputDate;
            }

            if (typeof parseInputDate !== 'function') {
                throw new TypeError('parseInputDate() sholud be as function');
            }

            options.parseInputDate = parseInputDate;

            return picker;
        };

        picker.disabledTimeIntervals = function (disabledTimeIntervals) {
            ///<signature helpKeyword="$.fn.datetimepicker.disabledTimeIntervals">
            ///<summary>Returns an array with the currently set disabled dates on the component.</summary>
            ///<returns type="array">options.disabledTimeIntervals</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
            ///options.enabledDates if such exist.</summary>
            ///<param name="dates" locid="$.fn.datetimepicker.disabledTimeIntervals_p:dates">Takes an [ string or Date or moment ] of values and allows the user to select only from those days.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.disabledTimeIntervals ? $.extend({}, options.disabledTimeIntervals) : options.disabledTimeIntervals);
            }

            if (!disabledTimeIntervals) {
                options.disabledTimeIntervals = false;
                update();
                return picker;
            }
            if (!(disabledTimeIntervals instanceof Array)) {
                throw new TypeError('disabledTimeIntervals() expects an array parameter');
            }
            options.disabledTimeIntervals = disabledTimeIntervals;
            update();
            return picker;
        };

        picker.disabledHours = function (hours) {
            ///<signature helpKeyword="$.fn.datetimepicker.disabledHours">
            ///<summary>Returns an array with the currently set disabled hours on the component.</summary>
            ///<returns type="array">options.disabledHours</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of
            ///options.enabledHours if such exist.</summary>
            ///<param name="hours" locid="$.fn.datetimepicker.disabledHours_p:hours">Takes an [ int ] of values and disallows the user to select only from those hours.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.disabledHours ? $.extend({}, options.disabledHours) : options.disabledHours);
            }

            if (!hours) {
                options.disabledHours = false;
                update();
                return picker;
            }
            if (!(hours instanceof Array)) {
                throw new TypeError('disabledHours() expects an array parameter');
            }
            options.disabledHours = indexGivenHours(hours);
            options.enabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, 'h')) {
                    date.add(1, 'h');
                    if (tries === 24) {
                        throw 'Tried 24 times to find a valid date';
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };

        picker.enabledHours = function (hours) {
            ///<signature helpKeyword="$.fn.datetimepicker.enabledHours">
            ///<summary>Returns an array with the currently set enabled hours on the component.</summary>
            ///<returns type="array">options.enabledHours</returns>
            ///</signature>
            ///<signature>
            ///<summary>Setting this takes precedence over options.minDate, options.maxDate configuration. Also calling this function removes the configuration of options.disabledHours if such exist.</summary>
            ///<param name="hours" locid="$.fn.datetimepicker.enabledHours_p:hours">Takes an [ int ] of values and allows the user to select only from those hours.</param>
            ///</signature>
            if (arguments.length === 0) {
                return (options.enabledHours ? $.extend({}, options.enabledHours) : options.enabledHours);
            }

            if (!hours) {
                options.enabledHours = false;
                update();
                return picker;
            }
            if (!(hours instanceof Array)) {
                throw new TypeError('enabledHours() expects an array parameter');
            }
            options.enabledHours = indexGivenHours(hours);
            options.disabledHours = false;
            if (options.useCurrent && !options.keepInvalid) {
                var tries = 0;
                while (!isValid(date, 'h')) {
                    date.add(1, 'h');
                    if (tries === 24) {
                        throw 'Tried 24 times to find a valid date';
                    }
                    tries++;
                }
                setValue(date);
            }
            update();
            return picker;
        };

        picker.viewDate = function (newDate) {
            ///<signature helpKeyword="$.fn.datetimepicker.viewDate">
            ///<summary>Returns the component's model current viewDate, a moment object or null if not set.</summary>
            ///<returns type="Moment">viewDate.clone()</returns>
            ///</signature>
            ///<signature>
            ///<summary>Sets the components model current moment to it. Passing a null value unsets the components model current moment. Parsing of the newDate parameter is made using moment library with the options.format and options.useStrict components configuration.</summary>
            ///<param name="newDate" locid="$.fn.datetimepicker.date_p:newDate">Takes string, viewDate, moment, null parameter.</param>
            ///</signature>
            if (arguments.length === 0) {
                return viewDate.clone();
            }

            if (!newDate) {
                viewDate = date.clone();
                return picker;
            }

            if (typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
                throw new TypeError('viewDate() parameter must be one of [string, moment or Date]');
            }

            viewDate = parseInputDate(newDate);
            viewUpdate();
            return picker;
        };

        // initializing element and component attributes
        if (element.is('input')) {
            input = element;
        } else {
            input = element.find(options.datepickerInput);
            if (input.size() === 0) {
                input = element.find('input');
            } else if (!input.is('input')) {
                throw new Error('CSS class "' + options.datepickerInput + '" cannot be applied to non input element');
            }
        }

        if (element.hasClass('input-group')) {
            // in case there is more then one 'input-group-addon' Issue #48
            if (element.find('.datepickerbutton').size() === 0) {
                component = element.find('.input-group-addon');
            } else {
                component = element.find('.datepickerbutton');
            }
        }

        if (!options.inline && !input.is('input')) {
            throw new Error('Could not initialize DateTimePicker without an input element');
        }

        // Set defaults for date here now instead of in var declaration
        date = getMoment();
        viewDate = date.clone();

        $.extend(true, options, dataToOptions());

        picker.options(options);

        initFormatting();

        attachDatePickerElementEvents();

        if (input.prop('disabled')) {
            picker.disable();
        }
        if (input.is('input') && input.val().trim().length !== 0) {
            setValue(parseInputDate(input.val().trim()));
        }
        else if (options.defaultDate && input.attr('placeholder') === undefined) {
            setValue(options.defaultDate);
        }
        if (options.inline) {
            show();
        }
        return picker;
    };

    /********************************************************************************
     *
     * jQuery plugin constructor and defaults object
     *
     ********************************************************************************/

    $.fn.datetimepicker = function (options) {
        return this.each(function () {
            var $this = $(this);
            if (!$this.data('DateTimePicker')) {
                // create a private copy of the defaults object
                options = $.extend(true, {}, $.fn.datetimepicker.defaults, options);
                $this.data('DateTimePicker', dateTimePicker($this, options));
            }
        });
    };

    $.fn.datetimepicker.defaults = {
        timeZone: 'Etc/UTC',
        format: false,
        dayViewHeaderFormat: 'MMMM YYYY',
        extraFormats: false,
        stepping: 1,
        minDate: false,
        maxDate: false,
        useCurrent: true,
        collapse: true,
        locale: moment.locale(),
        defaultDate: false,
        disabledDates: false,
        enabledDates: false,
        icons: {
            time: 'glyphicon glyphicon-time',
            date: 'glyphicon glyphicon-calendar',
            up: 'glyphicon glyphicon-chevron-up',
            down: 'glyphicon glyphicon-chevron-down',
            previous: 'glyphicon glyphicon-chevron-left',
            next: 'glyphicon glyphicon-chevron-right',
            today: 'glyphicon glyphicon-screenshot',
            clear: 'glyphicon glyphicon-trash',
            close: 'glyphicon glyphicon-remove'
        },
        tooltips: {
            today: 'Go to today',
            clear: 'Clear selection',
            close: 'Close the picker',
            selectMonth: 'Select Month',
            prevMonth: 'Previous Month',
            nextMonth: 'Next Month',
            selectYear: 'Select Year',
            prevYear: 'Previous Year',
            nextYear: 'Next Year',
            selectDecade: 'Select Decade',
            prevDecade: 'Previous Decade',
            nextDecade: 'Next Decade',
            prevCentury: 'Previous Century',
            nextCentury: 'Next Century',
            pickHour: 'Pick Hour',
            incrementHour: 'Increment Hour',
            decrementHour: 'Decrement Hour',
            pickMinute: 'Pick Minute',
            incrementMinute: 'Increment Minute',
            decrementMinute: 'Decrement Minute',
            pickSecond: 'Pick Second',
            incrementSecond: 'Increment Second',
            decrementSecond: 'Decrement Second',
            togglePeriod: 'Toggle Period',
            selectTime: 'Select Time'
        },
        useStrict: false,
        sideBySide: false,
        daysOfWeekDisabled: false,
        calendarWeeks: false,
        viewMode: 'days',
        toolbarPlacement: 'default',
        showTodayButton: false,
        showClear: false,
        showClose: false,
        widgetPositioning: {
            horizontal: 'auto',
            vertical: 'auto'
        },
        widgetParent: null,
        ignoreReadonly: false,
        keepOpen: false,
        focusOnShow: true,
        inline: false,
        keepInvalid: false,
        datepickerInput: '.datepickerinput',
        keyBinds: {
            up: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(7, 'd'));
                } else {
                    this.date(d.clone().add(this.stepping(), 'm'));
                }
            },
            down: function (widget) {
                if (!widget) {
                    this.show();
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(7, 'd'));
                } else {
                    this.date(d.clone().subtract(this.stepping(), 'm'));
                }
            },
            'control up': function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'y'));
                } else {
                    this.date(d.clone().add(1, 'h'));
                }
            },
            'control down': function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'y'));
                } else {
                    this.date(d.clone().subtract(1, 'h'));
                }
            },
            left: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'd'));
                }
            },
            right: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'd'));
                }
            },
            pageUp: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().subtract(1, 'M'));
                }
            },
            pageDown: function (widget) {
                if (!widget) {
                    return;
                }
                var d = this.date() || this.getMoment();
                if (widget.find('.datepicker').is(':visible')) {
                    this.date(d.clone().add(1, 'M'));
                }
            },
            enter: function () {
                this.hide();
            },
            escape: function () {
                this.hide();
            },
            //tab: function (widget) { //this break the flow of the form. disabling for now
            //    var toggle = widget.find('.picker-switch a[data-action="togglePicker"]');
            //    if(toggle.length > 0) toggle.click();
            //},
            'control space': function (widget) {
                if (widget.find('.timepicker').is(':visible')) {
                    widget.find('.btn[data-action="togglePeriod"]').click();
                }
            },
            t: function () {
                this.date(this.getMoment());
            },
            'delete': function () {
                this.clear();
            }
        },
        debug: false,
        allowInputToggle: false,
        disabledTimeIntervals: false,
        disabledHours: false,
        enabledHours: false,
        viewDate: false
    };
}));

function RegistredModule(selector) {
	this.selector = selector;
}

RegistredModule.prototype.attachToDom = function() {
	this.jquery = undefined;
	if (this.selector !== undefined) {
		this.jquery = $(this.selector);
	}
};

RegistredModule.prototype.exist = function() {
	if (this.jquery !== undefined) {
		return this.jquery.length > 0; 
	} else {
		return true;
	}	
};

RegistredModule.prototype.loading = function() {
	
	this.attachToDom();
	
	if (this.exist()) {
	
		if (typeof this.loadingBusiness == 'function') {
			this.loadingBusiness();
		} else {
			console.warn('unable to load the module ' + this.constructor.name);
		}
	}
};
pdmainCartridgeRegistrer.prototype = new RegistredModule();
pdmainCartridgeRegistrer.prototype.constructor=pdmainCartridgeRegistrer;

function pdmainCartridgeRegistrer() {
	this.selector = '#pdm_productdetailsmaincartridge';
}

pdmainCartridgeRegistrer.prototype.loadingBusiness = function() {
		
	// Force init to avoid js error from other modules
	window.pdmMainCartridgeModelsJsObject = undefined;
	window.brightCoveParameters = undefined;
	
	// Get the data.
	if ( !_.isUndefined(this.jquery.data('pdmjsmodels')) && !_.isNull(this.jquery.data('pdmjsmodels')) ) {
		window.pdmMainCartridgeModelsJsObject = this.jquery.data('pdmjsmodels');
	}
	
	// Get the data.
	if ( !_.isUndefined(this.jquery.data('brigthcoveparameters')) && !_.isNull(this.jquery.data('brigthcoveparameters')) ) {
		window.brightCoveParameters = this.jquery.data('brigthcoveparameters');
	}
	
	// Init the gallery : pictures & video.
	if (window.pdmMainCartridgeModelsJsObject[0].media !== null && !_.isUndefined(window.pdmMainCartridgeModelsJsObject[0].media) &&
		 !_.isUndefined(window.pdmMainCartridgeModelsJsObject[0].media.videos) &&
		 !_.isNull(window.pdmMainCartridgeModelsJsObject[0].media.videos) &&
 		 window.pdmMainCartridgeModelsJsObject[0].media.videos.length > 0) {
 		$("#container-floor-video").show();
        showOverlayTab("video");
 	}
};

var picturesFloorRegistrer = function (selector) {
	this.selector = '#container-floor-product-pictures';
};

picturesFloorRegistrer.prototype = {

	attachToDom: function() {
		this.jquery = $(this.selector);
	},
		
	exist: function() {
		return this.jquery.length > 0;
	},
	
	loading: function() {
		
		this.attachToDom();
		
		if (this.exist()) {
	
			// Setup data for the other scripts from DOM.
			// TODO ugly, refactor this later.
			if ( !_.isUndefined(this.jquery.data('picturefloormodels')) && !_.isNull(this.jquery.data('picturefloormodels')) ) {
				window.pictureFloorModels = this.jquery.data('picturefloormodels');
			}
		}
	}
		
};

var productAmbianceFloorRegistrer = function (selector) {
	this.selector = '#container-floor-ambience';
};

productAmbianceFloorRegistrer.prototype = {

	attachToDom: function() {
		this.jquery = $(this.selector);
	},
		
	exist: function() {
		return this.jquery.length > 0;
	},
	
	loading: function() {
		
		this.attachToDom();
		
		if (this.exist()) {
	
			// Setup data for the other scripts from DOM.
			// TODO ugly, refactor this later.
			if ( !_.isUndefined(this.jquery.data('ambiancepicturefloormodels')) && !_.isNull(this.jquery.data('ambiancepicturefloormodels')) ) {
				window.ambiencePictureFloorModels = this.jquery.data('ambiancepicturefloormodels');
			}
		}
	}
		
};

var videoFloorRegistrer = function (selector) {
	this.selector = '#container-floor-video';
};

videoFloorRegistrer.prototype = {

	attachToDom: function() {
		this.jquery = $(this.selector);
	},
		
	exist: function() {
		return this.jquery.length > 0;
	},
	
	loading: function() {
		
		this.attachToDom();
		
		if (this.exist()) {
		
			// Showing background image ?
			// TODO Warning : don't we need to use the pixel refactor for that matter + picture tag instead of background.
			if ( !_.isUndefined(this.jquery.data('bgimg')) && !_.isNull(this.jquery.data('bgimg')) ) {
				updateVideoFloorBackgroundImage('url(' + this.jquery.data('bgimg') + ')');
			}
	
			// Setup data for the other scripts from DOM.
			// TODO ugly, refactor this later.
			if ( !_.isUndefined(this.jquery.data('videofloormodels')) && !_.isNull(this.jquery.data('videofloormodels')) ) {
				window.videoFloorModels = this.jquery.data('videofloormodels');
			}
		}
	}
		
};

brigthCoveRegistrer.prototype = new RegistredModule();
brigthCoveRegistrer.prototype.constructor = brigthCoveRegistrer;

function brigthCoveRegistrer() {
	this.selector = undefined;
	this.description = "Retrieve data from BrightCove";
}


brigthCoveRegistrer.prototype.loadingBusiness = function() {
	fetchAllBCVideoData();
};
bundlesFloorSlider.prototype = new RegistredModule();
bundlesFloorSlider.prototype.constructor=bundlesFloorSlider;

function bundlesFloorSlider() {
  this.selector = $('.modal-sidebar--bundles');
  this.bundleSliders = new Cube.InitSliderSlick(this.selector);
}

bundlesFloorSlider.prototype.loadingBusiness = function() { 
  this.bundleSliders.init();
};

storeLocatorModule.prototype = new RegistredModule();
storeLocatorModule.prototype.constructor = storeLocatorModule;

function storeLocatorModule() {
	this.selector = '.store-locator';
	this.description = "Manage Data for the Store Locator page";
}

storeLocatorModule.prototype.loadingBusiness = function() {
	// // Load new API Google Map for other countries instead of legacy map for CHINA
	if (Cube.Features.useGoogleAsMapProvider()) {
		// Map Initialization
		var myMap = new Cube.Map.Google();
		// Map configuration
		myMap.setCenter({lat:parseFloat($("input#default-lat").val()), lng:parseFloat($("input#default-long").val()), zoom:parseFloat($("input#default-zoom").val())});
		// Map loader
		myMap.load();
	}
	storeLocatorInit();
	storeLocatorinitMap();
};

function storeLocatorInit () {

	// MANAGEMENT OF INTERACTIVE MAP OF COUNTRY

	// interactive html map and resize management
	$('#country-map img[usemap]').mapster({
		stroke: false,
		fillColor: '0082c3',
		singleSelect: true,
		onClick: function(data){
			data.e.preventDefault();
			if(data.selected === true) {
				$('#country-select').val($(this).attr('id'));
				changeCountry($('#country-'+$(this).attr('id')));
			} else {
				$('#country-select').val('-1');
				$('.country-map-wrapper .list-stores').hide();
			}
		}
	});

	$('.mobile #Map area').on('touchend', function(e){
		e.preventDefault();
		$('#' +$(this).attr('id')).click();
	});

	var img = $('#country-map img[usemap]')[0];
	var originalWidth;
	var originalHeight;
	$("<img/>") // Make in memory copy of image to avoid css issues
		.attr("src", $(img).attr("src"))
		.load(function() {
			originalWidth = this.width;   // Note: $(this).width() will not
			originalHeight = this.height; // work for in memory images.

			var the_timer;
			var ratio = originalWidth / originalHeight;


			window.addEventListener('resize', function(){
				clearTimeout(the_timer);
				the_timer = setTimeout(function(){

					var wraper =  $('#country-map');

					if(wraper.width() <= originalWidth){
						$('#country-map img[usemap]').mapster('resize',wraper.width(), wraper.width() / ratio, 100);
					}
				}, 75);
			});
		});

	// link map and associated select to the lists
	// $('#Map').find('area').on('click', function(e){
	//     e.preventDefault();
	//     $('#country-select').val($(this).attr('id'));
	//     changeCountry($('#country-'+$(this).attr('id')));
	// });

	// mobile view
	$('#country-select').on('change', function(e){
		e.preventDefault();
		$('#Map').find('#'+$(this).val()).click();
	});

	function changeCountry(country){
		$('.country-map-wrapper .list-stores').hide();
		$('#Map').find(country).click();
		$(country).show();
	}
}


function storeLocatorinitMap() {
	var data = $('#default-lat').val()+","+ $('#default-long').val()+","+ $('#default-zoom').val();
	var callURL = $('#call-url').val();
	var callGlobalURL = $('#call-global-url').val();
	var map = $('#typeMap').val();
	if (map === undefined || map === null || map === '') {
		map = 'bmap';
	}

	var storeLocatorMap = new UX_MapObject({
		mapObject: 'map',
		typeMap: map,
		storesData: data,
		callURL: callURL,
		callGlobalURL: callGlobalURL,
		localisator: $('.locate-me'),
		formAddress: $('.search-address'),
		offCentered: false,
		panel: $('#map-panel'),
		showStore: false
	});
}
storePageModule.prototype = new RegistredModule();
storePageModule.prototype.constructor = storePageModule;

function storePageModule() {
    this.selector = '.store-page';
    this.description = "Manage Data for the Store Page";
}

storePageModule.prototype.loadingBusiness = function () {

    var methods = {
            init: function () {

                this.coordStoreLat = Number($('#coordStoreLat').val());
                this.coordStoreLong = Number($('#coordStoreLong').val());


                this.storeReviews();
                //storePage.initMap();

            },
            initMap: function (data) {
                if (Cube.Features.useBaiduAsMapProvider()) {
                    this.initMapBaidu();
                } else {
                    this.initMapGoogle();
                }
            },
            initMapBaidu: function () {
                var data = JSON.parse($('#call-url').val());

                this.createMapBaidu({
                    mapId: 'map-bg',
                    centerLat: data.latitude,
                    centerLng: (data.longitude - 1), // The store is displayed at the right of the map.
                    zoom: 10,
                    storeLat: data.latitude,
                    storeLng: data.longitude,
                    storeName: data.storeName,
                    storeAddress: this.getStoreAddressFromData(data)
                });
            },
            initMapGoogle: function () {
                var data = JSON.parse($('#call-url').val());

                this.createMapGoogle({
                    mapId: 'map-bg',
                    centerLat: data.latitude,
                    centerLng: (data.longitude - 1), // The store is displayed at the right of the map.
                    zoom: 9,
                    storeLat: data.latitude,
                    storeLng: data.longitude,
                    storeName: data.storeName,
                    storeAddress: this.getStoreAddressFromData(data)
                });
            },
            createMapBaidu: function (data) {
                var MyBmap = new BMap.Map(document.getElementById('map-bg'));

                // Center Map
                MyBmap.centerAndZoom(new BMap.Point(data.centerLng, data.centerLat), data.zoom);

                // Disable dragg and drop on mobile
                if (jQuery('body').hasClass('mobile')) {
                    MyBmap.disableDragging();
                }

                // Store location
                var storePoint = new BMap.Point(data.storeLng, data.storeLat);

                // Add Info Window
                var template = this.createMapInfoWindowTemplate(data.storeName, data.storeAddress);
                var infoWindow = new BMap.InfoWindow(template);

                // Add store marker
                var icon = new BMap.Icon("/assets/images/pin-icon-blue.png", new BMap.Size(22, 35));
                var marker = new BMap.Marker(storePoint, {icon: icon});
                marker.addEventListener("click", function () {
                    this.openInfoWindow(infoWindow);
                });
                MyBmap.addEventListener('tilesloaded', function () {
                    marker.openInfoWindow(infoWindow);
                });
                MyBmap.addOverlay(marker);
            },
            createMapGoogle: function (data) {
                // Create and center Map
                var MyGmap = new google.maps.Map(document.getElementById('map-bg'), {
                    center: {lat: data.centerLat, lng: data.centerLng},
                    scrollwheel: false,
                    zoom: 9,
                    disableDefaultUI: true
                });

                // Add Info Window
                var template = this.createMapInfoWindowTemplate(data.storeName, data.storeAddress);
                var infoWindow = new google.maps.InfoWindow({
                    content: template
                });

                // Add store marker
                var icon = '/assets/images/pin-icon-blue.png';
                var marker = new google.maps.Marker({
                    position: {lat: data.storeLat, lng: data.storeLng},
                    map: MyGmap,
                    icon: icon
                });
                marker.addListener('click', function () {
                    infoWindow.open(MyGmap, marker);
                });
                MyGmap.addListener('tilesloaded', function () {
                    infoWindow.open(MyGmap, marker);
                });
            },
            getStoreAddressFromData: function (data) {
                var template = '';

                template += data.address.address1 !== null ? data.address.address1 + '<br />' : "";
                template += data.address.postalCode + ' ' + data.address.city;

                return template;
            },
            createMapInfoWindowTemplate: function (name, address) {
                var template = '';

                template += '<div class="info-store">';
                template += '<div class="content">';
                template += '<p class="store-name">' + name + '</p>';
                template += '<p class="store-address">' + address + '</p>';
                template += '</div>';
                template += '<div class="store-picture">';
                template += '<img src="/assets/images/decathlon-logo.svg" alt="' + name + '" />';
                template += '</div>';
                template += '</div>';

                return template;
            },
            initSlickOpenings: function () {
                $('.slick-openings').slick({
                    infinite: false,
                    arrows: true,
                    dots: true,
                    useCSS: true,
                    useTransform: true,
                    speed: 300,
                    slidesToShow: 3,
                    slidesToScroll: 1
                });
            },
            initSlickOffers: function () {
                $('.slick-offers').slick({
                    infinite: false,
                    dots: true,
                    speed: 300,
                    useCSS: true,
                    useTransform: true,
                    slidesToShow: 3,
                    slidesToScroll: 3,
                    responsive: [
                        {
                            breakpoint: decathlon.uxBreakpoints.smMin,
                            settings: {
                                slidesToShow: 1,
                                slidesToScroll: 1
                            }
                        }
                    ]
                });
            },
            initSlickServices: function () {
                $('.slick-store-services').slick({
                    infinite: false,
                    dots: true,
                    speed: 300,
                    useCSS: true,
                    useTransform: true,
                    slidesToShow: 3,
                    slidesToScroll: 3,
                    responsive: [
                        {
                            breakpoint: decathlon.uxBreakpoints.smMin,
                            settings: {
                                slidesToShow: 1,
                                slidesToScroll: 1
                            }
                        }
                    ]
                });
            },
            ie8: function () {
                var windowWidth = $(window).width();

                var dynamicWidth = decathlon.uxBreakpoints.lgMin * (2 / 3);
                // positioning the top element
                if (windowWidth >= decathlon.uxBreakpoints.lgMin) {
                    var leftPos = (windowWidth - decathlon.uxBreakpoints.lgMin) / 2;
                    $('.st-p-wrapper.top').css({'left': leftPos + 'px', 'width': dynamicWidth + 'px'});
                } else {
                    $('.st-p-wrapper.top').css({'left': '15px', 'width': dynamicWidth + 'px'});
                }
            },
            storeReviewsMoveRatings: function (bool) {
            	$('.panel-review-user-smiley').each(function(){
        			var $fields = $(this).find('.fields');
        			var $to = null;
        			
        			if(bool){ 
        				$to = $(this).find('.review-info > #criteria-container');
        			}else{
        				$to = $(this).find('.sidebar');
        			}
        			
        			$fields.detach().appendTo($to);
        		}); 
            },
            storeReviews: function () {
                var mobile = $('body').hasClass('mobile');
                this.storeReviewsMoveRatings(mobile);

                $(window).resize(function () {
                    var width = $('body').width();
                    this.storeReviewsMoveRatings((width < 769));
                });
            }
        };

    methods.init();
    methods.initSlickOpenings();
    methods.initSlickOffers();
    methods.initSlickServices();
    methods.initMap();

    // IE :(
    if ($('html').hasClass('ie8')) {
        methods.ie8();
    }
};
menuModule.prototype = new RegistredModule();
menuModule.prototype.constructor = menuModule;

function menuModule() {
	this.selector = undefined;
	this.description = "Manage AJAX loading for the menu";
}

menuModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MenuPlugin',
        THIRD_LEVEL_SERVICE_URL: 'getCategoryChildren',
        LOGOUT_URL_DATA             :   "logout-url",
        CUSTOMER_PORTAL_URL_DATA    :   "cp-url"
    };

    var methods = {
    		
    	    initMiniCart: function() {

    		    
    	    	$('#dropdown-cart') 
    		    .MiniCartPlugin()
    		    .on('mouseenter', function(){
    		        if(!jQuery(this).parent().hasClass("open"))
    		        {
    		            jQuery(this).closest('.dropdown').addClass('loading');
    		            jQuery("#mc_currentminicartdetails .info-row").hide();
    		            jQuery(this).MiniCartPlugin('display', 
    		                    $(this), 
    		                    'mc_currentminicartdetails');
    		        } 
    		    });
    		},
    		
    		loadThirdLevelCategories: function() {
                  var $this = $(this);
                  var categoryId = $(this).data("categoryid");

                  // call AJAX only if there is no yet links list in the third level panel
                  var menuPanels = $this.filter("[data-categoryid='" + categoryId + "']").next("ul");
                		  
                  if (menuPanels.length === 0) {
                	  var params = {
                			'categoryid': categoryId
                		};
                	  
	                  getAjaxHandler()
		              	.withCaller($this)
		              	.withUrl(csts.THIRD_LEVEL_SERVICE_URL)
		              	.withParameters(params)
		              	.withSuccess(methods._loadThirdLevelCategoriesSuccess)
		              	.withError(function() {
		              		window.location = $this.data("url");
		              	})
		              	.call();
                  }
              },


              _loadThirdLevelCategoriesSuccess : function($this, result, params) {
                  var options = [];
                  var locale = $("html").attr("lang");
                  var categories = result.categories;
                  // if there is no category, redirect to the 2nd category level
                  
                  if(Cube.Features.openMenuCategoriesInNewTab()){
                      options = 'target = "_blank"';
                  }
                  var linksToUpdateWithMenu = $("a.thirdLevelLink").filter("[data-categoryid='" + params.categoryid + "']");
                  // There are two panels to update (one for mobile view, one for desktop view)
                  $.each(linksToUpdateWithMenu, function(key, value) {
                	  if (categories === null || categories === undefined || categories.length === 0) {
                		  window.location = $(value).data("url");
                		  return;
                	  }
                	  
                	  var menu = $("<ul role='menu' class='thirdLevelCategories'>");
                	  var subMenuTop = $this.closest('.menu-submenu-content').find('.row').offset().top - $this.closest('.menu-submenu-content').offset().top;
                	  //menu.css('top', subMenuTop);
                      menu.insertAfter(value);
                      
                	  $.each(categories, function(index) {
                		  menu.append('<li role="presentation"><a class="thirdLevelCategory" '+ options +' href="' + Cube.Utils.localizeUri(categories[index].url) + '" role="menuitem">' + categories[index].name + '</a></li>');
                      });
                  });
              },
              
              _registerLogoutCallBack : function($this, result) {
                  $('#logout-confirmation').on('click', '.logoutLink', function(e) {
                      e.preventDefault(); 
                      window.location.href    =   $(e.currentTarget).data(csts.LOGOUT_URL_DATA);
                      var customerPortalLogoutUrl = $(e.currentTarget).data(csts.CUSTOMER_PORTAL_URL_DATA);
                      if (customerPortalLogoutUrl) {
                          (new Image()).src       =   customerPortalLogoutUrl;
                      }
                  });
              }
            
    
    };
    $.fn.MenuPlugin = basePlugin(methods, csts.NAME);
    
    var menuPluginEvents = function() {
    	
        $("a.thirdLevelLink").on('click', function() {
            (function($this) {
                $this.MenuPlugin('loadThirdLevelCategories');
            })($(this));
        });
        
    };

 
    menuPluginEvents();
    
    $.fn.MenuPlugin('initMiniCart');
    
    methods._registerLogoutCallBack();

    Cube.NativeWebView.enableMyMenu();
};
/* Module used for testing purpose for the Promotion test Page */
promotionsModule.prototype = new RegistredModule();
promotionsModule.prototype.constructor = promotionsModule;

function promotionsModule() {
	this.selector = '#main-container-promo-test';
}


promotionsModule.prototype.loadingBusiness = function() {
	(function($) {
		var csts = {
			NAME:'GetAllPromotionsPlugin',
			MAIN_ERROR: 'mainError'
		};
		
		var actors = {
			GET_ALL_PROMOTIONS:'rest/model/com/decathlon/cube/commerce/pricing/promotion/PromotionActor'	
		};
		
		var methods = {
			// Initialize function, i.e plugin constructor.
			
			init : function(options) {

				return this.each(function() {
				});
			},

			getAllPromotions : function() {
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.GET_ALL_PROMOTIONS+"/getAllPromotions")
					.withSuccess(methods._getAllPromotionsSuccess)
					.call();
			},
			
			getAllPricingAdjustments : function() {
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.GET_ALL_PROMOTIONS+"/getAllPricingAdjustments")
					.withSuccess(methods._getAllPromotionsSuccess)
					.call();
			},

			getAllOrderDiscountPromotions : function() {
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.GET_ALL_PROMOTIONS+"/getAllOrderDiscountPromotions")
					.withSuccess(methods._getAllPromotionsSuccess)
					.call();
			},
			
			getAllShippingDiscountPromotions : function() {
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.GET_ALL_PROMOTIONS+"/getAllShippingDiscountPromotions")
					.withSuccess(methods._getAllPromotionsSuccess)
					.call();
			},
			
			getAllItemDiscountPromotions : function() {
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.GET_ALL_PROMOTIONS+"/getAllItemDiscountPromotions")
					.withSuccess(methods._getAllPromotionsSuccess)
					.call();
			},			// ----- Callback methods -----

			_getAllPromotionsSuccess : function($this, result, input) {
				$("#inner-container").empty();
				var promotionsTable = $("<table class='table table-bordered'>");
				
				 promotionsTable.append("<tr><td>displayName</td><td>description</td><td>Begin Usable Date</td><td>End Usable Date</td><td>pmdlRule</td></tr>");
				
				 
				 $.each(result.responseTO, function(index,currentPromotion){
					 var row = $('<tr></tr>');
					 
					 if(!currentPromotion.displayName){
						 currentPromotion = currentPromotion.promotionTO;
					 }
					 
					 row.append(methods._appendCellToRow(currentPromotion.displayName));
					 row.append(methods._appendCellToRow(currentPromotion.description));
					 row.append(methods._appendCellToRow(currentPromotion.beginUsable));
					 row.append(methods._appendCellToRow(currentPromotion.endUsable));
					 row.append(methods._appendCellToRow(currentPromotion.pmdlRule));
					 	 
					 promotionsTable.append(row);
				 });				
				
				 $("#inner-container").append(promotionsTable);
			},
			
			_appendCellToRow : function(cellValue, row){
				 if(cellValue){
					 return $('<td></td>').text(cellValue);
				 } else{
					 return $('<td>Not available</td>');
				 }
			}
		};
		// Plugin entry point
		$.fn.GetAllPromotionsPlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	
	/* Bind click function to page buttons */
    $('#get_all_promotions').unbind('click').GetAllPromotionsPlugin().click(function() {
        (function($this) {
            $this.GetAllPromotionsPlugin('getAllPromotions');
        })(jQuery(this));
    });

    $('#get_applied_promotions').unbind('click').GetAllPromotionsPlugin().click(function() {
        (function($this) {
            $this.GetAllPromotionsPlugin('getAllPricingAdjustments');
        })(jQuery(this));
    });
    
    $('#get_all__order_promotions').unbind('click').GetAllPromotionsPlugin().click(function() {
        (function($this) {
            $this.GetAllPromotionsPlugin('getAllOrderDiscountPromotions');
        })(jQuery(this));
    });
           
     $('#get_all__shipping_promotions').unbind('click').GetAllPromotionsPlugin().click(function() {
         (function($this) {
             $this.GetAllPromotionsPlugin('getAllShippingDiscountPromotions');
         })(jQuery(this));
     });

     $('#get_all__item_promotions').unbind('click').GetAllPromotionsPlugin().click(function() {
         (function($this) {
             $this.GetAllPromotionsPlugin('getAllItemDiscountPromotions');
         })(jQuery(this));
     });
};
/* Module used for testing purpose for the Promotion test Page coupons form */
couponsModule.prototype = new RegistredModule();
couponsModule.prototype.constructor = couponsModule;

function couponsModule() {
	this.selector = '#claim-coupon-form-container';
}


couponsModule.prototype.loadingBusiness = function() {
	(function($) {
		var csts = {
			NAME:'ClaimCouponPlugin',
			MAIN_ERROR: 'mainError'
		};
		
		var actors = {
				CLAIM_COUPON:'rest/model/atg/commerce/promotion/CouponActor/claimCoupon'	
		};
		
		var methods = {
			// Initialize function, i.e plugin constructor.
			
			init : function(options) {

				return this.each(function() {
				});
			},
			
			claimCoupon:function($this, couponCode) {
				getAjaxHandler()
					.withCaller($this)
					.withUrl(actors.CLAIM_COUPON)
					.withParameter('couponClaimCode', couponCode)
					.withSuccess(methods._claimCouponSuccess)
					.call();
			},
			 
			// ----- Callback methods -----

			_claimCouponSuccess : function($this, result, input) {
				console.log("================ Success ====================");
			}
		};
		// Plugin entry point
		$.fn.ClaimCouponPlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	
	/* Bind click function to page buttons */
    $('#claim-coupon-btn').unbind('click').ClaimCouponPlugin().click(function() {
        (function($this) {
        	var enteredCouponCode = $("#claim-coupon-txt").val();//console.log(enteredCouponCode);
            $this.ClaimCouponPlugin('claimCoupon', $this, enteredCouponCode);
        })(jQuery(this));
    });
};
/* Module used for testing purpose for the Promotion test Page */
conversionZoneModule.prototype = new RegistredModule();
conversionZoneModule.prototype.constructor = conversionZoneModule;

function conversionZoneModule() {
	this.selector = '#conversion-zone-container';
}

conversionZoneModule.prototype.loadingBusiness = function() {
	modelIdToDefaultSkuIdMap = {}; // Hold Map of modelId and DefaultSkuId to reduce processing.
	(function($) {
		// Plugin constants
		var csts = {
			// Plugin identifier
			NAME : 'ConversionZonePlugin',
			MAIN_ERROR: 'mainError',
			AJAX_RELOAD_CONVERSION_ZONE : 'ajaxReloadConversionZoneCartridge'
		};

		var methods = {
			// Initialize function, i.e plugin constructor.
			init : function(options) {

				return this.each(function() {
				});
				
			},

			/**
			 * Reloads the ProductConversionZone Cartridge using PDO_ProductConversionZone Cartridge using 
			 * the currently being viewed bundle in the Bundle Floor. And the Current record being viewed.
			 */
			ajaxReloadConversionZoneCartridge : function() {
         		var panoplyId = $(this).data('panoply-id'); // Panoply Id From Bundle Floor
         		var rParameter = $("#conversion-zone-container").attr("t-args"); // Retrieve the current page recordSpec for instatiating the recordState
         		var currentIbenefitBtnClickedStatus = $(this).attr("data-clicked-status");

         		if(currentIbenefitBtnClickedStatus === "false" && panoplyId && rParameter){
         			//$('#msb-conversionzone-products-list').empty();
         			
    				reloadCartridgeContentCollection($(this), "conversion-zone-container", {
    					"R":rParameter,
    					"panoplyId":panoplyId
    				}, methods._ajaxReloadConversionZoneCartridgeSuccess);   
    				
    				methods.updateClickedIBenefitButtonStatus($(this));
         		} else{
         			var target = $(this).attr("data-target");
					if(target == '#modal-product-bundles'){
         				$(target).trigger('open');
         			}else{
         				displayError(Messages("bundle.one.or.more.out.of.stock"), csts.MAIN_ERROR, null);
         			}
         		}
			},

			/**
			 * The success method for reloading the PDO_ProductConversionZone cartridge.
			 */
			_ajaxReloadConversionZoneCartridgeSuccess : function($this, result) {

				if(result.length){
					this.result = result;
					var target = $($this).attr("data-category");
					if(target == 'set-sidebar'){
			            new Cube.SetSidebar('.set-sidebar').loading();
					}else if(target == 'modal-sidebar--bundles'){
						new bundlesFloorSlider().loading();
					}
					new Cube.ManageSidebar($('.modal-sidebar--bundles')).init();
					methods._refreshSelectPicker("select[id^='conversion-zone-select-picker-']");
					methods.delegateMsbColorCarousel();
					methods.delegateMSBSizesDropDown();
					methods.addPanoplyToCart();
					methods.initializeCurrentPanoplyModelIdToDefaultSkuIdMap();
					$("#modal-product-bundles").trigger('open');				
				} else{
					displayError(Messages("bundle.one.or.more.out.of.stock"), csts.MAIN_ERROR, null);
				}
			}, 
			
			initializeCurrentPanoplyModelIdToDefaultSkuIdMap : function(){
				$(".msb__color").each(function (index, value) {
					modelIdToDefaultSkuIdMap[$(this).data("model-id")]=$(this).data("default-sku-id");
				});
			},
			
			/**
			 * Delegate for the The models sliders in the the Conversion Zone Overlay.
			 */
			delegateMsbColorCarousel : function() {
				$('.msb__colors').delegate('.msb__colors-carousel', 'click', function(event){
					  if(event && event.originalEvent === undefined){
						 return;
					  }
					
				      var index = $('.msb__colors-carousel').index($(this));
				      var selectedModelId = $(this).find(".slick-current").data('model-id');
				      var parentSlickDivObject = $(this).closest(".msb__colors-carousel");
				      var parentSlickDivObjectIndex = parentSlickDivObject.data("msb__colors-carousel-index");
				      var parentProductObjet = parentSlickDivObject.data("product-object");
				      
				      if(parentProductObjet){
					      $.each( parentProductObjet.models, function(index, model){
				    	    	if(!_.isUndefined(model) && model.id == selectedModelId){
				    	    		
				    	    		var sizesDropDownObject = $("#conversion-zone-select-picker-"+parentSlickDivObjectIndex);
				    	    		
				    	    		sizesDropDownObject.empty();
				    	    		
				    	    		var newOption = '<option data-content="">' + Messages('bundle.conversion.zone.size') + '</option>';
				    	    		sizesDropDownObject.append(newOption);
				    	    		
				    	    		$.each( model.skus, function(index, sku){
					    	    		newOption = "<option " + methods._generateProductModelsSizeSelectedAttribute(parentProductObjet, model.skus, sku.id) + 
					    	    					" " + methods._generateProductModelsSizeInfoWith(parentSlickDivObject,sku) + 
					    	    					" data-content=\"<div class='size-selected " + methods._generateProductModelsSizeInfoColorParams(sku.availableQuantity) + "'><span class='sortby lib-size'>" + sku.size + 
					    	    					"</span><div class='stock-list'><span class='lib-stock'><lang class='lk_pdm-stock'> Stock </lang></span><span class='number-stock'>"+ sku.availableQuantity + 
					    	    					"</span></div></div>\">" + sku.size + "</option>";
					    	    		sizesDropDownObject.append(newOption);
				    	    		});
				    	    		
				    	    		sizesDropDownObject.attr("data-current-model-id", model.id);
				    	    		
				    	    		if(!_.isUndefined(model.defaultPriceInfo)){
				    	    			sizesDropDownObject.attr("data-is-current-model-uniform", model.defaultPriceInfo.uniformPrice);
				    	    		}
				    	    		
				    	    		sizesDropDownObject.selectpicker('refresh');
				    	    		methods.updateProductPrice();		
				    	    		
				    	    		var panoplyId = sizesDropDownObject.data("panoply-id");
				    	    		var productGroupId = sizesDropDownObject.data("product-group-id"); 
				    	    		var productId = sizesDropDownObject.data('product-id');
				    	    		$(this).PanoplyContextPlugin("updateCurrentModelSelection", panoplyId, productGroupId, productId, "", model.id);
				    	    	}
					    	});
				      }
				      
	    	    	methods.enableOrDisableAddPanoplyToCartBtn();
				      
				    });
			},
			
			/**
			 * Handles the Click event of the Add Panoply To Cart.
			 */
			addPanoplyToCart : function() {
				$('#add-panoply-to-cart').on( "click", function(e) {
					
					e.preventDefault();
					
					var itemsSelected = methods._getItemsSelected(); // Currently selected skus.
					
					//Analytics Enhanced Ecommerce AddToCart
					CUBE.Analytics.panoply.sendAddToCartForPanoply(itemsSelected);
					
					if(typeof itemsSelected !== 'undefined' && itemsSelected.length > 0){ // In Case the selections have made throw an event that conditions to add to cars are meant.
			            throwEvent(
			            		Events.CART_MULTIPLE_ITEMS_ADDED, 
			            		itemsSelected,
				            	$(this));
					} else{ // Do not allow, simply give an error message.
						displayError(Messages('bundle.conversion.zone.select.from.all.products'), csts.MAIN_ERROR, null);
					}
				});
		   },
			
		   /**
		    * Delegate for the size selector. Enables or disables the Add to Cart Controls. And Updates the prices.
		    */
			delegateMSBSizesDropDown : function(){
				$("select[id^='conversion-zone-select-picker-']").each(function (index, value) {
					$("#"+value.id).on('change', function($this) {
						methods.enableOrDisableAddPanoplyToCartBtn();
						
						methods.updateProductPrice();
					
				    });
				});
			},
			
			/**
			 * Update current IBenefit data-clicked-status and disables the previous clicked IBenefit Button data-clicked-status 
			 */
			updateClickedIBenefitButtonStatus : function(currentIBenefitBtn) {
				var allIBenefitLinks = $("a[id^='temp-bundles-button-']");
				
				if(currentIBenefitBtn && allIBenefitLinks){
					$.each(allIBenefitLinks, function (index, value) {
						if(value){
							$("#"+value.id).attr("data-clicked-status", "false");
						}
					});
					
					currentIBenefitBtn.attr("data-clicked-status", "true");
				}
			},
			
			/**
			 * Invoke the PricingPlugin to make a request to update the price for the bundle, and the curre skus selected.
			 */
			updateProductPrice : function(){
				if ($('div.modal-sidebar--bundles').length) {
					$().PricingPlugin('fetchPanoplyLatestPrice', methods._getProductSkusSelected(), ".msb__price", ".msb__total, .content-total", "bundle");
				}
			},
			
			/**
			 * Invokes function to enable or disable Add to cart controls based on all items selected.
			 */
			enableOrDisableAddPanoplyToCartBtn : function(){
				methods._enableOrDisableAddPanoplyToCartBtnWithInputs(methods._getItemsSelected());
			},
			
			/**
			 * Generate an object to send to the Panoply Pricing Service, for a current price.
			 * When one of the dropdown has not been selected, a default sku is used for pricing that product.
			 */
			_getProductSkusSelected : function(){
				var quantityOfItem = $("#spinner").val();
				var productSkus  = [];
				var item = {};
				item["@class"] = "com.decathlon.cube.commerce.pricing.api.ProductSkusRequestTO";
				
				$("select[id^='conversion-zone-select-picker-']").each(function (index, value) {
					var currentSelectedOption = $(this).find(":selected");
					var selectedDataContent = currentSelectedOption.data("content"); // Used to determine if a value was selected
					var currentProductId = "";
					var currentSkuId = "";
					var requireFromDisplay = true;
					
					if(selectedDataContent.length){ // When in the product of the bundle a sku has been selected.
						currentProductId = currentSelectedOption.data("product-id");
						currentSkuId = currentSelectedOption.data("sku-id");						
					} else{ // When in the product of the bundle a sku has not been selected. Use the default sku.
						var currentModelId = $(this).attr("data-current-model-id");
						currentProductId = $(this).data("product-id");
						requireFromDisplay = $(this).attr("data-is-current-model-uniform") === 'true';
						currentSkuId = modelIdToDefaultSkuIdMap[currentModelId];
					}
					
					if(currentProductId && currentSkuId){
						productSkus.push({
							"productId" : currentProductId,
							"skuId" : currentSkuId,
							"quantity" : 1,
							"requireFromDisplay" : !requireFromDisplay
						});
					}					
				});
				
				item.pricingCommerceItemInputTOs = productSkus;

				return item;
			},
			
			/**
			 * Enable or disable the add to cart controls, depending on wether the items have been disabled.
			 * @param itemsSelected array of skus selected.
			 */
			_enableOrDisableAddPanoplyToCartBtnWithInputs : function(itemsSelected){
				if(typeof itemsSelected !== 'undefined' && itemsSelected.length > 0 && methods._hasStockForEachSkus()){
					methods._disableCartControls(false);
				} else{
					methods._disableCartControls(true);
				}				
			},
			
			 _hasStockForEachSkus : function() {
				  var hasStockForAll = true;
				  var stocks = $("#msb-conversionzone-products-list div.msb__sizes li.selected span.number-stock");
				  
				  $.each(stocks, function(index, stock){
					  hasStockForAll = hasStockForAll && parseInt($(stock).html(), 10) > 0;
				  });
				  	  
				  return hasStockForAll;
			  },
			
			/**
			 * Enable or disable the add to cart controls using the selected items  classes.
			 * @param disabled boolean indicating whether the add to cart controls should be disabled.
			 */
			_disableCartControls : function(disabled){
				if(disabled){
					$("#add-panoply-to-cart").addClass('disabled');
				} else{
					$("#add-panoply-to-cart").removeClass('disabled');
				}
				
				$("#msb-actions-id > div > form > div > span > button").attr('disabled', disabled);
				$("#msb-actions-id > div > form > div > input").attr('disabled', disabled);
			},
			
			/**
			 * Generate an array of items {"catalogRefId","productId","quantity"} to send to the CartModifier FormHander.
			 */
			_getItemsSelected : function(){
				var quantityOfItem = $("#spinner").val();
				var itemsSelected = [];
				
				if(!quantityOfItem){
					return itemsSelected;
				}
				
				$("select[id^='conversion-zone-select-picker-']").each(function (index, value) {
					var currentSelectedOption = $(this).find(":selected");
					var selectedDataContent = currentSelectedOption.data("content"); // Used to determine if a value was selected
					var currentSelectedOptionAvailableQuantity = currentSelectedOption.data("sku-available-quantity"); // Hold current stock quantity.
					if(selectedDataContent && currentSelectedOptionAvailableQuantity && currentSelectedOptionAvailableQuantity > 0){
						itemsSelected.push({"catalogRefId" : currentSelectedOption.data("sku-id"),
										    "productId" : currentSelectedOption.data("product-id"),
										    "quantity": quantityOfItem
										  });
					} else{
						itemsSelected = [];
						return false;
					}
				});
				
				return itemsSelected;
			},
			
			/**
			 * Generate data attributes for a specific size used during user interaction with the conversion zone. 
			 */
			_generateProductModelsSizeInfoWith: function(parentSlickDivObject, skuObject){
				if(parentSlickDivObject){
					return methods._generateProductModelsSizeInfoWithParams(skuObject,parentSlickDivObject.data("product-object"),parentSlickDivObject.data("product-group-id"),parentSlickDivObject.data("panoply-id"));
				}
			},
			
			/**
			 * Generate data attributes for a specific size used during user interaction with the conversion zone
			 * based on the provided inputs.
			 */
			_generateProductModelsSizeInfoWithParams : function(skuObject, productObject, productGroupId, panoplyId) {
				var productModelsSizeInfo = "data-sku-available-quantity='" + skuObject.availableQuantity + "'" + "data-sku-id='" + skuObject.id + "' data-product-id='" + productObject.id + "' data-product-group-id='" + productGroupId + "' data-panoply-id='" + panoplyId + "'";
				return productModelsSizeInfo;
			},

			/**
			 * Generate the selected attribute for an option in the sizes available.
			 */
			_generateProductModelsSizeSelectedAttribute : function(currentProductObject, currentModelSkus, currentSkuId){
				if(!currentProductObject || !currentSkuId){
					return "";
				}
				
				if(currentProductObject.selectedSkuId){
					if(currentProductObject.selectedSkuId == currentSkuId){
						return "selected='selected'";
					}
				}
				
				if(currentModelSkus){
					if(currentModelSkus.length == 1){
						return "selected='selected'";
					}
				}
				
				return "";
			},

			_generateProductModelsSizeInfoColorParams : function(sku){
				if(sku === 0){
					return 'valred';
				}else{
					return 'valgreen';
				}
			},
			
			_ajaxReloadConversionZoneCartridgeError : function($this, jqXHR, textStatus,
					errorThrown) {
				logError('ajaxReloadConversionZoneCartridge error !');
			},
			
			/**
			 * Refreshes all selectPicker that all ids starts with the startsWithString specified string,
			 * after reloading the conversion zone cartridge.
			 */
			_refreshSelectPicker : function(startsWithString){
				if(startsWithString){
					var allSelectConversionZonePicker = $(startsWithString);
					if(allSelectConversionZonePicker){
						$.each(allSelectConversionZonePicker, function (index, value) {
							if(value){
								$("#"+value.id).selectpicker('refresh');
							}
						});
					}
					
					methods.enableOrDisableAddPanoplyToCartBtn();					
				}
			}
			

		};

		// Plugin entry point
		$.fn.ConversionZonePlugin = basePlugin(methods, csts.NAME);
	})(jQuery);
	
	 function bindIBenefitLinksToConversionZoneReload (){
		var allIBenefitLinks = $("a[id^='temp-bundles-button-']");
		
		if(allIBenefitLinks){
			$.each(allIBenefitLinks, function (index, value) {
				if(value){
					$("#"+value.id).unbind('click').ConversionZonePlugin().click(function() {
					  (function($this) {
					      $this.ConversionZonePlugin('ajaxReloadConversionZoneCartridge');
					  })(jQuery(this));
				    });
				}
			});
		}
	 }
	 
	 /**
	  * Used to invoke conversion zone involved cartridges function, 
	  * when page loads and a currentPanoply had already been set.
	  */
	 function invokePluginsMethodsOnReady (){
	  (function($this) {
		  $this.ConversionZonePlugin('delegateMsbColorCarousel');
		  $this.ConversionZonePlugin('delegateMSBSizesDropDown');
	      $this.ConversionZonePlugin('addPanoplyToCart');
	      $this.ConversionZonePlugin('enableOrDisableAddPanoplyToCartBtn');
	      $this.ConversionZonePlugin('initializeCurrentPanoplyModelIdToDefaultSkuIdMap');
	      $this.ConversionZonePlugin('updateProductPrice');
	  })(jQuery(this));
     }
	  
	$(document).ready(function(){
		bindIBenefitLinksToConversionZoneReload();
		invokePluginsMethodsOnReady();
	});

};
/* panoplyContextModule */
panoplyContextModule.prototype = new RegistredModule();
panoplyContextModule.prototype.constructor = panoplyContextModule;

function panoplyContextModule() {
	this.selector = '#conversion-zone-container';
}


panoplyContextModule.prototype.loadingBusiness = function() {
	(function($) {
		// Plugin constants
		var csts = {
			// Plugin identifier
			NAME : 'PanoplyContextPlugin',
			MAIN_ERROR: 'mainError'
		};

		var actors = {
				PANOPLY_CONTEXT_ACTOR:'rest/model/com/decathlon/cube/commerce/panoplycontext/PanoplyContextActor'	
			};
		
		var methods = {
			// Initialize function, i.e plugin constructor.
			init : function(options) {

				return this.each(function() {
				});
			},

			/**
			 * Invokes the Panoply Context Actor to update current user's panoply's selections.
			 */
			_updateCurrentSkuSelection : function($this, panoplySelectionUpdateInputTO) {
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.PANOPLY_CONTEXT_ACTOR+"/updateCurrentPanoplySelection")
					.withParameter('panoplySelectionUpdateInputTO', JSON.stringify(panoplySelectionUpdateInputTO))
					.withSuccess(methods._updateCurrentPanoplyQuantitySuccess)
					.call();
			},
			
			/**
			 * Bundle type panoply update cureent's panoply' s users sku selections.
			 */
			updateCurrentSkuSelection : function() {
		    	var selectedOption = $(this).find(':selected');
		    	var panoplyId = $(this).data("panoply-id");
		    	var productGroupId = $(this).data("product-group-id");
		    	var productId = selectedOption.data('product-id');
		    	var skuId = selectedOption.data('sku-id');	
		    	var panoplySelectionUpdateInputTO = methods._createPanoplySelectionUpdateInputTO(panoplyId, productGroupId, productId, skuId, 0, "", "", "");
		    	methods._updateCurrentSkuSelection($(this), panoplySelectionUpdateInputTO);
			},
			
			/**
			 * Bundle type panoply update current's panoply' s users models selections.
			 */
			updateCurrentModelSelection : function(panoplyId, productGroupId, productId, skuId, modelId){
				var panoplySelectionUpdateInputTO = methods._createPanoplySelectionUpdateInputTO(panoplyId, productGroupId, productId, skuId, 1, modelId, "", "");
				methods._updateCurrentSkuSelection($(this), panoplySelectionUpdateInputTO);
			},
			
			/**
			 * Set type panoply update current's panoply users selections.
			 */
			updateSetTypePanoplySelection : function(panoplyId, productGroupId, productId, skuId, skuQuantity,  modelId, previousModelId, previousSkuId){
				var panoplySelectionUpdateInputTO = methods._createPanoplySelectionUpdateInputTO(panoplyId, productGroupId, productId, skuId, skuQuantity, modelId, previousModelId, previousSkuId);
				methods._updateCurrentSkuSelection($(this), panoplySelectionUpdateInputTO);
			},
			
			/**
			 * Update current panoply' quantity selections.
			 */
			updateCurrentPanoplyQuantity : function(currentLine) {	
				var quantityOfItem = $("#spinner").val(); // Quantity of Panoplies to be added
				
				// Check parameters
				getAjaxHandler()
					.withCaller($(this))
					.withUrl(actors.PANOPLY_CONTEXT_ACTOR+"/updateQuantity")
					.withParameter('selectedQuantity', quantityOfItem)
					.withSuccess(methods._updateCurrentPanoplyQuantitySuccess)
					.call();
			},
			
			/**
			 * Create a PanoplySelectionUpdateInputTO object to send input parameters to the Panoply Context Actor.
			 */
			_createPanoplySelectionUpdateInputTO : function(panoplyId, productGroupId, productId, skuId, skuQuantity, modelId, previousModelId, previousSkuId){
				var panoplySelectionUpdateInputTO = {
					"panoplyId":panoplyId,
					"productGroupId":productGroupId,
				    "productId":productId,
				    "skuId":skuId,
					"skuQuantity":skuQuantity,
				    "modelId":modelId,
					"previousModelId":previousModelId,
					"previousSkuId":previousSkuId
				};
				
				//panoplySelectionUpdateInputTO["@class"] = "com.decathlon.cube.commerce.catalog.panoply.to.PanoplySelectionUpdateInputTO"
				
				return panoplySelectionUpdateInputTO;
			},
			
			_updateCurrentPanoplyQuantitySuccess : function($this, result, input) {
				var selectedQuantity = result.responseTO.selectedQuantity === null ? 0 :  result.responseTO.selectedQuantity
				$().ProductConversionPlugin('updateClosenessQualifier', selectedQuantity, result.responseTO.quantityNeededToQualify, ".set-sidebar .ms__sub_header");
			},
		};

		// Plugin entry point
		$.fn.PanoplyContextPlugin = basePlugin(methods, csts.NAME);
	})(jQuery);  

	$(document).on('change', '#msb-actions-id input', function($this) {
        (function($this) {
            $this.PanoplyContextPlugin('updateCurrentPanoplyQuantity');
        })(jQuery(this));
    });
    
	$(document).on('click', '#msb-actions-id button', function($this) {
        (function($this) {
            $this.PanoplyContextPlugin('updateCurrentPanoplyQuantity');
        })(jQuery(this));
    });
	
    $(document).on('change', "select[id^='conversion-zone-select-picker-']", function($this){
        (function($this) {
            $this.PanoplyContextPlugin('updateCurrentSkuSelection');
        })(jQuery(this));
	});
};
var AccountUtils = {

		_displayGeneralError : function(message) {
			$('body').pushAlert({
				text : message,
				type : 'danger',
				icon : 'bell'
			});
		},

		_displayGeneralInformation : function(message) {
			$('body').pushAlert({
				text : message,
				type : 'info',
				icon : 'bell'
			});
		},

		_displayGeneralSuccess : function() {
			$('body').pushAlert({
				text : Messages('profile.changesSaved'),
				type : 'success',
				icon : 'bell'
			});
		},

		// présent dans loginmodule et lostPasswordModule
		_showLoginError : function(field, valueArray) {
			if (field == "generic") {
				$("#error-container").removeClass("hide");
				$("div #errorContent").append(valueArray);
			} else {
				$("#" + field + "-error").parents(':eq(1)').addClass(
						"has-error");
				$("#" + field + "-error").append(valueArray);
			}
		},

		_showError : function(field, valueArray) {
			var errorLabel = $("<label></label>").attr("role", "alert").text(
					valueArray).addClass("alert alert-danger");
			if (field == "generic") {
				$("div #errorContent").append(errorLabel);
			} else {
				$("." + field + "-error").append(errorLabel);
			}
		},

		_clearError : function() {
			$('label.alert').remove();
			$("div #errorContent").empty();
		},

		_clearGenericError : function() {
			$("#error-container").addClass("hide");
			$("div #errorContent").empty();
		},

		_clearFieldErrors : function(formId) {
			var formGroupsSelector = "#" + formId + " .form-group";
			$(formGroupsSelector).removeClass("has-error");
			var errorsFieldSelector = "#" + formId + " .hideable";
			$(errorsFieldSelector).addClass("hide");
		},

		_showFieldErrors : function(fieldGroupId, messageToDisplay) {
			$("#" + fieldGroupId).addClass("has-error");
			$("#" + messageToDisplay).removeClass("hide");
		},

		_reloadHeaderMyAccountSuccessError : function() {
			$('#dropdown-account').uxHeaderDropdownFunctions();
			UxHeaderFunctions.ellipseCustomersName();
		},

		_enableFormBtn : function($form) {
			// Re-enable buttons
			$form.find('.loading-icon').remove();
			$form.find('[type="submit"]').prop("disabled", false);
			$form.find('[type="submit"]').removeClass("disabled");
		},

		_disabledFormBtn: function($submitBtn) {
			$submitBtn.prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" /> ');
			// Disable submit buttons
			$submitBtn.prop("disabled", true);
			$submitBtn.addClass("disabled");
		},

		_validateLogin : function(login) {
			return this._validateEmail(login) || this._validatePhone(login);
		},

		_validateEmail : function(email) {
			var emailValidator = /^(?!.{41})[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+((\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)?)+@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z\-]*[a-zA-Z])?$/i;
			return emailValidator.test(email);
		},

		_validatePhone : function(phone) {
			var phoneValidator = /1[0-9]{10}$/i;
			return phoneValidator.test(phone);
		},

		_checkIfErrors : function($this, result) {

			if (result.responseTO.errors.length > 0) {
				var errors = result.responseTO.errors;
				for ( var i in errors) {
					_displayGeneralError(errors[i].message);
					$this.show();
				}
			}
		},

		_isEmail : function(value) {
			return /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
					.test(value);
		},

		_pushAccountAlert : function(type, icon, text) {
			$('body').pushAlert({
				type : type,
				icon : icon,
				text : text,
				delay : 0
			});
		},
		
        _countryCodeChanged : function(option){
        	var exemple = option.attr("example");
        	var regex = option.attr("regex");

        	if(exemple) {
        		$(".phone-example-group").show();
        		$(".phoneExample").html(exemple);
        	} else {
        		$(".phone-example-group").hide();
        	}
        	$(".phoneExample").html(exemple);
        	$("#phone").attr("pattern",regex);
        },
        
	};
geoDataModule.prototype = new RegistredModule();
geoDataModule.prototype.constructor = geoDataModule;

function geoDataModule() {
	this.selector = '.selectpicker.geodata';

}

geoDataModule.prototype.loadingBusiness = function() {

};
myLanguageModule.prototype = new RegistredModule();
myLanguageModule.prototype.constructor = myLanguageModule;

function myLanguageModule() {
	this.selector = '#mylanguage-page';
}

myLanguageModule.prototype.loadingBusiness = function() {

	
	  //Prefered language page
    var preferedLanguageEvents = function(){
    	$("form#updatePreferedLanguage").hide();
        $('.selectpicker').selectpicker('render');
        $('.selectpicker').selectpicker('refresh');
        
        var openPreferedLanguageForm = function(e) {
            e.preventDefault();
            $('form#updatePreferedLanguage').show();
            $('.preferedLanguageInformationsAndAction').hide();
        };
        
        var closePreferedLanguageForm = function(e){
        	e.preventDefault();
            $('form#updatePreferedLanguage').hide();
            $('.preferedLanguageInformationsAndAction').show();
            $('form#updatePreferedLanguage')[0].reset(); 
            $('form#updatePreferedLanguage .selectpicker').selectpicker('refresh');
        };

		 var updateUserPreferedLanguageResponse = function($this, response, params) {
	
				if (response[0] !== null && response[0].responseTO !== null && response[0].responseTO !== undefined && response[0].responseTO.errors.length > 0) {
				    AccountUtils._displayGeneralError(response[0].responseTO.errors[0].message);
			        $this.show();
			        AccountUtils._enableFormBtn($($this));

			    } else {
			    	AccountUtils._displayGeneralSuccess();
		            preferedLanguageEvents();
		      
			    }
			};
        $("#editPreferedLanguage").on('click', openPreferedLanguageForm);
        $("#cancelPreferedLanguageForm").on('click', closePreferedLanguageForm);
        $('form#updatePreferedLanguage').handleform('init', { successCb: updateUserPreferedLanguageResponse });
    };
    
    preferedLanguageEvents();
	
	
};

mySubscriptionsModule.prototype = new RegistredModule();
mySubscriptionsModule.prototype.constructor = mySubscriptionsModule;

function mySubscriptionsModule() {

	this.selector = '#mysubscriptions-page';

}


mySubscriptionsModule.prototype.loadingBusiness = function() {
	
	var csts={
		     NAME: 'MySubscriptionsPlugin',
			SET_DECATHLON_OPTIN: 'rest/model/atg/userprofiling/ProfileActor/setUserOptin'
				
			};
	

    var methods = {

        // Initialize function, i.e plugin constructor.
        init: function(options) {

            return this.each(function() {

                var $this = $(this),
                    data = $this.data(csts.NAME);

                if (undefined === data) {

                    // Plugin cache & configuration content
                    data = {};

                    // Extends configuration with provided options if exist.
                    if (undefined !== options) {
                        $.extend(data, options);
                    }

                    // Stores configuration
                    $this.data(csts.NAME, data);
                }
            });
        },

    setUserOptin: function() {
        var $this=$(this);
        var radioButton = $('input[name=subscriptionRadio]:checked', '#mysubscriptions-form').val();
        if (radioButton == "no") {
            $("#unsubscribe-modal").modal("show");
        } else if (radioButton == "yes") {
            var message = Messages("mysubscriptions.dashboard.subscriptionConfirmation");
            setOptinWithModal(true, message);
        }
    },
    
	};

    // Plugin entry point
    $.fn.MySubscriptionsPlugin = basePlugin(methods, csts.NAME);
	
	  var addEventsOnOptins = function() {
        $('input[type=radio][name=subscriptionRadio]').MySubscriptionsPlugin()
        .on('change', function() {
            (function($this) {
            $this.MySubscriptionsPlugin("setUserOptin");
            })(jQuery(this));
         });

         $("#validate-button", "#unsubscribe-modal").on("click", function(e) {
             e.preventDefault();
             $("#unsubscribe-modal", '#mysubscription-modal-container').modal("hide");
             var message = Messages("mysubscriptions.dashboard.unsubscriptionConfirmation");
             setOptinWithModal(false, message);
         });
         $("#cancel-button", "#unsubscribe-modal").on("click", function(e) {
             e.preventDefault();
             $("#unsubscribe-modal").modal("hide");
             $('input[type=radio][name=subscriptionRadio][id=optin_radio]').prop('checked', true);
         });
    };

    var setOptinWithModal = function(hasSubscribed, message) {
        successCallBack = function() {
             var messageContainer = $("#message-conf-container", "#confirmation-modal");
             messageContainer.empty();
             messageContainer.append(message);
             $("#confirmation-modal", '#mysubscription-modal-container').modal("show");
         };
         ajaxCall(
             $('#mysubscriptions-form'),
             csts.SET_DECATHLON_OPTIN,
             {'optin' : hasSubscribed},
             successCallBack);
    };

    addEventsOnOptins();
};

myAddressBookModule.prototype = new RegistredModule();
myAddressBookModule.prototype.constructor = myAddressBookModule;

function myAddressBookModule() {
	this.selector = '#address-book';

}

myAddressBookModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MyAddressBookPlugin',
        ADD_SHIPPING_ADDRESS: 'account/addShippingAddress',
        
        SET_PREFERED_ADDRESS: 'account/selectPreferedShippingAddress',
        GET_GEO_DATA_BY_POSTAL_CODE: 'rest/model/com/decathlon/cube/geodata/actor/GeoDataActor/getGeoDataByPostalCode'
      };

    var methods = {

        // Initialize function, i.e plugin constructor.
        init: function(options) {

            return this.each(function() {

                var $this = $(this),
                    data = $this.data(csts.NAME);

                if (undefined === data) {

                    // Plugin cache & configuration content
                    data = {};

                    // Extends configuration with provided options if exist.
                    if (undefined !== options) {
                        $.extend(data, options);
                    }

                    // Stores configuration
                    $this.data(csts.NAME, data);
                }
            });
        },

        // ----- Public methods -----


        reloadAddressBook: function() {
        	var $this = $(this);
        	reloadCartridgeContentCollection(
                    $this,
                    'address-book',
                     {},
                     methods._loadAddressBookSuccess,
                     methods._addressBookError);
        },

        
        addShipingAddress: function() {
            var $this = $(this);
            var disabled = $('#address-book').find(':input:disabled').removeAttr('disabled');
            var params = $('#address-book :input').serialize();
            disabled.attr('disabled','disabled');

            ajaxCall(
                $this,
                csts.ADD_SHIPPING_ADDRESS,
                params,
                methods._addShipingAddressSuccess);
        },

        setPreferedAddress: function() {
            var $this = $(this);
                params = {'idAddress' : $('input[name="favoriteRadioButton"]:checked').data('address-id') };

            ajaxCall(
                $this,
                csts.SET_PREFERED_ADDRESS,
                params,
                methods._setPreferedAddressSuccess,
                methods._setPreferedAddressError);
        },

        deleteShippingAddress: function() {
            var $this = $(this),
            params = { 'addressIdToDelete': $this.data().addressid, 'contentCollection': $('#address-book').attr("t-url") };
            $(".modal-delete-address").modal("hide");

            reloadCartridgeFromActor(
                    $this,
                    'address-book',
                     params,
                     methods._deleteShippingAddressSuccess,
                     methods._addressBookError);
        },

        modifyShippingAddress: function() {
            var $this = $(this);
            
            params = { 'addressId': $this.data().addressid };

            reloadCartridgeContentCollection(
                    $this,
                    'address-book',
                     params,
                     methods._loadShippingAddressSuccess);
        },

        addressBookEvents: function(){
        	addressBookEvents();
        },

        _deleteShippingAddressSuccess: function($this, response) {
            if(!resultHasErrors(response[0])){
                 AccountUtils._displayGeneralSuccess();
            }
            methods._loadAddressBookSuccess($this, response);

        },
        
        _loadAddressBookSuccess: function($this, response) {
            $("#address-book-list").show();
            $("#add-address-container").hide();
            addressBookEvents();
            if (resultHasErrors(response[0])) {
                $.each(response[0].responseTO.errors, function(index, valueArray) {
                     AccountUtils._pushAccountAlert('danger','bell', valueArray.message);
                });
            }
        },


        _addressBookError: function($this, response) {
            $('.modal-backdrop').remove();
            $this.modal('hide');
            if (resultHasErrors(response[0])) {
                $.each(response[0].responseTO.errors, function(index, valueArray) {
                    methods._pushAccountAlert('danger','bell', valueArray.message);
                });
            }
        },
         _loadShippingAddressSuccess: function(caller, data) {

        	 $("#address-book-list").hide();
             $("#add-address-container").show();
             $("#postcode").trigger('keyup');
             if($("#isValid").val() == "false") {
             	AccountUtils._displayGeneralError(Messages("addressbook.modifyInvalidAddress"));
             }
             addressBookEvents();
         },

      
        
        _setPreferedAddressSuccess: function($this, result) {
             AccountUtils._clearError();
            if (resultHasErrors(result)) {
                 AccountUtils._displayGeneralError(result.responseTO.errors[0].message);
            } else {
                 AccountUtils._displayGeneralSuccess();
            }
            reloadCartridgeContentCollection(
                    $this,
                    'address-book',
                     {},
                     methods._loadAddressBookSuccess,
                     methods._addressBookError);
        },

        _setPreferedAddressError: function($this, result) {

        },

        
        
        _addShipingAddressSuccess: function($this, result) {
            //location.reload();
        },
        
        _addShipingAddressError: function($this, jqXHR, textStatus, errorThrown) {

            logError('Add shipping address error !');
        },
        
        countryCodeChanged : function(option){
        	var exemple = option.attr("example");
        	var regex = option.attr("regex");

        	if(exemple) {
        		$(".phone-example-group").show();
        		$(".phoneExample").html(exemple);
        	} else {
        		$(".phone-example-group").hide();
        	}
        	$(".phoneExample").html(exemple);
        	$("#mobile").attr("pattern",regex);
        },



        _resetPostalCodeForm :function(){
        	$("#cityname").prop("disabled", false);
        	$("#streetname").prop("disabled", false);
        	$("#postcode,#streetnumber").removeClass("validData");
        },

    };
    
    $.fn.MyAddressBookPlugin = basePlugin(methods, csts.NAME);


    var validationPluginOpts = $.validator.cubeOptions;

    var addressDetailsSuccessCb = function($form, result) {
        var $this = $(this);

        if(!resultHasErrors(result[0])){
             AccountUtils._displayGeneralSuccess();
             CUBE.Analytics.queue.send('adressBookValidation');
        }

        reloadCartridgeContentCollection(
                $this,
                'address-book',
                 {},
                 methods._loadAddressBookSuccess,
                 methods._addressBookError);
        
        reloadCartridgeContentCollection(
                $(this), 
                'header-my-account',
                {},
                function() { $('#dropdown-account').uxHeaderDropdownFunctions(); });
    };

    var addressBookEvents = function() {
        $("input[type='radio'][name='favoriteRadioButton']").on('change',function() {
            (function($this) {
                $this.MyAddressBookPlugin('setPreferedAddress');
            })($(this));
        });
        $('.confirm-deletion').MyAddressBookPlugin().on('click',function(e) {
          e.preventDefault();
          $(this).MyAddressBookPlugin('deleteShippingAddress');
        });
        $('.modify-item.account').MyAddressBookPlugin().on('click',function(e) {
            e.preventDefault();
            $(this).MyAddressBookPlugin('modifyShippingAddress');
        });
        $(".add-address-btn").on('click',function() {
        	$("#address-book-empty-list").hide();
            $("#address-book-list").hide();
            $("#add-address-container").show();
        });
        $("#back-address-book-btn").on('click',function() {
            (function($this) {
            	$this.MyAddressBookPlugin('reloadAddressBook');
            })($(this));
        });
        $('.selectpicker').selectpicker('render');
        $('.selectpicker').selectpicker('refresh');
        new geoDataModule().loadingBusiness();
       // geoDataEvents();
      
        $('#address-details-form').validate( $.extend(null, validationPluginOpts, {
            ignore:"",
            rules: {
                title: {
                    required: true,
                    notEqualToTab: $('#address-details-form #title').data("unauthorized"),
                    extendedalphanumeric: true
                },
                name: "extendedalphanumeric"
            },
            messages: {
                name: {
                    required: Messages("shippingAddress.error.nameRequired")
                },
                mobile: {
                    required: Messages("shippingAddress.error.mobileRequired")
                },
                streetName: {
                    required: Messages("shippingAddress.error.streetNameRequired")
                },
                title: {
                    required: Messages("shippingAddress.error.titleRequired")
                }
            }
        }));

        jQuery.validator.addMethod("notEqualToTab",
                function(value, element, param) {
            var notEqual = true;
            value = $.trim(value);
            for (i = 0; i < param.length; i++) {
                if (value == param[i]) { notEqual = false; }
            }
            return this.optional(element) || notEqual;
        },
        	Messages("shippingAddress.error.labelexists")
        );
        $('#address-details-form').handleform('init', { successCb: addressDetailsSuccessCb });
        $('.cancel-deletion').on('click', function(e){
            $('.close-modal').trigger('click');
          });
        
        
        
        $(".selectpicker").change(function(elem){
        	var option = $(elem.target).find("option:selected");
        	methods.countryCodeChanged(option);
        	});
        
        methods.countryCodeChanged($("select[name=mobileCountryCode]").find("option:selected"));
        
    	    $("#countryCodeGeoId").change(function(){
    	    	if(genericAddressFormModule.getAddressConfigByCountry){
    	    		genericAddressFormModule.getAddressConfigByCountry($(this).val());
    	    	}
    	    });
    	    
    	    genericAddressFormModule.getAddressConfigByCountry($("#countryCodeGeoId").val());
    };

    
    $(function(){
        addressBookEvents();
    });
};

myProfileModule.prototype = new RegistredModule();
myProfileModule.prototype.constructor = myProfileModule;

function myProfileModule() {
	this.selector = '#profileData';
}

myProfileModule.prototype.loadingBusiness = function() {
	
    var csts = {
    		 NAME: 'MyProfilePlugin',
    		 SEND_VERIFICATION_CODE_UPDATE: 'rest/model/atg/userprofiling/ProfileActor/sendVerificationCodeUpdate',
    	        UPDATE_LOGIN_INFORMATION_URL: 'rest/model/atg/userprofiling/ProfileActor/updateLoginInformation-mobileValidation',
    	        UPDATE_PASSWORD_URL: 'updatePassword',
    	        SUBMIT_UPDATE_PASSWORD: 'rest/model/atg/userprofiling/ProfileActor/updatePassword',
    	        GET_GEO_DATA_BY_POSTAL_CODE: 'rest/model/com/decathlon/cube/geodata/actor/GeoDataActor/getGeoDataByPostalCode'
    };
    
    var methods={
            updateLoginInformation: function() {
                var $this = $(this),
                    params = {
                		'mobile': $('form#send-code #mobile').val(),
                		'mobileCountryCode': $('form#send-code #mobileCountryCode').children(':selected').val(),
                		'email' : $('#login').val(),
                		'verificationCode' : $('#verificationCode').val()
                	};

                ajaxCall(
                    $this,
                    csts.UPDATE_LOGIN_INFORMATION_URL,
                    params,
                    methods._updateLoginInformationSuccess,
                    methods._updateLoginInformationSuccess
                );
            },

    		
    		_updateLoginInformationSuccess : function($this, response) {
    			if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
    				      $('#verification-code .form-group')
    				        .removeClass('has-notif')
    				        .addClass('has-error')
    	              .find('.form-help .text')
    	              .text(response.responseTO.errors[0].message);
    			} else if (response.responseTO.data){
    	            $('#verification-code .form-group')
    	              .removeClass('has-error')
    	              .addClass('has-notif')
  	                .find('.form-help .text')
  	                .text(Messages('profile.changesSaved'));

    	            $.fn.MyProfilePlugin('doRedirectOnLogin');
    			}
    		},
        	_sendVerificationUpdateCodeSuccess : function($this, response) {
    			var result = response.responseTO.data;
    			if (result) {
    			    $('.resendCode').data('countdown').go();
    			    AccountUtils._displayGeneralInformation(Messages('profile.smsSent'));
                    $('div.verificationCodeForm').show();
    			} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
    				 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
    			}
    		},

            _findGeoDataByPostalCode : function(postalCode, streetNumber){
            	var url = csts.GET_GEO_DATA_BY_POSTAL_CODE+ "?postalCode="+postalCode+"&streetNumber="+streetNumber;
            	ajaxCall(
            			$(this),
            			url,
                        null, function($this, result){methods._updateGeoDataInformation(result.responseTO.data);}, function(e){console.log("error");});

            },
            
            _updateGeoDataInformation : function(data){
            	if(!$.isEmptyObject(data)){
            		$("#postcode,#streetnumber").addClass("validData");
            	}
            	
            	if(data.city !== null){
            		$("#cityname").val(data.city.label).prop("disabled", true);
            	}
            	if(data.streetName !== null){
            		$("#streetname").val(data.streetName.label).prop("disabled", true);
            	}
            	
            	 
            },
            sendVerificationCodeUpdate: function() {
                var $this = $(this),
                    params = { 'mobile': $('[name="mobile"]').val(), 'mobileCountryCode': $('[name="mobileCountryCode"]').children(':selected').val() };

                ajaxCall(
                    $this,
                    csts.SEND_VERIFICATION_CODE_UPDATE,
                    params,
                    methods._sendVerificationUpdateCodeSuccess,
                    methods._sendVerificationUpdateCodeSuccess
                );
            },

            storeOpenedInfosContentsBlocks: function(){
            	localStorage.removeItem("openedInfosContents");
            	
            	$('.infos-content').each(function(index, element) {
            		var style = $(this).attr('style');
            		var id = $(this).attr('id');
            		
            		if(style !== undefined && $(this).is(':hidden')){
            			
            			var localStorageInfoContents = localStorage.getItem("openedInfosContents");
            			
            			if(localStorageInfoContents === null){
            				id = id + ";";
            			} else {
            				id = localStorageInfoContents + id + ";";
            			}
            			
            			localStorage.setItem("openedInfosContents",id);
            		}
            	});
            },
            
            openInfosContentsBlocks: function(){
    	    	var localStorageInfoContents = localStorage.getItem("openedInfosContents");
    	    	
    	    	if(localStorageInfoContents !== null){
    	    		var split = localStorageInfoContents.split(";");
    	    		
    	    		if(split !== null){
    			       for (var i = 0; i < split.length; i++) {
    			           if(split[i] !== null && split[i].length > 0){
    			        	   $("#"+split[i]).parent().find(".edit-options").find("a")[0].click();
    			           }
    			         }
    	    		}
    	    	}
    	    	
    	    	localStorage.removeItem("openedInfosContents");
            },
            
            initHomeAddressEvents: function(){
            	// Init country code at page loading
            	$.fn.MyProfilePlugin('changeCountryCode');
            	
            	// Init phone country code
                AccountUtils._countryCodeChanged($("form#updateHomeAddress select[name=mobileCountryCode]").find("option:selected"));
                
                $('#updateHomeAddressButton').unbind('click');
                $('#updateHomeAddressButton').click(function (e) {
                    e.preventDefault();
                    
                    AccountUtils._enableFormBtn($('form#updateHomeAddress'));
                    
                    if(!$('#addInAddressBook').is(':checked')){
                    	$('form#updateHomeAddress #name').val('');
                    	$('form#updateHomeAddress #phone').val('');
                    	$('form#updateHomeAddress #title').val('');
                    	$('form#updateHomeAddress #name').val('');
                    	$('form#updateHomeAddress #surname').val('');
                    }
                    
            		$('form#updateHomeAddress').validate($.extend(null, validationPluginOpts, {
                        ignore: "",
                        onkeyup: false,
                        rules: {
                            title: {
                            	required: false,
                                extendedalphanumeric: true
                            },
                            name: {
                            	extendedalphanumeric: true,
                            	required: false
                            },
                            surname: {
                            	extendedalphanumeric: true,
                            	required: false
                            },
                            mobileCountryCode: {
                            	required: false                     	
                            },
                            mobile: {
                            	digits: true,
        		                mobile: {
        			                  countryCodeSelector: '[name="mobileCountryCode"]'
        		                },
                            	required: false
                            }
                        },
                        messages: {
                            name: {
                                required: Messages("shippingAddress.error.nameRequired")
                            },
                            mobile: {
                                required: Messages("shippingAddress.error.mobileRequired"),
                                pattern: Messages("validationMsg.mobile")
                            },
                            streetName: {
                                required: Messages("shippingAddress.error.streetNameRequired")
                            },
                            title: {
                                required: Messages("shippingAddress.error.titleRequired")
                            }
                        }
                        
                    }));
            		
            		if($(".add-address [name='title']").length) {
            			$(".add-address [name='title']").rules('add', {required: $('#addInAddressBook').is(':checked')});
            		}
            		if($(".add-address [name='name']").length) {
            			$(".add-address [name='name']").rules('add', {required: $('#addInAddressBook').is(':checked')});
            		}
            		if($(".add-address [name='surname']").length) {
            			$(".add-address [name='surname']").rules('add', {required: $('#addInAddressBook').is(':checked')});
            		}
            		if($(".add-address [name='mobileCountryCode']").length) {
            			$(".add-address [name='mobileCountryCode']").rules('add', {required: $('#addInAddressBook').is(':checked')});
            		}
            		if($(".add-address [name='mobile']").length) {
            			$(".add-address [name='mobile']").rules('add', {required: $('#addInAddressBook').is(':checked')});
            		}
            		
            		
                    var updateHomeAddress = $('form#updateHomeAddress');
                    if(updateHomeAddress.valid()){
                    	updateHomeAddress.submit();
                	} 
                });
            },
            
            changeCountryCode: function() {
            	
            	// Change address country code
	        	var countryCodeIdSelectedValue = $("form#updateHomeAddress select[name=countryCodeGeoId]").find("option:selected").val();
	        	
	        	var countriesIdForShippingAddress = JSON.parse($("#countriesIdForShippingAddress").text());
	        	
	        	if(jQuery.inArray(countryCodeIdSelectedValue, countriesIdForShippingAddress) !== -1){
	        		$("#addInAddressBookCheckbox").show();
	        	} else {
	        		$("#addInAddressBookCheckbox").hide();
	        		$("#complementaryDataForShippingAddress").hide();
	        		$("#addInAddressBook").prop('checked', false);
	        	}
	        	
                $('#addInAddressBook').click(function () {
                    if($('#addInAddressBook').is(':checked')){
                    	$('#complementaryDataForShippingAddress').show();
                    } else {
                    	$('#complementaryDataForShippingAddress').hide();
                    }
                });
            }
    };
    
    $.fn.MyProfilePlugin = basePlugin(methods, csts.NAME);
    //Customer details page
    var personalDataEvents = function() {

		    $("#countryCodeGeoId").change(function(){
		    	if(genericAddressFormModule.getAddressConfigByCountry){
		    		genericAddressFormModule.getAddressConfigByCountry($(this).val(),"BILLING");
		    	}
		    	$.fn.MyProfilePlugin('changeCountryCode');
		    });
		    
		    if(genericAddressFormModule.getAddressConfigByCountry){
		    	genericAddressFormModule.getAddressConfigByCountry($("#countryCodeGeoId").val(),"BILLING");
		    }
		    
            $("form#updateLoginInformation").hide();
            $("form#updatePassword").hide();
            $("form#customer-identity-form").hide();
            $('form#updateHomeAddress .selectpicker').selectpicker('refresh');
            $('form#updateLoginInformation .selectpicker').selectpicker('refresh');
            $('form#customer-identity-form .selectpicker').selectpicker('refresh');

            var passwordResponse = function($this, response, params) {
    			if (response === null || response === undefined || response.responseTO === null || response.responseTO === undefined) {
    				AccountUtils._displayGeneralError(Messages("error.oc.call"));
    				AccountUtils._enableFormBtn($($this));
    				return false;
    			}
    			
            	if (response.responseTO.errors.length > 0) {
            		var code = response.responseTO.errors[0].code;
            		var message = response.responseTO.errors[0].message;
            		var validator;
            		
            		if(code == 'account.authentication.forbiddenPassword'){
                        validator = $('#updatePassword').validate();
                        validator.showErrors({
                              "password": message
                        });
            		} else if (code == 'account.authentication.wrongPassword'){
                        validator = $('#updatePassword').validate();
                        validator.showErrors({
                              "actualPassword": message
                        });
            		} else {
            			AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
            		}
    		        $this.show();
    		    } else {
    		    	AccountUtils._displayGeneralSuccess();
    		    	localStorage.removeItem("openedInfosContents");
    		    	CUBE.Analytics.queue.send('savePassword');
		    		$("#cancelPasswordForm").trigger('click.analytics');
    		    }
            	
		        AccountUtils._enableFormBtn($($this));
    		};

            $('#updatePasswordButton').click(function(e) {
                e.preventDefault();
                
                var form = $('form#updatePassword');
                form.removeData('validator');

                AccountUtils._disabledFormBtn($(this));

                form.validate($.extend(null, validationPluginOpts, formPasswordValidator) );

                if(form.valid()){

                    var actualPassword = $('#actualPassword').val();
                    var password = $('#confirmPassword').val();

                    var params = {'actualPassword' : actualPassword, 'password' : password };

                    ajaxCall(
                       		form,
                            csts.SUBMIT_UPDATE_PASSWORD,
                            params,
                            passwordResponse,
                            passwordResponse);

                } else {
                	AccountUtils._enableFormBtn(form);
                }
            });

            var validationPluginOpts = $.validator.cubeOptions;

            var customerIdentityValidator = $('form#customer-identity-form').validate($.extend(null, validationPluginOpts, {
                rules: {
                    lastName: "extendedalphanumeric",
                    firstName: "extendedalphanumeric",
		            'mobile': {
		                digits: true,
		                required: function(element) {
		                	return $(element).closest('form').find('[name="mobile"]').hasClass('required');
		                },
		                mobile: {
		                  countryCodeSelector: '[name="mobileCountryCode"]'
		                }
		            }
                }
            }));
            
            var formValidationRulesWithPhoneUpdate = {
                rules: {
                    'mobile': {
                        digits: true,
                        required: function(element) {
          								  return $(element).closest('form').find('[name="mobile"]').hasClass('required');
          							},
          							mobile: {
                            countryCodeSelector: '[name="mobileCountryCode"]'
                        }
                    },
                    email : {
                    	  maxlength: 40,
                    }
                }
            };

            
            var loginValidator = $('form#updateLoginInformation').validate($.extend(null, validationPluginOpts, formValidationRulesWithPhoneUpdate));
            var popupMobileValidationValidator = $('form#send-code').validate($.extend(null, validationPluginOpts, formValidationRulesWithPhoneUpdate));

    		 var updateUserProfileResponse = function($this, response, params) {
    			if (response[0] !== null && response[0].responseTO !== null && response[0].responseTO !== undefined && response[0].responseTO.errors.length > 0) {
    				AccountUtils._displayGeneralError(response[0].responseTO.errors[0].message);
    		        $this.show();
    		        AccountUtils._enableFormBtn($($this));

    		    } else {
    		    	
    		    	// Analytics : Dequeue and send the good event, based on the form ID
    		    	var formId = $this.attr('id');
    		    	if (formId === "customer-identity-form") CUBE.Analytics.queue.send('saveInfoPerso');
    		    	if (formId === "updateLoginInformation") CUBE.Analytics.queue.send('saveLogin');
    		    	if (formId === "updateHomeAddress") CUBE.Analytics.queue.send('saveHomeAddress');
    		    	
    		    	localStorage.removeItem("openedInfosContents");
    		    	AccountUtils._displayGeneralSuccess();
    		        personalDataEvents();

    		        
    		        if (formId === "customer-identity-form") {
	    	            reloadCartridgeContentCollection(
	    	                    $this,
	    	                    'header-my-account',
	    	                    {},
	    	                    AccountUtils._reloadHeaderMyAccountSuccessError,
	    	                    AccountUtils._reloadHeaderMyAccountSuccessError);
	    	            reloadCartridgeContentCollection(
	    	                    $this,
	    	                    'dashboard-account-nav');
    		        }
    	                    
    		    }
    		};

    		//geoDataEvents();
    		new geoDataModule().loadingBusiness();
    		
            $('form#customer-identity-form').handleform('init', { successCb: updateUserProfileResponse });
            $('form#updateLoginInformation').handleform('init', { successCb: updateUserProfileResponse });
            $('form#updateHomeAddress').handleform('init', { successCb: updateUserProfileResponse });
            $('form#updatePassword').handleform('init', { successCb: updateUserProfileResponse });

            var openLoginForm = function(e) {
                e.preventDefault();
                
                loginValidator.settings.ignore = "*";
                
                $('#updateLoginInformation').show();
                $('#loginInformation').hide();
                $('#editLogin').hide();
                $("#requiredFieldsLogin").show();

                $('p #cancelLoginForm').show();
                if ($('span.icon.icon-ok-roll').hasClass('is-verified')) {
                    $('a.sendVerificationCodeUpdateLogin').hide();
                    $('div.sendVerificationCodeUpdateLogin').hide();
                    $('div.verificationCodeForm').hide();
                } else {
                    $('a.sendVerificationCodeUpdateLogin')
                      .show()
                      .removeClass('disabled');
                    $('div.sendVerificationCode').show();
                    $('div.verificationCodeForm').hide();
                }
                
                var mobileValid = $("span.mobile-check").hasClass("error-message");
                var emailValid = $("span.email-check").hasClass("error-message");
                
                if($("div.errorMessageEditLogin").text().trim() !== ''){
                    $('body').pushAlert({
                        type: 'danger', 
                        icon: 'bell',
                        text: $("div.errorMessageEditLogin").text()
                      });
                }
                
                if($('#mobile') !== undefined && $('#mobile').val().trim() === ''){
                	$('.sendVerificationCodeUpdateLogin').hide();
                }
            };

            var resendVerificationCode = function(e) {
                e.preventDefault();
                $.fn.MyProfilePlugin('sendVerificationCodeUpdate');
            };


            var sendVerificationCode = function(e) {
                resendVerificationCode(e);
                $('a.sendVerificationCode').hide();
            };

            var mobileChanged = function(e) {
                e.preventDefault();
                if (this.value != $("#original_mobile").val() || !$('span.icon.icon-ok-roll').hasClass('is-verified')) { 
                    $('a.sendVerificationCodeUpdateLogin').show();
                    $('div.sendVerificationCode').show();
                    $('div.verificationCodeForm').hide();
                } else {
                    $('a.sendVerificationCodeUpdateLogin').hide();
                    $('div.sendVerificationCode').hide();
                    $('div.verificationCodeForm').hide();
                }
            };
            
            
            var sendVerificationCodeUpdateLogin = function(e) {
                e.preventDefault();
                
                loginValidator.settings.ignore = "#email";
                
                if($('#mobile').valid()){
                	$.fn.MyProfilePlugin('sendVerificationCodeUpdate');
                	$('a.sendVerificationCodeUpdateLogin').hide();
                    $('div.sendVerificationCode').show();
                    $('div.verificationCodeForm').show();
                } else {
                    $('a.sendVerificationCodeUpdateLogin').show();
                    $('div.sendVerificationCode').show();
                    $('div.verificationCodeForm').hide();
                }
            };
            
            var sumbitUpdateLoginForm = function(e) {
                e.preventDefault();
                
                var $updateLoginForm = $('form#updateLoginInformation');
                
                if($updateLoginForm.find('.sendVerificationCodeUpdateLogin').is(':visible')){
                    if($updateLoginForm.find('#mobile').valid()){
                    	$('div.verificationCodeForm').show();
                    } 
                }
                
                if(!$updateLoginForm.find('#verificationCode').is(':visible')){
                	loginValidator.settings.ignore = "#verificationCode";
                } else {
                	loginValidator.settings.ignore = "";
                }
                
                if($updateLoginForm.valid()){
                  $updateLoginForm.submit();
                } 
            };

            var closeLoginForm = function(e) {
                e.preventDefault();
                loginValidator.resetForm();
                loginValidator.settings.ignore = "*";
                $('form#updateLoginInformation')[0].reset();
                $('form#updateLoginInformation .selectpicker').selectpicker('refresh');
                $('a.sendVerificationCode').removeClass('disabled');
                $('#updateLoginInformation').hide();
                $('#loginInformation').show();
                $('#editLogin').show();
                $("#requiredFieldsLogin").hide();
                $('p #cancelLoginForm').hide();
                $("a.resendCode").data('countdown').stop();
            };

            var openPasswordForm = function(e) {
                e.preventDefault();
                $('#updatePassword').show();
                $('#passwordInformation').hide();
                $('#editPassword').hide();
                $('#requiredFieldsPassword').show();
                $('p #cancelPasswordForm').show();
            };

            var closePasswordForm = function(e) {
                e.preventDefault();
                var updatePasswordForm = $('form#updatePassword');
                updatePasswordForm.validate().resetForm();
                updatePasswordForm.removeData('validator');

                $('.password-checking').find('span').removeClass('highlighted');

                updatePasswordForm.hide();
                $('#passwordInformation').show();
                $('#editPassword').show();
                $('#requiredFieldsPassword').hide();
                $('p #cancelPasswordForm').hide();

                updatePasswordForm.find(':input').each(
                	function(){
                		$(this).val('');
                	}
                );
            };

            var openPersonalDataForm = function(e) {
                e.preventDefault();
                $('#customer-identity-form').show();
                $('#personalDataInformation').hide();
                $('#editPersonalData').hide();
                $('#requiredFieldsPersonalData').show();
                $('p #cancelPersonalDataForm').show();
                
                if ($('span.icon.icon-ok-roll').hasClass('is-verified')) {
                    $('a.sendVerificationCodeUpdateLogin').hide();
                    $('div.sendVerificationCodeUpdateLogin').hide();
                    $('div.verificationCodeForm').hide();
                } else {
                    $('a.sendVerificationCodeUpdateLogin')
                      .show()
                      .removeClass('disabled');
                    $('div.sendVerificationCode').show();
                    $('div.verificationCodeForm').hide();
                }
                
                if($('#mobile') !== undefined && $('#mobile').text().trim() === ''){
                	$('.sendVerificationCodeUpdateLogin').hide();
                }
            };

            var closePersonalDataForm = function(e) {
                e.preventDefault();
                customerIdentityValidator.resetForm();
                $('form#customer-identity-form')[0].reset();
                $('#customer-identity-form').hide();
                $('#personalDataInformation').show();
                $('#editPersonalData').show();
                $('#requiredFieldsPersonalData').hide();
                $('p #cancelPersonalDataForm').hide();
                };

            var openHomeAddressForm = function(e) {
                e.preventDefault();
                $('#updateHomeAddress').show();
                $('#homeAddress').hide();
                $('p #editHomeAddress').hide();
                $('#requiredFieldsHomeAddress').show();
                $('p #cancelHomeAddressForm').show();
                $('p#invalidAddress').hide();
                if ($("#isValid").val() == "false") {
	             	AccountUtils._displayGeneralError(Messages("addressbook.modifyInvalidAddress"));
	            }
                $.fn.MyProfilePlugin('initHomeAddressEvents');
            };

            var closeHomeAddressForm = function(e) {
                e.preventDefault();
                var $updateHomeAddressForm = $('form#updateHomeAddress');
                $updateHomeAddressForm.validate().resetForm();
                $('#updateHomeAddress').hide();
                $('#homeAddress').show();
                $('p #editHomeAddress').show();
                $('#requiredFieldsHomeAddress').hide();
                $('p #cancelHomeAddressForm').hide();
                $('p#invalidAddress').show();
            };
            
            $('[name="mobileCountryCode"]').on('change', function() {
                var $input = $(this).closest('form').find('[name="mobile"]');
                if ($input.val() && $input.val().length !== 0) {
                    $input.valid();
                }
                AccountUtils._countryCodeChanged($("form#updateHomeAddress select[name=mobileCountryCode]").find("option:selected"));
            });

            $('#submitVerificationCode').on('click', function(e) {
            	e.preventDefault();
            	$.fn.MyProfilePlugin('updateLoginInformation');
            });



            $('form#send-code #mobile').on('keyup', function(e) {
            	e.preventDefault();
            	$('#verification-code').hide();
            	$('#submitSendCodeButton').show();
            });

            $("#editLogin").on('click', openLoginForm);
            $("a.sendVerificationCode").on('click', sendVerificationCode);
            $("a.resendCode").on('click', resendVerificationCode).data('countdown',  new decathlon.userAccount.Countdown($("a.resendCode"), 30));
            $("#cancelLoginForm").on('click', closeLoginForm);
            $("#editPassword").on('click', openPasswordForm);

            if($('.password-checking').length > 0){
    	        var passwordChecking =  new PasswordChecking({
    	            formGroup: $('.password-process'),
    	            formGroupConfirm: $('.password-confirm')
    	        });
            }
            
            if ($('.password-strengh-list').length > 0) {
                var passwordStrength = new PasswordStrength({
                    formGroup: $('.password-process'),
                    formGroupConfirm: $('.password-confirm')
                });
            }

            $("#cancelPasswordForm")
              .on('click', closePasswordForm)
              .on('click.analytics', closePasswordForm);
            $("#editPersonalData").on('click', openPersonalDataForm);
            $("#cancelPersonalDataForm").on('click', closePersonalDataForm);
            $("#editHomeAddress").on('click', openHomeAddressForm);
            $("#cancelHomeAddressForm").on('click', closeHomeAddressForm);
            
            var $updateLoginForm = $("form#updateLoginInformation");
            $updateLoginForm.find("#mobile").on('keyup', mobileChanged);
            $updateLoginForm.find(".sendVerificationCodeUpdateLogin").on('click', sendVerificationCodeUpdateLogin);
            $updateLoginForm.find("#sumbitUpdateLoginForm").on('click', sumbitUpdateLoginForm);
            
            var $customerIdentityForm = $('form#customer-identity-form');
            $customerIdentityForm.find("#mobile").on('keyup', mobileChanged);
            $customerIdentityForm.find(".sendVerificationCodeUpdateLogin").on('click', sendVerificationCodeUpdateLogin);
            $customerIdentityForm.find("#sumbitUpdateLoginForm").on('click', sumbitUpdateLoginForm);            

            var $dateInput = $customerIdentityForm.find('input#date');
            if($dateInput.length !== 0) {
              $dateInput.datetimepicker();
              $dateInput.data("DateTimePicker").maxDate(new Date());
              $dateInput.on("dp.change",function (e) {
                  if( $dateInput.data('DateTimePicker').date() !== null ){
                      $customerIdentityForm.find('#dateOfBirth').val($dateInput.data('DateTimePicker').date().format($('form#customer-identity-form #dateOfBirth').data("date-format")));
                  } else {
                      $customerIdentityForm.find('#dateOfBirth').val(null);
                  }
              });
            }
            
    	};

    	personalDataEvents();
    	
        //check if customer-details blocks must be reopened
        $('.edit-options').on('click', function() {
        	(function($this) {
        		$this.MyProfilePlugin('storeOpenedInfosContentsBlocks');
            })($(this));
    	});
        
        if ($('.account.dashboard').find('#profileData').length){
        	(function($this) {
        		$this.MyProfilePlugin('openInfosContentsBlocks');
            })($(this));
        }
        

        $(document).on("keyup","#postcode,#streetnumber",function(){

        	if ($("#postcode")[0].validity.valid && $("#streetnumber")[0].validity.valid) {
        		methods._findGeoDataByPostalCode($("#postcode").val(),$("#streetnumber").val());
    		  }
        	else{
        		$("#cityname").prop("disabled", false);
        		$("#streetname").prop("disabled", false);
        		$("#postcode,#streetnumber").removeClass("validData");
        	}
        });
        $("#postcode").trigger('keyup');
        
        var validationPluginOpts = $.validator.cubeOptions;
        
	    var formPasswordValidator = {
	            onsubmit: true,
	            rules: {
	                'actualPassword': {
	                    minlength:6
	                },
	                'password': {
	                	passwordCheck: true
	                },
	                'confirmPassword': {
	                    equalTo: "#password"
	                }
	            },
	            messages: {
	                actualPassword: {
	                    minlength: Messages("profile.updatePassword.newpassword.minLength"),
	                    required: Messages("profile.updatePassword.actualPassword.required")
	                },
	                password: {
	                    required: Messages("profile.updatePassword.newpassword.required"),
	                    minlength: Messages("profile.updatePassword.newpassword.minLength")
	                },
	                confirmPassword: {
	                    required: Messages("profile.updatePassword.confirmPassword.required"),
	                    minlength: Messages("profile.updatePassword.newpassword.minLength"),
	                    equalTo: Messages("profile.updatePassword.confirmPassword.equalsTo")
	                }
	            }
	     };
    	   
    	    $(function(){
    	    	$.fn.MyProfilePlugin('initHomeAddressEvents');
    	    });
};
myPurchasesModule.prototype = new RegistredModule();
myPurchasesModule.prototype.constructor = myPurchasesModule;

function myPurchasesModule() {
	this.selector = '#my-purchase';

}

myPurchasesModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MyPurchasesPlugin',
        CREATE_RETURN: Events.CREATE_RETURN,
    };

    var methods = {

            reloadPurchaseForFiltering: function() {
                var $this = $(this),
                // reloadCartridge MyPurchase from the begining
                params = { 'filter': $('#order-filter').val(),
                           'currentPage': 1 };
                
                window.history.pushState({}, null, window.location.href.split(/[?#]/)[0] + "?filter="+$('#order-filter').val()+"&currentPage=1");

                reloadCartridgeContentCollection(
                        $this,
                        'my-purchase',
                         params,
                         methods._reloadPurchaseSuccess);
            },

            
            reloadPurchaseForPagination: function(e) {
            	
                var $this = $(this),
                // reloadCartridge MyPurchase from the begining
                params = { 'filter': $('#order-filter').val(),
                           'currentPage': $this.data().page };
                
                if(!$this.is(".bottom")) {
                	e.preventDefault();
                }

                window.history.pushState({}, null, window.location.href.split(/[?#]/)[0] + "?filter="+$('#order-filter').val()+"&currentPage=" + $this.data().page);

                reloadCartridgeContentCollection(
                        $this,
                        'my-purchase',
                         params,
                         methods._reloadPurchaseSuccess);
            },

            _reloadPurchaseSuccess: function(){
            	
                myPurchaseEvents();
                // Display timer for payment action
                $('[data-toggle="popover"]').popover('show');
                $('[data-toggle="popover"]').each(function() {
                    var $this = $(this);
                    var id = $($this.data('content')).attr('id');
                    var countDownFinishedCallBack = function() {
                        $this.popover('destroy');
                        $this.remove();
                    };
                    decathlon.tools.countdown("#"+ id, countDownFinishedCallBack);
                });
                
                $('.make-return-button').unbind('click');
                var createReturnCsts = csts.CREATE_RETURN;
                $('.make-return-button').click(function() {
                    throwEvent(createReturnCsts, $(this).data('order-id'));
                });

            },
            
    
    };
    $.fn.MyPurchasesPlugin = basePlugin(methods, csts.NAME);
    
    var myPurchaseEvents = function() {
        $(".dropdown-list").on('change', '#order-filter',function() {
            (function($this) {
                $this.MyPurchasesPlugin('reloadPurchaseForFiltering');
            })($(this));
        });
        
        $(".next").on('click',function(e) {
            (function($this) {
                $this.MyPurchasesPlugin('reloadPurchaseForPagination', e);
            })($(this));
        });
        
        $(".previous").on('click',function(e) {
            (function($this) {
                $this.MyPurchasesPlugin('reloadPurchaseForPagination', e);
            })($(this));
        });
        
        $(".change-page").on('click',function(e) {
            (function($this) {
                $this.MyPurchasesPlugin('reloadPurchaseForPagination', e);
            })($(this));
        });
        
        $('.selectpicker').selectpicker('refresh');
        decathlon.tools.slickReinitSlider('.product-item', '.product-img', '', productListSlickSettings);
        
        var createReturnCsts = csts.CREATE_RETURN;
        $('.make-return-button').click(function(e) {
            e.preventDefault();
            throwEvent(createReturnCsts, $(this).data('order-id'));
        });

        $('.make-return-popup-button').click(function(e) {
            e.preventDefault();
            $('#makeReturnButton').attr("data-order-id", $(this).data('order-id'));
        });
        
    };

 
     myPurchaseEvents();
    
};
loginModule.prototype = new RegistredModule();
loginModule.prototype.constructor = loginModule;

function loginModule() {

	this.selector = '.m-login';

}

loginModule.prototype.loadingBusiness = function() {

    var csts = {
        // Plugin identifier
        NAME: 'LoginPlugin',
        SUBMIT_LOGIN: 'rest/model/atg/userprofiling/ProfileActor/login',
        URL_PARAMS_TO_KEEP_ON_REDIRECTION: ['orderId', 'returnId'],
        SEND_VERIFICATION_CODE_CREATE: 'account/sendVerificationCodeCreation',
        SEND_VERIFICATION_CODE_UPDATE: 'account/sendVerificationCodeUpdate',
        UPDATE_LOGIN_INFORMATION_URL: 'rest/model/atg/userprofiling/ProfileActor/updateLoginInformation-mobileValidation'

    };

    var methods = {
    	        doLogin: function() {
    	            var $this = $(this),
    	            params = $('#loginForm').serialize();

    	            var selectedFlag = $("#countryCode").val();
    	            if (selectedFlag) {
    	                params += "&countryCode="+selectedFlag;
    	            }

    	            ajaxCall(
    	                $('#loginForm'),
    	                csts.SUBMIT_LOGIN,
    	                params,
    	                methods._doLoginSuccess,
    	                methods._doLoginError);
    	        },
    	        
    	        doLoginExpressCart : function() {
    	            var $this = $(this),
    	            params = $('#loginForm').serialize();

    	            var selectedFlag = $("#countryCode").val();
    	            if (selectedFlag) {
    	                params += "&countryCode="+selectedFlag;
    	            }

    	            ajaxCall(
    	                $('#loginForm'),
    	                csts.SUBMIT_LOGIN,
    	                params,
    	                methods._doLoginSuccessExpressCart,
    	                methods._doLoginError);
    	        },
    	        
    	        _doLoginSuccessExpressCart: function($this, result) {
    	        	if(result.responseTO === undefined){
    	        		AccountUtils._pushAccountAlert('danger','bell', Messages('error.oc.call'));
    	        	} else if(result.responseTO.data) {
    	        		$this.XpressCartPlugin('checkAndCreateOrder');
    	        		
    		            reloadCartridgeContentCollection(
    		                    $this,
    		                    'header-my-account',
    		                    {},
    		                    AccountUtils._reloadHeaderMyAccountSuccessError,
    		                    AccountUtils._reloadHeaderMyAccountSuccessError);
    		            
    	            } else {
    	            	AccountUtils._clearGenericError();
    	                $.each(result.responseTO.errors, function(index, valueArray) {
    	                    $('body').pushAlert({
    	                        type: 'danger',
    	                        icon: 'bell',
    	                        text: valueArray.message,
    	                        delay: 5000
    	                      });
    	                    //pushAlert('danger','bell', valueArray.message);
    	                });
    	            	var eventIncorrect = CUBE.Analytics.newEvent(null, "CheckoutEvent", "Login", "ErrorMessage", "IncorrectPasswordOrEmail", "", false);
    	            	eventIncorrect.send($this);
    	            }
    	        },
    	        
    	        _doLoginSuccess: function($this, result) {
    	        	if(result.responseTO === undefined){
    	        		AccountUtils._pushAccountAlert('danger','bell', Messages('error.oc.call'));
    	        	} else if(result.responseTO.data) {
    	                // Form OK : Dequeue and send 'analyticsLoginEvent'
    	                CUBE.Analytics.queue.send('analyticsLoginEvent');
    	                
    	        	    if (true === needRedirect(result)) {
    	        	    	methods.doRedirectOnLogin(result);//window.location.replace(result.responseTO.data.url);
    	                    return;
    	                }
    	               if(!result.responseTO.data.activateMobileValidation){
    	            	   $.fn.LoginPlugin('doRedirectOnLogin');
    	               } else {
    	                   
    	                   if (result.responseTO.data.isModalDisposable) {
                           $('#modal-phone-verification').modal('show');
    	                   } else {
                           $('#modal-phone-verification').modal({
                             show: true,
                             backdrop: 'static',
                             keyboard: false
                           });
                           $('#close-mobile-validation-modal').hide();
    	                   }

    	                   $('#modal-phone-verification').on('hidden.bs.modal', function () {
    	                	   $.fn.LoginPlugin('doRedirectOnLogin');
    	                   });

    	                   $('#mobileValidationCountryCode').val(result.responseTO.data.mobileCountryCode);
    	                   $('#mobile').val(result.responseTO.data.mobile);
    	               }

    	            } else {
    	            	AccountUtils._clearGenericError();
    	                $.each(result.responseTO.errors, function(index, valueArray) {
    	                    $('body').pushAlert({
    	                        type: 'danger',
    	                        icon: 'bell',
    	                        text: valueArray.message,
    	                        delay: 5000
    	                      });
    	                    //pushAlert('danger','bell', valueArray.message);
    	                });
    	            	var eventIncorrect = CUBE.Analytics.newEvent(null, "CheckoutEvent", "Login", "ErrorMessage", "IncorrectPasswordOrEmail", "", false);
    	            	eventIncorrect.send($this);
    	            }
    	        },
    	        doRedirectOnLogin: function(result){
    				
    	        	var url = window.location.search.substring(1);
    				
    				var redirectUrl = null;
    				
    				if (result && result.responseTO && result.responseTO.data && result.responseTO.data.url) {
    					redirectUrl = result.responseTO.data.url;
    				} else if(url.indexOf('redirectUrl=') > -1){
    					var endIndex = null;
    					if (url.indexOf('&') > -1) {
    						endIndex = url.indexOf('&');
    					} else {
    						endIndex = url.length;
    					}
    					redirectUrl = url.substring(url.indexOf('redirectUrl=') +12, endIndex);
    	        	}
    	        
    				if (redirectUrl !== null && redirectUrl !== undefined) {
    					var r = new RegExp('^(?:[a-z]+:)?//', 'i');
    					if (!r.test(redirectUrl)) {
    						// Retrieve specifics parameters in the URL and add them to the redirection
    						for (var i = 0; i < csts.URL_PARAMS_TO_KEEP_ON_REDIRECTION.length; i++) {
    							var _specificParam = getURLParameter(csts.URL_PARAMS_TO_KEEP_ON_REDIRECTION[i]);
    							if (_specificParam !== null && _specificParam !== undefined) {
    								redirectUrl = addURLParameter(redirectUrl, csts.URL_PARAMS_TO_KEEP_ON_REDIRECTION[i], _specificParam);
    							}
    						}
    						
    						// Defect 11230 : login url should not be stored in browser's history
    						window.location.replace(redirectUrl);
    					} else {
    						if(window.location.pathname.indexOf("/wechat/") > -1){
    							window.location.replace(redirectUrl);
    						} else {
    							location.href = '/';
    						}
    					}
    				} else if (location.pathname.match(/checkout\/login/)){
    					location.href = location.pathname.replace('login','cart');
    				}else{
    					location.href = '/';
    				}
    	        },
    	        
    	        _doLoginError: function($this, result) {
    	            //Actually no errors is returned by the ajax method call. Response is always 200
    	        	AccountUtils._clearGenericError();
    	            $.each(result, function(field, valueArray) {
    	            	methods._showLoginError(field, valueArray);
    	            });
    	            var eventIncorrect = CUBE.Analytics.newEvent($this, "CheckoutEvent", "Login", "ErrorMessage", "IncorrectPasswordOrEmail", "", false);
    	            eventIncorrect.send($this);
    	        },
    	        
    	        _showLoginError: function(field, valueArray) {
    	            if (field == "generic") {
    	                $("#error-container").removeClass("hide");
    	                $("div #errorContent").append(valueArray);
    	            } else {
    	                $("#" + field + "-error").parents(':eq(1)').addClass("has-error");
    	                $("#" + field + "-error").append(valueArray);
    	            }
    	        },
    	        
                sendVerificationCodeUpdateOnLogin: function() {
                  $('#save-mobile-btn').remove();
                  
        	        var $this = $(this),
        	        params = { 'mobile': $('form#mobile-modal-form #mobile').val(), 'mobileCountryCode': $('[name="mobileCountryCode"]').children(':selected').val() };

        	        ajaxCall(
        	            $this,
        	            csts.SEND_VERIFICATION_CODE_UPDATE,
        	            params,
        	            methods._sendVerificationUpdateCodeOnLoginSuccess,
        	            methods._sendVerificationUpdateCodeOnLoginSuccess
        	        );
                },

            _sendVerificationUpdateCodeOnLoginSuccess : function($this, response) {
        			var result = response.responseTO.data;
        			if (result) {
        	            $('#submitSendCodeButton').hide();
        	            $('#verification-code').show();
        	            $("a.resendVerificationCode").data('countdown').go();
        	            $('#verification-code .form-group').removeClass('has-error');
        	            $('#verification-code .form-group').addClass('has-notif');
        	            $('#verification-code .form-group .form-help .text').text(Messages('profile.smsSent'));
        			} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
        				$('#mobile-modal-form .form-group').removeClass('has-notif');
        	            $('#mobile-modal-form .form-group').addClass('has-error');
        	            $('#mobile-modal-form .form-group .form-help .text').text(response.responseTO.errors[0].message);
        			}
        		},

        		addParameterOnLostPasswordLink : function() {

                	var login = $('#login').val();
                	var countryCode = $('[name="countryCode"]').children(':selected').val();

                	$('#linkLostPassword').attr('href', function() {
        	        		return $('#linkLostPassword').attr('href').trim() + '?login='+login + '&countryCode='+countryCode;
        	        	});
                },
                
                updateLoginInformation: function() {
                    var $this = $(this),
                        params = {
                    		'mobile': $('form#mobile-modal-form #mobile').val(),
                    		'mobileCountryCode': $('form#mobile-modal-form #mobileCountryCode').children(':selected').val(),
                    		'verificationCode' : $('#verificationCode').val()
                    	};

                    ajaxCall(
                        $this,
                        csts.UPDATE_LOGIN_INFORMATION_URL,
                        params,
                        methods._updateLoginInformationSuccess,
                        methods._updateLoginInformationSuccess
                    );
                },

        		
        		_updateLoginInformationSuccess : function($this, response) {
        			if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
        				$('#verification-code .form-group').removeClass('has-notif');
        	            $('#verification-code .form-group').addClass('has-error');
        	            $('#verification-code .form-group .form-help .text').text(response.responseTO.errors[0].message);
        			} else if (response.responseTO.data){
        	            $('#verification-code .form-group').removeClass('has-error');
        	            $('#verification-code .form-group').addClass('has-notif');
        	            $('#verification-code .form-group .form-help .text').text(Messages('profile.changesSaved'));

        	            methods.doRedirectOnLogin(response);
        			}
        		},
    };
    

    var resendVerificationCodeOnLogin = function(e) {
        e.preventDefault();
        $.fn.LoginPlugin('sendVerificationCodeUpdateOnLogin');
    };
    
    $.fn.LoginPlugin = basePlugin(methods, csts.NAME);
    
    var loginValidationOpts = $.validator.cubeOptions;
    
    if ( $('#loginForm input[name="login"]').hasClass('just-mobile') ) {
        $.extend(loginValidationOpts, loginValidationOpts, {
            rules: {
                login: {
                	digits: true,
                	mobile: {
 		                digits: true,
 		                countryCodeSelector: '[name="countryCode"]'
 		            }
                }
            }
        });
    }
    else if ( $('#loginForm input[name="login"]').hasClass('email-and-mobile') ) {
        $.extend(loginValidationOpts, loginValidationOpts, {
            rules: {
                login: {
                    or: [
                         {
                        	 mobile: {
         		                digits: true,
         		                countryCodeSelector: '[name="countryCode"]'
         		            }
                         },
                         { email: true }
                    ]
                }
            },
            messages: {
                login: {
                    or: Messages("validationMsg.emailmobile")
                }
            }
        });
    }
    
    $('#loginForm').validate(loginValidationOpts);
    
    $('#loginForm').submit(function(e) {
        e.preventDefault();
        if ($(this).valid()) {
            $.fn.LoginPlugin('doLogin');
        } else {
        	var eventError = CUBE.Analytics.newEvent(null, "CheckoutEvent", "Login", "ErrorMessage", "IncorrectFormat", "", false);
            eventError.send($(this));
        	return false;
        }
    });
    
    $("a.resendVerificationCode").on('click', resendVerificationCodeOnLogin).data('countdown', new decathlon.userAccount.Countdown($("a.resendVerificationCode"), 30));
    
    $('#submitSendCodeButton').click(function(e) {
        e.preventDefault();

        var form = $('form#mobile-modal-form');

        var validationPluginOpts = $.validator.cubeOptions;
        var popinPhoneNumberValidator = form.validate($.extend(null, validationPluginOpts, {
            rules: {
	            mobile: {
	                digits: true,
	                mobile: {
	                	countryCodeSelector: '[name="mobileCountryCode"]',
	                },
	                required: function(element) {
	                	return $(element).closest('form').find('[name="mobile"]').hasClass('required');
	                },	                
		            
	            }
            }
        }));
        
        if(form.valid()){
        	$.fn.LoginPlugin('sendVerificationCodeUpdateOnLogin');
        }
    });
    
    $('form#mobile-modal-form #mobile').on('keyup', function(e) {
    	e.preventDefault();
    	$('#verification-code').hide();
    	$('#submitSendCodeButton').show();
    });
    
    $('#verification-code').on('keyup', function(e) {
    	e.preventDefault();
    	$('#verification-code .form-group').removeClass('has-notif');
    	$('#verification-code .form-group').removeClass('has-error');
    	$('#verification-code .form-group .form-help .text').text("");
    	
        var form = $('form#verification-code');
        form.removeData('validator');
    });
    
    $('#submitVerificationCode').on('click', function(e) {
    	e.preventDefault();
    	
    	$('#verification-code .form-group').removeClass('has-notif');
    	$('#verification-code .form-group .form-help .text').text("");
    	
        var form = $('form#verification-code');

        var validationPluginOpts = $.validator.cubeOptions;
        var popinVerificationCodeValidator = form.validate($.extend(null, validationPluginOpts, {
            rules: {
	            'verificationCode': {
	                digits: true,
	                required: true
	            }
            }
        }));
        
        if(form.valid()){
        	$.fn.LoginPlugin('updateLoginInformation');
        }
    });
    
    $("#linkLostPassword").on('click', methods.addParameterOnLostPasswordLink);
    
    var mobileModalSaveSuccessCb = function($form, result) {
      $.fn.LoginPlugin('doRedirectOnLogin', result);
    };
    
    $("#login,#password" ).mouseover(function() {
    	$(this).css('cursor', 'text');
     });
    
    $('form#mobile-modal-form').handleform('init', { successCb: mobileModalSaveSuccessCb });
    $('form#mobile-modal-form').validate($.extend(null, $.validator.cubeOptions, {
      rules: {
        mobile: {
          mobile: {
            countryCodeSelector: '[name="mobileCountryCode"]',
            digits: true
          }
        }
      }
    }));
};
lostPasswordModule.prototype = new RegistredModule();
lostPasswordModule.prototype.constructor = lostPasswordModule;

function lostPasswordModule() {
	this.selector = '#lostPasswordForm';
}

lostPasswordModule.prototype.loadingBusiness = function() {

	var validationPluginOpts = $.validator.cubeOptions;
    
    if ( $('#lostPasswordForm input[name="login"]').hasClass('just-mobile') ) {
        $.extend(validationPluginOpts, validationPluginOpts, {
            rules: {
                login: {
                	digits: true,
		            mobile:{
 		                digits: true,
 		                countryCodeSelector: '[name="countryCode"]'
 		            }
                }
            }
        });
    }
    else if ( $('#lostPasswordForm input[name="login"]').hasClass('email-and-mobile') ) {
        $.extend(validationPluginOpts, validationPluginOpts, {
            rules: {
                login: {
                    or: [
                         {
                        	 mobile: {
         		                digits: true,
         		                countryCodeSelector: '[name="countryCode"]'
         		            }
                         },
                         { email: true }
                    ]
                }
            },
            messages: {
                login: {
                    or: Messages("validationMsg.emailmobile")
                }
            }
        });
    }
    
    var formValidationRulesWithPhone = {
        rules: {
        	mobile: {
                digits: true,
                countryCodeSelector: '[name="countryCode"]'
            },
            emailmobile: {
            	maxlength: 40,
                or: [
                    {
                    	mobile: {
    		                digits: true,
    		                countryCodeSelector: '[name="countryCode"]'
    		            }
                    }, {
                        email: {
                            fillInput: "email"
                        }
                    }
                ]
            },
            email: {
            	maxlength: 40,
            }
        },
        messages: {
            emailmobile: {
                or: Messages("validationMsg.emailmobile")
            }
        }
    };
	
    var formPasswordValidator = {
            onsubmit: true,
            rules: {
                'actualPassword': {
                    minlength:6
                },
                'password': {
                	passwordCheck: true
                },
                'confirmPassword': {
                    equalTo: "#password"
                }
            },
            messages: {
                actualPassword: {
                    minlength: Messages("profile.updatePassword.newpassword.minLength"),
                    required: Messages("profile.updatePassword.actualPassword.required")
                },
                password: {
                    required: Messages("profile.updatePassword.newpassword.required"),
                    minlength: Messages("profile.updatePassword.newpassword.minLength")
                },
                confirmPassword: {
                    required: Messages("profile.updatePassword.confirmPassword.required"),
                    minlength: Messages("profile.updatePassword.newpassword.minLength"),
                    equalTo: Messages("profile.updatePassword.confirmPassword.equalsTo")
                }
            }
    };
    
    var formValidationRulesSecretQuestion = {
            messages: {
                text: {
                    required : Messages("account.lostpassword.questionOrAnswerEmpty")
                }
            }
        };
    
	// Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'LostPasswordPlugin',
        BACK: "rest/model/atg/userprofiling/ProfileActor/backToPreviousState",
        FORGOTTEN_PASSWORD: "rest/model/atg/userprofiling/ProfileActor/forgottenPassword",
        RESET_PASSWORD_SMS_CODE: "rest/model/atg/userprofiling/ProfileActor/passwordReinitSmsCode",
        REINITIALIZE: "rest/model/atg/userprofiling/ProfileActor/reinitialize",
    };
    
    // STEPS
    var CHECK_CREDENTIALS = 0;
    var CHOOSE_ELINK_PCODE = 1;
    var CHOOSE_ECODE_PCODE = 2;
    var CHOOSE_PCODE_ECODE = 3;
    var EMAIL_CODE_SENT = 4;
    var CHOOSE_ELINK_ECODE = 5;
    var SECRET_QUESTION = 6;
    var CHECK_CODE = 7;
    var PREFILLED_FORM = 8;
    var RESET_PSW = 9;
    var RESET_PSW_SUCCESS = 10;
    var EMAIL_LINK_SENT_ECODE = 11;
    var STATE_GENERIC_MSG = 12;
    var EMAIL_LINK_SENT_PCODE = 13;
    var EMAIL_LINK_SENT = 14;
    var STATE_NOT_EXISTS = 15;
    
    var BY_EMAIL_CODE = "CMAIL";
    var BY_MOBILE_CODE = "CPHONE";
    var BY_EMAIL_LINK = "LMAIL";
    var DATA_EMAIL = "data-email";
    var DATA_MOBILE = "data-mobile";

    var previousState;
    
    var methods = { 

    	    // Necessary code to show the given step (does not hide anything)
    	    showStepLostPassword : function(stepId, response) {
    	        
    	    	var data = null;
    	    	var selectedOption = null;
    	    	
    	        switch (stepId) {
    	                
    	            case CHECK_CREDENTIALS:
    	            	$('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.title"));
    	                });         
    	            	
    	            	$('#verification-code-form').hide();
    	            	$('#lostPasswordForm').show();
    	                $('#forgottenPasswordHow').hide();
    	                $('#verification-code-form').hide();
    	                $('#secret-question').hide();
    	                
    	                break;
    	            	
    	            case CHOOSE_ECODE_PCODE:	
    	            	data = response.responseTO.data;
    	            	
    	            	$('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.title"));
    	                });
    	            	
    	            	$('#verification-code-form').hide();
    	            	$('#lostPasswordForm').hide();
    	                $('#forgottenPasswordHow').show();
    	                
    	                $("div#firstChoice div").html(Messages("account.lostpassword.resetByMail") + " <strong>" + data.email + "</strong>");
    	                $("input#firstRadio").val(BY_EMAIL_CODE);
    	                $("input#firstRadio").attr(DATA_EMAIL, data.email);
    	                $("input#firstRadio").prop("checked", true);
    	                
    	                $("div#secondChoice div").html(Messages("account.lostpassword.resetByPhone") + " <strong>" + data.mobile + "</strong>");
    	                $("input#secondRadio").val(BY_MOBILE_CODE);
    	                $("input#secondRadio").attr(DATA_MOBILE, data.mobile);
    	                break;
    	                
    	            case CHOOSE_PCODE_ECODE:
    	            	data = response.responseTO.data;
    	            	
    	            	$('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.title"));
    	                });
    	            	
    	            	$('#verification-code-form').hide();
    	            	$('#lostPasswordForm').hide();
    	                $('#forgottenPasswordHow').show();

    	                $("div#firstChoice div").html(Messages("account.lostpassword.resetByPhone")  + " <strong>" + data.mobile + "</strong>");
    	                $("input#firstRadio").val(BY_MOBILE_CODE);
    	                $("input#firstRadio").attr(DATA_MOBILE, data.mobile);
    	                $("input#firstRadio").prop("checked", true);
    	                
    	                $("div#secondChoice div").html(Messages("account.lostpassword.resetByMail") + " <strong>" + data.email + "</strong>");
    	                $("input#secondRadio").val(BY_EMAIL_CODE);
    	                $("input#secondRadio").attr(DATA_EMAIL, data.email);
    	                break;
    	                
    	            case EMAIL_CODE_SENT:

    	                data = response.responseTO.data;
    	                previousState = data.previousState;
    	                $('#lostPasswordForm').hide();
    	                $('#verification-code-form').show();
    	                $('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.confirmCodeTitle"));
    	                });
    	                
    	                selectedOption = $('input[name=optionsRadios]:checked', '#forgottenPasswordHow').val();
    	                AccountUtils._checkIfErrors(null, response);
    	                if (selectedOption === null) {
                    		methods.showMessageCodeSent(BY_EMAIL_CODE, response);
                    	} else {
                    		methods.showMessageCodeSent(selectedOption, response);
                    	}
    	                break;
    	                
    	            case CHOOSE_ELINK_ECODE:
    	            	data = response.responseTO.data;
    	            	
    	            	$('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.title"));
    	                });
    	            	
    	            	$('#verification-code-form').hide();
    	            	$('#lostPasswordForm').hide();
    	                $('#forgottenPasswordHow').show();
    	                
       	                $("div#firstChoice div").html(Messages("account.lostpassword.resetByMailByLink")  + " <strong>" + data.email + "</strong>");
    	                $("input#firstRadio").val(BY_EMAIL_LINK);
    	                $("input#firstRadio").attr(DATA_EMAIL, data.email);
    	                $("input#firstRadio").prop("checked", true);
    	                
    	                $("div#secondChoice div").html(Messages("account.lostpassword.resetByMail") + " <strong>" + data.email + "</strong>");
    	                $("input#secondRadio").val(BY_EMAIL_CODE);
    	                $("input#secondRadio").attr(DATA_EMAIL, data.email);

    	                break;
    	                
    	            case SECRET_QUESTION:
    	            	data = response.responseTO.data;
    	            	$('#lostPasswordForm').hide();
    	                $('#secret-question').show();
    	                
    	                new SecretQuestions("#question-id","#secretAnswer", $("#locale").val(),$("#dateOfBirthFormat").val()).initialize( data.fields);
    	                break;
    	                
    	            case CHECK_CODE:
    	            	data = response.responseTO.data;
    	                previousState = data.previousState;
    	            	if (previousState == EMAIL_CODE_SENT) {
    	            		methods.showMessageCodeSent(BY_EMAIL_CODE, response);
    	            	} else if (previousState == SECRET_QUESTION) {
    	            		$('#cancelValidateCode').hide();
    	            		methods.showMessageCodeSent(BY_MOBILE_CODE, response);
    	            	}
	            		$('#lostPasswordForm').hide();
    	            	$('#forgottenPasswordHow').hide();
    	                $('#verification-code-form').show();
    	                $('#secret-question').hide();
    	                $('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.confirmCodeTitle"));
    	                });
    	                
    	                selectedOption = $('input[name=optionsRadios]:checked', '#forgottenPasswordHow').val();
    	                AccountUtils._checkIfErrors(null, response);
    	                if (previousState != SECRET_QUESTION) {
    	                	if (selectedOption === null) {
                        		methods.showMessageCodeSent(BY_EMAIL_CODE, response);
                        	} else {
                        		methods.showMessageCodeSent(selectedOption, response);
                        	}
    	                }
    	                break;

    	            case PREFILLED_FORM:
    					
    	            	window.location.href = response.responseTO.data.url;
    	            	break;
    	               
    	            case RESET_PSW:
    	                $('#resetPasswordForm').show();
    	                $('#verification-code-form').hide();
    	                
    	                $('div#lost-password h2').each(function() {
    	                    $(this).text(Messages("account.lostpassword.resetPasswordTitle"));
    	                });
    	                
    	                break;
    	            
    	            case RESET_PSW_SUCCESS:
    	                $('#verification-code-form').show();
    	                $('#secret-question').show();
    	                break;
    	            
    	            case EMAIL_LINK_SENT_ECODE:
    	            case EMAIL_LINK_SENT_PCODE: 
    	            case EMAIL_LINK_SENT:
    	            	
    	            	$('#chooseButton').attr('disabled', true);
    	            	$('#chooseButton').addClass('disabled');
    	            	methods.reinitializeCb($(this));
    	                break;
    	                
    	            case STATE_GENERIC_MSG:
    	            	var params = $('#lostPasswordForm').serialize();
    	            	ajaxCall(
    	            			$(this),
    	                        csts.REINITIALIZE,
    	                        params, methods.reinitializeCb, methods.reinitializeCb);
    	                
    	                break;
    	            
    	            case STATE_NOT_EXISTS:
    	            	
    	            	ajaxCall(
    	            			$(this),
    	                        csts.REINITIALIZE,
    	                        params, methods.reinitializeNotExistCb, methods.reinitializeNotExistCb);
    	            	
    	            	break;

    	        }
    	    },
    	    
    	    reinitializeNotExistCb: function($this, result) {
    	    	
    	    	var login = $('#login').val();
    	    	
    	    	if (AccountUtils._isEmail(login)) {
    	    		AccountUtils._displayGeneralError(Messages('account.lostpassword.emailNotFound'));
    	    	} else {
    	    		AccountUtils._displayGeneralError(Messages('account.lostpassword.mobileNotFound'));
    	    	}
    	    	
            },
    	    
    	    reinitializeCb : function($this) {
    	    	$('#returning').show();
                $('#lostPasswordForm').hide();
            	$('#forgottenPasswordHow').hide();
                $('#verification-code-form').hide();
            },

            validateLostPasswordForm: function() {
            	AccountUtils._showFieldErrors();
            	AccountUtils._clearFieldErrors("lostPasswordForm");
                var isValidated = true;
                if ($('#login').val() === '') {
                	AccountUtils._showFieldErrors("login-group", "login-empty-error");
                    isValidated = false;
                } else {
                    if (!AccountUtils._validateLogin($('#login').val())) {
                    	AccountUtils._showFieldErrors("login-group", "login-invalid-error");
                        isValidated = false;
                    }
                }
                
                return isValidated;
            },
            
           // Success callback for the first step (check credentials)
           lostPswSuccessCb : function($form, result) {                
                var data = result.responseTO.data;
                
                AccountUtils._checkIfErrors($form, result);
                window.history.pushState('page2', 'Title', window.location.pathname + "?login="+$("#login").val()+"&countryCode="+$("#country-code").val());
                methods.showStepLostPassword(data.nextState, result);
            },
            
            back : function() {
            	var $this = $(this);
                
                ajaxCall(
                		$this,
                        csts.BACK,
                        null,
                        methods.backSuccessCb,
                        methods.backSuccessCb);
            },
            
            backSuccessCb : function($this, result) {
            	
            	$('a.resendCodePsw').data('countdown').stop();
            	AccountUtils._checkIfErrors($this, result);
            	if (result.responseTO.errors.length <= 0) {
            		var data = result.responseTO.data;
            		methods.showStepLostPassword(data.nextState, result);
            	}
            },
            
            sendCodeSuccessCb : function($this, result) {
  
                $('a.resendCodePsw').data('countdown').go();
                $(".loading-icon").remove();
                
                if (result.responseTO.errors.length <= 0) {
                	var selectedOption = $('input[name=optionsRadios]:checked', '#forgottenPasswordHow').val();
                	if (selectedOption === null) {                		
                		if ($('#secret-question').serialize() !== "") {
                			methods.showMessageCodeSent(BY_MOBILE_CODE, result);
                		} else {
                			methods.showMessageCodeSent(BY_EMAIL_CODE, result);
                		}
                	} else {
                		methods.showMessageCodeSent(selectedOption, result);
                	}
            		
            	} else {
            		AccountUtils._checkIfErrors($this, result);
            	}
            },
            
            resendCodeLostPassword : function() {
            	
            	var params = $('#forgottenPasswordHow').serialize();
            	
            	if (params === "") {
            		if ($('#secret-question').serialize() !== "") {
            			params="optionsRadios="+BY_MOBILE_CODE;
            		} else {
            			params="optionsRadios="+BY_EMAIL_CODE;
            		}
            	}
            	
            	$('a.resendCodePsw').data('countdown').stop();
                
                ajaxCall(
                		$(this),
                        csts.FORGOTTEN_PASSWORD,
                        params,
                        methods.sendCodeSuccessCb,
                        methods.errorCb);
            },
            
            showMessageCodeSent : function(option, result) {
            	var data = result.responseTO.data;
            	
            	if (option === undefined) {
            	    if (data.email) {
            	        $("a.resendCodePsw").data('countdown').go();
                        AccountUtils._displayGeneralInformation(Messages('account.lostpassword.codeSentToEmail', data.email));
            	    } else if (data.mobile) {
            	        $("a.resendCodePsw").data('countdown').go();
                        AccountUtils._displayGeneralInformation(Messages('account.lostpassword.codeSentToMobile', data.mobile));
            	    }
            	} else {
                	switch (option) {
                    case BY_EMAIL_CODE : 
                    	if (data.emailSent) {
                    	    $("a.resendCodePsw").data('countdown').go();
                    		AccountUtils._displayGeneralInformation(Messages('account.lostpassword.codeSentToEmail', data.email));
                    	}
                    	break;
                    case BY_MOBILE_CODE :
                    	if (data.smsSent) {
                    		$("a.resendCodePsw").data('countdown').go();
                    		AccountUtils._displayGeneralInformation(Messages('account.lostpassword.codeSentToMobile', data.mobile));
                    	}
                    	break;
                    case BY_EMAIL_LINK :
                        if (data.emailSent) {
                            AccountUtils._displayGeneralInformation(Messages('account.lostpassword.linkSentToEmail', data.email));
                        }
                        break;
                    }
            	}
            },
            
            errorCb : function($this, result) {
            	AccountUtils._clearGenericError();
            	AccountUtils._checkIfErrors($this, result);
            },
            
            invalidateField : function($form, fieldName, errorMessage) {
            	CUBE.Analytics.manualTrackError(fieldName, "other");
                var error = {};
                error[fieldName] = errorMessage;
                $form.validate().resetForm();
                $form.validate().showErrors(error);
            },
            
            lostPswCheckCodeSuccessCb : function($form, result) {                
                 var data = result.responseTO.data;                 
                 AccountUtils._checkIfErrors($form, result);
                 
                 if(!data.valid) {
                	methods.invalidateField($form, "smsCode", $.validator.messages.invalidValidationCode);
                 }
                 methods.showStepLostPassword(data.nextState, result);

             },
             
             passwordResponse : function($this, response, params) {
             	if (response.responseTO.errors.length > 0) {

             		var code = response.responseTO.errors[0].code;
             		var message = response.responseTO.errors[0].message;
             		var validator = null;
             		
             		if(code == 'account.authentication.forbiddenPassword'){
                         validator = $('#resetPasswordForm').validate();
                         validator.showErrors({
                               "password": message
                         });
             		} else if (code == 'account.authentication.wrongPassword'){
                         validator = $('#resetPasswordForm').validate();
                         validator.showErrors({
                               "actualPassword": message
                         });
             		} else {
             			AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
             		}
     		        $this.show();
     		        AccountUtils._enableFormBtn($($this));

     		    } else {
     		    	AccountUtils._displayGeneralSuccess();
     		    	
     		    	window.setTimeout(function(){
 		    			location.href = '/';  
 		    		}, 2000);
     		    	
     		    }             	
     		},
     		
     		codeChanged : function(e) {
                e.preventDefault();
                
                var validator = $('#verification-code-form').validate();
                validator.resetForm();
            },
            
    };
    
    $('form#lostPasswordForm').validate(validationPluginOpts);    
   
    

    $('form#lostPasswordForm').handleform('init', { successCb: methods.lostPswSuccessCb , errorCb: methods.passwordResponse});
    
    $('form#forgottenPasswordHow').validate(validationPluginOpts);
    $('form#forgottenPasswordHow').handleform('init', { successCb: methods.lostPswSuccessCb, errorCb: methods.passwordResponse });
    
    $('form#verification-code-form').validate($.extend(null, validationPluginOpts, formValidationRulesWithPhone));
    $('form#verification-code-form').handleform('init', { successCb: methods.lostPswCheckCodeSuccessCb , errorCb: methods.passwordResponse});

    $('form#resetPasswordForm').validate($.extend(null, validationPluginOpts, formPasswordValidator));
    $('form#resetPasswordForm').handleform('init', { successCb: methods.passwordResponse, errorCb: methods.passwordResponse});
    
    $('form#secret-question').validate($.extend(null, validationPluginOpts, formValidationRulesSecretQuestion));
    $('form#secret-question').handleform('init', { successCb: methods.lostPswSuccessCb, errorCb: methods.passwordResponse});

    $("form#verification-code-form #smsCode").on('keyup', methods.codeChanged);
    
    $("form#verification-code-form a.resendCodePsw").on('click', methods.resendCodeLostPassword).data('countdown',  new decathlon.userAccount.Countdown($("a.resendCodePsw"), 30));
    
    $('#cancelValidateCode').click(function(e) {
        e.preventDefault();
        $('a.resendCodePsw').data('countdown').stop();
        methods.codeChanged(e);
        $("form#verification-code-form").trigger("reset");      
        methods.back();
    }); 
    
    $('input[type=radio][name=optionsRadios]').change(function() {
    	$('#chooseButton').attr('disabled', false);
    	$('#chooseButton').removeClass("disabled");
    });
    
    if($('.password-checking').length > 0){
        var passwordChecking =  new PasswordChecking({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
    
    if ($('.password-strengh-list').length > 0) {
        var passwordStrength = new PasswordStrength({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
    
    // Submit the form on 'enter' keypress 
    $(document).keypress(function( event ) {
    	if (event.which == 13) {
    		event.preventDefault();
    		var form = $('#main-container form:visible:first');
    		form.submit();
    	}
    });

};
resetPswModule.prototype = new RegistredModule();
resetPswModule.prototype.constructor = resetPswModule;

function resetPswModule() {
	this.selector = '#resetPasswordForm';
}

resetPswModule.prototype.loadingBusiness = function() {

	var csts = {
	        // Plugin identifier 
	        NAME: 'ResetPasswordPlugin',
	        RESET_PASSWORD: "rest/model/atg/userprofiling/ProfileActor/passwordReinit"
	    };
	
    var formPasswordValidator = {
            onsubmit: true,
            rules: {
                'password': {
                	passwordCheck: true
                },
                'confirmPassword': {
                    equalTo: "#password"
                }
            },
            messages: {
                password: {
                    required: Messages("profile.updatePassword.newpassword.required"),
                    minlength: Messages("profile.updatePassword.newpassword.minLength")
                },
                confirmPassword: {
                    required: Messages("profile.updatePassword.confirmPassword.required"),
                    minlength: Messages("profile.updatePassword.newpassword.minLength"),
                    equalTo: Messages("profile.updatePassword.confirmPassword.equalsTo")
                }
            }
    };
    
    var form = $('form#resetPasswordForm');
    
	var methods = {
	        validateResetPasswordForm: function() {
	        	var isValidated = false;
	        	var validationPluginOpts = $.validator.cubeOptions;

	        	form.validate($.extend(null, validationPluginOpts, formPasswordValidator) );

	        	if(form.valid()){
	        		isValidated = true;
	        	} else {
	        		AccountUtils._enableFormBtn(form);
	        	}

	        	return isValidated;
	        },
	        
	        doResetPassword: function() {
	        	var $this = $(this);
                var params = "";
	            var tokenId = getURLParameter("tokenId");
	            var tokenAction = getURLParameter("tokenAction");
	            if (tokenId !== null && tokenId !== undefined && tokenAction !== null && tokenAction !== undefined) {
	                params = "newPassword=" + $('#password').val() + "&tokenId=" + tokenId + "&tokenAction=" + tokenAction;
	                ajaxCall(
	                        $this,
	                        csts.RESET_PASSWORD,
	                        params,
	                        methods._doResetPasswordSuccess,
	                        methods._doResetPasswordError);
	            } else {
	            	AccountUtils._showLoginError("generic", 'Missing Token!');
	            }    
	        },
	        
	        _doResetPasswordError: function($this, result) {
	            //Actually no errors is returned by the ajax method call. Response is always 200
	        	AccountUtils._enableFormBtn(form);
	        	
	            methods._clearGenericError();
	            $.each(result, function(field, valueArray) {
	            	AccountUtils._showLoginError(field, valueArray);
	            });
	        },

	        _doResetPasswordSuccess: function($this, result) {
	            if (result.responseTO.data) {
     		    	AccountUtils._displayGeneralSuccess();
     		    	
     		    	window.setTimeout(function(){
 		    			location.href = '/';  
 		    		}, 2000);
     		    	
	            } else if (resultHasErrors(result)) {
	            	AccountUtils._enableFormBtn(form);
	            	
	                $.each(result.responseTO.errors, function(index, valueArray) {
	                	AccountUtils._pushAccountAlert('danger','bell', valueArray.message);
	                });
	            }
	        },
	};
	
    $.fn.ResetPasswordPlugin = basePlugin(methods, csts.NAME);
    
    $('#validatePasswordResetButton').click(function(e) {
        e.preventDefault();
        AccountUtils._disabledFormBtn($(this));
        
        if ($.fn.ResetPasswordPlugin("validateResetPasswordForm")) {
        	$.fn.ResetPasswordPlugin("doResetPassword");
        } 
    });
    
    if($('.password-checking').length > 0){
        var passwordChecking =  new PasswordChecking({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
    
    if ($('.password-strengh-list').length > 0) {
        var passwordStrength = new PasswordStrength({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
	
    // Submit the form on 'enter' keypress 
    $(document).keypress(function( event ) {
    	if (event.which == 13) {
    		event.preventDefault();
    		var form = $('#main-container form:visible:first');
    		form.submit();
    	}
    });
	
};

contactModule.prototype = new RegistredModule();
contactModule.prototype.constructor = contactModule;

function contactModule() {
	this.selector = 'body.contact';
}

contactModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'ContactPlugin',

    };

    var methods = {

            _setSendUserRequestSuccess : function($this, result) {
                if (result.responseTO.data) {
                    $('#alert-success-container').show();
                    $('#contact-form-container').parent().hide();
                } else {
                    $.each(result.responseTO.errors, function(index, valueArray) {
                    	AccountUtils._pushAccountAlert('danger','bell', valueArray.message);
                    });

                }
            },

    };
    
    $.fn.ContactPlugin = basePlugin(methods, csts.NAME);

    $('form#contact-form').handleform('init', { successCb: methods._setSendUserRequestSuccess });
    
    $('form#contact-form').validate($.extend(null, $.validator.cubeOptions, {
    	ignore: "",
        messages: {
                name: {
                    required: Messages('contact.form.mandatory.name')
                },
                phone: {
                    required: Messages('contact.form.mandatory.phone'),
                    pattern: Messages('contact.form.invalidPhone')
                },
                email: {
                    required: Messages('contact.form.mandatory.email')
                },
                category: {
                    required: Messages('contact.form.mandatory.field')
                },
                message: {
                    required: Messages('contact.form.mandatory.field')
                }
        },
        rules: {
            name: "extendedalphanumeric",
            loyaltycardnumber: {
            	loyaltycard : {
            		depends: function (element) {
            			return !$('#loyaltycardnumber') || $.trim($('#loyaltycardnumber').val()) !== "";
            		}
            	}
            }
        }
    }));
    
};
createAccountNominalModule.prototype = new RegistredModule();
createAccountNominalModule.prototype.constructor = createAccountNominalModule;

function createAccountNominalModule() {
	this.selector = '#create-account-container';
}

createAccountNominalModule.prototype.loadingBusiness = function() {
    
    // STEPS
    var VERIFY_PHONE = 1;
    var PERSONAL_DATA = 2;
    var RETURNING_LOYALTY = 3;
    var RETURNING_LOGIN = 4;
    var RETURNING = 5;
    var RETURNING_LOYALTY_KNOWN_EMAIL = 6;
    var RETURNING_LOGIN_KNOWN_EMAIL = 7;
    var RETURNING_KNOWN_EMAIL = 8;
    
    var STATE_RETURNING_LOYALTY_EMAIL_PERSONAL_DATA = 21;
    var STATE_RETURNING_LOGIN_EMAIL_PERSONAL_DATA = 22;
    var STATE_RETURNING_LOYALTY_MOBILE_PERSONAL_DATA = 23;
    var STATE_RETURNING_LOGIN_MOBILE_PERSONAL_DATA = 24;
    
    var initializeCounters = function(){
    	$('a.resend-code-btn').each(function(){
    	    $(this).data('countdown',  new decathlon.userAccount.Countdown($(this), 30));
    	});
    };
    
    var launchCounters = function(){
    	$('a.resend-code-btn').each(function(){
    		$(this).data('countdown').go();
    	});
    };
    
    var stopCounters =  function(){
    	$('a.resend-code-btn').each(function(){
    		$(this).data('countdown').stop();
    	});
    };
    
    
    var csts = {
    		SEND_CREATION_CODE: 'account/send-creation-code',
    		CHECK_VERIFICATION_CODE: 'account/check-verification-code',
    		CHECK_MOBILE : 'account/check-mobile',
    		CHECK_EMAIL : 'account/check-email',
   };
    
    // Necessary code to show the given step (does not hide anything)
    var showStep = function(stepId, data) {
        switch (stepId) {
                
            case VERIFY_PHONE:
                $('#phone-validation-container').removeClass('sneakpeek');
                $('#phone-validation-form').validate( $.extend(null, validationPluginOpts, formValidationRulesMobileCode,  { invalidHandler: validationErrorCb }) );
                
                // Switch buttons
                showBackButtonNominal();
                
                break;
                
            case PERSONAL_DATA:
            	
            	showBackButtonNominal();
            	
                $('#personal-data-container').show();
                $('.mentions').show();
                $('#personal-data-container').removeClass('sneakpeek');
                
                break;
                
            case RETURNING_LOYALTY:
                $('#returning-loyalty-container').show();
                // Switch buttons
                showBackButtonNominal();
                break;
                
            case RETURNING_LOGIN:
                $('#returning-login-container').show();
                // Switch buttons
                showBackButtonNominal();
                break;
                
            case RETURNING:
                $('#returning-container').show();
                // Switch buttons
                showBackButtonNominal();
                break;
                
            case RETURNING_LOYALTY_KNOWN_EMAIL:
                $('#returning-loyalty-email-known-container').show();
                // Switch buttons
                showBackButtonNominal();
                break;
                
            case RETURNING_LOGIN_KNOWN_EMAIL:
                $('#returning-login-email-known-container').show();
                // Switch buttons
                showBackButtonNominal();
                break;
                
            case RETURNING_KNOWN_EMAIL:
                $('#returning-email-known-container').show();
                // Switch buttons
                showBackButtonNominal();
                break;
        }
    };
    
    // Success callback for the first step (check credentials)
    var checkCredentialsSuccessCb = function($form, result) {
        var data = result.responseTO.data;
        
        
        validateForm( $form );
        switch (data.nextState) {
        
        case VERIFY_PHONE:
            
            // Form OK : Dequeue and send 'AccountStep1'
            CUBE.Analytics.queue.send('AccountStep1');
            
            $('#personal-data-container').show();
            $('.mentions').show();
            
            if (data.smsSent) {
                displayGeneralSMSInformation();
                launchCounters();
            }
            
            break;
            
        case PERSONAL_DATA:
            $('#phone-validation-container').hide();
            break;
        }

        if(data.maskedEmail !== null) {
            $('.send-email-message').show();
            $('.masked-email').each(function() {
                $(this).text(data.maskedEmail);
            });
        } else {
            $('.send-email-message').hide();
        }

        $('#personaldata-mobile').hide();
        $('#personaldata-email').hide();
        
        if($('[name="mobile"]').val() !== undefined && ($('[name="mobile"]').val() === null || $.trim($('[name="mobile"]').val()).length === 0)){
            $('#personaldata-mobile').show();
        }
        
        if($('[name="email"]').val() !== undefined && ($('[name="email"]').val() === null || $.trim($('[name="email"]').val()).length === 0)){
            $('#personaldata-email').show();
        }
        
        if(data.mobileAvailable !== null && !data.mobileAvailable && $('#mobile').val() !== undefined && $('#mobile').val() !== null) {
        	var $href = $('.login-link-anchor').attr('href');
        	$('.login-link-anchor').attr('href', replaceUrlParam($href, "login", $('#mobile').val()));
        }
        
        showStep(data.nextState, data);
    };
    
    var replaceUrlParam = function(url, paramName, paramValue) {
        var pattern = new RegExp('\\b('+paramName+'=).*?(&|$)');
        if(url.search(pattern)>=0){
            return url.replace(pattern,'$1' + paramValue + '$2');
        }
        return url + (url.indexOf('?')>0 ? '&' : '?') + paramName + '=' + paramValue;
    };
    
    // Success callback for the Change credentials button (back to the first
    // step)
    var resetProcessSuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        $form.closest('.m-account-block-content').find('.loading-icon').remove();
        
        if (data) {
            
            // Clean phone verification form
            if (data.previousState == VERIFY_PHONE) {
                $('#phone-validation-form').trigger('reset').validate().resetForm();
            }
            
            // Hide phone verification and personal data step
            $('#phone-validation-container').addClass('sneakpeek');
            $('#personal-data-container').hide();
            
            // Reactivate first login information step
            var $loginInfoForm = $('#login-information-form');
            $loginInfoForm.find('input, select, [type="submit"]').prop('disabled', false).removeClass('disabled');
            $loginInfoForm.find('input').each(function() {
                $(this).closest('.form-group').removeClass('validated');
            });
            $('#country-code').selectpicker('refresh');
            $loginInfoForm.closest('.m-account-block').removeClass('validated');
            
            // Changing buttons
            $('#restart-process-button').addClass('hide');
            $loginInfoForm.find('[type="submit"]').closest('.form-group').removeClass('hide');
            
            // Hide all the intermediate steps between login input and mobile
            // validation
            $('div[id^="returning-"]').hide();
            
            // Restoring SMS sending countdown

            $('.code-resent-msg').hide();
            $('#phone-validation-container').show();
            $('#check-question-container').show();
            $('#personal-data-container').hide();
            $('div[id*=returning]').find('.m-account-block-content').show();
            $('.success-msg-info').hide();
            $('.mentions').hide();
        }

    };
    
    var genericErrorCb = function($form, result) {
        $form.closest('.m-account-block-content').find('.loading-icon').remove();
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
    var validationErrorCb = function(e, validator) {
    	CUBE.Analytics.autoTrackError(validator);
    };
    
    // Success callback for code validation
    var codeValidationSuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        
        switch (data.nextState) {

        case VERIFY_PHONE:
            // If we remain in the same step, it means the code is invalid.
            invalidateField($form, "verificationCode", $.validator.messages.invalidValidationCode);
            break;
        
        case PERSONAL_DATA:
            validateForm( $('#phone-validation-form') );
            
            // Form OK : Dequeue and send 'AccountStep2'
            CUBE.Analytics.queue.send('AccountStep2');
            
            $form.closest('.m-account-block').addClass('validated');
            $form.siblings('#send-validation-code-form').hide();
            stopCounters();
            $('.send-code-btn').hide();
            break;
        }

        // Hide restart process button
        if (data.nextState != VERIFY_PHONE) {
            $('#restart-process-button').addClass('hide');
            $('.modify-login-button').addClass('hide');
        }

        showStep(data.nextState, data);
        
    };
    
    // Success callback for code validation 'send again' function
    var sendCodeValidationSuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        var $btn = $('.send-code-btn');
            
        switch(data.nextState) {
        
        case VERIFY_PHONE:
                
            if (data.previousState == VERIFY_PHONE) {
            	  launchCounters();
            }
            else {

          		stopCounters();

                $('#returning-loyalty-container').hide();
                $('#returning-login-container').hide();
                $('#returning-container').hide();
                $('#personal-data-container').show();
                $('.mentions').show();
                $('.m-account-block#login-information-container').addClass('validated');
            }
        
            break;
        }
        
        displayGeneralSMSInformation();
        
        showStep(data.nextState, data);
        
    };
    
    // Method call when the resend code lead to an error
    var sendCodeValidationErrorCb = function($this, result) {
        
       stopCounters();
        
        // Fill errors from ResponseTO
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
    var verificationCodePersonalDataSuccess = function($this, response) {
        if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
        	showErrors(response.responseTO.errors);
    	} else if (!response.responseTO.data.valid) {  
             invalidateField($('form#personal-data-form'), "verificationCode", $.validator.messages.invalidValidationCode);
    	} else if (response.responseTO.data.valid){
    		$("#personal-data-form").submit();
    	}
    };
    
    var completeAccountEmailSuccessCb = function($form, result) {
    	  var accountBlock = $form.closest('.m-account-block');
        accountBlock.addClass('validated');
        accountBlock.find('.success-msg-info').show();
        var $msg = accountBlock.find('.success-msg').show();
        if ($msg) {
          accountBlock.find('.m-account-block-content').html($msg);
        }
        $('#restart-process-button').hide();
        $('#phone-validation-container').hide();
    };
    
    var completeAccountEmailPersonalDataSuccessCb = function($form, result) {
      	$('.email-complete-account-btn-personal-data').show();
          	$('.loading-icon').hide();
          	$('body').pushAlert({
      			text: $form.find(".success-msg").text(),
      			type: 'info',
      			icon:'bell'
    		});
    };
    
    var completeAccountEmailErrorCb = function($form, result) {
        $form.closest('ul').find('.email-complete-account-btn').show().next('.loading-icon').remove();
        // Fill errors from ResponseTO
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
	var mobileExistPersonalDataSuccess = function($this, response) {
		var result = response.responseTO.data;
		if (result) {
			if(!result.mobileAvailable){
		        
				switch(result.nextState) {
		        case STATE_RETURNING_LOYALTY_MOBILE_PERSONAL_DATA:
					$('#mobile-personal-data-loyalty-arrowbox').show();
	                break;
		        case STATE_RETURNING_LOGIN_MOBILE_PERSONAL_DATA:
					$('#mobile-personal-data-login-arrowbox').show();
		    		var $href = $('#mobile-personal-data-login-arrowbox .login-link-anchor').attr('href');
		    		$('#mobile-personal-data-login-arrowbox .login-link-anchor').attr('href', replaceUrlParam($href, "login", $('#mobile').val()));
	                break;
		        default:
		        	$('.sendVerificationCode').show();
		        	break;
		        }
		        
		        if(result.maskedEmail !== null) {
		            $('.send-email-message').show();
		            $('.masked-email').each(function() {
		                $(this).text(result.maskedEmail);
		            });
		        } else {
		            $('.send-email-message').hide();
		        }
		        
			} else {
                var $inputMobile = $('#personal-data-form input#mobile');
                if ($inputMobile.valid()) {
                    $inputMobile.closest('.form-group').addClass('validated');
                    $('.sendVerificationCode').show();
                    $('.verifyMyMobilePopover').show();
                }
			}
		} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
			 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
		}
		
	};
	
	var emailExistPersonalDataSuccess = function($this, response) {
		var result = response.responseTO.data;
		if (result) {
			if(!result.emailAvailable){
				switch(result.nextState) {
		        case STATE_RETURNING_LOYALTY_EMAIL_PERSONAL_DATA:
					$('#email-personal-data-loyalty-arrowbox').show();
	                break;
		        case STATE_RETURNING_LOGIN_EMAIL_PERSONAL_DATA:
		    		var $href = $('#email-personal-data-login-arrowbox .login-link-anchor').attr('href');
		    		$('#email-personal-data-login-arrowbox .login-link-anchor').attr('href', replaceUrlParam($href, "login", $('#email').val()));
					$('#email-personal-data-login-arrowbox').show();
	                break;
		        default:
		        	break;
		        }
			}
		} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
			 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
		}
		
	};
	
    var resendCreationCode = function(e) {
        e.preventDefault();
        sendCreationCodeUpdate();
    };


    var sendCreationCode = function(e) {
      var sendVerificationCodeButton = $('a.sendVerificationCode');

      // Send the Verification Code only once...
      if (!sendVerificationCodeButton.hasClass('disabled')) {
        resendCreationCode(e);
      }

      // Disable the "Send code" button...
      sendVerificationCodeButton.addClass('disabled').prop('disabled', true);

      // Prevent loading spinner to be displayed multiple times...
      if (!sendVerificationCodeButton.children('img.loading-icon').length) {
        sendVerificationCodeButton.prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />&nbsp;');
      }

      $('.verifyMyMobilePopover').hide();
    };
    
    var sendCreationCodeUpdate = function() {
    	var $this = $(this),
            params = { 'mobile': $('[name="mobile"]').val(), 'mobileCountryCode': $('[name="mobileCountryCode"]').children(':selected').val() };

        ajaxCall(
            $this,
            csts.SEND_CREATION_CODE,
            params,
            sendCreationCodeSuccess,
            sendCreationCodeSuccess
        );
    };
    
    var updateSkipValidationInput = function() {
        // Inject input to tell server not to send the verification code
        if ( $('#skip-validation-input').length ) {
          $('#skip-validation-input').val(false);
        }
        else {
          $('#personal-data-form').append('<input id="skip-validation-input" type="hidden" name="skipValidation" value="false"/>');
        }
        if ( !$('#verification-code').val() && !$('#verificationCode').val() && $('.optional-mobile-validation').length ) {
          $('#skip-validation-input').val(true);
        }
	};
    
    var submitCreateAccount = function(e) {
    	e.preventDefault();
    	
        updateSkipValidationInput();
        
      	if($(".sendVerificationCode").is(":visible") && $('.optional-mobile-validation').length === 0 ){
      		$('.sendVerificationCode').hide();
      		$('div.verificationCodeForm').show();
      	}
      	
      	if($("#personal-data-form").valid()){
	      	if ( $('#verificationCode').is(":visible")) {
	  			// Phone in personal data
	      		if($("#personal-data-form input#verificationCode").valid()){
	  				var $this = $(this),
	  				params = {
	  					'verificationCode': $("#personal-data-form #verificationCode").val()
	  				};
	        
			        ajaxCall(
			            $this,
			            csts.CHECK_VERIFICATION_CODE,
			            params,
			            verificationCodePersonalDataSuccess,
			            verificationCodePersonalDataSuccess
			        );
	      		}
	      	}else if( $('[id|="mobile-personal-data"]').is(':visible') || $('[id|="email-personal-data"]').is(':visible') ) {
	      	  // Just enter here if an action regarding the mobile phone is expected in personal data stage (famous -and celebrated- RED SQUARE displayed <-- you gotta love it)
	          // Show an alert saying an action is expected
	          $('body').pushAlert({
	            text: Messages('createAccount.actionRequired'),
	            type: 'danger',
	            icon:'bell'
	          });
			} else {
				$("#personal-data-form").submit();
			}
      	}
    };
    
	// Method call when the resend code lead to a success
	var sendCreationCodeSuccess = function($this, response) {
		var result = response.responseTO.data;
		if (result) {
		    launchCounters();
		    AccountUtils._displayGeneralInformation(Messages('profile.smsSent'));
            $('a.sendVerificationCode').hide();
            $('div.verificationCodeForm').show();
		} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
			 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
			 stopCounters();
		}
		$('.optional-mobile-validation > .loading-icon').remove();
		$('.optional-mobile-validation').removeClass('disabled');
	};
    
    var resetPwdEmailSuccessCb = function($form, result) {
    	var accountBlock = $form.closest('.m-account-block');
        accountBlock.addClass('validated');
        accountBlock.find('.m-account-block-content').hide();
        accountBlock.find('.success-msg-info').show();
        
    	$('.email-reset-pwd-btn').show();
    	$('.loading-icon').hide();
    	
        $('#phone-validation-container').hide();
        $('#check-question-container').hide();
    };
    
    var resetPwdEmailPersonalDataSuccessCb = function($form, result) {
    	
    	$('.email-reset-pwd-btn-personal-data').show();
    	$('.loading-icon').hide();
    	
		$('body').pushAlert({
			text: $form.find(".success-msg").text(),
			type: 'info',
			icon:'bell'
		});
    };
    
    var resetPwdEmailErrorCb = function($form, result) {
        $form.closest('ul').find('.email-reset-pwd-btn').show().next('.loading-icon').remove();
        // Fill errors from ResponseTO
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
    var accountCreationErrorCb = function($form, result) {
		var code = result.responseTO.errors[0].code;
		var message = result.responseTO.errors[0].message;
		var validator;
		
        $form.find('.loading-icon').remove();
		
		if(code == 'account.authentication.forbiddenPassword'){
			validator = $('#personal-data-form').validate( $.extend(null, validationPluginOpts, { rules: { firstName: "alphanumeric", lastName: "alphanumeric" } }) );
            validator.showErrors({
                  "password": message
            });
		} else if (code == 'account.authentication.wrongPassword'){
            validator = $('#personal-data-form').validate( $.extend(null, validationPluginOpts, { rules: { firstName: "alphanumeric", lastName: "alphanumeric" } }) );
            validator.showErrors({
                  "actualPassword": message
            });
		} else {
	        var errors = result.responseTO.errors;
	        showErrors(errors);
		}
    };
    
    var accountCreationSuccessCb = function($form, result) {
        $form.find('.loading-icon').remove();
        if (result.responseTO.data) {
            $('body').pushAlert({ type: "success", text: Messages("createAccount.success"), icon: "chrono" });

            // Form OK : Dequeue and send 'accountCreated'
            CUBE.Analytics.queue.send('accountCreated');
            
            setTimeout(
                function() {
                    if ($form.data("redirect")) {
                        location.href = $form.data("redirect");
                    }
                    else {
                        if (true === needRedirect(result)) {
                            window.location.replace(result.responseTO.data.url);
                            return;
                        }
                        location.href = '/';
                    }
                }, 3000);
        }
    };
    
    // Helper functions
    var showBackButtonNominal = function() {
        $('#login-information-form').find('[type="submit"]').closest('.form-group').addClass('hide');
        $('#restart-process-button').removeClass('hide disabled').prop('disabled', false);
    };
    
    var showErrors = function(errors) {
        var text = Messages("error");
        for (var i in errors) {
            var error = errors[i];
            text += '<br>' + error.message;
        }        
        $('body').pushAlert({ type: "danger", text: text, icon: "bell" });
    };
    
    var validateForm = function($form) {
        $form.find('input, select, [type="submit"], a').prop('disabled', true);
        $form.find('a, [type="submit"]').addClass('disabled');
        $form.find('input').each(function() {
            $(this).closest('.form-group').addClass('validated');
        });
        $form.closest('.m-account-block').addClass('validated');
    };
    
    var invalidateField = function($form, fieldName, errorMessage) {
    	CUBE.Analytics.manualTrackError(fieldName, "other");
        var error = {};
        error[fieldName] = errorMessage;
        $form.validate().resetForm();
        $form.validate().showErrors(error);
    };
    
    var displayGeneralSMSInformation = function() {
		$('body').pushAlert({
			text: Messages('profile.smsSent'),
			type: 'info',
			icon:'bell'
		});
	};
    
    // Page init
    var validationPluginOpts = $.validator.cubeOptions;
    
    var formValidationRulesWithPhone = {
        rules: {
            countryCode: "required",
            mobile: {
              digits: true,
              mobile: {
                countryCodeSelector: '[name="countryCode"]'
              }
            },
            emailmobile: {
            	maxlength: 40,
                or: [
                    {
                        mobile: {
                            fillInput: "mobile",
                            countryCodeSelector: '[name="countryCode"]'
                        }
                    },
                    {
                        email: {
                            fillInput: "email"
                        }
                    }
                ]
            },
            email: {
            	maxlength: 40,
            }
        },
        messages: {
            emailmobile: {
                or: Messages("validationMsg.emailmobile")
            }
        }
    };
    
    var formValidationRulesMobileCode = {
        rules: {
        	verificationCode: {
                required: true,
                digits: true
            }
        }
    };

    $('form#login-information-form').validate($.extend(null, validationPluginOpts, formValidationRulesWithPhone, {invalidHandler: validationErrorCb}));
    
    $('form#login-information-form').handleform('init', { successCb: checkCredentialsSuccessCb });
    
    // For prefilled entry point
    $('form#phone-validation-form').handleform('init', { successCb: codeValidationSuccessCb });
    
    $('form#send-validation-code-form').handleform('init', { successCb: sendCodeValidationSuccessCb, errorCb: sendCodeValidationErrorCb });
    
    $('form#personal-data-form').handleform('init', { successCb: accountCreationSuccessCb, errorCb: accountCreationErrorCb });
    
    $('form.email-complete-account-form').handleform('init', { successCb: completeAccountEmailSuccessCb, errorCb: completeAccountEmailErrorCb });
    
    $('form.email-complete-account-form-personal-data').handleform('init', { successCb: completeAccountEmailPersonalDataSuccessCb, errorCb: completeAccountEmailErrorCb });
    
    $('form.email-reset-pwd-form').handleform('init', { successCb: resetPwdEmailSuccessCb, errorCb: resetPwdEmailErrorCb });
    
    $('form.email-reset-pwd-form-personal-data').handleform('init', { successCb: resetPwdEmailPersonalDataSuccessCb, errorCb: resetPwdEmailPersonalDataSuccessCb });
    
    $('form#restart-process-form').handleform('init', { successCb: resetProcessSuccessCb, errorCb: genericErrorCb });

    $('a.send-code-btn').on('click', function(e) {
        e.preventDefault();
        $('form#send-validation-code-form').trigger('submit');
    });
    
	initializeCounters();
    
    $('.send-code-btn-personal-data').on('click', function(e) {
    	sendCreationCode(e);
        $('#mobile-personal-data-login-arrowbox').hide();
        $('#mobile-personal-data-loyalty-arrowbox').hide();
    });
    
    $('.email-complete-account-btn').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $btn.closest('ul').find('.email-complete-account-form').trigger('submit');
    });
    
    $('.email-complete-account-btn-personal-data').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $('.email-complete-account-form-personal-data').trigger('submit');
    });
    
    $('.email-reset-pwd-btn').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $btn.closest('ul').find('.email-reset-pwd-form').trigger('submit');
    });
    
    $('.email-reset-pwd-btn-personal-data').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $('form.email-reset-pwd-form-personal-data').trigger('submit');
    });
    
    $('#restart-process-button').on('click', function(e) {
        e.preventDefault();
        $(this).prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" /> ');
        $('form#restart-process-form').trigger('submit');
    });
    
    $('.login-with-email-link').on('click', function(e) {
    	// Add email to link on click (to auto fill next form)
    	e.preventDefault();
    	var $href = $(this).attr('href').trim();
    	var emailValue = $('#login-information-form').find('[name="email"]').val();
    	var separator = $href.indexOf("?") == -1 ? '?' : '&';
    	var redirectTo = $href + separator + 'login=' + emailValue.trim();
    	location.href = redirectTo;
    });
    
    // Trigger validation whenever the country code changes
    $('.create-account [name="countryCode"],.create-account [name="mobileCountryCode"]').on('change', function() {
        var $input = $(this).closest('form').find('[name="mobile"],[name="emailmobile"]');
        if ($input.val().length !== 0) {
            if ($input.valid()) {
              $('.sendVerificationCode').show();
              $(this).closest('form-group').addClass('validated');
            }
            else {
              $('.sendVerificationCode').hide();
            }
        }
    });
    
    var mobileChanging = function() {
      if ( $('#verificationCode').length) {
	      $('#mobile-personal-data-login-arrowbox').hide();
	      $('#mobile-personal-data-loyalty-arrowbox').hide();
	      $('.sendVerificationCode').hide();
	      $('.verifyMyMobilePopover').hide();
	      $('.verificationCodeForm').hide();
	      $('#verificationCode').val([]);
	      updateSkipValidationInput();
	      
	      var validator = $('#personal-data-form').validate();
	      
	      if(validator.check('#mobile')){
	        
	          var params = {
	            'mobile': $("#personal-data-form #mobile").val(),
	            'countryCode': $("#personal-data-form").find('[name="mobileCountryCode"]').children(':selected').val(),
	          };
	            
	          ajaxCall(
	              $(this),
	              csts.CHECK_MOBILE,
	              params,
	              mobileExistPersonalDataSuccess,
	              mobileExistPersonalDataSuccess
	          );
	      } 
      }
    };
    
    $("#personal-data-form #mobile").on('keyup', function(e) {
    	mobileChanging();
    });
    
    $('#personal-data-form [name="mobileCountryCode"]').on('change', function(e) {
		mobileChanging();
    });
    
    $("#personal-data-form #email").on('keyup', function(e) {
    	$('#email-personal-data-login-arrowbox').hide();
    	$('#email-personal-data-loyalty-arrowbox').hide();
    });
    
    $("#personal-data-form #email").on('focusout', function(e) {
    	if($("#personal-data-form #email").valid()){
            var $this = $(this),
            params = {
        		'email': $("#personal-data-form #email").val()
        	};
            
	        ajaxCall(
	            $this,
	            csts.CHECK_EMAIL,
	            params,
	            emailExistPersonalDataSuccess,
	            emailExistPersonalDataSuccess
	        );
    	}
    });
    
    $("#personal-data-form #email").on('keyup', function(e) {
    	$('#personaldata-email-arrowbox').hide();
    });
    
    $("a.sendVerificationCode").on('click', sendCreationCode);
    $("a.resendCode").on('click', resendCreationCode);
    
    $("#submitCreateAccount").on('click', submitCreateAccount);

    // Hide the Verify your Mobile Phone popover
    $('.closeVerifyMyMobilePopover').on('click', function(e) {
        e.preventDefault();
        $(this).closest('.popover'). addClass('hidden');
    });
    
    if($('.password-checking').length > 0){
        var passwordChecking =  new PasswordChecking({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
    
    if ($('.password-strengh-list').length > 0) {
        var passwordStrength = new PasswordStrength({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }   
    
    /* FIX UNCHANGING COUNTRY CODE */
    $("#country-code").change(function(event){
    	$("#personal-data-form").find('[name="mobileCountryCode"]').val(event.target.value);
    });
    
    $('#personal-data-form').validate( $.extend(null, validationPluginOpts, {
        rules: {
            confirmPassword: {
                equalTo: "#password"
            },
            password: {
            	passwordCheck: true
            },
            lastName: {
                maxlength: 36,
                extendedalphanumeric: true,
                required: function(element) {
                    return element.hasAttribute('required');
                }
            },
            firstName: {
            	maxlength: 36,
            	extendedalphanumeric: true,
                required: function(element) {
                    return element.hasAttribute('required');
                }
            },
            mobile: {
                digits: true,
                mobile: {
                    countryCodeSelector: '[name="mobileCountryCode"]'
                }
            },
            subscribeOffers: {
            	required: true
            }
        },
        messages: {
            confirmPassword: {
                equalTo: Messages("profile.updatePassword.confirmPassword.equalsTo")
            }
        }
    }));
};
createAccountLoyaltyModule.prototype = new RegistredModule();
createAccountLoyaltyModule.prototype.constructor = createAccountLoyaltyModule;

function createAccountLoyaltyModule() {
	this.selector = '#create-account-loyalty-container';
}

createAccountLoyaltyModule.prototype.loadingBusiness = function() {
    
    // STEPS
    var NOT_EXISTING_CARD = 11;
    var DELETED_CARD = 12;
    var NOT_EXISTING_LOYALTY_ACCOUNT = 14;
    var EXISTING_LOYALTY_ACCOUNT = 13;
    var PREFILLED_FORM = 15;
    var LOGIN_DATA_PHONE = 16;
    var LOGIN_DATA_EMAIL = 17;
    var VERIFY_PHONE_LOYALTY = 20;
    var STATE_RETURNING_LOYALTY_MOBILE_PERSONAL_DATA = 23;
    var STATE_RETURNING_LOGIN_MOBILE_PERSONAL_DATA = 24;
    var LOGIN_DATA_EMAIL_AND_PHONE = 26;
    var LOGIN_DATA_EMAIL_OR_PHONE = 27;
    
    var GENDER_MALE = 1;
 
    var SMS_TIMER = 30;
    var counterInterval;
    var emailEditable;
    
    var initializeCounters = function(){
    	$('a.resend-code-btn').each(function(){
    	    $(this).data('countdown',  new decathlon.userAccount.Countdown($(this), 30));
    	});
    };
    
    var launchCounters = function(){
    	$('a.resend-code-btn').each(function(){
    		$(this).data('countdown').go();
    	});
    };
    
    var stopCounters =  function(){
    	$('a.resend-code-btn').each(function(){
    		$(this).data('countdown').stop();
    	});
    };
    
    var csts = {
    		SEND_CREATION_CODE: 'account/send-creation-code-loyalty',
    		CHECK_VERIFICATION_CODE: 'account/check-verification-code-loyalty',
    		CHECK_MOBILE : 'account/check-mobile-loyalty',
    		CHECK_EMAIL : 'account/check-email-loyalty',
   };
    
    // Necessary code to show the given step (does not hide anything)
    var showStep = function(stepId, data) {
    	
    	var autoSubmitForm = true;
    	
    	switch (stepId) {
    	
            case NOT_EXISTING_CARD:
                $('#card-not-exists-container').show();
                break;
                
            case DELETED_CARD:
                $('#card-deleted-container').show();
                break;
                
            case EXISTING_LOYALTY_ACCOUNT:
                $('#check-question-container').removeClass('sneakpeek');
                $('#check-question-form').validate( $.extend(null, validationPluginOpts, formValidationRulesSecretQuestion) );
                new SecretQuestions("#question-id","#secretAnswer", $("#locale").val(),$("#dateOfBirthFormat").val()).initialize( data.fields);
                break;
                
            case NOT_EXISTING_LOYALTY_ACCOUNT:
                $('#returning-login-loyalty-container').show();
                break;
                
            case LOGIN_DATA_PHONE:
                $('#verify-login-container').show().removeClass('sneakpeek');
                $('.credentials-loyalty-form').validate( $.extend(null, validationPluginOpts, formValidationRulesWithPhone) );
                break;
                
            case LOGIN_DATA_EMAIL:
                $('#verify-login-container').show().removeClass('sneakpeek');
                $('.credentials-loyalty-form').validate( validationPluginOpts );
                
                if(data.emailAvailable === false) {
                	autoSubmitForm = false;
                }
                
                if(!$('.credentials-loyalty-form #email').is(':blank') && autoSubmitForm){
                	$('.credentials-loyalty-form').submit();
                }

                $('personaldata-email').hide();
                
                break;
                
            case LOGIN_DATA_EMAIL_AND_PHONE:
                $('#phone-validation-container').show();
                $('#verify-login-container').show().removeClass('sneakpeek');
                
                if (!$('#mobile').prop('required') && !$('#email').prop('required')) {

                    $('.credentials-loyalty-form input#mobile').rules("add", {
                        required: function(element) {
                            return $('#email').is(':blank');
                        },
                        messages: {
                            required: Messages("validationMsg.fillOne")
                        }
                    });

                    $('.credentials-loyalty-form input#email').rules("add", {
                        required: function(element) {
                            return $('#mobile').is(':blank');
                        },
                        messages: {
                            required: Messages("validationMsg.fillOne")
                        }
                    });
                    
					$('.credentials-loyalty-form input').on('keyup', function() {
                        $('.credentials-loyalty-form').valid();
                    });
                }
                
                if (!data.mobile) {
                    $('#mobile').prop('disabled', false);
                }
                
                if (!data.email) {
                    $('#email').prop('disabled', false);
                    emailEditable = true;
                } else {
                    $('#email').prop('disabled', true);
                }       
                
                break;
                
            case LOGIN_DATA_EMAIL_OR_PHONE:
                $('#phone-validation-container').show();
                $('#verify-login-container').show().removeClass('sneakpeek');
                $('.credentials-loyalty-form').validate( $.extend(null, validationPluginOpts, formValidationRulesWithPhone) );
                
                var preferredIdentifier = data.preferredIdentifier;
                var email = data.email;
                
                $('.credentials-loyalty-form #emailmobile').val(data.preferredIdentifier);
                $('.credentials-loyalty-form #emailmobile').focus();
                
                if(data.emailAvailable === false) {
                	autoSubmitForm = false;
                }
                
                if(preferredIdentifier !== undefined && email !== undefined && preferredIdentifier === email && autoSubmitForm){
                	$('.credentials-loyalty-form').submit();
                }
                
                break;
                
            case VERIFY_PHONE_LOYALTY:
                $('#phone-validation-container').show().removeClass('sneakpeek');
                $('#phone-validation-container #verification-code').val('');
                $('#phone-validation-form').validate($.extend(null, validationPluginOpts, formValidationRulesMobileCode,  { invalidHandler: validationErrorCb }));
                
                // Switch buttons
                $('form.credentials-loyalty-form').find('[type="submit"]').closest('.form-group').addClass('hide');
                $('.modify-login-button').removeClass('hide disabled').prop('disabled', false);
                break;
                
            case PREFILLED_FORM:
                $('#personal-data-container').show().removeClass('sneakpeek');
                $('.mentions').show();
                
        		// For the prefilled form, if we have a value in the login part, we go directly in the personal data
        		var loginEmailInput = $("#personal-data-form #email");
        		if(loginEmailInput.is(":visible") && !loginEmailInput.is(':blank')){
        			emailChanging();
        		}
        		
        		var loginMobileInput = $("#personal-data-form #mobile");
        		if(loginMobileInput.is(":visible") && !loginMobileInput.is(':blank')){
        			mobileChanging();
        		}
        		
                break;
        }
    };
    
    var genericErrorCb = function($form, result) {
        $form.closest('.m-account-block-content').find('.loading-icon').remove();
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
    var validationErrorCb = function(e, validator) {
    	CUBE.Analytics.autoTrackError(validator);
    };
    
    var modifyLoginSuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        $form.closest('.m-account-block-content').find('.loading-icon').remove();
        
        if (data) {
            
            // Clean phone verification form
            $('#phone-validation-form').trigger('reset').validate().resetForm();
            
            // Hide phone verification and personal data step
            $('#phone-validation-container').addClass('sneakpeek');
            $('#personal-data-container').hide();
            
            // Reactivate first login information step
            var $loginInfoForm = $('form.credentials-loyalty-form');
            $loginInfoForm.find('input#mobile, select, [type="submit"]').prop('disabled', false).removeClass('disabled');
            $loginInfoForm.find('input').each(function() {
                $(this).closest('.form-group').removeClass('validated');
            });
            $('#country-code').selectpicker('refresh');
            $loginInfoForm.closest('.m-account-block').removeClass('validated');
            
            // Changing buttons
            $('.modify-login-button').addClass('hide');
            $loginInfoForm.find('[type="submit"]').closest('.form-group').removeClass('hide');
            
            // Enable phone input
            if ((data.nextState == LOGIN_DATA_EMAIL_AND_PHONE && $loginInfoForm.find('input#email').is(':blank')) || emailEditable) {
                $loginInfoForm.find('input#email').prop('disabled', false).removeClass('disabled');
            }
            
            // Restoring SMS sending countdown
            clearInterval(counterInterval);
            $('.code-resent-msg').hide();

            $('.timer-counter').text(SMS_TIMER);
        }
    };
    
    // Success callback for code validation
    var codeValidationSuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        
        switch (data.nextState) {
     
        case VERIFY_PHONE_LOYALTY:
            // If we remain in the same step, it means the code is invalid.
            invalidateField($form, "verificationCode", $.validator.messages.invalidValidationCode);
            break;
            
        case PREFILLED_FORM:
            validateForm( $('#phone-validation-form') );
            $form.closest('.m-account-block').addClass('validated');
            $form.siblings('#send-validation-code-form').hide();
            $('.send-code-btn').hide();
            break;
        }

        showStep(data.nextState, data);
    };
    
    // Success callback for code validation 'send again' function
    var sendCodeValidationSuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        var $btn = $('.send-code-btn');
            
        switch(data.nextState) {
        
        case VERIFY_PHONE_LOYALTY:
            
        	 launchCounters();
            break;
        }
        
        displayGeneralSMSInformation();
        
        showStep(data.nextState, data);
    };
    
    // Method call when the resend code lead to an error
    var sendCodeValidationErrorCb = function($this, result) {
        
       stopCounters();
        
        // Fill errors from ResponseTO
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
    var verificationCodePersonalDataSuccess = function($this, response) {
    	
	  	$("#prefilledMobile").val("");
		$("#prefilledVerificationCode").val("");
		
		$(".form-group").find('.sendVerificationCode').each(function() {
			$(this).removeClass('disabled');
			$(this).find('.loading-icon').remove();
		});
	  
        if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
        	showErrors(response.responseTO.errors);
    	} else if (!response.responseTO.data.valid) {  
             invalidateField($('form#personal-data-form'), "verificationCode", $.validator.messages.invalidValidationCode);
    	} else if (response.responseTO.data.valid){
    		$("#personal-data-form").submit();
    	}
    };
    
    var checkLoyaltySuccessCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        if (data.previousState == NOT_EXISTING_CARD) {
            $('#card-not-exists-container').hide();
        }
        
        if (data.nextState != NOT_EXISTING_CARD) {
            // Form OK : Dequeue and send 'LOYALTY_EVENT'
            CUBE.Analytics.queue.send('LOYALTY_EVENT');
        }
        switch (data.nextState) {
        
        case NOT_EXISTING_CARD:
            invalidateField($form, "cardNumber", $.validator.messages.cardNotExisting);
            break;
            
        case DELETED_CARD:
            $('#check-question-container').hide();
            $form.closest('.m-account-block-content').find('.other-choices, .or').remove();
            validateForm($form);
            break;
                
        case EXISTING_LOYALTY_ACCOUNT:
            $('.m-account-block#loyalty-card-container').addClass('validated');
            $('#verify-login-container').addClass('sneakpeek').show();
            $form.closest('.m-account-block-content').find('.other-choices, .or').remove();
            validateForm($form);
            break;
            
        case NOT_EXISTING_LOYALTY_ACCOUNT:
            $('.m-account-block#loyalty-card-container').addClass('validated');
            $form.closest('.m-account-block-content').find('.other-choices, .or').remove();
            validateForm($form);
            break;
            
        case LOGIN_DATA_EMAIL_AND_PHONE:
            $('#check-question-container').hide();
            $('.m-account-block#loyalty-card-container').addClass('validated');
            $form.closest('.m-account-block-content').find('.other-choices, .or').remove();
            validateForm($form);
            break;
        }
        
        showStep(data.nextState, data);
    };
    
    var forgotCardSuccessCb = function($form, result) {
        setTimeout(function() {
            location.reload();
        }, 10000);
        validateForm($form);
        $('body').pushAlert({ type: "success", text: Messages("createAccount.recoveryEmailSent"), icon: "chrono", delay: 10000 });
    };
    
    var secretQuestionSuccessCb = function($form, result) {
        var data = result.responseTO.data;
        
        if (data.gender) {
            data.gender = (data.gender == GENDER_MALE ? "male" : "female");
        }
        
        if (data.nextState == EXISTING_LOYALTY_ACCOUNT) {
            
            invalidateField($form, "secretAnswer", $.validator.messages.incorrectAnswer);
            
        } else {
            
            $('.m-account-block#check-question-container').addClass('validated');
            $('#secret-question-options').remove();
            
            validateForm($form);
            
            prefillForm( $('#personal-data-form'), data);
            prefillForm( $('.credentials-loyalty-form'), data);
            
            if (data.mobile) {
                // If the account has a mobile, we show right away the button to
                // send the verification code
            	$('[name="mobileCountryCodePd"]').val(data.countryCode).change();
            	$('#personal-data-form #mobile').val(data.mobile);
            }
            
            if (!data.email) {
                // If the account does not have an email, we make it modifiable
                $('#email').prop('disabled', false);
            } else {
            	$('#personal-data-form #email').prop('disabled', true);
            	$('#personal-data-form #email').val(data.email);
            }
        }
        
        showStep(data.nextState, data);
    };
    
    var verifyCredentialsLoyaltyCb = function($form, result) {
        
        var data = result.responseTO.data;
        
        switch(data.nextState) {
        
        case LOGIN_DATA_EMAIL:
        case LOGIN_DATA_EMAIL_AND_PHONE:
            if (!data.emailAvailable) {
                invalidateField($form, "email", $.validator.messages.emailInUse);
            }
            break;
            
        case LOGIN_DATA_EMAIL_OR_PHONE:
            if (!data.emailAvailable) {
                invalidateField($form, "emailmobile", $.validator.messages.emailInUse);
            }
            break;
            
        case VERIFY_PHONE_LOYALTY:
            $('.m-account-block#verify-login-container').addClass('validated');
            validateForm($form);
            $('#personal-data-container').show();
            $('.mentions').show();
            
            if (data.smsSent) {
                displayGeneralSMSInformation();
                launchCounters();
            }
            
            break;
            
        case PREFILLED_FORM:
            $('.m-account-block#verify-login-container').addClass('validated');
            $('#phone-validation-container').hide();
            $('.mentions').show();
            validateForm($form);
            
            break;
        
        default:
            break;
        }
        
        $('#personaldata-mobile').hide();
        $('#personaldata-email').hide();
        
        var mobileCredentials = $('.credentials-loyalty-form #mobile');
        if(mobileCredentials.val() === undefined || mobileCredentials.val() === null || $.trim(mobileCredentials.val()).length === 0){
            $('#personaldata-mobile').show();
        }
        
        var emailCredentials = $('.credentials-loyalty-form #email');
        if(emailCredentials.val() === undefined || emailCredentials.val() === null || $.trim(emailCredentials.val()).length === 0){
            $('#personaldata-email').show();
        }
        
        showStep(data.nextState, data);
    };
    
    var completeAccountEmailSuccessCb = function($form, result) {	
    	  var accountBlock = $form.closest('.m-account-block');
        accountBlock.addClass('validated');
        accountBlock.find('.success-msg-info').show();
        
        var $msg = $form.find('.success-msg').show();
        $('#check-question-container').find('.m-account-block-content').html($msg);
        
        $('#phone-validation-container').hide();

    };
    
    var completeAccountEmailPersonalDataSuccessCb = function($form, result) {
    	$('.email-complete-account-btn-personal-data').show();
    	$('.loading-icon').hide();
    	$('body').pushAlert({
  			text: $form.find(".success-msg").text(),
  			type: 'info',
  			icon:'bell'
  		});
    };
    
    var completeAccountEmailErrorCb = function($form, result) {
        $form.closest('ul').find('.email-complete-account-btn').show().next('.loading-icon').remove();
        // Fill errors from ResponseTO
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
	var mobileExistPersonalDataSuccess = function($this, response) {
		var result = response.responseTO.data;
		if (result) {
			if(!result.mobileAvailable){
		        
				switch(result.nextState) {
		        case STATE_RETURNING_LOYALTY_MOBILE_PERSONAL_DATA:
		        case STATE_RETURNING_LOGIN_MOBILE_PERSONAL_DATA:
					$('#mobile-personal-data-login-arrowbox').show();
					$('.sendVerificationCode').hide();
	                break;
		        default:
		        	$('.sendVerificationCode').show();
		        	break;
		        }
		        
			} else {
                var $inputMobile = $('#personal-data-form input#mobile');
                if ($inputMobile.valid()) {
                    $inputMobile.closest('.form-group').addClass('validated');
                    $('.sendVerificationCode').show();
                    $('.verifyMyMobilePopover').show();
                }
			}
		} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
			 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
		}
	};
	
	var emailExistPersonalDataSuccess = function($this, response) {
		var result = response.responseTO.data;
		if (result) {
			if(!result.emailAvailable){
				invalidateField($('form[id="personal-data-form"]'), "email-pd", $.validator.messages.emailInUse);
			}
		} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
			 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
		}
	};
	
    var resendCreationCode = function(e) {
        e.preventDefault();
        sendCreationCodeUpdate();
    };

    var sendCreationCode = function(e) {
      var sendVerificationCodeButton = $('a.sendVerificationCode');

      // Send the Verification Code only once...
      if (!sendVerificationCodeButton.hasClass('disabled')) {
        resendCreationCode(e);
      }

      // Disable the "Send code" button...
      sendVerificationCodeButton.addClass('disabled').prop('disabled', true);

      // Prevent loading spinner to be displayed multiple times...
      if (!sendVerificationCodeButton.children('img.loading-icon').length) {
        sendVerificationCodeButton.prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />&nbsp;');
      }

      $('.verifyMyMobilePopover').hide();
    };
    
    var sendCreationCodeUpdate = function() {
    	var $this = $(this),
            params = { 'mobile': $('[name="mobile"]').val(), 'mobileCountryCode': $('[name="mobileCountryCode"]').children(':selected').val() };

        ajaxCall(
            $this,
            csts.SEND_CREATION_CODE,
            params,
            sendCreationCodeSuccess,
            sendCreationCodeSuccess
        );
    };
    
	// Method call when the resend code lead to a success
	var sendCreationCodeSuccess = function($this, response) {
		var result = response.responseTO.data;
		if (result) {
		    launchCounters();
		    AccountUtils._displayGeneralInformation(Messages('profile.smsSent'));
        $('a.sendVerificationCode').hide();
        $('div.verificationCodeForm').show();
		} else if (response.responseTO !== undefined && response.responseTO.errors.length > 0) {
			 AccountUtils._displayGeneralError(response.responseTO.errors[0].message);
			 stopCounters();
		}
    $('.optional-mobile-validation > .loading-icon').remove();
    $('#personaldata-mobile .loading-icon').remove();
    $('a.sendVerificationCode').hide().removeClass('disabled');
		$('.optional-mobile-validation').removeClass('disabled');
	};
    
    var resetPwdEmailSuccessCb = function($form, result) {
    	var accountBlock = $form.closest('.m-account-block');
        accountBlock.addClass('validated');
        accountBlock.find('.m-account-block-content').hide();
        accountBlock.find('.success-msg-info').show();
        
    	$('.email-reset-pwd-btn').show();
    	$('.loading-icon').hide();
    	
        $('#phone-validation-container').hide();
        $('#check-question-container').hide();
    };
    
    var resetPwdEmailPersonalDataSuccessCb = function($form, result) {
    	
    	$('.email-reset-pwd-btn-personal-data').show();
    	$('.loading-icon').hide();
    	
		$('body').pushAlert({
			text: $form.find(".success-msg").text(),
			type: 'info',
			icon:'bell'
		});
    };
    
    var resetPwdEmailErrorCb = function($form, result) {
        $form.closest('ul').find('.email-reset-pwd-btn').show().next('.loading-icon').remove();
        // Fill errors from ResponseTO
        var errors = result.responseTO.errors;
        showErrors(errors);
    };
    
    var accountCreationErrorCb = function($form, result) {
		var code = result.responseTO.errors[0].code;
		var message = result.responseTO.errors[0].message;
		var validator = null;
		
        $form.find('.loading-icon').remove();
		
		if(code == 'account.authentication.forbiddenPassword'){
			validator = $('#personal-data-form').validate( $.extend(null, validationPluginOpts, { rules: { firstName: "alphanumeric", lastName: "alphanumeric" } }) );
            validator.showErrors({
                  "password": message
            });
		} else if (code == 'account.authentication.wrongPassword'){
            validator = $('#personal-data-form').validate( $.extend(null, validationPluginOpts, { rules: { firstName: "alphanumeric", lastName: "alphanumeric" } }) );
            validator.showErrors({
                  "actualPassword": message
            });
		} else {
	        var errors = result.responseTO.errors;
	        showErrors(errors);
		}
    };
    
    var accountCreationSuccessCb = function($form, result) {
        $form.find('.loading-icon').remove();
        if (result.responseTO.data) {
            $('body').pushAlert({ type: "success", text: Messages("createAccount.success"), icon: "chrono" });

            // Form OK : Dequeue and send 'accountCreated'
            CUBE.Analytics.queue.send('accountCreated');
            
            setTimeout(
                function() {
                    if ($form.data("redirect")) {
                        location.href = $form.data("redirect");
                    }
                    else {
                        if (true === needRedirect(result)) {
                            window.location.replace(result.responseTO.data.url);
                            return;
                        }
                        location.href = '/';
                    }
                }, 3000);
        }
    };
    
    // Helper functions
    var showErrors = function(errors) {
        var text = Messages("error");
        for (var i in errors) {
            var error = errors[i];
            text += '<br>' + error.message;
        }        
        $('body').pushAlert({ type: "danger", text: text, icon: "bell" });
    };
    
    var prefillForm = function($form, data) {
        $form.find('input').each(function() {
            var name = $(this).attr('name');
            if (data[name]) {
                if ( $(this).attr('type') == "radio" ) {
                    if ( $(this).val() == data[name] ) {
                        $(this).prop('checked', true);
                    }
                }
                else {
                	if( $(this).attr('type') !== "hidden"){
                		$(this).val( data[name] );
                	}
                }
            }
        });
        $form.find('select').each(function() {
            var name = $(this).attr('name');
            if (data[name]) {
                $(this).find('option[value="' + data[name] + '"]').prop('selected', true);
            }
            if ($(this).selectpicker) {
                $(this).selectpicker('refresh');
            }
        });
    };
    
    var validateForm = function($form) {
        $form.find('input, select, [type="submit"], a').prop('disabled', true);
        $form.find('a, [type="submit"]').addClass('disabled');
        $form.find('input').each(function() {
            $(this).closest('.form-group').addClass('validated');
        });
        $form.closest('.m-account-block').addClass('validated');
    };
    
    var invalidateField = function($form, fieldName, errorMessage) {
    	CUBE.Analytics.manualTrackError(fieldName, "other");
        var error = {};
        error[fieldName] = errorMessage;
        $form.validate().resetForm();
        $form.validate().showErrors(error);
    };
    
    var displayGeneralSMSInformation = function() {
		$('body').pushAlert({
			text: Messages('profile.smsSent'),
			type: 'info',
			icon:'bell'
		});
	};
    
    // Page init
    var validationPluginOpts = $.validator.cubeOptions;
    
    var formValidationRulesWithPhone = {
        rules: {
            countryCode: "required",
            mobile: {
              digits: true,
              mobile: {
                countryCodeSelector: '[name="countryCode"]'
              }
            },
            emailmobile: {
            	maxlength: 40,
                or: [
                    {
                        mobile: {
                            fillInput: "mobile",
                            countryCodeSelector: '[name="countryCode"]'
                        }
                    },
                    {
                        email: {
                            fillInput: "email"
                        }
                    }
                ]
            },
            email: {
            	maxlength: 40,
            }
        },
        messages: {
            emailmobile: {
                or: Messages("validationMsg.emailmobile")
            }
        }
    };
    
    var formValidationRulesSecretQuestion = {
        rules: {
        	secretAnswer: {
                required: true,
                text: false,
                email: {
                    depends: function(element) {
                      return $("form#check-question-form #question-id").val()==3;
                    }
                },
                digits: {
                    depends: function(element) {
                      return $("form#check-question-form #question-id").val()==2;
                    }
               }
            }
        }
    };
    
    var formValidationRulesMobileCode = {
        rules: {
        	verificationCode: {
                required: true,
                digits: true
            }
        }
    };

    $('form#loyalty-card-form').validate( $.extend(null, validationPluginOpts, {
        rules: {
            cardNumber: "loyaltycard"
        }
    },
    {invalidHandler: validationErrorCb}));
    $('form#loyalty-card-form').handleform('init', { successCb: checkLoyaltySuccessCb });
    
    $('form#forgot-card-form').validate(validationPluginOpts);
    $('form#forgot-card-form').handleform('init', { successCb: forgotCardSuccessCb });
    
    // For prefilled entry point
    $('form.credentials-loyalty-form').validate( $.extend(null, validationPluginOpts, formValidationRulesWithPhone) );
    
    $('form#phone-validation-form').handleform('init', { successCb: codeValidationSuccessCb });
    
    $('form#send-validation-code-form').handleform('init', { successCb: sendCodeValidationSuccessCb, errorCb: sendCodeValidationErrorCb });
    
    $('form#check-question-form').handleform('init', { successCb: secretQuestionSuccessCb });
    
    $('form.credentials-loyalty-form').handleform('init', { successCb: verifyCredentialsLoyaltyCb });
    
    $('form#personal-data-form').handleform('init', { successCb: accountCreationSuccessCb, errorCb: accountCreationErrorCb });
    
    $('form.email-complete-account-form').handleform('init', { successCb: completeAccountEmailSuccessCb, errorCb: completeAccountEmailErrorCb });
    
    $('form.email-complete-account-form-personal-data').handleform('init', { successCb: completeAccountEmailPersonalDataSuccessCb, errorCb: completeAccountEmailErrorCb });
    
    $('form.email-reset-pwd-form').handleform('init', { successCb: resetPwdEmailSuccessCb, errorCb: resetPwdEmailErrorCb });
    
    $('form.email-reset-pwd-form-personal-data').handleform('init', { successCb: resetPwdEmailPersonalDataSuccessCb, errorCb: resetPwdEmailPersonalDataSuccessCb });
    
    $('form.modify-login-form').handleform('init', { successCb: modifyLoginSuccessCb, errorCb: genericErrorCb });
    
    $('a.send-code-btn').on('click', function(e) {
        e.preventDefault();
        $('form#send-validation-code-form').trigger('submit');
    });
    
	initializeCounters();
    
    $('#send-code-pd-btn').on('click', function(e) {
        e.preventDefault();
        $(this).prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $('form#send-code-pd-form').trigger('submit');
    });
    
    $('#resend-code-pd-btn').on('click', function(e) {
        e.preventDefault();
        $(this).hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $('form#send-code-pd-form').trigger('submit');
    });
    
    $('#resend-code-pd-btn').data('countdown', new decathlon.userAccount.Countdown($('#resend-code-pd-btn'), 30));
            
    $('.send-code-btn-personal-data').on('click', function(e) {
    	sendCreationCode(e);
        $('#mobile-personal-data-login-arrowbox').hide();
    });
    
    $('.email-complete-account-btn').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $btn.closest('ul').find('.email-complete-account-form').trigger('submit');
    });
    
    $('.email-complete-account-btn-personal-data').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $('.email-complete-account-form-personal-data').trigger('submit');
    });
    
    $('.email-reset-pwd-btn').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $btn.closest('ul').find('.email-reset-pwd-form').trigger('submit');
    });
    
    $('.email-reset-pwd-btn-personal-data').on('click', function(e) {
        e.preventDefault();
        var $btn = $(this);
        $btn.hide().after('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" />');
        $('form.email-reset-pwd-form-personal-data').trigger('submit');
    });
    
    $('#restart-process-button').on('click', function(e) {
        e.preventDefault();
        $(this).prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" /> ');
        $('form#restart-process-form').trigger('submit');
    });
    
    $('.modify-login-button').on('click', function(e) {
        e.preventDefault();
        $(this).prepend('<img class="loading-icon" src="/assets/images/ajax-loader.gif" height="17" width="" alt="Loading" /> ');
        $(this).closest('.m-account-block-content').find('form.modify-login-form').trigger('submit');
    });
    
    $('.login-with-email-link').on('click', function(e) {
    	// Add email to link on click (to auto fill next form)
    	e.preventDefault();
    	var $href = $(this).attr('href').trim();
    	var emailValue = $('#login-information-form').find('[name="email"]').val();
    	var separator = $href.indexOf("?") == -1 ? '?' : '&';
    	var redirectTo = $href + separator + 'login=' + emailValue.trim();
    	location.href = redirectTo;
    });
    
    // Trigger validation whenever the country code changes
    $('.create-account [name="countryCode"],.create-account [name="mobileCountryCode"]').on('change', function() {
        var $input = $(this).closest('form').find('[name="mobile"],[name="emailmobile"]');
        if ($input.val().length !== 0) {
            if ($input.valid()) {
              $('.sendVerificationCode').show();
              $(this).closest('form-group').addClass('validated');
            }
            else {
              $('.sendVerificationCode').hide();
            }
        }
    });
    
    $('#forgot-card-btn').on('click', function(e) {
        e.preventDefault();
        $(this).parent('li').hide();
        $('#loyalty-card-form').hide();
        $('#forgot-card-form').show();
    });
    
    var mobileChanging = function() {
      if ( $('#verificationCode').length) {
	      $('#mobile-personal-data-login-arrowbox').hide();
	      $('.sendVerificationCode').hide();
	      $('.verifyMyMobilePopover').hide();
	      $('.verificationCodeForm').hide();
	      $('#verificationCode').val([]);
	      updateSkipValidationInput();  
	      
	      if($("#personal-data-form #mobile").valid()){
	        
	    	  var prefilledMobile = $("#prefilledMobile");
	    	  var prefilledVerificationCode = $("#prefilledVerificationCode");
	    	  
	    	  var checkMobile = true;
	    	  
	    	  	if(!prefilledMobile.is(':blank') && !prefilledVerificationCode.is(':blank') && $("#personal-data-form #mobile").val() === prefilledMobile.val()){
	    	  		//We don't check the preffiled mobile (in case we come from the lost password page)
	    	  		checkMobile = false;
	    	  	}
	    	  	
	    	  	if(checkMobile){
		          var params = {
		            mobile: $("#personal-data-form #mobile").val(),
		            countryCode: $("#personal-data-form").find('[name="mobileCountryCodePd"]').children(':selected').val()
		          };
		            
		          ajaxCall(
		              $(this),
		              csts.CHECK_MOBILE,
		              params,
		              mobileExistPersonalDataSuccess,
		              mobileExistPersonalDataSuccess
		          );
	      		}
	      } 
      }
    };
    
    $("#personal-data-form #mobile").on('keyup', function(e) {
    	mobileChanging();
    });
    
    $('#personal-data-form [name="mobileCountryCodePd"]').on('change', function(e) {
    	mobileChanging();
    });
    
    var emailChanging = function() {
    	if($("#personal-data-form #email").valid()){
            var $this = $(this),
            params = {
        		'email': $("#personal-data-form #email").val()
        	};
            
	        ajaxCall(
	            $this,
	            csts.CHECK_EMAIL,
	            params,
	            emailExistPersonalDataSuccess,
	            emailExistPersonalDataSuccess
	        );
    	}
    };
    
    $("#personal-data-form #email").on('keyup', function(e) {
    	$("#personal-data-form #email").closest('.form-group').removeClass('has-error');
    });
    
    $("#personal-data-form #email").on('focusout', function(e) {
    	emailChanging();
    });
    
    $("a.sendVerificationCode").on('click', sendCreationCode);
    $("a.resendCode").on('click', resendCreationCode);
    

    // Hide the Verify your Mobile Phone popover
    $('.closeVerifyMyMobilePopover').on('click', function(e) {
        e.preventDefault();
        $(this).closest('.popover'). addClass('hidden');
    });
    
    if($('.password-checking').length > 0){
        var passwordChecking =  new PasswordChecking({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
    
    if ($('.password-strengh-list').length > 0) {
        var passwordStrength = new PasswordStrength({
            formGroup: $('.password-process'),
            formGroupConfirm: $('.password-confirm')
        });
    }
    
    var updateSkipValidationInput = function() {
        // Inject input to tell server not to send the verification code to OneID
        if ( $('#skip-validation-input').length ) {
          $('#skip-validation-input').val(false);
        }
        else {
          $('#personal-data-form').append('<input id="skip-validation-input" type="hidden" name="skipValidation" value="false"/>');
        }
        if ( !$('#verification-code').val() && !$('#verificationCode').val() && $('.optional-mobile-validation').length ) {
          $('#skip-validation-input').val(true);
        }
	};
    
    /**
     * Handler for account creation button's click event, loyalty process
     */
    $('#create-account-loyalty-btn').on('click', function(e) {
    	e.preventDefault();

        updateSkipValidationInput();
        
      	if($(".sendVerificationCode").is(":visible") && $('.optional-mobile-validation').length === 0 ){
      		$('.sendVerificationCode').hide();
      		$('div.verificationCodeForm').show();
      	}
      	
      	if($("#personal-data-form").valid()){
	      	if ( $('#verificationCode').is(":visible")) {
	      	
		        // Phone in personal data
	        	if($("#personal-data-form input#verificationCode").valid()){
	                var $this = $(this),
	                params = {
	            		'verificationCode': $("#personal-data-form #verificationCode").val()
	            	};
	                
	    	        ajaxCall(
	    	            $this,
	    	            csts.CHECK_VERIFICATION_CODE,
	    	            params,
	    	            verificationCodePersonalDataSuccess,
	    	            verificationCodePersonalDataSuccess
	    	        );
	        	}
	        } else if( $('[id|="mobile-personal-data"]').is(':visible')) {
	        	  // Just enter here if an action regarding the mobile phone is expected in personal data stage (famous -and celebrated- RED SQUARE displayed <-- you gotta love it)
	            // Show an alert saying an action is expected
	            $('body').pushAlert({
	              text: Messages('createAccount.actionRequired'),
	              type: 'danger',
	              icon:'bell'
	            });
	  		} else {
	        	 $("#personal-data-form").submit();
	        }
    	}
	});
    
    /* FIX UNCHANGING COUNTRY CODE */
    $("#country-code").change(function(event){
    	$("#personal-data-form").find('[name="mobileCountryCodePd"]').val(event.target.value);
    });
    
    $('#personal-data-form').validate( $.extend(null, validationPluginOpts, {
        rules: {
            confirmPassword: {
                equalTo: "#password"
            },
            password: {
            	passwordCheck: true
            },
            lastName: {
                maxlength: 36,
                extendedalphanumeric: true,
                required: function(element) {
                    return element.hasAttribute('required');
                }
            },
            firstName: {
                maxlength: 36,
                extendedalphanumeric: true,
                required: function(element) {
                    return element.hasAttribute('required');
                }
            },
            mobilepd: {
                digits: true,
                mobile: {
                    countryCodeSelector: '[name="mobileCountryCodePd"]'
                }
            },
            subscribeOffers: {
            	required: true
            }
        },
        messages: {
            confirmPassword: {
                equalTo: Messages("profile.updatePassword.confirmPassword.equalsTo")
            }
        }
    }));
    
	$(document).ready(function() {
		// For the prefilled form, if we have a value in the login part, we go directly in the personal data
		var loginEmailMobileInput = $('.credentials-loyalty-form #emailmobile');
		var autoSubmitForm = false;
		
		if(loginEmailMobileInput.is(":visible") && !loginEmailMobileInput.is(':blank')){
			autoSubmitForm = true;
		}
		
		var loginMobileInput = $('.credentials-loyalty-form #mobile');
		if(loginMobileInput.is(":visible") && !loginMobileInput.is(':blank')){
			autoSubmitForm = true;
		}
		
		var loginEmailInput = $('.credentials-loyalty-form #email');
		if(loginEmailInput.is(":visible") && !loginEmailInput.is(':blank')){
			autoSubmitForm = true;
		}
		
		if(autoSubmitForm){
			$('.credentials-loyalty-form').submit();
		}
	});
};

dashboardModule.prototype = new RegistredModule();
dashboardModule.prototype.constructor = dashboardModule;

function dashboardModule() {
	this.selector = '#dashboard';

}

dashboardModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'DashboardPlugin',

    };

    var methods = {


    };
    
    $.fn.DashboardPlugin = basePlugin(methods, csts.NAME);
    

    // Check if this is the dashboard page
    if($('.account.dashboard').find('#dashboard').length) {
    	$('body').addClass('dashboard-page');
    }

    // check if nav preference must be reopened
    if ($('.account.dashboard').find('#address-book-list, #mystore-page, #mysubscriptions-page, #mylanguage-page').length) {
    	$('.account-nav').find('#preferences').collapse('show');
    }

    

    if ($('.account.dashboard').find('.loyalty').length){
    	$('.popover-alert-btn').popover();
    }
};
myStoreModule.prototype = new RegistredModule();
myStoreModule.prototype.constructor = myStoreModule;

function myStoreModule() {
	this.selector = '#mystore-page';
}

myStoreModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MyStorePlugin',

    };

    var methods = {


    };
    
    $.fn.MyStorePlugin = basePlugin(methods, csts.NAME);
    
    $("#itinary-mystore").on('click', function(e){
        e.preventDefault();
        var storeName = jQuery("#storeName").text();
        storeName = storeName.substring(0, storeName.indexOf("("));
          window.open('http://map.baidu.com/?newmap=1&ie=utf-8&s=s%26wd%3D迪卡侬'+storeName,'_blank');
    });
};
myReturnsModule.prototype = new RegistredModule();
myReturnsModule.prototype.constructor = myReturnsModule;

function myReturnsModule() {
	this.selector = '#my-returns';
}

myReturnsModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MyReturnsPlugin',

    };

    var methods = {

            reloadReturnsForPagination: function() {
            	
                var $this = $(this),
                // reloadCartridge my-returns from the begining
                params = {'currentPage': $this.data().page };

                reloadCartridgeContentCollection(
                        $this,
                        'my-returns',
                         params,
                         methods._reloadReturnsSuccess);
            },
            
            
            _reloadReturnsSuccess: function(){
            	
                myReturnsEvents();
            },
    };
    
    $.fn.MyReturnsPlugin = basePlugin(methods, csts.NAME);

    var myReturnsEvents = function() {
        $(".next").on('click',function(e) {
        	e.preventDefault();
            (function($this) {
                $this.MyReturnsPlugin('reloadReturnsForPagination');
            })($(this));
        });
        $(".previous").on('click',function(e) {
        	e.preventDefault();
            (function($this) {
                $this.MyReturnsPlugin('reloadReturnsForPagination');
            })($(this));
        });
        $(".change-page").on('click',function(e) {
        	e.preventDefault();
            (function($this) {
                $this.MyReturnsPlugin('reloadReturnsForPagination');
            })($(this));
        });
        
        decathlon.tools.slickReinitSlider('.product-item', '.product-img', '', productListSlickSettings);
    };

    $(function(){
    	myReturnsEvents();
    });
    
    };
myVouchersModule.prototype = new RegistredModule();
myVouchersModule.prototype.constructor = myVouchersModule;

function myVouchersModule() {

	this.selector = '#my-vouchers';

}

myVouchersModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MyVouchersPlugin',

    };
    
    var settings = {
    	LOYALTY_MOVEMENT_TABLE : '#loyaltyPointMovementTable'
    };

    var methods = {
            reloadVouchersForPagination: function() {
                var $this = $(this),

                params = { 'nextvouchers': $this.data().nextvouchers,
                           'previousCount' :$this.data().previouscount };

                reloadCartridgeContentCollection(
                        $this,
                        'my-vouchers',
                         params,
                         methods._reloadVouchersSuccess,
                         methods._reloadVouchersSuccess);
            },
            
            _reloadVouchersSuccess: function(){
            	myLoyaltyBalancePointsEvents();
                myVouchersEvents();
            },
            
            _setUserLoyaltySubscriptionSucess: function($this, response, params){
                if (response[0] !== null && response[0].responseTO !== null && response[0].responseTO !== undefined && response[0].responseTO.errors.length > 0) {
                    AccountUtils._displayGeneralError(Messages(response[0].responseTO.errors[0].code));
                    $this.show();
                    AccountUtils._enableFormBtn($($this));
                } else {
                    AccountUtils._displayGeneralSuccess();
                    mySubscriptionEvents();
                    
                    // Reload cartridge for Vouchers
                    reloadCartridgeContentCollection(
                            $this,
                            'my-vouchers',
                             {},
                             methods._reloadVouchersSuccess,
                             methods._reloadVouchersSuccess);
                    
                    // Reload cartridge for Balance points
                    reloadCartridgeContentCollection(
                            $this,
                            'my-balance-points',
                             {},
                             methods._reloadVouchersSuccess,
                             methods._reloadVouchersSuccess);
                }
            },
            
            _openLoyaltySubscriptionForm: function(e) {
                e.preventDefault();
                $('form.loyalty-subscription-form').show();
                $('#messageLoyaltySubscription').show();
                $('#loyaltySubscriptionInformation').hide();
                $('#editMyLoyaltySubscription').hide();
                $('.popover-alert-btn').popover('show');
            },
            
            _closeLoyaltySubscriptionForm: function(e){
                e.preventDefault();
                $('form.loyalty-subscription-form').hide();
                $('#messageLoyaltySubscription').hide();
                $('#loyaltySubscriptionInformation').show();
                $('#editMyLoyaltySubscription').show();
                $('form#updatePreferedLanguage')[0].reset(); 
            }

    };
    
    $.fn.MyVouchersPlugin = basePlugin(methods, csts.NAME);

    var myVouchersEvents = function() {
        $(".moreVouchers").on('click',function() {
            (function($this) {
                $this.MyVouchersPlugin('reloadVouchersForPagination');
            })($(this));
        });
        /* Loyalty */
        $('.slick-vouchers').slick({
            infinite: true,
            arrows: true,
            dots: false,
            speed: 300,
            slidesToShow: 1,
            slidesToScroll: 1
        });
    };
    
    var mySubscriptionEvents = function() {
        var validationPluginOpts = $.validator.cubeOptions;
        $('form.loyalty-subscription-form').validate($.extend(null, validationPluginOpts, {
            ignore: ""
        }));
        $('form.loyalty-subscription-form').handleform('init', { successCb: methods._setUserLoyaltySubscriptionSucess });
        
        $("#editMyLoyaltySubscription").on('click', methods._openLoyaltySubscriptionForm);
        $("#cancelMyLoyaltySubscription").on('click', methods._closeLoyaltySubscriptionForm);
        
        $('.popover-alert-btn').popover('show');
    };
    
    var myLoyaltyBalancePointsEvents = function() {
    	var loyaltyPointMovementTable = $(settings.LOYALTY_MOVEMENT_TABLE);
    	if(loyaltyPointMovementTable){
    		loyaltyPointMovementTable.after('<nav><ul id="nav" class="pagination"></ul></nav>');
            var rowsShown = loyaltyPointMovementTable.data('size-per-page');
            if(!rowsShown || rowsShown < 1){
            	rowsShown = 10;
            }
            var loyaltyPointMovementTableTr = $(settings.LOYALTY_MOVEMENT_TABLE + ' tbody tr');
            var rowsTotal = loyaltyPointMovementTableTr.length;
            var numPages = Math.ceil(rowsTotal/rowsShown);
            createNavigationBar(numPages, 1, $('#nav'));
            loyaltyPointMovementTableTr.hide();
            loyaltyPointMovementTableTr.slice(0, rowsShown).show();
            $('#nav a').bind('click', function(e){
            	e.preventDefault();
            	if(!$(this).parent().hasClass('active')){
            		$('body').scrollTo('#headingOne');
                    $('#nav li').removeClass('active');
                    $(this).parent().addClass('active');
                    var currPage = $(this).attr('rel');
                    var startItem = currPage * rowsShown;
                    var endItem = startItem + rowsShown;
                    createNavigationBar(numPages, (parseInt(currPage)+1), $('#nav'));
                    loyaltyPointMovementTableTr.css('opacity','0.0').hide().slice(startItem, endItem).
                            css('display','table-row').animate({opacity:1}, 300);
            	}
            	
            });
    	}
    	
    	$(".my-vouchers-link").on('click',function(e) {
            (function($this) {
            	e.preventDefault();
            	$('body').scrollTo('#my-vouchers');
            })($(this));
        });
    };
    
    var createNavigationBar = function(numPages, currentPage, $nav) {
    	if($nav.is(':empty')) {
    		$nav.append('<li></li>');
        	for(i = 0;i < numPages;i++) {
                var pageNum = i + 1;
                if(pageNum == currentPage) {
                	$nav.append('<li class="active"><a class="change-page" href="#" rel="'+i+'">'+pageNum+'</a></li>');
                } else {
                	$nav.append('<li><a class="change-page" href="#" rel="'+i+'">'+pageNum+'</a></li>');
                }
            }
        	$nav.append('<li></li>');
    	} else {
    		$( 'a[class="change-page"]' ).show();
    		$( 'li[class="hidden-page"]' ).remove();
    	}
    	
    	if(numPages>=10) {
    		var pointsElement = '<li class="hidden-page"><a class="change-page">...</a></li>';
    		if (currentPage < 4) {
    			for(i = currentPage+1;i < numPages-1;i++) {
    				if(i>2) {
    					$( "a[rel='"+i+"']" ).hide();
    				}
    			}
    			$( "a[rel='"+(numPages-2)+"']" ).parent().after(pointsElement);
    		} else if ( numPages - currentPage < 4 ) {
    			for(i = 1;i < currentPage-2;i++) {
    				if(i<numPages-3) {
    					$( "a[rel='"+i+"']" ).hide();
    				}
    			}
    			$( "a[rel='"+(currentPage-4)+"']" ).parent().after(pointsElement);
    		} else {
    			for(i = 1;i < (numPages-1);i++) {
    				console.log(currentPage-1);
    				if(i+1<currentPage-1 || i+1>(currentPage+1)) {
    					$( "a[rel='"+i+"']" ).hide();
    				}
    			}
    			$( "a[rel='"+(currentPage-3)+"']" ).parent().after(pointsElement);
    			$( "a[rel='"+(currentPage+1)+"']" ).parent().after(pointsElement);
    		}
    	}
    };

    
    myVouchersEvents();
    mySubscriptionEvents();
    myLoyaltyBalancePointsEvents();
};
mobilePhoneModule.prototype = new RegistredModule();
mobilePhoneModule.prototype.constructor = mobilePhoneModule;

function mobilePhoneModule() {

	this.selector = '';

}

mobilePhoneModule.prototype.loadingBusiness = function() {

	// Plugin constants
	var csts = {
		// Plugin identifier
		NAME : 'MobilePhonePlugin',
		SELECT_PICKER_CLASS : ".selectpicker"
	};

	var methods = {
		_countryCodeChanged : function(option){
        	var exemple = option.attr("example");
        	var regex = option.attr("regex");

        	if(exemple) {
        		$(".phone-example-group").show();
        		$(".phoneExample").html(exemple);
        	} else {
        		$(".phone-example-group").hide();
        	}
        	$(".phoneExample").html(exemple);
        	$("#mobile").attr("pattern",regex);
        }
	};
	
	

	$.fn.MobilePhonePlugin = basePlugin(methods, csts.NAME);
	
	var mobilePhoneEvents = function() {
		$(csts.SELECT_PICKER_CLASS).change(function(elem){
        	var option = $(elem.target).find("option:selected");
        	methods._countryCodeChanged(option);
        	});
        
        methods._countryCodeChanged($("select[name=mobileCountryCode]").find("option:selected"));
	}
    mobilePhoneEvents();

};
accountStoreModule.prototype = new RegistredModule();
accountStoreModule.prototype.constructor = accountStoreModule;

function accountStoreModule() {
	this.selector = 'body.store-page';

}

accountStoreModule.prototype.loadingBusiness = function() {

	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'AccountStorePlugin',
        

        CANCEL_FAVORITE_STORE: 'rest/model/atg/userprofiling/ProfileActor/cancelUsualStore',
        SET_FAVORITE_STORE: 'rest/model/atg/userprofiling/ProfileActor/setUsualStore',
    };

    var methods = {

            
            cancelFavoriteStore: function() {
                var $this = $(this);
                getAjaxHandler()
            	.withCaller($this)
            	.withUrl(csts.CANCEL_FAVORITE_STORE)
            	.withParameters({})
            	.withSuccess(methods._cancelFavoriteStoreSuccess)
            	.withError(function() {})
            	.call();
            },
            
            setFavoriteStore: function() {
                var $this = $(this); 
                var storeId = $("#favorite-store").data("storeid");
                var params = {'storeId' : storeId};
                
                getAjaxHandler()
            	.withCaller($this)
            	.withUrl(csts.SET_FAVORITE_STORE)
            	.withParameters(params)
            	.withSuccess(methods._setFavoriteStoreSuccess)
            	.withError(function() {})
            	.call();
            },


            _setFavoriteStoreSuccess : function($this) {
                if(!$("#favorite-store").data('cancellable')) {
                    $("#favorite-store").prop('disabled', true);
                }
                // Hide the "Select as Favorite" label
                $("#select-favorite-store").hide();
                // Display the "My Favorite" label
                $("#is-favorite-store").toggle();
                reloadCartridgeContentCollection(
                		$this,
                        'header-my-account',
                        {},
                        AccountUtils._reloadHeaderMyAccountSuccessError,
                        AccountUtils._reloadHeaderMyAccountSuccessError);
            

            },
            
            _cancelFavoriteStoreSuccess : function($this) {
                // Display the "My Favorite" label
                $("#is-favorite-store").hide();
                // Hide the "Select as Favorite" label
                $("#select-favorite-store").toggle();
                reloadCartridgeContentCollection(
                		$this,
                        'header-my-account',
                        {},
                        AccountUtils._reloadHeaderMyAccountSuccessError,
                        AccountUtils._reloadHeaderMyAccountSuccessError);
            
            },



    };
    
    $.fn.AccountStorePlugin = basePlugin(methods, csts.NAME);
      
    $("input:checkbox[id=favorite-store]").on('change', function(e) {
        (function($this) {
            e.preventDefault();
            if($this.is(':checked')){
                $this.AccountStorePlugin("setFavoriteStore");
            } else {
                $this.AccountStorePlugin("cancelFavoriteStore");
            }
        })(jQuery(this));
     });

};
secretQuestionModule.prototype = new RegistredModule();
secretQuestionModule.prototype.constructor = secretQuestionModule;

// Assuming :
// * The question secret dropdown have the class '.dropdown-secret-question'
// * The answer input have the id #secretAnswer
// * The locale is in a hidden field #locale
// * the dateOfBirthFormat is in a hidden field #dateOfBirthFormat

function secretQuestionModule() {

	this.selector = '.dropdown-secret-question';

}

secretQuestionModule.prototype.loadingBusiness = function() {

	// Plugin constants
	var csts = {
		// Plugin identifier
		NAME : 'SecretQuestionPlugin',
		SECRET_FIELD_EMAIL : "email",
		SECRET_FIELD_PHONE : "telPortable",
		SECRET_FIELD_CARD : "numeroCarte",
		SECRET_FIELD_NOM : "nom",
		SECRET_FIELD_PRENOM : "prenom",
		SECRET_FIELD_BIRTHDATE : "dateNaissance"
	};

	var methods = {

	};

	SecretQuestions = function(secretQuestionDropDownSelector,
			secretAnswerSelector, locale, dateFormat) {



		this.$secretQuestionDropDown = $(secretQuestionDropDownSelector);
		this.secretAnswerSelector = secretAnswerSelector;
		this.locale = locale;
		this.dateFormat = dateFormat;

		this.updateAnswerInput = function(fieldValue) {
			console.log(this);
			switch (fieldValue) {
			case csts.SECRET_FIELD_BIRTHDATE:

				$(this.secretAnswerSelector).datetimepicker({
					locale : this.locale,
					format : this.dateFormat
				});
				$(this.secretAnswerSelector).data("DateTimePicker").maxDate(
						new Date());
				break;
			default:
				$(this.secretAnswerSelector).replaceWith($(this.secretAnswerSelector).clone());
				$(this.secretAnswerSelector).val('');
			}
		};

		this.addOptionSecretQuestion = function(fieldValue) {
			switch (fieldValue) {
			case csts.SECRET_FIELD_EMAIL:
				this.$secretQuestionDropDown.append($("<option></option>")
						.attr("value", fieldValue).text(
								Messages("createAccount.whatIsYourEmail")));
				break;
			case csts.SECRET_FIELD_PHONE:
				this.$secretQuestionDropDown.append($("<option></option>")
						.attr("value", fieldValue)
						.text(Messages("createAccount.whatIsYourPhoneNumber")));
				break;
			case csts.SECRET_FIELD_CARD:
				this.$secretQuestionDropDown.append($("<option></option>")
						.attr("value", fieldValue)
						.text(Messages("createAccount.whatIsYourLoyaltyCard")));
				break;
			case csts.SECRET_FIELD_PRENOM:
				this.$secretQuestionDropDown.append($("<option></option>")
						.attr("value", fieldValue).text(
								Messages("createAccount.whatIsYourFirstName")));
				break;
			case csts.SECRET_FIELD_NOM:
				this.$secretQuestionDropDown.append($("<option></option>")
						.attr("value", fieldValue).text(
								Messages("createAccount.whatIsYourLastName")));
				break;
			case csts.SECRET_FIELD_BIRTHDATE:
				this.$secretQuestionDropDown.append($("<option></option>")
						.attr("value", fieldValue).text(
								Messages("createAccount.whatIsYourBirthdate")));
				break;
			}
		};

		this.initialize = function(questions) {

			var secretQuestion = this;
			this.$secretQuestionDropDown.on("change", function() {
				secretQuestion.updateAnswerInput($(this).val());
			});

			if (questions !== null) {
				for (i = 0; i < questions.length; ++i) {
					if (questions[i].fiedlHasValue) {
						secretQuestion.addOptionSecretQuestion(questions[i].fieldName);
					}
				}
			}
		};
	};

	$.fn.SecretQuestionPlugin = basePlugin(methods, csts.NAME);

};
genericAddressFormModule.prototype = new RegistredModule();
genericAddressFormModule.prototype.constructor = genericAddressFormModule;

function genericAddressFormModule() {
	
}

genericAddressFormModule.prototype.loadingBusiness = function() {
    
    
	  // Plugin constants
    var csts = {
        // Plugin identifier
        NAME: 'MyAddressBookPlugin',

        GET_GEO_DATA_BY_POSTAL_CODE: 'rest/model/com/decathlon/cube/geodata/actor/GeoDataActor/getGeoDataByPostalCode',
        GET_ADDRESS_CONFIG_BY_COUNTRY :'/rest/model/atg/userprofiling/ProfileActor/getAddressConfigByCountry',
        	GET_GEO_DATA_BASE_URL :'rest/model/com/decathlon/cube/geodata/actor/GeoDataActor/'
    };
    
    

    /**** UTILITIES ****/

    var checkFieldsValidities = function(fields){
        fields = fields !== null && fields !== undefined ?fields:[];
     
        for(var i in fields){

        	var domElement = $(fields[i]);

            if( !domElement || !domElement[0].checkValidity()){
                return false;
            }
        }
    	
        return true;
    };

    var cleanFields = function(fields){
    	if(fields){
    	$.each(fields,function(){
    		var field = $(""+this);
    		if(isSelect(field)){
    			field.find("option:gt(0)").remove();
    		}
    		else{
    			field.removeAttr("readonly");
    			field.val('');
    		}
    		
    	});
    	}
    };
    var isSelect = function(jqElement){
    	if(jqElement[0]!==null && jqElement[0]!==undefined && jqElement[0].tagName && jqElement[0].tagName.toLowerCase() == "select"){
    		return true;
    	}
    	return false;
    };

    var buildApiJson = function(params){
        params = params!==null && params!==undefined ? params:{};
    	
        var dataUrl = "{";
    	 
    	for(var key in params){
    		var value;
    		if(params[key].startsWith("#")){
    			value = $(params[key]).val();
    		}
    		else value = params[key];
    		
    			dataUrl += '"'+key+'":"'+value+'",';
    	}
        
        dataUrl = dataUrl.slice(0, -1);
    	dataUrl += "}";
        
        return JSON.parse(dataUrl); 
    };

    var unlockFields = function(fields){
        $.each(fields,function(){
        	var field = $(this.fieldId);
	        if(field !== null && field !== undefined){
	        	field.attr("disabled",false);
	        }
        });
    };
    
    var makeFieldsReadOnly = function(fields){
        $.each(fields,function(){
        	var field = $(this.fieldId);
	        if(field !== null && field !== undefined && !isSelect(field)){
	        	field.attr("readonly",true);
	        }
        });
    };

    var mapObjects= function(objects){
    	var array=[];
    	if(objects){
    	  $.each(objects,function(){
       		  array.push(this.fieldId);
       	  });     	  
    	} 
    	return array;
    };
    
    var index = function(obj,i) {
    	return obj!==null  && obj!==undefined? obj[i] : null;
	};
    /**** LIAISON GENERATOR ****/


    var DEFAULT_GEODATE_API = "getGeoDataByPostalCode"; 


        var addLinkActions = function(liaisons){
	    		liaisons=liaisons?liaisons:[];
	    $.each(liaisons,function(){
	    			var api = this.api!==null?this.api:DEFAULT_GEODATE_API;
	    			addLinkAction(api, this.triggers,this.destinations,this.params,this.fieldToClean);
	    });

        
        };

        var addLinkAction = function(api, triggers,destinations, params,fieldToClean){
        	triggers=triggers?triggers:[];
        	
            $.each(triggers,function(){
            	if(this == 'INITIAL'){
            		callGeoDataAPI(api, buildApiJson(params), destinations);
            	}
            	else{
	            	var domSource = $(""+this);
	    			if(domSource){
	    				var event = "keyup"; // Default is test
	    				if(isSelect(domSource)) {
	    					event = "change";
	    				}
	    				
	    				domSource.on(event,function(){
	    					cleanFields(mapObjects(destinations));
	    					if(checkFieldsValidities(triggers)){
	    						cleanFields(fieldToClean);
	    						callGeoDataAPI(api, buildApiJson(params), destinations);
	    					}          
	    				});
	    				// We trigger the event in case of autofill datas
	    				domSource.keyup();
	    			}
            	}
            });
        };


    /**** API GEO DATA ACTION ****/

   

    var callGeoDataAPI = function(api, datas, destinations){

        var url = csts.GET_GEO_DATA_BASE_URL + api+"?"+$.param(datas);

        ajaxCall(
            $(this),
            url,
            null, 
            function($this, result){
            	var r = result.responseTO.data;
                updateFormInfoFromGeoDataResponse(r,destinations);
       
            },
            function(e){
    			console.log("error : " + e);
    		}
        );	
    };


    var updateInputFieldWithResult = function(config,field,results){
    	
    	var dataPath = config.dataPath;

			var updatedField = false;
				var attrValue = dataPath.split('.').reduce(index,results);
				if(attrValue !== null && attrValue !== undefined){
					field.val(attrValue);
					updatedField = true;
				}
			
			// Disable only is update

			if(updatedField & !config.keepFieldEnabled){
    			field.attr("readonly",true);
			}
			return updatedField;
    };
    
    var updateSelectFieldWithResult = function(config,field,results){
    	
    	field.find("option:gt(0)").remove();
    	$.each(results,function(){
    		
    		var selected = CurrentAddress!==null && CurrentAddress!==undefined && (this[config.value]==CurrentAddress[config.defaultShippingValue]);

	    		field.append(
	       	 $('<option/>', {
	             'value':this[config.value],
	             'text':this[config.text],
	             'selected':selected
	         }));
    	});

    	$('.selectpicker').selectpicker('refresh');
    
    	field.trigger("change");
    	return true;
    };
    
    
    var updateFormInfoFromGeoDataResponse = function(results, destinations){

    	destinations=destinations?destinations:[];
         
    	results=results?results:[];

    	$.each(destinations,function(){
    		var field = $(this.fieldId);
    		var dataPath = this.dataPath;

    		var updated;
    		if(dataPath !== null && dataPath !== undefined && field){

    			if(isSelect(field)) {
    				updated = updateSelectFieldWithResult(this,field,results);
    			}
    			else{
    				updated = updateInputFieldWithResult(this,field,results);
    			}
				
    			if(updated){
    				field.parents(".form-group").removeClass("has-error");
    			}
    			else{
    				field.removeAttr("readonly");
    			}
    		
    		}
    	}); 
    };

    var reloadForm= function(country,addressType) {
    	var $this = $(this);
    	reloadCartridgeContentCollection(
                $this,
                'addressFormGenerator',
                 {'countryGeoCode':country, 'idAddress':$("#idAddress").val(),'addressType':addressType},
                 function(){
                	 $('.selectpicker').selectpicker('render');
                	 addLinkActions(Liaisons);
                 },
                function(error){
                	 console.log(" error : " +error);
                 });
    };
    
    var getAddressConfigByCountry = function(country,addressType){
        reloadForm(country,addressType);
    };


    genericAddressFormModule.addLinkActions = addLinkActions;
    genericAddressFormModule.getAddressConfigByCountry = getAddressConfigByCountry;

};
headerModule.prototype = new RegistredModule();
headerModule.prototype.constructor = headerModule;

function headerModule() {
    this.selector = '#container-header';
}

headerModule.prototype.loadingBusiness = function() {

      // Plugin constants
    var csts = {
        // Plugin identifier
        NAME                        :   'HeaderPlugin',
        LOGOUT_LINK_CLASS           :   ".logoutLink",
        LOGOUT_URL_DATA             :   "logout-url",
        CUSTOMER_PORTAL_URL_DATA    :   "cp-url"
    };

    var methods = {
        _registerLogoutCallBack : function($this, result) {
            $('#container-header').on('click', '.logoutLink', function(e) {
                e.preventDefault(); 
                window.location.href    =   $(e.currentTarget).data(csts.LOGOUT_URL_DATA);
                var customerPortalLogoutUrl = $(e.currentTarget).data(csts.CUSTOMER_PORTAL_URL_DATA);
                if (customerPortalLogoutUrl) {
                    (new Image()).src       =   customerPortalLogoutUrl;
                }
            });
        }
    };
    
    $.fn.HeaderPlugin = basePlugin(methods, csts.NAME);
    
    methods._registerLogoutCallBack();
};
Plugins.register('Transverse', function($required) {
	// --------------------------------------------------------------------
	// Plugin definition
	// --------------------------------------------------------------------
	(function($) {
		var csts = {
				NAME: 'TransversePlugin'
		};
		

		var methods = {
			init:function() {
				return this.each(function() {
					// init next button

					$(window).on("load", function() {
						methods.equalizeElements();
					});

					var $this = $(this);
				});
			},

			equalizeElements : function($this){
			    $("[data-equalizer]").each(function(index, groupToEqualize){
				        var maxHeight = 0;
				        var $children = $(groupToEqualize).find("[data-equalizer-watch]");

				        var heights = $children.map(function(index, objectToEqualize){
			            var $objectToEqualize = $(objectToEqualize);
			            var currentHeight = $objectToEqualize.height();
			            if (maxHeight<currentHeight){
			                maxHeight = currentHeight;
			            }
			            return {jqueryObjectToEqualize: $objectToEqualize, height:currentHeight};
			        });
			        $.each(heights, function(index, itemToEqualize){
			            var $objectToEqualize = itemToEqualize.jqueryObjectToEqualize;
			            $objectToEqualize.height(maxHeight);
			            var marginTop=0;
			            if ($objectToEqualize.hasClass('verticalAlign')){
			                marginTop = maxHeight-itemToEqualize.height;
			            }
			            else if ($objectToEqualize.hasClass('middleAlign')){
			                marginTop = (maxHeight-itemToEqualize.height)/2;
			            }
			            $objectToEqualize.children().first().css({marginTop:marginTop +'px'});
			        });
			    });
			}
		};
		$.fn.TransversePlugin = basePlugin(methods, csts.NAME);
	})(jQuery);


//	--------------------------------------------------------------------
//	End of plugin definition
//	----------------------------------------------------- ---------------
	$required.TransversePlugin();
});
/* Enable the loading of modules specific to some pages */
var JsRegistrer = {
	
	attachToDom: function() {
	
		this.loadableModule = [];
		
		// We are on the product detail page.
		if ($('.product-page').length > 0) {
			// Order of modules is uber important due to dependencies (shame) ...
			this.loadableModule = [ 
			                        new pdmainCartridgeRegistrer(),
			                        new productAmbianceFloorRegistrer(),
			                        new picturesFloorRegistrer(),
			                        new videoFloorRegistrer(),
			                        new brigthCoveRegistrer(),
			                        new conversionZoneModule(),
			                        new panoplyContextModule(),
			                        new loginModule(),
									new Cube.ManageSidebar($('.modal-sidebar--bundles'))
			                      ];
		}	
		
		
		// We are on the product detail page.
		if ($('body.account').length > 0) {
			// Order of modules is uber important due to dependencies (shame) ...
			this.loadableModule = [ 
			                       	new myLanguageModule(),
			                        new mySubscriptionsModule(),
			            	        new genericAddressFormModule(),
			                        new myAddressBookModule(),
			                        new myProfileModule(),
			                        new myPurchasesModule(),
			                        new myReturnsModule(),
			                        new geoDataModule(),
			                        new dashboardModule(),
			                       	new myStoreModule(),
			                       	new myVouchersModule(),
			                       	new mobilePhoneModule()
			                      ];
		}

		// TODO Better way
		// Module has been separated in bloc
		// body.login is not present on wechat pages
		

		if ($('.m-login').length > 0) {
			// Order of modules is uber important due to dependencies (shame) ...
			this.loadableModule = [ 
			                       new loginModule(),
			                       new mobilePhoneModule()
			                      ];
		}
		
		if ($('#resetPasswordForm').length > 0) {
			// Order of modules is uber important due to dependencies (shame) ...
			this.loadableModule = [ 
			                   	new resetPswModule()
			                      ];
		}
		
		if ($('#lostPasswordForm').length > 0) {
			// Order of modules is uber important due to dependencies (shame) ...
			this.loadableModule = [ 
			                       new lostPasswordModule(),
			                       new secretQuestionModule()
			                      ];
		}
		
		if($('#create-account-loyalty-container').length > 0){
						this.loadableModule = [ 
						           new secretQuestionModule(),
						           new createAccountLoyaltyModule(),
			                       new mobilePhoneModule()
			                      ];
		}
		
		if($('#create-account-container').length > 0){
			this.loadableModule = [ 
			           new createAccountNominalModule(),
                      new mobilePhoneModule()
                      ];
		}

		if ($('body.contact').length > 0) {
			// Order of modules is uber important due to dependencies (shame) ...
			this.loadableModule = [ 
			                        new contactModule()
			                      ];
		}

		// relay module
		if ($('.store-locator').length > 0) {
			this.loadableModule = [
				new storeLocatorModule()
			];
		}
		
		
		if ($('.store-page').length > 0) {
			this.loadableModule = [
				new storePageModule(),
				// Interaction between the store page and the dashboard
				// (Set the favorite store of the user)
				new accountStoreModule()
			];
		}
		
		// on each page
		this.loadableModule.push(new menuModule());
		
		// We are on the promotion test page.
		if ($('.promotions-test-page').length > 0) {
			this.loadableModule = [ 
			                        new promotionsModule(),
			                        new couponsModule()
			                      ];
		}
		
		if ($('.checkout-cart').length > 0) {
			this.loadableModule = [ 
			                        //new claimableCouponModule()
									new Cube.ManageToggleCart()
			                      ];
		}	
		if ($(".checkout-delivery").length > 0) {
	        this.loadableModule.push(
	        		                new genericAddressFormModule(),
                   	                new mobilePhoneModule());
		}
		if ($(".checkout-payment").length > 0) {
	        this.loadableModule.push(
	                                new genericAddressFormModule(),
   	                                new mobilePhoneModule());
		}
		if ($("#container-header").length > 0) {
		    // Load header module on needed pages
	        this.loadableModule.push(new headerModule());
		}
	},
		
	loadJsFromDom: function() {
		
		_.each(this.loadableModule, function(registrer) {
			registrer.loading();
		});		
	},
	
	scanAndDelegate: function() {
		this.attachToDom();
		this.loadJsFromDom();
	}
		
};

// Init my plugin @ startup
$( document ).ready(function() {
	JsRegistrer.scanAndDelegate();
});

var AnalyticsConstants = {
		
	// GLOBAL
	separator:		'|',
	separatorST:	'-',
	concatenator:	'|',
	namespace:		'Analytics',
	delayReloadCartridge: 500,
	
	isServerSideActive: true,
	isShoppingToolActive: true,
    isEnhancedActive: true,
    

	ref: {
		pendingSearch: 'Analytics.pendingSearch',
		addrBookEdit: 'Analytics.adressBook.edit',
        storage: 'Analytics.storage',
	},
	
	shoppingtool: {
		name: 'ST',
		lock: {
			colorama: false,
            search: false,
		},
		actual: {},
		tmp: null
	},
    
    enhanced: {
        name: 'EC',
        actual: {},
    },
	
    // TRACKERS LIST
	// 	& STANDARD VALUES FOR RELATED EVENTS
	trackers : {
		shoppingtool: {
			name: 'shopping-tool', active: true, reload: false,
			defaultEvent: {type: 'ShoppingToolEvent', category: 'ShoppingTool'}
		},
		homepage: {
            homepage: {
                name: 'homepage', active: true, reload: false,
                defaultEvent: {type: 'NavigationEvent', category: 'Merchandising'}
            },
            sportsadvice: {
                name: 'sportsadvice', active: true, reload: false,
                defaultEvent: {type: 'NavigationEvent', category: 'Merchandising', action: 'HPAllSports'}
            },
            lvp: {
	    		name: 'lvp', active: true, reload: false,
	    		defaultEvent: {type: 'LvpEvent', category: 'HomePage - Lvp'}
	    	}
		},
	    commons: {
            header: {
                name: 'header', active: true, reload: false,
                defaultEvent: {type: 'header', category: 'Header'}
            },
            footer: {
                name: 'footer', active: true, reload: false,
                defaultEvent: {type: 'NavigationEvent', category: 'Navigation', action: 'FooterLinks'}
            },
            filters: {
                name: 'filters', active: true, reload: true,
                defaultEvent: {type: 'ProductListingEvent', category: 'ProductListing', action: 'Filters'}
            },
            navigation: {
                name: 'navigation', active: true, reload: false,
                defaultEvent: {type: 'NavigationEvent', category: 'Navigation'}
            },
            search: {
                name: 'search', active: true, reload: false,
                defaultEvent: {type: 'SearchEvent', category: 'InternalSearch'}
            }
	    },
	    customer: {
	    	menu: {
                name: 'menu-customer', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: '', label: 'ClickMenu'}
	    	},
            myDashboard: {
                name: 'my-dashboard', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'MyDashboard'}
            },
            purchases: {
                name: 'my-purchases', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'MyPurchases'}
            },
            profile: {
                name: 'my-profile', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'MyProfile'}
            },
            loyalty: {
                name: 'my-loyalty', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'CustomerLoyalty'}
            },
            store: {
                name: 'my-store', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'MyStore'}
            },
            subscription: {
                name: 'my-subscription', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'MySubscription'}
            },
            billing: {
                name: 'my-perso-info', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'InfoPerso'}
            },
            addressBook: {
                name: 'my-address-book', active: true, reload: true,
                defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'AdressBook'}
            },
            account: {
    	    	creation: {
                    name: 'account-creation', active: true, reload: true,
                    defaultEvent: {type: 'CheckoutEvent', category: 'Checkout - AccountCreation'}
    	    	},
    	    	login: {
                    name: 'account-login', active: true, reload: true,
                    defaultEvent: {type: 'CheckoutEvent', category: 'CustomerAccount'}
    	    	},
                lostPassword: {
                    name: 'lost-password', active: true, reload: true,
                    defaultEvent: {type: 'CustomerAccount', category: 'CustomerAccount', action: 'ForgetPassword'}
                },
            },
            lvp: {
	    		name: 'lvp', active: true, reload: false,
	    		defaultEvent: {type: 'LvpEvent', category: 'CustomerAccount - Lvp'}
	    	}
	    },
	    funnel: {
            global: {
                name: 'fun-global', active: true, reload: false,
                defaultEvent: {type: 'CheckoutEvent', category: '', action: '', label: ''}
            },
            express: {
                name: 'express-checkout', active: true, reload: true,
                defaultEvent: {type: 'CheckoutEvent', category: 'Checkout - Express'}
            },
            basket: {
                name: 'fun-basket', active: true, reload: true,
                defaultEvent: {type: 'CheckoutEvent', category: 'Checkout - Basket'}
            },
            savelater: {
                name: 'fun-savelater', active: true, reload: true,
                defaultEvent: {type: 'CheckoutEvent', category: 'Checkout - Basket'}
            },
            delivery: {
                name: 'fun-delivery', active: true, reload: true,
                defaultEvent: {type: 'CheckoutEvent', category: 'Checkout - Delivery'}
            },
            payment: {
                name: 'fun-payment', active: true, reload: true,
                defaultEvent: {type: 'CheckoutEvent', category: 'Checkout - Payment'}
            },
            crosssellMoveToCart: {
	    		name: 'crosssellMoveToCart', active: true, reload: false,
	    		defaultEvent: {type: 'CrossSellEvent', category: 'Checkout - Basket'}
	    	},
	    	lvp: {
	    		name: 'lvp', active: true, reload: false,
	    		defaultEvent: {type: 'LvpEvent', category: 'Checkout - Lvp'}
	    	}
	    },
	    product: {
            conversion: {
                name: 'productConversion', active: true, reload: false,
                defaultEvent: {type: 'ProductEvent', category: 'ProductPage - Conversion'}
            },
            media: {
                name: 'product-media', active: true, reload: false,
                defaultEvent: {type: 'ProductEvent', category: 'ProductPage - Content'}
            },
            productList: {
                name: 'product-list', active: true, reload: true,
                defaultEvent: {type: 'ProductList', category: 'ProductListing'},
                lvp: {
    	    		name: 'lvp', active: true, reload: false,
    	    		defaultEvent: {type: 'LvpEvent', category: 'Listpage - Lvp'}
    	    	}
            },
            review: {
                name: 'review', active: true, reload: false,
                defaultEvent: {type: 'ReviewEvent', category: 'Review'}
            },
            crosssellMoveToCart: {
	    		name: 'crosssellMoveToCart', active: true, reload: false,
	    		defaultEvent: {type: 'CrossSellEvent', category: 'ProductPage - Conversion'}
	    	},
	    	crosssell: {
	    		name: 'crosssell', active: true, reload: false,
	    		defaultEvent: {type: 'CrossSellEvent', category: 'ProductPage - CrossSell'}
	    	},
	    	lvp: {
	    		name: 'lvp', active: true, reload: false,
	    		defaultEvent: {type: 'LvpEvent', category: 'ProductPage - Lvp'}
	    	},
	    	panoply: {
	    		name: 'panoply', active: true, reload: false,
	    		defaultEvent: {type: 'PanoplyEvent', category: 'ProductPage - Panoply'}
	    	},
	    	addPanoply: {
                name: 'add-panoply', active: true, reload: true,
                defaultEvent: {type: 'PanoplyEvent', category: 'ProductPage - Panoply'}
            },
	    },
	    suggestions: {
	    	crosssellMoveToCart: {
	    		name: 'crosssellMoveToCart', active: true, reload: false,
	    		defaultEvent: {type: 'CrossSellEvent', category: 'Suggestions - Conversion'}
	    	},
	    	crosssell: {
	    		name: 'crosssell', active: true, reload: false,
	    		defaultEvent: {type: 'CrossSellEvent', category: 'Suggestions - CrossSell'}
	    	}
	    }
	},
	
	// FWK - Slick
	slick: {
		defaultValueArrowRight: 'ArrowRight',
		defaultValueArrowLeft: 'ArrowLeft',
		defaultValuePagination: 'Pagination-',
		defaultValuePosition: 'Position-',
		defaultValueFloor: 'Floor-',
		selectorCssFloors: "div[class^='floor'],div[class*=' floor']",
		selectorCssDots: 'ul.slick-dots li',
		selectorCssArrowNext: '.slick-next',
		selectorCssArrowPrev: '.slick-prev',
		parsingFloorName: '%FLOOR_NAME%',
	},
	
	debug: {
		event: false,
		shoppingtool: false,
		enhanced: false,
		eval: {
			event: false,
			tracker: false,
		},
		init: {
			event: false,
			tracker: false,
		},
	}
};
var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	// PRIVATE
	var main = null;
	var sep = AnalyticsConstants.separatorST;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics = {
			
		activeDebug: function() { localStorage.setItem('Analytics.debug', 'true'); },
		removeDebug: function() { localStorage.removeItem('Analytics.debug'); },
		
		/* ANALYTICS INITIALISATION */
		init: function() {
			//GLOBAL INIT
			if(localStorage.getItem('Analytics.debug')) {
				AnalyticsConstants.debug.event = true;
				AnalyticsConstants.debug.shoppingtool = true;
				AnalyticsConstants.debug.enhanced = true;
			}
			
			// INIT ALL TRACKERS
			// -> Auto-init from the tracker itself

			// INIT SHOPPING TOOL
			this.shoppingtool.init();
			
			// INIT ENHANCED ECOMMERCE
			this.enhanced.init();

		},
		
		// Get the Storage
		getStorage: function() { return JSON.parse((localStorage.getItem(AnalyticsConstants.ref.storage) || '{}')); },

		// Set the property value inside a json object
		setStorage: function(name, val) {
			if (typeof localStorage === "object") {
				try {
					var storage = this.getStorage();
					storage[name] = val;
					localStorage.setItem(AnalyticsConstants.ref.storage, JSON.stringify(storage));
				} catch(e) {
					console.warn("No localStorage for this browser!");
				}
			}
		},
		

		// TODO methods :
		trackAlert: function(_action) {
			var $element = $('#alertTracking');
			if ($element !== null) {
				var dataEvent = $element.data('track-event-error');
				var arrEvent = utils.getArray(dataEvent);

				var alertEvent = main.newEvent(null, arrEvent[0], arrEvent[1], arrEvent[2], arrEvent[3], arrEvent[4], arrEvent[5]);

				alertEvent.label = $element.data('track-label-error');
				alertEvent.action = _action;

				alertEvent.send();
			}
		},
		autoTrackError: function(param, param2) { /*console.log('todo : Analytics.autoTrackError');*/ },
		manualTrackError: function(param, param2) { /*console.log('todo : Analytics.autoTrackError');*/ },

		/* Create an event from given parameters, and send it directly */
		newEvent: function($element, _type, _category, _action, _label, _value, _interaction) {

			var event = new AnalyticsEvent();
			event.options.type = _type;
			event.options.category = _category;
			event.options.action = _action;
			event.options.label = _label;
			event.options.value = _value;
			return event;

			//return parseEvent(_type, _category, _action, _label, _value, _interaction);
		},

		/* FINAL METHOD : The event is sent to TagCommander here */
		sendEvent: function(_element, _event) {
			
			var data = main.utils.trimEvent(_event);

			main.debug.event(_event.name, data, true);

			if ('function' === typeof(cube_events_analytics))
				cube_events_analytics(_element, _event.options.type, data, data.Category, data.Action, data.Label, data.Value ? data.Value : data.Amount, false);

			if (_event.name === 'eventShoppingTool')
	        	AnalyticsConstants.shoppingtool.tmp = null;
		}

	};
	main = CUBE.Analytics;

	/* PRIVATES METHODS */

	// TODO - To Delete (after refacto)
	var utils = {
		/* From a String event, return an Array */
		getArray: function (_dataTrackEvent) {
			if ('undefined' === typeof _dataTrackEvent) return [];
			return _dataTrackEvent.split(AnalyticsConstants.separator);
		},
		/* From an Array, return a String event */
		joinArray: function(_data) {
			if ('undefined' === typeof _data) return "";
			return _data.join(AnalyticsConstants.separator);
		},

	};

})(jQuery);

/* ANALYTICS TRACKERS METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var main = null;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.trackers = {
        // Contain all the AnalyticsTracker
        list: {},
        
        // Add an AnalyticsEvent to the 'trackers' list
        add: function(tracker) {
            this.list[tracker.params.name] = tracker;
            CUBE.Analytics.debug.time(tracker.params.name, "tracker", "eval", true);
        },
        
        // Init an AnalyticsTracker
        init: function(name) {
            var self = this;
            
            if (this.list[name] !== undefined) {
                // INIT ON LOAD
                var timeoutHandle = window.setTimeout(function() { self.list[name].init(); }, 0);
                
                if (self.list[name].params.reload) {
                    // INIT ON RELOAD CARTRIDGE (After x ms)
                    $(window).on('cartridge.reload', function() {
                        window.clearTimeout(timeoutHandle);
                        timeoutHandle = window.setTimeout(function() {
                            self.list[name].init();
                        }, AnalyticsConstants.delayReloadCartridge);
                    });
                }
            }
            else
                console.warn('Analytics: Trying to init() the tracker \''+name+'\', but was not found');
        },
        
        // Init All an AnalyticsTracker
        initAll: function() {
            for (var tracker in this.list)
                if (this.list[tracker].active)
                    this.init(tracker);
        },

	};
    
	main = CUBE.Analytics;

})(jQuery);
/* ANALYTICS DATALAYER METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var main = null;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.datalayer = {
        
        // NO METHODS
        
    };
    
	main = CUBE.Analytics;

})(jQuery);
/* ANALYTICS SHOPPING TOOL METHODS */
(function($) {
	"use strict";
	
	var sep = AnalyticsConstants.separatorST;
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics.enhanced = {
		/*
		 * ENHANCED ECOMMERCE INITIALISATION
		 */
        init: function() {
        	// Persist EC value on product page
            if (AnalyticsConstants.isEnhancedActive && tc_vars.env_template === "product")
            	this.persist();
        },
        
        /*
         * IMPRESSION
         */
        sendImpression: function(model) {
        	fwk.debug.enhancedECommerce('IMPRESSION', model);
            var methodEC = (typeof GAEnhancedEcommerce === 'undefined') ? $.noop : GAEnhancedEcommerce.sendProductImpression;
            this.sendHit(methodEC, model);
        },
        /*
         * CLICK
         */
        sendClick: function(model) {
        	fwk.debug.enhancedECommerce('CLICK', model);
            var methodEC = (typeof GAEnhancedEcommerce === 'undefined') ? $.noop : GAEnhancedEcommerce.sendProductClick;
            this.sendHit(methodEC, model);
        },
        /*
         * ADD TO CART
         */
        sendAddToCart: function(model) {
        	fwk.debug.enhancedECommerce('ADD TO CART', model);
            var methodEC = (typeof GAEnhancedEcommerce === 'undefined') ? $.noop : GAEnhancedEcommerce.sendProductAddToCart;
            this.sendHit(methodEC, model);
        },
        /*
         * REMOVE FROM CART
         */
        sendRemoveToCart: function(model) {
        	fwk.debug.enhancedECommerce('REMOVE FROM CART', model);
            var methodEC = (typeof GAEnhancedEcommerce === 'undefined') ? $.noop : GAEnhancedEcommerce.sendProductRemoveToCart;
            this.sendHit(methodEC, model);
        },
        /*
         * PRODUCT CHECKOUT
         */
        sendProductCheckout: function(model, step) {
        	fwk.debug.enhancedECommerce('PRODUCT CHECKOUT - STEP ' + step, model);
        	if (typeof GAEnhancedEcommerce !== 'undefined') {
        		var listProduct = [];
        		listProduct.push(model);
        		GAEnhancedEcommerce.sendProductsToCheckout(listProduct, step, null);
        	}
        },
        
        /*
         * SEND HIT - FROM MODEL
         */
        sendHit: function(methodEC, model) {
            methodEC(
                model.id,
                model.name,
                model.variant,
                model.brand,
                model.position,
                model.list,
                model.category,
                model.price,
                model.quantity,
                model.coupon
            );
        },

        /*
         * ENHANCED - GETTER / SETTER / PERSIST
         */
        get: function(prop) { return fwk.utils.getProperty(fwk.getStorage()[AnalyticsConstants.enhanced.name], prop); },
        getActual: function(prop) { 
        	var _ecList = fwk.utils.getProperty(AnalyticsConstants.enhanced.actual, prop); 
        	if (typeof _ecList === "object" && _ecList.list !== undefined && _ecList.list.indexOf("//") === 0) {
        		_ecList.list = _ecList.list.substring(1);
        	}
        	return _ecList;
        },
        set: function(objEC) { fwk.setStorage(AnalyticsConstants.enhanced.name, objEC); },
        persist: function() { AnalyticsConstants.enhanced.actual = this.get(); },
        
    };
    
})(jQuery);
/* ANALYTICS QUEUE METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var main = null;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.queue = {
		// Contain All the Queued events
		list: {},
		
		// Add a named event (array) in the queue
		add: function(_name, _event) {
			this.list[_name] = _event;
			main.debug.event(_event.name, main.utils.trimEvent(_event), false);
		},
		
		// Remove a specific event from the queue
		remove: function(_name) {
			if (typeof this.list[_name] !== 'undefined')
				delete this.list[_name];
		},
		
		// Returns a specific event from the queue (and keep it inside)
		get: function(_name) {
			if (typeof this.list[_name] !== 'undefined')
				return this.list[_name];
			return null;
		},
		
		// Sends the event, and then delete it
		send: function(_name) {
			var event = this.get(_name);
			if (event !== null) {
				event.send();
				this.remove(_name);
			}
			else
				console.warn('Analytics: Trying to send \''+_name+'\' event from queue, but was not found');
		}
	};
	
	main = CUBE.Analytics;

})(jQuery);
/* ANALYTICS SERVER SIDE METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var main = null;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.serverside = {
        // Construct and encode a key / value parameter for server side
        buildParam: function(name, value) {
            return name + "=" + encodeURIComponent(value);
        },
        
        // Generates the COMMON data to send with each Analytics HIT
        getGACommon: function() {
            var params = [];
            var build = this.buildParam;
            
            var url = window.location.origin + '/' + location.pathname.split('/')[1] + '/' + 'checkoutPaymentServerSide';
            var tid, cid;
            
            if (typeof tC !== 'undefined' && !!tC.internalvars && !!tC.internalvars.ua_id)
            	tid = tC.internalvars.ua_id;
            else
            	tid = '';
            
            if (typeof GAFramework !== 'undefined' && !!GAFramework.getClientIdGA())
            	cid = GAFramework.getClientIdGA();
            else
            	cid = '';

            params.push(build("v", "1"));
            params.push(build("tid", tid));	// GA Account
            params.push(build("cid", cid));// User ID
            params.push(build("cu", tc_vars.env_currency));		// Currency
            params.push(build("ua", navigator.userAgent));		// User Agent
            params.push(build("de", document.charset));			// Document Encoding type
            params.push(build("ul", navigator.language));		// User Language code
            params.push(build("dl", url));						// Document Location
            params.push(build("dt", document.title));			// Document Title
            params.push(build("z", Date.now()));				// Cache reference
            
            return params.join("&");
        },
        
        // Generates the CUSTOM DIMENSIONS data to send with each Analytics HIT
        getGADimensions: function(isVirtualPage) {
            var params = [];

            if ('undefined' !== typeof GAFramework) {
            	var _gaFramework = GAFramework;
            	//Get GAFramework from virtual page
                if (typeof isVirtualPage !== "undefined" && isVirtualPage) {
                	var ifrm = window.frames['virtual-page'];
                	try {
                		ifrm = (ifrm.contentWindow) ? ifrm.contentWindow : (ifrm.contentDocument.document) ? ifrm.contentDocument.document : ifrm.contentDocument;
                	} catch(e) {
                		ifrm = undefined;
                	}
                	if ('undefined' !== typeof ifrm && 'undefined' !== typeof ifrm.GAFramework) {
                		_gaFramework = ifrm.GAFramework;
                	}
                }
                
                var dimensions = _gaFramework.getDimensionsByType();
                // Check if string is already encoded
                if (decodeURIComponent(dimensions) === dimensions)
                    return encodeURIComponent(dimensions);
                else
                    return dimensions;
            }
            else
                return " ";
        },
        
       
        
    };
	
	var getClientId = function() {
		var cookieGA = getCookie('_ga');
		if (!!cookieGA) {
			var data = cookieGA.split('.');
			return data[data.length-2] + '.' + data[data.length-1];
		} else {
			return '555';
		}
	};
    
	main = CUBE.Analytics;

})(jQuery);
/* ANALYTICS SHOPPING TOOL METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	
	CUBE.Analytics.shoppingtool = {
		/*
		 * SHOPPINGTOOL - INITIALISATION
		 */
        init: function() {
            // Is ShoppingTool Activated ?
            if (!AnalyticsConstants.isShoppingToolActive)
                return false;

            var st = this;
            
            // ShoppingTool : reset on homepage
            st.checkHomepage();

            // Performs actions only on product page
            if (!(tc_vars.env_template === "product" || tc_vars.env_template === "list" || tc_vars.env_template === "internal_search"))
                return false;
            
            // ShoppingTool : 'internal-search // redirection-auto'
            st.checkSearch();
            // ShoppingTool : 'direct // access'
            st.checkDirect();
            // Persist current ShoppingTool on page (avoid multi-tab navigation problems)
            st.persist();
            
            // Send the first shopping tool event 'Click'
            if (tc_vars.env_template === "product")
            	st.sendClick();
        },
        
        /*
         * CHECKHOMEPAGE -
         * 	- Check if current page = homepage; then reset shoppingtool
         */
        checkHomepage: function() {
        	if (tc_vars.env_template == 'homepage')
        		this.set('', '');
        },
        
        /*
         * CHECKSEARCH -
         * 	- Check for pending search; for 'internal-search // redirection-auto' shoppingtool
         */
        checkSearch: function() {
        	var pendingSearch = localStorage.getItem(AnalyticsConstants.ref.pendingSearch);
            if (!!pendingSearch && tc_vars.env_template == 'product') {
                var _st = this.get();
                // We came here from an auto-redirection in an internal-search
                // Change ShoppingTool to 'redirection-auto' only if it's a classical research (not an autocomplete)
                if (typeof _st.std === 'string' && _st.std.indexOf('autocompletion') === -1 && pendingSearch != 'undefined')
                    this.set('internal-search', 'redirection-auto' + sep + pendingSearch);
            }
        },
        /*
         * CHECKDIRECT -
         * - Check for existing shoppping tool & referrer; for 'direct // access' shopping tool
         */
        checkDirect: function() {
        	var _st = this.get();
            if ($.isEmptyObject(_st) || _st.st.indexOf('undefined') > -1) this.set('direct', 'access');
        },
        
        /*
         * SHOPPINGTOOL - CLICK EVENT
         */
        sendClick: function() { var event = createSTEvent('Click'); if (event) event.send();},
        /*
         * SHOPPINGTOOL - ADDTOCART EVENT
         */
        sendAddToCart: function() {
        	if (!(tc_vars.env_template === "product" || tc_vars.env_template === "homepage" || tc_vars.env_template === "checkout" || tc_vars.env_template === "suggestions" || tc_vars.env_template === "list"))
        		return;
            
        	var event = createSTEvent('AddToCart');
        	if (event)
        		event.send();
    	},
        
        /*
         * SHOPPINGTOOL - PERSISTS / GETTER / SETTER
         */
        persist: function() { AnalyticsConstants.shoppingtool.actual = $.extend({}, this.get(), {label: generateLabel(), channel: tc_vars.env_channel.toUpperCase()}); },
        get: function(prop) { return fwk.utils.getProperty(fwk.getStorage()[AnalyticsConstants.shoppingtool.name], prop); },
        getActual: function(prop) {
        	if (AnalyticsConstants.shoppingtool.tmp)
            	return fwk.utils.getProperty(AnalyticsConstants.shoppingtool.tmp, prop);
        	else
        		return fwk.utils.getProperty(AnalyticsConstants.shoppingtool.actual, prop);
    	},
        set: function(stType, stDetail, stColorama) {
        	fwk.debug.shoppingTool(stType, stDetail, stColorama);
        	if (!stType && !stDetail)
        		fwk.setStorage(AnalyticsConstants.shoppingtool.name, { });
        	else
        		fwk.setStorage(AnalyticsConstants.shoppingtool.name, { st: stType, std: stDetail, stc: stColorama });
        },
        setTmp: function(stType, stDetail, label, value, stColorama) {
        	fwk.debug.shoppingTool(stType, stDetail, stColorama);
        	var st = {
    			st: stType,
    			std: stDetail,
    			label: label,
                stc: stColorama,
    			channel: tc_vars.env_channel.toUpperCase(),
    			value: value
        	};
        	AnalyticsConstants.shoppingtool.tmp = st;
        },
        reBind: function() {
        	var st = this.getActual();
        	if (st.st && st.std)
        		this.set(st.st, st.std);
        }
    };
	
	// Return a built shoppingtool event
    var createSTEvent = function(stAction) {
        // Check stAction
        if (!stAction) { console.warn('Analytics : Trying to send a ShoppingTool without action'); return false; }
        // Check shoppingTool
        if (!AnalyticsConstants.shoppingtool.actual && !AnalyticsConstants.shoppingtool.tmp) { console.warn('Analytics : Trying to send an empty ShoppingTool'); return false; }
        // Create and returns shoppingtool event
        var eventST = new AnalyticsEvent('eventShoppingTool', AnalyticsConstants.trackers.shoppingtool.defaultEvent);
        
        eventST.stopEvent = stopEventShoppingTool;
        
        eventST.options.action = generateAction(stAction);
        eventST.options.label = generateLabel();
        eventST.options.value = generateValue();
        
        AnalyticsConstants.shoppingtool.tmp = null;
        
        return eventST;
    };
    
    var stopEventShoppingTool = function() {
    	
    	// 'REVIEWS' page refresh
    	if (~window.location.hash.indexOf("reviews-product"))
    		return true;
    	
    	return false;
    };
    
    // Returns 'Action' for ST Event
    //	> #action#-#ST#-#STD#
    var generateAction = function(stAction) {
        var _shoppingTool = AnalyticsConstants.shoppingtool.tmp || AnalyticsConstants.shoppingtool.actual;
        
        if(_shoppingTool.stc)
        	return stAction + sep + _shoppingTool.st + sep + _shoppingTool.std + sep + _shoppingTool.stc;
        else
        	return stAction + sep + _shoppingTool.st + sep + _shoppingTool.std;
    };
    // Returns 'Label' for ST Event
    // 	> #productName#-#modelId#-#productId#
    var generateLabel = function() {
    	if (AnalyticsConstants.shoppingtool.tmp)
    		return AnalyticsConstants.shoppingtool.tmp.label;
    	
        var _displayName = tc_vars.product_label_displayed;
        var _model = fwk.utils.productpage.getSelectedModelId();
        var _sku = fwk.utils.productpage.getSelectedSku();
        return _displayName + sep + _model + sep + _sku;
    };
    // Returns 'Value' for ST Event
    //	> #price# * #quantity#
    var generateValue = function() {
    	if (AnalyticsConstants.shoppingtool.tmp)
    		return AnalyticsConstants.shoppingtool.tmp.value;
    	
        var _price = fwk.utils.productpage.getSelectedPrice();
        var _quantity = fwk.utils.productpage.getSelectedQuantity();
        return parseInt(_price * _quantity) || 0;
    };
    
})(jQuery);
/* ANALYTICS UTILS METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var main = null;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.debug = {
        
    	/*
    	 * LOG EVENT SENDING / QUEUING
    	 */
    	event: function(name, data, isSend) {
    		if (!AnalyticsConstants.debug.event)
    			return;
    		
			if (isSend) {
				if (typeof main.queue.list[name] != 'undefined')
					console.groupCollapsed('Analytics: %cEVENT \''+name+'\' SENT', styleSend);
				else
					console.group('Analytics: %cEVENT \''+name+'\' SENT', styleSend);
			} else
				console.group('Analytics: %cEVENT \''+name+'\' QUEUED', styleQueue);
	
			console.debug('%cCategory:\t%c' + data.Category, style1, style2);
			console.debug('%cAction:\t\t%c' + data.Action, style1, style2);
			console.debug('%cLabel:\t\t%c' + data.Label, style1, style2);
			console.debug('%cValue:\t\t%c' + (typeof data.Value === 'undefined' ? '' : data.Value), style1, style2);
			console.groupEnd('Analytics: %cEVENT \''+name+'\' ' + (isSend ? 'SENT' : 'QUEUED'), styleSend);
    	},
    	
    	/*
    	 * LOG SHOPPING TOOL UPDATE
    	 */
    	shoppingTool: function(stType, stDetail, stColorama, isActual) {
    		if (!AnalyticsConstants.debug.shoppingtool)
    			return;
    		
    		var tmp = isActual ? ' TEMPORARY' : '';
    		
			console.group('Analytics: %cSHOPPING TOOL' + tmp + ' UPDATE', styleST);
			console.log('%cType:\t\t%c' + stType, style1, style2);
			console.log('%cDetail:\t\t%c' + stDetail, style1, style2);
			console.log('%cColorama:\t%c' + (stColorama ? 'Oui : ' + stColorama : 'Non'), style1, style2);
			console.groupEnd('Analytics: %cSHOPPING TOOL UPDATE', styleST);
    	},
    	
    	/*
    	 * LOG ENHANCED ECOMMERCE
    	 */
    	enhancedECommerce: function(type, model) {
    		if (!AnalyticsConstants.debug.enhanced)
    			return;
    		
			console.group('Analytics: %c ADD ENHANCED ECOMMERCE INFORMATION', styleEC);
			console.log('%cType:\t\t%c' + type, style1, style2);
			console.log('%cModel:\t\t%c' + JSON.stringify(model), style1, style2);
			console.groupEnd('Analytics: %c ADD ENHANCED ECOMMERCE INFORMATION', styleEC);
    	},
    	

    	/*
    	 * TIME INFORMATION (Initialisation, evaluation ...)
    	 */
		time: function(name, type, action, endTime) {

			if (AnalyticsConstants.debug.eval.event && type == "event" && action === "eval") {
				if (!endTime) console.time('Eval Event \''+name+'\'');
				else console.timeEnd('Eval Event \''+name+'\'');
			}
			if (AnalyticsConstants.debug.init.event && type == "event" && action === "init") {
				if (!endTime) console.time('Init Event \''+name+'\'');
				else console.timeEnd('Init Event \''+name+'\'');
				
			}
			if (AnalyticsConstants.debug.eval.tracker && type == "tracker" && action === "eval") {
				if (!endTime) console.time('> Eval Tracker \''+name+'\'');
				else {
					console.timeEnd('> Eval Tracker \''+name+'\'');
					console.debug('');
				}
			}
			if (AnalyticsConstants.debug.init.tracker && type == "tracker" && action === "init") {
				if (!endTime) console.time('> Init Tracker \''+name+'\'');
				else {
					console.timeEnd('> Init Tracker \''+name+'\'');
					console.debug('');
				}
			}
		},

    };
	
	var styleSend = 'color: #4CAF50; font-weight: bold;';
	var styleQueue = 'color: orange; font-weight: bold;';
	var styleST = 'color: #2196F3; font-weight: bold;';
	var styleEC = 'color: #9C27B0; font-weight: bold;';
	var style1 = 'font-weight: bold; color: #f44336;';
	var style2 = 'font-weight: normal; color: #607D8B;';
    
	main = CUBE.Analytics;

})(jQuery);
/* ANALYTICS COLORAMA METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var fwk = null;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.colorama = {
			
		listColorama: {},
		
		add: function(idModel, area) {
			
			if (this.listColorama[idModel] === undefined || this.listColorama[idModel] !== area)
				this.listColorama[idModel] = area;
			
		},
		
		getDetail: function(idModel) {
			
			if (this.listColorama[idModel] !== undefined)
				return 'colorama-' + this.listColorama[idModel];
			
			return '';
		}
        
    };
    
	fwk = CUBE.Analytics;

})(jQuery);
/* ANALYTICS CROSSSELL METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var fwk = null;
	var sep = AnalyticsConstants.separatorST;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.crosssell = {
		
		colorama: {},
		
		getIdModelProductPage: function($product) {
			if ($product.hasClass('multiple-colors'))
				return $product.find('.plv2-el__images .slick-slide[aria-hidden="false"]').data('modelid');
			else
				return $product.find('.plv2-el__image').data('modelid');
		},
		
		getPosition: function($element, elementSelector, containerSelector) {
			return $(containerSelector).find(elementSelector).index($element) + 1;
		},
		
		clickOnColorama: function(element) {
			var idModel, position, $product, stColorama;
			
			$product = element.closest('.plv2-element');
			position = this.getPosition($product, '.plv2-element', '.product-list-v2');
			idModel = this.getIdModelProductPage($product);
			stColorama = (tc_vars.list_crosssells[position-1].list_crosssell_id_model == idModel) ? '' : 'colorama-crosssell';

			var label = tc_vars.list_crosssells[position-1].list_crosssell_label_displayed;
			var value = tc_vars.list_crosssells[position-1].list_crosssell_currentprice_ati;
			
			var type_page = 'product-page';
			if (tc_vars.env_template === "suggestions") {
				type_page = 'addtocart-page';
			}
			
			this.colorama[position] = this.buildStDetail(type_page, position, idModel, stColorama);
			$product.find(".plv2-el__image.slick-active a").off('click.st').on('click.st', function() {
				fwk.shoppingtool.set('merchandising', CUBE.Analytics.crosssell.colorama[position], 'colorama-crosssell');
			});
			
		},
		
		hasColoramaSelected: function(position) {
			return this.colorama[position];
		},
		
		buildStDetail: function(pageType, position, modelId, stColorama) { 
			if (stColorama !== '') stColorama = sep + stColorama;
			return 'cross-selling' + sep + pageType + sep + 'position' + sep + position + sep + modelId + stColorama;
		}
        
    };
    
	fwk = CUBE.Analytics;

})(jQuery);
/* ANALYTICS PANOPLY METHODS */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var fwk = null;
	var sep = AnalyticsConstants.separatorST;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.panoply = {
		hasSendClick:{},
		previousType:"",
		
		sendClickForPanoply: function(_type) {
			this.previousType = _type;
			var indexPanoply = $("#product-bundles .slick-slide.slick-active").index();
			if (indexPanoply === -1) {
				indexPanoply = 0;
			}
			var typePanoply = $("#product-bundles .slick-slide.slick-active").data("panoply-type");
			if (typePanoply === undefined) {
				typePanoply = $("#product-bundles .pb__element").data("panoply-type");
			}
			if (this.hasSendClick[indexPanoply] === undefined || !this.hasSendClick[indexPanoply]) {
				this.hasSendClick[indexPanoply]=true;
				
				var _typeEventPanoply = "Pack";
				if (typePanoply === "set") {
					_typeEventPanoply = "Set";
				}
				createECEvent(indexPanoply, _type, "Click", _typeEventPanoply);
		        
		        //Send virtual page
				CUBE.Analytics.utils.sendEvent('addPanoplyVirtualDetail', AnalyticsConstants.trackers.product.addPanoply.name);
			}
		},
		
		sendAddToCartForPanoply: function(items) {
			var indexPanoply = $("#product-bundles .slick-slide.slick-active").index();
			if (indexPanoply === -1) {
				indexPanoply = 0;
			}
			var typePanoply = $("#product-bundles .slick-slide.slick-active").data("panoply-type");
			if (typePanoply === undefined) {
				typePanoply = $("#product-bundles .pb__element").data("panoply-type");
			}
			var _typeEventPanoply = "Pack";
			if (typePanoply === "set") {
				_typeEventPanoply = "Set";
			}
			
			createECEvent(indexPanoply, this.previousType, "AddToCart", _typeEventPanoply, items);
			var shoppingToolActual = CUBE.Analytics.shoppingtool.getActual();
			var enhancedActual = CUBE.Analytics.enhanced.getActual();
			
			$.each(items, function(index,item) {
				// Get the 'ProductSold' shoppingtool (ANALYTICS)
				var _position = 0;
				var _productInTcVars = tc_vars.list_panoplies[indexPanoply].products[0];
				if (_typeEventPanoply === "Pack") {
					_productInTcVars = tc_vars.list_panoplies[indexPanoply].products[index];
					_position = index;
				}
				shoppingToolActual.s = index + 1;
				shoppingToolActual.st = CUBE.Analytics.panoply.previousType.toLowerCase();
				shoppingToolActual.std = "position-" + (_position + 1) + "-" + tc_vars.product_id_model + "-" + tc_vars.list_panoplies[indexPanoply].id;
				
				var modelId = _productInTcVars.product_id_model;
				if (_typeEventPanoply === "Set") {
					modelId = $($("#conversion-zone-container .product-item").get(index)).find(".pop-in .wrap-images").attr("active-color");
				}
					
				shoppingToolActual.label = _productInTcVars.product_label_displayed + "-" + modelId;
				shoppingToolActual.type = _typeEventPanoply;
				
				enhancedActual = {
					id:modelId,
					position:index+1,
					list:'/' + fwk.utils.getInfoNavFromURL(document.location.pathname),
					variant:_productInTcVars.product_nature,
					category:_productInTcVars.product_category,
					brand:_productInTcVars.product_brand,
					label:_productInTcVars.product_label_displayed
				};
				
				var _analyticsAttributes = {
					'ga_shoppingtool': JSON.stringify(shoppingToolActual),
					'ga_enhanced': JSON.stringify(enhancedActual)
				};
				item.commerceItemAttributes = _analyticsAttributes;
			});
		}
    };
	
	var createECEvent = function(_indexPanoply, _packType, _ecType, _typePanoply, _items) {
		var nbProductsInPanoply;
		//Send EC Click or AddToCart for each product present in the selected panoply
		if (_typePanoply === "Pack" || _ecType === "Click") {
			//BUNDLE PACK
			nbProductsInPanoply = 0;
			$('.slick-active .pb-el__product').each(function() { 
	    		var model = fwk.utils.productpage.getPanoplyModel(_indexPanoply, $(this).data("productid"), "SM");
	    		if (_ecType === "Click") {
	    			fwk.enhanced.sendClick(model);
	    		} else {
					model.price = parseFloat(jQuery(jQuery("#msb-conversionzone-products-list").find(".price").get(nbProductsInPanoply)).data("price"));
	    			fwk.enhanced.sendAddToCart(model);
	    		}
	            
	            //Send shopping tool event
	            var _productInTcVars = tc_vars.list_panoplies[_indexPanoply].products[nbProductsInPanoply];
				var eventPanoply = new AnalyticsEvent('eventPanoply' + _ecType, {});
				
				var shoppingToolActual = CUBE.Analytics.shoppingtool.getActual();
				eventPanoply.options.category = 'ShoppingTool';
				eventPanoply.options.action = _ecType + _typePanoply + "-" + _packType.toLowerCase() + "-position-" + (nbProductsInPanoply + 1) + "-" + tc_vars.product_id_model + "-" + tc_vars.list_panoplies[_indexPanoply].id;
				eventPanoply.options.label = _productInTcVars.product_label_displayed + "-" + _productInTcVars.product_id_model;

				if (_ecType === "Click") {
					eventPanoply.options.value = _productInTcVars.product_currentprice_ati;
				} else {
					eventPanoply.options.value = parseFloat(jQuery(jQuery("#msb-conversionzone-products-list").find(".price").get(nbProductsInPanoply)).data("price"));
				}
				
		        fwk.sendEvent(window, eventPanoply);
		        
	            nbProductsInPanoply++;
	    	});	
		} else {
			//BUNDLE SET
			nbProductsInPanoply = 0;
			// Take the value of productId
			var productId = $('.slick-active .pb-el__product').data("productid");
			
			// If there is only one set or bundle section in the page
			if(productId === undefined){
				productId = $('.pb-el__product').data("productid");
			}
			
			var model = fwk.utils.productpage.getPanoplyModel(_indexPanoply, productId, "SM");
			$("#conversion-zone-container .product-item").each(function() {
				model.id = $(this).find(".pop-in .wrap-images").attr("active-color");
				model.quantity = parseInt(_items[nbProductsInPanoply].quantity, 10);
				try {
					model.price = parseFloat(/([0-9]+[.,]{1}[0-9]+)/.exec($(this).find(".product-unit-price").text())[0]);
				} catch(e) {
					model.price = 0;
				}
				fwk.enhanced.sendAddToCart(model);
				
				//Send shopping tool event
	            var _productInTcVars = tc_vars.list_panoplies[_indexPanoply].products[nbProductsInPanoply];
				var eventPanoply = new AnalyticsEvent('eventPanoply' + _ecType, {});
				
				var shoppingToolActual = CUBE.Analytics.shoppingtool.getActual();
				eventPanoply.options.category = 'ShoppingTool';
				eventPanoply.options.action = _ecType + _typePanoply + "-" + _packType.toLowerCase() + "-position-" + (nbProductsInPanoply + 1) + "-" + tc_vars.product_id_model + "-" + tc_vars.list_panoplies[_indexPanoply].id;
				eventPanoply.options.label = model.name + "-" + model.id;
				eventPanoply.options.value = model.price * model.quantity;
		        fwk.sendEvent(window, eventPanoply);
		        
	            nbProductsInPanoply++;
				
			});
		}
		
	};
	
	fwk = CUBE.Analytics;

})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics = CUBE.Analytics || {};
	CUBE.Analytics.utils = {
        
        
        // Returns the good navigation information for a given URL
        getInfoNavFromURL: function(url, completeUrl) {
        	//Get the last category url
            function getLastCategoryUrl(url, completeUrl) {
                var result = "";
                var regexCategory = /^c[0-9]+.*/;
                for(var i=url.length-1;i>=0;i--) {
                    if (regexCategory.exec(url[i]) !== null) {
                        result = "/" + url[i] + result;
                        if (!completeUrl) {
                            break;
                        }
                    }
                }
                return result;
            }

            //Get the last product url
            function getLastProductUrl(url) {
                var i;
                for(i=url.length-1;i>=0;i--) {
                    if (url[i] === "_" && i > 0) {
                        return url[i - 1];
                    }
                }
                //Not found "_", then search "p"
                for(i=0; i<url.length;i++) {
                    if (url[i] === "p") {
                        return url[i + 1];
                    }
                }
                return result[3];
            }

            var result = "";
            if (url === undefined) {
                url = document.location.pathname;
            }
            
            if (url.indexOf('/category') > -1 || url.indexOf('/browse') > -1)  {
                // 'CATEGORY' > Ex: /en/sports-advice/category/c-equipement-du-cycliste/_/N-1c5979u
                // 'BROWSE' > Ex: /en/browse/c-velos-cyclisme/_/N-137v5bh
                result = getLastCategoryUrl(url.split("/"), completeUrl);
            } else if (url.indexOf('/search') > -1) {
                // 'SEARCH' > Ex: /en/search?Ntt=searched-phrase
                result = '/search/' + decodeURIComponent(getURLParameterFromUrlString(document.location.href, 'Ntt')) || '';
            } else if (url.indexOf('/product-details') > -1 || url.indexOf('/p/') > -1) {
                // 'PRODUCT PAGE' > Ex: /nl/product-details/herenpolo-soft-wit-padel-tennis-badminton-tafeltennis-squash-artengo/_/R-u-2003738
                // 'PRODUCT PAGE' > Ex: /product-details/herenpolo-soft-wit-padel-tennis-badminton-tafeltennis-squash-artengo/_/R-u-2003738
                // 'PRODUCT PAGE' > Ex: /nl/p/my-long-top-fitness-tank-voor-dames-gemeleerd-grijs/_/R-p-10018
                result = getLastProductUrl(url.split("/"));
            } else {
                // ELSE > Return the plain url
                result = url;
            }
            
            if (result === "" || (result.length > 0 && result.substr(0,1) !== "/")) {
            	result = "/" + result;
            }
            return result;
        },
        
        //Return url for shopping tool action
        getInfoNavFromURLForShoppingTool: function(url) {
        	var result = this.getInfoNavFromURL(url, false);
        	if (result !== "" && result.length > 0 && result.substr(0,1) === "/") {
        		result = result.substr(1);
        	}
        	return result;
        },
        
        //Return url for enhanced ecommerce list
        getInfoNavFromURLForEnhancedEcommerce: function(url) {
        	var result = this.getInfoNavFromURL(url, false);
        	
        	return result;
        },
        
        // Return the selected property of a json object
        getProperty: function(obj, prop) {
	    	if (typeof obj === 'undefined')
	    		return (typeof prop === 'undefined') ? {} : '';
    		else if (typeof prop === 'undefined')
	    		return obj;
	    	else {
	    		if (typeof obj[prop] === 'undefined')
	    			return '';
	    		else
	    			return obj[prop];
	    	}
		},
		
		getEvent: function(eventName, trackerName) {
			
			var trackerList = fwk.trackers.list;
			
			// Direct Search > from TrackerName and EventName
			if (!!trackerList[trackerName] && !!trackerList[trackerName].events[eventName])
				return trackerList[trackerName].events[eventName];
			
			// Not found > Search in ALL trackers for 'eventName'
			for (var tracker in trackerList) {
				if (!!trackerList[tracker].events[eventName])
					return trackerList[tracker].events[eventName];
			}
			
			return null;
		},
		
		sendEvent: function(eventName, trackerName) {
			var evt = this.getEvent(eventName, trackerName);
			if (!!evt)
				evt.send();
			else
                console.warn('Analytics: Trying to send() the event \''+trackerName+'\', but was not found');
		},

    	// Event epuration
    	trimEvent: function(_event) {
    		var _data = {};
    		
    		_data = {
    			'Category' : _event.options.category,
    			'Action' : _event.options.action,
    			'Label' : _event.options.label,
    			'Value' : _event.options.value,
    			'Non-interaction' : _event.options.interaction
    		};
    		
    		return _data;
    	},

        /**
         * IS VISIBLE
         * 	Check if an element is visible in the viewport
         */
        isVisible: function($elt, offset) {
            var viewport = {};
            viewport.top = $(window).scrollTop();
            viewport.bottom = viewport.top + $(window).height();
            var bounds = {};
            bounds.top = $elt.offset().top;
            bounds.bottom = bounds.top + $elt.outerHeight();
            if (offset) bounds.top = bounds.top - offset
            return ((bounds.top <= viewport.bottom) && (bounds.bottom >= viewport.top));
        }
    };

})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.homepage = {
			
		/**
		 * FLOORS
		 */
		
		// returns ALL FLOORS
		getAllFloors: function() {
			return $('[class^="floor-push"]');
		},
		
		// returns FLOOR (from any floor's element)
		getFloor: function(element) {
			var $elt;
			if (!(element instanceof jQuery)) $elt = $(element);
	        else $elt = element;
			
			return $elt.closest('[class^="floor-push"]');
		},
		
		// returns FLOOR INDEX (from any floor element)
		getFloorIndex: function(floor) {
			var $floor = this.getFloor(floor);
			var $allFloors = this.getAllFloors();
			
			return $allFloors.index($floor) + 1;
		},
		
		// returns FLOOR NAME (from any floor's element)
		getFloorName: function(floor) {
			var $floor = this.getFloor(floor);
			return $floor.find('a[title]').attr('title').trim();
		},
		
		/**
		 * PRODUCTS
		 */
		
		getProduct: function(element) {
			var $elt;
			if (!(element instanceof jQuery)) $elt = $(element);
	        else $elt = element;
			
			if ($elt.closest('.inner-product').length > 0)
				return $elt.closest('.inner-product');
			else
				return $elt.closest('.inner-content');
			
			return null;
		},
		
		getProductName: function (product) {
			var $product = this.getProduct(product);
			var name = $product.find('picture[alt]');
			if (name.length > 0)
				return name.attr('alt').trim();
			else
				return $product.find('.title h3').text().trim();
		},

		getProductValue: function (product) {
			var $product = this.getProduct(product);
			var price = $product.find('.price-container .price');
			if (price.length > 0)
				return price.data('price');
			else
				return 0;
		},
		
		getAllProductsFloor: function(floor) {
			var $floor = this.getFloor(floor);
			return $floor.find('.slick-slide > div .inner-product, .slick-slide > div .inner-content');
		},
		
		getProductIndex: function(product) {
			var $floor = this.getFloor(product);
			
			var $product = this.getProduct(product);
			var $allProducts = this.getAllProductsFloor($floor);

			return $allProducts.index($product) + 1;
		},
		
		getProductIndexAll: function(product) {
			var $product = this.getProduct(product);
			var $allProducts = $('.inner-product, .inner-content');

			return $allProducts.index($product) + 1;
		},
		
		/**
		 * DATALAYER
		 */
		findProductByAttribute: function(attribute, value) {
			return tc_vars.homepage_products.filter(function(product) {
				for (var key in product)
					if (key.indexOf(attribute) > -1 && product[key].toLowerCase() == value.toLowerCase())
						return true;
				return false;
			})[0];
		},
		
		getModel: function(product) {

			var productLabel = this.getProductName(product);
			var productDL = this.findProductByAttribute('label_displayed', productLabel);

			var model = {};
	        model.id = productDL.product_id_model;
	        model.name = productDL.product_label_displayed;
	        model.brand = productDL.product_brand.trim().toUpperCase();
	        model.position = this.getProductIndexAll(product);
	        model.list = '/homepage';
	        model.variant = productDL.product_nature;
	        model.category = productDL.product_category;
	        model.price = productDL.product_originalprice_ati;
	        
	        return model;
		},

    };
	
})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";

	var fwk = CUBE.Analytics;

	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.pagelist = {

		// Get product from any element
		getProduct : function(element) {
			var $elt;
			if (!(element instanceof jQuery))
				$elt = $(element);
			else
				$elt = element;
			return $elt.closest('.inner-element');
		},

		// In case of colorama, get the selected model
		getSelectedProduct : function(product) {
			var $product = this.getProduct(product);
			var $selectedProduct = $product.find('[data-model]');

			if ($selectedProduct.length > 1) // COLORAMA
				return $product
						.find('.slick-product .slick-track .slick-slide[aria-hidden="false"]')
						.first();
			else
				// NO COLORAMA
				return $selectedProduct.first();
		},

		// Get the currently displayed spotlight
		getSpotlight : function(element) {
			return $('#lpt-tg .pl-wrapper .slick-list > .slick-track .pl-element.slick-current:not(.slick-cloned) .inner-element').first();
		},

		// From product element, get the associated data-model
		getModel : function(product) {
			var $product = this.getProduct(product);
			var $selectedProduct = this.getSelectedProduct($product);
			
			if (!$selectedProduct.data('model'))
				return null;
			
			var rawModel = $selectedProduct.data('model');
			var model = {};

			model.id = rawModel.id || '';
			model.name = this.findProductName($product);
			model.brand = this.findProductBrand($product);
			model.position = this.findProductIndex($product);

			model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce(document.location.pathname + document.location.search);
			model.variant = this.findProductNature($product);
			model.category = this.findProductCategory($product);
			model.price = rawModel.salePrice || rawModel.listPrice;

			var rawSticker = $selectedProduct.data('sticker');
			if (rawSticker.length) {
				model.sticker = true;
				model.stickerValue = rawSticker.displayName;
			} else {
				model.sticker = false;
			}

			return model;
		},

		// Get STICKER from SPOTLIGHT
		getStickerSpotlight : function() {
			return $('#lpt-tg .pl-tags .slick-slide.slick-current');
		},
		// Get STICKER from PRODUCT's element
		getSticker : function($element) {
			return $element.closest('.product').find('.pl-banner');
		},

		// Get STICKER VALUE from STICKER's element
		getStickerValue : function($sticker) {

			// STICKER = DIV
			if ($sticker.find('div[class^=label-]').length > 0)
				return $sticker.find('div[class^=label-]').attr('class')
								.replace('label-' + tc_vars.env_language, '')
								.replace('label-', '').trim() + '-';

			// STICKER = IMAGE
			if ($sticker.find('img').length > 0)
				return $sticker.find('img').attr('src').replace('pl-', '')
						.replace('assets/', '').replace('images/', '').replace(
								'/', '').replace(/\.[^/.]+$/, "") + '-';

			return '';
		},

		findProductName : function($product) {
			return $product.find('.title .name').text().trim();
		},
		findProductBrand : function($product) {
			return $product.find('.title .brand').text().trim().toUpperCase();
		},
		findProductNature : function($product) {
			return $product.data('nature');
		},
		findProductCategory : function($product) {
			return $product.data('category');
			
		},
		findProductIndex : function($product) {
			var $allProducts = $('#spotlightFloor .inner-element, #listing-product .inner-element');
			return $allProducts.index($product) + 1;
		}
	};

})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.productpage = {
        
        // Get the current selected element (size-selected product in the 'Make your choice' panel)
        getSelectedElement: function() {
            return $('#modal-product-layout section.size-selection.selected ul a.selected') || $();
        },
        // Returns the SKU ID of the selected product
        getSelectedSku: function() {
            return this.getSelectedElement().data('selected-sku-id') || '';
        },
        // Returns the MODEL ID of the selected product
        getSelectedModelId: function() {
            return this.getSelectedElement().data('selected-model-id') || '';
        },
        // Returns the QUANTITY of the selected product
        getSelectedQuantity: function() {
            return parseInt($('#modal-product-layout .quantity-input').val()) || 0;
        },
        // Returns the PRICE of the selected product
        getSelectedPrice: function() {
            return parseFloat($('#modal-product-layout .product-price .price').data('price')) || 0;
        },
        getName: function() {
            return tc_vars.product_label_displayed;
        },
        getBrand: function() {
            return tc_vars.product_brand.replace('m_', '');
        },
        getNature: function() {
            return tc_vars.product_nature;
        },
        getCategory: function() {
            return tc_vars.product_category;
        },
        getModel: function() {
            var model = {};
            
            model.id = this.getSelectedModelId();
            model.name = this.getName();
            model.brand = this.getBrand();
            model.position = fwk.enhanced.get('position');
            model.list = fwk.enhanced.get('list');
            model.variant = this.getNature();
            model.category = this.getCategory();
            model.quantity = this.getSelectedQuantity();
            model.price = this.getSelectedPrice();
            
            /* / ! \ NO STICKER ON PRODUCT PAGE (in developpement, and at the time)
            model.sticker = true;
            if ($('.pl-banner >').length) model.stickerValue = fwk.utils.pagelist.getStickerValue($('.pl-banner >'));
            else model.sticker = false;
            */
            
            return model;
        },
        getCrossSellModel: function(modelId, typeSelector) {
        	//typeSelector : SM = Super Model, M = Model
            var model = {};
            var selectedModel;
            var products = tc_vars.list_crosssells;
            var position = 1;
            
            var selector = "list_crosssell_id_model";
            if (typeSelector === "SM") {
            	selector = "list_crosssell_id_super_model";
            }
            
            // Search in datalayer
            for (var i = 0; i < products.length; i++) {
            	if (products[i][selector] == modelId) {
            		selectedModel = products[i];
            		position = i + 1;
            		break;
            	}
            }
            
            if (!selectedModel) {
            	// Product not present in data layer, certainly a colorama product
            	position = $(".plv2-el__images").index($("[data-modelid=" + modelId + "]").closest(".plv2-el__images")) + 1;
            	selectedModel = products[position - 1];
            }
            
            model.id = selectedModel.list_crosssell_id_model;
            model.name = selectedModel.list_crosssell_label_displayed;
            model.brand = selectedModel.list_crosssell_brand;
            model.position = position;
            model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce(document.location.pathname);
            model.variant = selectedModel.list_crosssell_nature;
            model.category = selectedModel.list_crosssell_category;
            model.quantity = 1;
            
            if (typeof selectedModel.list_crosssell_currentprice_ati === 'undefined' || selectedModel.list_crosssell_currentprice_ati === 0) {
            	model.price = selectedModel.list_crosssell_originalprice_ati;
            } else {
            	model.price = selectedModel.list_crosssell_currentprice_ati;
            }
            
            return model;
        },
        getPanoplyModel: function(indexPanoply, modelId, typeSelector) {
        	//typeSelector : SM = Super Model, M = Model
            var model = {};
            var selectedModel;
            var products = tc_vars.list_panoplies[indexPanoply].products;
            var position = 1;
            
            var selector = "product_id_model";
            if (typeSelector === "SM") {
            	selector = "product_id_super_model";
            }
            
            // Search in datalayer
            for (var i = 0; i < products.length; i++) {
            	if (products[i][selector] == modelId) {
            		selectedModel = products[i];
            		position = i + 1;
            		break;
            	}
            }
            
            /*if (!selectedModel) {
            	// Product not present in data layer, certainly a colorama product
            	position = $(".plv2-el__images").index($("[data-modelid=" + modelId + "]").closest(".plv2-el__images")) + 1;
            	selectedModel = products[position - 1];
            }*/
            
            model.id = selectedModel.product_id_model;
            model.name = selectedModel.product_label_displayed;
            model.brand = selectedModel.product_brand;
            model.position = position;
            model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce(document.location.pathname);
            model.variant = selectedModel.product_nature;
            model.category = selectedModel.product_category;
            model.quantity = 1;
            
            if (typeof selectedModel.product_currentprice_ati === 'undefined' || selectedModel.product_currentprice_ati === 0) {
            	model.price = selectedModel.product_originalprice_ati;
            } else {
            	model.price = selectedModel.product_currentprice_ati;
            }
            
            return model;
        },
        // Returns true if the conversion layer is open
        isConversionOpen: function() {
        	return $('.fullscreen-layer').is(':visible');
        }
    };
	
})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.basketpage = {
            
        getModel: function($product) {
            
            // Get the product in the datalayer
            var products = tc_vars.order_products;
            var product;
            var refId = $product.find('[data-product-reference]').data('product-reference');
            var positionProduct;
            for (var i = 0; i < products.length; i++) {
                if (products[i].order_product_id_article == refId) {
                    product = products[i];
                    positionProduct = (i + 1);
                }
            }
            
            if (!product){
                return;
            }
          
            var model = {};

            model.id = product.order_product_id_model;
            model.name = product.order_product_name;
            model.brand = product.order_product_brand.toUpperCase();
            model.position = positionProduct;
            model.list = '/checkout/cart';
            model.variant = product.order_product_nature;
            model.category = product.order_product_category;
            model.quantity = $product.find('.quantity-input').val();
            
            if (typeof product.order_product_currentprice_ati === 'undefined' || product.order_product_currentprice_ati === 0) {
            	model.price = product.order_product_originalprice_ati;
            } else {
            	model.price = product.order_product_currentprice_ati;
            }
            
            /* / ! \ NO STICKER ON PRODUCT PAGE (in developpement, and at the time)
            model.sticker = true;
            if ($('.pl-banner >').length) model.stickerValue = fwk.utils.pagelist.getStickerValue($('.pl-banner >'));
            else model.sticker = false;
            */
            return model;
          
        },
	
		getCrossSellModel: function(refId) {
			var products = tc_vars.list_crosssells;
            var product;
            var position = 1;
            
            for (var i = 0; i < products.length; i++) {
                if (products[i].list_crosssell_id_super_model == refId) {
                    product = products[i];
                    position = i + 1;
                    break;
                }
            }
            
            if (!product){
                return;
            }
          
            var model = {};
            
            model.id = product.list_crosssell_id_model;
            model.name = product.list_crosssell_label_displayed;
            model.brand = product.list_crosssell_brand;
            model.position = position;
            model.list = '/checkout/cart';
            model.variant = product.list_crosssell_nature;
            model.category = product.list_crosssell_category;
            model.quantity = 1;
            
            if (typeof product.list_crosssell_currentprice_ati === 'undefined' || product.list_crosssell_currentprice_ati === 0) {
            	model.price = product.list_crosssell_originalprice_ati;
            } else {
            	model.price = product.list_crosssell_currentprice_ati;
            }
            
            return model;
		}
    };
	
})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.datalayer = {
		
		getProducts: function() {
			var prefix;
			if (tc_vars.list_products instanceof Array) prefix = 'list_';
			else if (tc_vars.search_products instanceof Array) prefix = 'search_';
			else return [];
			
			return tc_vars[prefix + 'products'].filter(function(e) { return e.spotlight == '0'; });
			/*
			list_products - list_product_id_super_model
			search_products - search_product_id_super_model
			*/
			
		},
		
		getProductsSpotlightFloor: function() {
			var prefix;
			if (tc_vars.list_products instanceof Array) prefix = 'list_';
			else if (tc_vars.search_products instanceof Array) prefix = 'search_';
			else return [];
			
			return tc_vars[prefix + 'products'].filter(function(e) { return e.spotlight == '1'; });
			
		},
		
		getProductsSpotlight: function() {
			if (tc_vars.spotlight_products instanceof Array)
				return tc_vars.spotlight_products;
			return [];
		},
		
		getProductsHP: function() {
			if (tc_vars.homepage_products instanceof Array)
				return tc_vars.homepage_products;
			return [];
		},
		
		findProductBySuperModel: function(list, superModel) {
			return list.filter(function(product) {
				for (var key in product) {
					if (key.indexOf('id_super_model') > -1 && product[key] == superModel)
						return true;
				}
				return false;
			});
		},
		


        getModel: function(id, type) {

            var foundProduct = [];
            var findType = type || '_id';

            var lists = ['list_crosssells', 'order_products', 'list_savelater', 'list_lvps'];

            lists.forEach(function(list) {
            	if (!tc_vars[list])
            		return;
                tc_vars[list].forEach(function(product) {

                    Object.keys(product)
                        .filter(function(k) { return k.indexOf(findType) != -1; })
                        .forEach(function (k) {
                            if (product[k] == id)
                                foundProduct.push($.extend({fromList: list, position: (tc_vars[list].indexOf(product) + 1)}, product));
                        });

                });
            });

            return this.mapModel(foundProduct[0]);

        },

        mapModel: function(product) {
        	var model = {};

        	if (!product)
        		return model;

        	Object.keys(product)
        		.forEach(function(k) {

        			if (~k.indexOf('_id_article')) { model.skuId = product[k]; return; }
        			if (~k.indexOf('_id_model')) { model.modelId = product[k]; return; }
        			if (~k.indexOf('_id_super_model')) { model.superModelId = product[k]; return; }


        			if (~k.indexOf('_label') || ~k.indexOf('_name')) { model.name = product[k]; return; }
        			if (~k.indexOf('_brand')) { model.brand = product[k]; return; }
        			if (~k.indexOf('_category')) { model.category = product[k]; return; }
        			if (~k.indexOf('_nature')) { model.variant = product[k]; return; }


        			if (~k.indexOf('_originalprice')) { model.priceOriginal = product[k]; return; }
        			if (~k.indexOf('_currentprice')) { model.priceCurrent = product[k]; return; }
        			if (~k.indexOf('_discount_ati')) { model.discountAti = product[k]; return; }

        		});

        		if (!!product.fromList)
        			model.fromList = product.fromList;

        		if (!!product.position)
        			model.position = product.position;

       		model.price = model.priceCurrent || model.priceOriginal;
       		model.id = model.modelId;

        	return model;
        }

    };
	
})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	
	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.suggestionspage = {
		
        getCrossSellModel: function(modelId) {
            var model = {};
            var selectedModel;
            var products = tc_vars.list_crosssells;
            var position = 1;
            
            // Search in datalayer
            for (var i = 0; i < products.length; i++) {
            	if (products[i].list_crosssell_id_model == modelId) {
            		selectedModel = products[i];
            		position = i + 1;
            		break;
            	}
            }
            
            if (!selectedModel) {
            	// Product not present in data layer, certainly a colorama product
            	position = $(".plv2-el__images").index($("[data-modelid=" + modelId + "]").closest(".plv2-el__images")) + 1;
            	selectedModel = products[position - 1];
            }
            
            model.id = modelId;
            model.name = selectedModel.list_crosssell_label_displayed;
            model.brand = selectedModel.list_crosssell_brand;
            model.position = position;
            model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce(document.location.pathname);
            model.variant = selectedModel.list_crosssell_nature;
            model.category = selectedModel.list_crosssell_category;
            model.quantity = 1;
            
            if (typeof selectedModel.list_crosssell_currentprice_ati === 'undefined' || selectedModel.list_crosssell_currentprice_ati === 0) {
            	model.price = selectedModel.list_crosssell_originalprice_ati;
            } else {
            	model.price = selectedModel.list_crosssell_currentprice_ati;
            }
            
            return model;
        }
    };
	
})(jQuery);
/* ANALYTICS UTILS METHODS */
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	var classProductViewed = 'viewed';
	
	CUBE.Analytics.utils = CUBE.Analytics.utils || {};
	CUBE.Analytics.utils.perso = {
			/*
			 * Based on a link element (a),
			 * 	> Gets the related [data-sku-id] and binds the product's URL to the href
			 */
			generateProductLink: function(anchorElement) {
				
				// Get jQuery object
				var $elt;
				if (!(anchorElement instanceof jQuery))
					$elt = $(anchorElement);
				else
					$elt = anchorElement;

				// Get datas
				var id = $elt.data('sku-id');
				var lang = tc_vars.env_language;
				
				var url = Cube.Utils.localizeUri('/product-details/_/R-u-' + id);
				
				// Set the HREF
				$elt.find('a.clickable-area').attr('href', url);
			},
			
			getLVPModel: function(element) {
	            var position = 1;
	            var superModelId = element.data("super-model-id");
	            var modelId = element.data("model-id");
				
	            var model = {};
	            
	            model.id = modelId;
				model.name = element.find('.product-name').text().trim();//product.list_lvp_label_displayed;
				model.brand = element.find('.brand-name').text().trim();//product.list_lvp_brand;
	            model.position = $('.lvp-element').index(element) + 1;//position in all LVP elements
	            if (tc_vars.env_template === "homepage") {
	            	model.list = '/homepage';
	            } else if (tc_vars.env_template === "product") {
	            	model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce();
	            } else if (tc_vars.env_template === "checkout") {
	            	model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce();
	            } else if (tc_vars.env_template === "list" || tc_vars.env_template === "internal_search") {
	            	model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce();
	            } else if (tc_vars.env_template === "other_myaccount") {
	            	model.list = fwk.utils.getInfoNavFromURLForEnhancedEcommerce();
	            }

	            model.variant = '';//product.list_lvp_nature;
	            model.category = '';//product.list_lvp_category;
	            model.quantity = 1;

				// Get displayed price
				model.price = element.find('.price-container:visible .price').data('price');
	            
				/* OLD METHOD for PRICE
	            if (typeof product.list_lvp_currentprice_ati === 'undefined' || product.list_lvp_currentprice_ati === 0) {
	            	model.price = product.list_lvp_originalprice_ati;
	            } else {
	            	model.price = product.list_lvp_currentprice_ati;
	            }
	            */
	            return model;
			}
    };
	
})(jQuery);
/*
 * ANALYTICS PAGE
 */
function AnalyticsTracker(params) {
	this.params = $.extend({}, params);
	this.events = {};

	CUBE.Analytics.debug.time(params.name, "tracker", "eval", false);
}

// Init all the AnalyticsEvents contained inside the Tracker
AnalyticsTracker.prototype.init = function() {

	CUBE.Analytics.debug.time(this.params.name, "tracker", "init", false);
	
	if (this.params.active)
		for (var event in this.events)
			if (this.events[event].active)
				this.events[event].start.bind(this.events[event])();

	CUBE.Analytics.debug.time(this.params.name, "tracker", "init", true);
};

// Add an AnalyticsEvent to the page
AnalyticsTracker.prototype.addEvent = function(event) {
	
	CUBE.Analytics.debug.time(event.name, "event", "eval", true);
	
	this.events[event.name] = event;
};

// Get the default options for events
AnalyticsTracker.prototype.defaultEvent = function() {
	return this.params.defaultEvent;
};

// On / Off tracker
AnalyticsTracker.prototype.disable = function() {
	this.params.active = false;
}; 
AnalyticsTracker.prototype.enable = function() {
	this.params.active = true;
};


/*
 * CLASSIC AnalyticsEvent
 */
function AnalyticsEvent(name, options) {
	this.build(name, options);
}
AnalyticsEvent.prototype.build = function(name, options) {
	CUBE.Analytics.debug.time(name, "event", "eval", false);
	
	this.name = name;
	this.options = $.extend({}, options);
	this.params = {};
	this.active = true;
	this.arrPostActions = [];
	this.timeStamp = '';
};
// > Getters
AnalyticsEvent.prototype.getType = function() { return this.options.type; };
AnalyticsEvent.prototype.getCategory = function() { return this.options.category; };
AnalyticsEvent.prototype.getAction = function() { return this.options.action; };
AnalyticsEvent.prototype.getLabel = function() { return this.options.label; };
AnalyticsEvent.prototype.getValue = function() { return this.options.value; };

// > START : Call the init method; and the preInit, postInit if any
AnalyticsEvent.prototype.start = function() {
	CUBE.Analytics.debug.time(this.name, "event", "init", false);
	
	if (typeof this.preInit === 'function')
		this.preInit();
	if (typeof this.init === 'function')
		this.init();
	if (typeof this.postInit === 'function')
		this.postInit();
	
	CUBE.Analytics.debug.time(this.name, "event", "init", true);
};
// > EVENT SENDING (Binding to callback)
AnalyticsEvent.prototype.bind = function(data) {
	//'bind()' function can be used directly as a callback for a JQuery event
	var event = this;
	return function(jqEvent, jqData) {
	  	var element = this;
	    event.send(element, data, jqEvent, jqData);
	};
};
AnalyticsEvent.prototype.postAction = function(func) {
	var event = this;
	event.arrPostActions.push(func);
};
// > EVENT SENDING
AnalyticsEvent.prototype.send = function(element, data, jqEvent, jqData) {
	// 'send()' function handle the event sending
	var event = this;
	var $element = $(element);
	
	if (typeof event.stopEvent === 'function' && this.stopEvent($element, data, jqEvent, jqData))
		return false;
	
	if (isDoubleEvent(event, jqEvent))
		return false;

	// --- Specific methods for custom event's options
	if(undefined !== event.getType) event.options.type			= event.getType($element, data, jqEvent, jqData);
	if(undefined !== event.getCategory) event.options.category	= event.getCategory($element, data, jqEvent, jqData);
	if(undefined !== event.getAction) event.options.action		= event.getAction($element, data, jqEvent, jqData);
	if(undefined !== event.getLabel) event.options.label		= event.getLabel($element, data, jqEvent, jqData);
	if(undefined !== event.getValue) event.options.value		= event.getValue($element, data, jqEvent, jqData);
	
	if(event.arrPostActions.length > 0) {
		for (var action in event.arrPostActions)
			event.arrPostActions[action].bind(this)($element, data, jqEvent, jqData, event);
	}
	
	CUBE.Analytics.sendEvent($element, event);
};

var isDoubleEvent = function(event, jqEvent) {
	if (jqEvent && event.timeStamp == jqEvent.timeStamp)
		return true;
	
	if (jqEvent)
		event.timeStamp = jqEvent.timeStamp;
};
/*
 * TRIGGER AnalyticsEvent
 */
function AnalyticsTriggerEvent(name, options) {
	this.build(name, options);
	this.domContainer = null;
	this.domElement = null;
	this.trigger = null;
	this.delay = false;
}

//> Inheritance
AnalyticsTriggerEvent.prototype = AnalyticsEvent.prototype;

AnalyticsTriggerEvent.prototype.init = function(data) {
	var event = this;
	var domContainer = event.domContainer ? event.domContainer : event.domElement;
	var triggerElement = event.domTriggerElement ? event.domTriggerElement : event.domElement;
	if (triggerElement == domContainer) triggerElement = null;

	$(domContainer).off(this.trigger + '.' + AnalyticsConstants.namespace + '.' + event.name);
	$(domContainer).on(this.trigger + '.' + AnalyticsConstants.namespace + '.' + event.name, triggerElement, function(jqEvent, jqData) {
		var $element = $(this);

		if('function' === typeof event.getElement)
			$element = event.getElement($element);
		
		if (event.delay && event.delay > 0)
			setTimeout(function() { event.send($element, data, jqEvent, jqData); }, event.delay);
		else
			event.send($element, data, jqEvent, jqData);
		
	});
	// Auto binding :
	//	$(this.domContainer).on(this.trigger + '.' + AnalyticsConstants.namespace, this.domElement, this.bind());
};

AnalyticsTriggerEvent.prototype.getElementPosition = function($element) {
	var $listElements = $element.closest(this.domContainer).find(this.domElement);
	return $listElements.index($element) + 1;
};
/*
 * CLICK AnalyticsEvent
 */
function AnalyticsClickEvent(name, options) {

	this.build(name, options);
	this.trigger = 'click';
}
// > Inheritance

AnalyticsClickEvent.prototype = AnalyticsTriggerEvent.prototype; 
/*
 * CONDITIONAL AnalyticsEvent
 */
function AnalyticsConditionalEvent(name, options) {
	this.build(name, options);
	this.condition = '';
	this.init = function() {

		if (!eval(this.condition)) return false; // jshint ignore:line
		this.send();
	};
}
// > Inheritance
AnalyticsConditionalEvent.prototype = AnalyticsEvent.prototype;
/*
 * SLICK AnalyticsEvent
 */
function AnalyticsSlickEvent(name, options) {
	this.build(name, options);
	this.domContainer = '';
	this.domElement = '';

	this.dots = { active: false };
	this.arrows = { active: false };
	this.sliderElements = { active: false };

	this.init = function() {
		var currentEvent = this;
		var $slider = $(this.domContainer);

		if (this.dots.active) {

			// Wait 1sec. (for slider initialisation) to init events on dots (slick slider initialisation)
			// > "" $slider.on('init', function() { ... } ) "" is a better option, but breaks the 'our-brand slider' on HP
			setTimeout(function() {
				var $listDots = $slider.find(AnalyticsConstants.slick.selectorCssDots);
				$listDots.off('click.' + AnalyticsConstants.namespace + '.' + event.name);
				$listDots.on('click.' + AnalyticsConstants.namespace + '.' + event.name, function() {
					var event = $.extend({}, currentEvent, currentEvent.dots);
					var $element = $(this);
					var index = getElementPosition($listDots, $element);
					event.options.label = AnalyticsConstants.slick.defaultValuePagination + index;
					event.sendSlick($element);
				});
			}.bind(this), 1000);
		}

		if (this.arrows.active) {

			//  Wait 1sec. (for slider initialisation) to init events on arrows (slick slider initialisation)
			setTimeout(function() {
				var $arrowNext = $slider.find(AnalyticsConstants.slick.selectorCssArrowNext);
				var $arrowPrev = $slider.find(AnalyticsConstants.slick.selectorCssArrowPrev);

				$arrowNext.off('click.' + AnalyticsConstants.namespace + '.' + event.name);
				$arrowNext.on('click.' + AnalyticsConstants.namespace + '.' + event.name, function() {
					var event = $.extend({}, currentEvent, currentEvent.arrows);
					event.options.label = AnalyticsConstants.slick.defaultValueArrowRight;
					event.sendSlick($(this));
				});
				
				$arrowPrev.off('click.' + AnalyticsConstants.namespace);
				$arrowPrev.on('click.' + AnalyticsConstants.namespace, function() {
					var event = $.extend({}, currentEvent, currentEvent.arrows);
					event.options.label = AnalyticsConstants.slick.defaultValueArrowLeft;
					event.sendSlick($(this));
				});
			}.bind(this), 1000);
		}


		if (this.sliderElements.active) {
			var $listElements = $slider.find(this.domElement);

	        $listElements.off('click.' + AnalyticsConstants.namespace + '.' + event.name);
	        $listElements.on('click.' + AnalyticsConstants.namespace + '.' + event.name, function() {
				var event = $.extend({}, currentEvent, currentEvent.sliderElements);
	        	var $element = $(this);
	        	var $listElementCurrent = $element.closest('.slick-slider').find(event.domElement);
	        	
	        	var _indexElement = getElementPosition($listElementCurrent, $element);
	        	var _indexFloor = getFloorPosition($element);

		    	event.sendSlick($element, _indexElement, _indexFloor);
	        });
		}

	};
}

AnalyticsSlickEvent.prototype = AnalyticsEvent.prototype;

AnalyticsSlickEvent.prototype.trackDots = function(params) {
	// Add params to event
	$.extend(this.dots, params);
	this.dots.active = true;
};
AnalyticsSlickEvent.prototype.trackArrows = function(params) {
	// Add params to event
	$.extend(this.arrows, params);
	this.arrows.active = true;
	
};
AnalyticsSlickEvent.prototype.trackElements = function(params) {
	// Add params to event
	$.extend(this.sliderElements, params);
	this.sliderElements.active = true;
};

AnalyticsSlickEvent.prototype.sendSlick = function($element, _indexElement, _indexFloor) {

	if (undefined !== typeof this.getType) this.options.type = this.getType($element, _indexElement, _indexFloor);
	if (undefined !== typeof this.getCategory) this.options.category = this.getCategory($element, _indexElement, _indexFloor);
	if (undefined !== typeof this.getAction) this.options.action = this.getAction($element, _indexElement, _indexFloor);
	if (undefined !== typeof this.getLabel) this.options.label = this.getLabel($element, _indexElement, _indexFloor);
	if (undefined !== typeof this.getValue) this.options.value = this.getValue($element, _indexElement, _indexFloor);

	// Remove all getter method
	this.getType = this.getCategory = this.getAction = this.getLabel = this.getValue = undefined;

	this.send($element);
};


/* PRIVATES METHODS */
// Get the ELEMENT's position from a LIST of elements
var getElementPosition = function ($list, $element) {
	return ($list.index($element) + 1);
};

// Get the FLOOR's position (among all floors)
var getFloorPosition = function ($element) {
	var $listFloors = $(AnalyticsConstants.slick.selectorCssFloors);
	var $currentFloor = $element.closest(AnalyticsConstants.slick.selectorCssFloors);
	return getElementPosition($listFloors, $currentFloor);
};
/*
 * TRIGGER AnalyticsEvent
 */
function AnalyticsQueueEvent(name, options) {
	this.build(name, options);
	this.domContainer = null;
	this.domElement = null;
	this.trigger = null;
	
	this.init = function(data) {
		var event = this;
		var domContainer = event.domContainer ? event.domContainer : event.domElement;
		var triggerElement = event.domTriggerElement ? event.domTriggerElement : event.domElement;
		if (triggerElement == domContainer) triggerElement = null;

		$(domContainer).off(this.trigger + '.' + AnalyticsConstants.namespace + '.' + event.name);
		$(domContainer).on(this.trigger + '.' + AnalyticsConstants.namespace + '.' + event.name, triggerElement, function(jqEvent, jqData) {
			
			var $element = $(this);
			
			if(undefined !== event.getType) event.options.type			= event.getType($element, data, jqEvent, jqData);
			if(undefined !== event.getCategory) event.options.category	= event.getCategory($element, data, jqEvent, jqData);
			if(undefined !== event.getAction) event.options.action		= event.getAction($element, data, jqEvent, jqData);
			if(undefined !== event.getLabel) event.options.label		= event.getLabel($element, data, jqEvent, jqData);
			if(undefined !== event.getValue) event.options.value		= event.getValue($element, data, jqEvent, jqData);
			
			CUBE.Analytics.queue.add(event.name, event);
		});
		// Auto binding :
		//	$(this.domContainer).on(this.trigger + '.' + AnalyticsConstants.namespace, this.domElement, this.bind());
	};
}

//> Inheritance
AnalyticsQueueEvent.prototype = AnalyticsEvent.prototype;
(function($) {

	// TRACKER 'HOMEPAGE'
	var sep = AnalyticsConstants.concatenator;
	var fwk = CUBE.Analytics;
	var utils = fwk.utils.homepage;
	
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.homepage.homepage);

	// - PUSH PRODUCT
	var hpPushProduct = new AnalyticsTriggerEvent('hpPushProduct', tracker.defaultEvent());
	hpPushProduct.trigger = 'mouseup.st';
	hpPushProduct.domContainer = '#main-container';
	hpPushProduct.domElement = '.inner-product, .inner-content';
	hpPushProduct.options.action = 'HPFloor';
	hpPushProduct.stopEvent = function($element, data, jqEvent) { return jqEvent.which === 3; };
	hpPushProduct.getAction = function($element) {
		return $element.hasClass('.inner-product') ? 'HPPushProduct' : 'HPContent';
	};
	hpPushProduct.getLabel = function($element) {
		var label = 'Floor-' + utils.getFloorIndex($element) + sep;
		label += 'Position-' + utils.getProductIndex($element) + sep;
		label += utils.getFloorName($element) + sep;
		label += utils.getProductName($element);
		return label;
	};
	hpPushProduct.getValue = function($element) {
		return utils.getProductValue($element);
	};
	tracker.addEvent(hpPushProduct);

	// - BRANDS
	var eventBrands = new AnalyticsSlickEvent('hpBrands', tracker.defaultEvent());

	eventBrands.domContainer = '.slick-brands';
	eventBrands.domElement = '.brand-block';
	eventBrands.options.action = 'HPBrands';

	eventBrands.trackDots();
	eventBrands.trackArrows();
	eventBrands.trackElements({
		getLabel: function($element, _indexElement, _indexFloor) {
	    	var _brandName = "unknown";
	    	var _searchedClass = 'sprite-brand-large-';
			var _brandClass = $.grep($element.find('a div').attr('class').split(" "), function(v, i){
				return v.indexOf(_searchedClass) === 0;
			}).join();
			if (_brandClass !== null)
				_brandName = _brandClass.replace(_searchedClass, '');
			return AnalyticsConstants.slick.defaultValuePosition +  _indexElement + AnalyticsConstants.concatenator + _brandName;
		}
	});

	tracker.addEvent(eventBrands);

	// - RECALLS
	var eventRecall = new AnalyticsSlickEvent('hpRecall', tracker.defaultEvent());

	eventRecall.domContainer = '.slick-informations';
	eventRecall.domElement = 'div.information a';
	eventRecall.options.action = 'HPRecall';

	eventRecall.trackDots();
	eventRecall.trackArrows();
	eventRecall.trackElements({
		vars: {
			selectorParent: '.row',
			selectorTarget: 'div.desc strong',
		},
		getLabel: function($element, _indexElement, _indexFloor) {
	    	// Recall's name is display in the strong tag of the element.
	    	var _recallName = "unknown";
	    	var _searchedElement = $element.closest(this.vars.selectorParent).find(this.vars.selectorTarget).first();
	    	if (_searchedElement !== null)
	    		_searchedElement = _searchedElement.text();
			return AnalyticsConstants.slick.defaultValuePosition +  _indexElement + AnalyticsConstants.concatenator + _searchedElement;
		}
	});

	tracker.addEvent(eventRecall);

	// - BANNER
	var eventBanner = new AnalyticsSlickEvent('hpBanner', tracker.defaultEvent());

	eventBanner.domContainer = '.opeco-carousel';
	eventBanner.domElement = '.slide';
	eventBanner.options.action = 'HPBanner';

	eventBanner.trackDots();
	eventBanner.trackElements({
		vars: {
			selectorParent: '.slide',
			selectorDataTrackingInfo: 'tracking-info',
		},
		getLabel: function($element, _index) {
			var _trackingInfo = $element.closest(this.vars.selectorParent).data(this.vars.selectorDataTrackingInfo);
			return AnalyticsConstants.slick.defaultValuePosition + _index + AnalyticsConstants.concatenator + _trackingInfo;
		}
	});

	tracker.addEvent(eventBanner);

	// - FLOOR BANNER
	var paramsFloorBanner = {
		vars: {
			selectorParent: '.container-fluid',
			selectorClassBig: 'floor-push-opco',
			selectorClassBigCta: 'button-wrapper',
			selectorClassMedium: 'floor-push',
			selectorClassPosition: 'floor-push-reverse',
		},
		getLabel: function($element, _indexElement, _indexFloor) {
			//  -> 'Floor-X' / '%FLOOR_NAME%' / [ 'Position-{left, right}' ] / '{big, medium[-cta]}'
	    	var _size, _position = '';
	    	var $parent = $element.closest(this.vars.selectorParent);
	    	var floorName = '';
	    	
	    	if ($parent.hasClass(this.vars.selectorClassBig)) { // OPCO
	    		_size = 'big';
	    		floorName = $element.closest('div.floor-push-opco').find('a:first').attr('title');
	    		if ($element.parent().hasClass(this.vars.selectorClassBigCta))
	    			_size = _size + '-cta';
	    	}
	    	if ($parent.hasClass(this.vars.selectorClassMedium)) { // LIST-PRODUCTS
	    		_size = 'medium';
				floorName = $element.closest('div.list-products').attr('id');
	    		if ($parent.hasClass(this.vars.selectorClassPosition))
	    			_position = AnalyticsConstants.slick.defaultValuePosition + 'left' + AnalyticsConstants.concatenator;
	    		else
	    			_position = AnalyticsConstants.slick.defaultValuePosition + 'right' + AnalyticsConstants.concatenator;
	    	}
	    	return AnalyticsConstants.slick.defaultValueFloor + _indexFloor + AnalyticsConstants.concatenator + floorName + AnalyticsConstants.concatenator + _position + _size;
			
		}
	};
	// + (inside floor)
	var eventFloorsBannerInsideFloor = new AnalyticsSlickEvent('hpFloorsBannerInside', tracker.defaultEvent());
	eventFloorsBannerInsideFloor.domContainer = '.floor-push';
	eventFloorsBannerInsideFloor.domElement = '.btn-wrapper a';
	eventFloorsBannerInsideFloor.options.action = 'HPBanner';
	eventFloorsBannerInsideFloor.trackElements(paramsFloorBanner);
	tracker.addEvent(eventFloorsBannerInsideFloor);
	// + (banner alone)
	var eventFloorsBannerAlone = new AnalyticsSlickEvent('hpFloorsBannerBig', tracker.defaultEvent());
	eventFloorsBannerAlone.domContainer = '.floor-push-opco';
	eventFloorsBannerAlone.domElement = 'a';
	eventFloorsBannerAlone.options.action = 'HPBanner';
	eventFloorsBannerAlone.trackElements(paramsFloorBanner);
	tracker.addEvent(eventFloorsBannerAlone);

	// - FLOOR NAVIGATION
	var eventFloorNavigation = new AnalyticsTriggerEvent('hpFloorNavigation', tracker.defaultEvent());

	eventFloorNavigation.domContainer = '#block_vertical-nav ul';
	eventFloorNavigation.domElement = 'a';
	eventFloorNavigation.trigger = 'click';
	eventFloorNavigation.options.action = 'HPFloorNavigation';

	eventFloorNavigation.getLabel = function($element) { return $(this.domContainer).find(this.domElement).index($element) + 1; };

	tracker.addEvent(eventFloorNavigation);

	// - INSURANCES TOP
	var eventInsurancesTop = new AnalyticsSlickEvent('hpInsurancesTop', tracker.defaultEvent());

	eventInsurancesTop.domContainer = 'nav.services .slick-slider';
	eventInsurancesTop.domElement = '.slick-slide';
	eventInsurancesTop.options.action = 'HPInsurances_top';

	eventInsurancesTop.trackArrows();
	eventInsurancesTop.trackElements({
		vars: {
			selectorElement: 'a',
			selectorAttribute: 'href',
			splitCharacter: '/',
		},
		getLabel: function($element, _indexElement, _indexFloor) {
	    	// There is no proper way to get the real insurance's name directly.
	    	// We get the link of the element, and keep the last part (after the last '/'), the only relevant one.
			var _arrInsuranceLink = $element.find(this.vars.selectorElement).attr(this.vars.selectorAttribute).split(this.vars.splitCharacter);
			var _insuranceName = _arrInsuranceLink[_arrInsuranceLink.length - 1];
			return AnalyticsConstants.slick.defaultValuePosition +  _indexElement + AnalyticsConstants.concatenator + _insuranceName;
		}
	});

	tracker.addEvent(eventInsurancesTop);

	// - INSURANCES BOTTOM
	var eventInsurancesBottom = new AnalyticsSlickEvent('hpInsurancesBottom', tracker.defaultEvent());

	eventInsurancesBottom.domContainer = '.slick-services.slick-slider';
	eventInsurancesBottom.domElement = '.slick-slide';
	eventInsurancesBottom.options.action = 'HPInsurances_bottom';

	eventInsurancesBottom.trackArrows();
	eventInsurancesBottom.trackElements({
		vars: {
			selectorElement: 'a',
			selectorAttribute: 'href',
			splitCharacter: '/',
		},
		getLabel: function($element, _indexElement, _indexFloor) {
	    	// There is no proper way to get the real insurance's name directly.
	    	// We get the link of the element, and keep the last part (after the last '/'), the only relevant one.
			var _arrInsuranceLink = $element.find(this.vars.selectorElement).attr(this.vars.selectorAttribute).split(this.vars.splitCharacter);
			var _insuranceName = _arrInsuranceLink[_arrInsuranceLink.length - 1];
			return AnalyticsConstants.slick.defaultValuePosition +  _indexElement + AnalyticsConstants.concatenator + _insuranceName;
		}
	});

	tracker.addEvent(eventInsurancesBottom);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

// -- INIT
if($('body').hasClass('homepage')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.homepage.homepage.name);
	});
}
(function($) {

	// TRACKER 'HOMEPAGE - SPORTS ADVICE'
	var sep = AnalyticsConstants.concatenator;
	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var defaultContainer = '#sports-advice';
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.homepage.sportsadvice);
	
	if (tc_vars.env_language === "zh") {
		
		// SPECIAL CAROUSEL (Slick) FOR "ZH" language (no alphabetic order)

		var eventAllSports = new AnalyticsSlickEvent('SportAdvice-SlickCarousel', tracker.defaultEvent());

		eventAllSports.domContainer = '.sports-advice-carousel';
		eventAllSports.domElement = 'a';
		eventAllSports.options.action = 'HPAllSports';

		eventAllSports.trackDots();
		eventAllSports.trackArrows();
		eventAllSports.trackElements({
			vars: {
				classSportName: 'sprite-sport-product-',
				selectorParent: 'span.sprite-sport-product',
				selectorType: 'class',
			},
			getLabel: function($element, _indexElement, _indexFloor) {
				// Sport's name is contained at the end of the div's className (e.g. "sprite-sport-product-tennis").
				// We search for the className that starts with 'sprite-sport-product-' and remove this value from the founded string.
				var _sportName = "unknown";
				var _searchedClass = this.vars.classSportName;
				var _sportClass = $.grep($element.find(this.vars.selectorParent).attr(this.vars.selectorType).split(" "), function(v, i){
					return v.indexOf(_searchedClass) === 0;
				}).join();
				if (_sportClass !== null)
					_sportName = _sportClass.replace(_searchedClass, '');
				return AnalyticsConstants.slick.defaultValuePosition +  _indexElement + AnalyticsConstants.concatenator + _sportName;
			}
		});
		
		eventAllSports.postAction(function($element) {
			var _urlCategory = fwk.utils.getInfoNavFromURL($element.attr('href'), false);
			if (_urlCategory !== null && _urlCategory !== "" && _urlCategory.endsWith("_")) {
				_urlCategory = _urlCategory.substr(0,_urlCategory.length -2);
			}
			
			if (_urlCategory !== null && _urlCategory !== "") {
				var _splitUrlCategory = _urlCategory.split("/");
				_urlCategory = _splitUrlCategory[_splitUrlCategory.length - 1];
			}
			
			fwk.shoppingtool.set("navigation", _urlCategory);
	    });

		tracker.addEvent(eventAllSports);
		
	} else {
		
		// DEFAULT CAROUSEL > ALPHABETICAL ORDER
		
		// - CLICK SPORT
		var clickSport = new AnalyticsClickEvent('SportAdvice-ClickSport', tracker.defaultEvent());
		clickSport.domContainer = defaultContainer;
		clickSport.domElement = '.line > a';
		clickSport.getLabel = function($element) {
			var sportName = $element.data('ordering-text');
			var sportPosition = $(this.domContainer).find(this.domElement).index($element) + 1;
			return 'Position-' + sportPosition + sep + sportName;
		};
		
		clickSport.postAction(function($element) {
			var _urlCategory = fwk.utils.getInfoNavFromURL($element.attr('href'), false);
			if (_urlCategory !== null && _urlCategory !== "" && _urlCategory.endsWith("_")) {
				_urlCategory = _urlCategory.substr(0,_urlCategory.length -2);
			}
			fwk.shoppingtool.set("navigation", _urlCategory);
	    });
		
		tracker.addEvent(clickSport);
	
		// - CLICK LETTER
		var clickLetter = new AnalyticsClickEvent('SportAdvice-ClickLetter', tracker.defaultEvent());
		clickLetter.domContainer = defaultContainer;
		clickLetter.domElement = '#sportsAdviceCarouselNav > div.bullet';
		clickLetter.getLabel = function($element) {
			return 'Click-' + $element.data('value');
		};
		tracker.addEvent(clickLetter);

	}

	// CLICK on category tabs link
	$("#category-tabs .category-tabs-list a").on('click.st', function() {
		var _urlCategory = fwk.utils.getInfoNavFromURLForShoppingTool($(this).attr('href'));
		if (_urlCategory !== null && _urlCategory !== "" && _urlCategory.endsWith("_")) {
			_urlCategory = _urlCategory.substr(0,_urlCategory.length -2);
		}
		
		if (_urlCategory !== null && _urlCategory !== "") {
			var _splitUrlCategory = _urlCategory.split("/");
			_urlCategory = _splitUrlCategory[_splitUrlCategory.length - 1];
		}
		
		CUBE.Analytics.shoppingtool.set("navigation", _urlCategory);
	});

	// - DEFAULT SEARCH IN 
	var clickSearch = new AnalyticsClickEvent('SportAdvice-ClickSearch', tracker.defaultEvent());
	clickSearch.domContainer = defaultContainer;
	clickSearch.domElement = '#sportsAdviceFilteredList li > a';
	clickSearch.getLabel = function($element) {
		var searchedValue = $('#sportsAdviceFilter').val().trim().toUpperCase();
		var clickedValue = $element.data('ordering-text');
		return 'Search-' + searchedValue + sep + clickedValue;
	};
	tracker.addEvent(clickSearch);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

// -- INIT
if($('body').hasClass('homepage')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.homepage.sportsadvice.name);
	});
}
(function($) {

	// TRACKER 'HEADER'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.commons.header);

	// - HelpLinkRollOver - Over #1
	var HelpLinkRollOver = new AnalyticsTriggerEvent("HelpLinkRollOver", tracker.defaultEvent());
	HelpLinkRollOver.options.action = "HelpLinkRollOver";
	HelpLinkRollOver.domContainer = "#dropdown-help";
	HelpLinkRollOver.trigger = "mouseenter";
	HelpLinkRollOver.params = {url_attr:"href"};
	HelpLinkRollOver.getLabel= function($element){return $element.attr(this.params.url_attr);};
	tracker.addEvent(HelpLinkRollOver);
	
	// - HelpLinkRollOver - Click #1
	var HelpLinkClick = new AnalyticsClickEvent("HelpLinkClick", tracker.defaultEvent());
	HelpLinkClick.options.action = "HelpLinkClick";
	HelpLinkClick.domContainer = "#dropdown-help";
	HelpLinkClick.params = {url_attr:"href"};
	HelpLinkClick.getLabel= function($element){return $element.attr(this.params.url_attr);};
	tracker.addEvent(HelpLinkClick);

	// - HelpLink1Click #1.1
	var HelpLink1Click = new AnalyticsClickEvent("HelpLink1Click", tracker.defaultEvent());
	HelpLink1Click.options.action = "HelpLink1Click";
	HelpLink1Click.domContainer = "#help-findAnswer";
	HelpLink1Click.params = {url_attr:"href"};
	HelpLink1Click.getLabel= function($element){return $element.attr(this.params.url_attr);};
	tracker.addEvent(HelpLink1Click);
			

	// - HelpLink2Click #1.2
	var HelpLink2Click = new AnalyticsClickEvent("HelpLink2Click", tracker.defaultEvent());
	HelpLink2Click.options.action = "HelpLink2Click";
	HelpLink2Click.domContainer = "#help-sendMail";
	HelpLink2Click.params = {url_attr:"href"};
	HelpLink2Click.getLabel= function($element){return $element.attr(this.params.url_attr);};
	tracker.addEvent(HelpLink2Click);		

	// - HelpLink2Click #1.3
	var HelpLink3Click = new AnalyticsClickEvent("HelpLink3Click", tracker.defaultEvent());
	HelpLink3Click.options.action = "HelpLink3Click";
	HelpLink3Click.domContainer = "#help-findStore";
	HelpLink3Click.params = {url_attr:"href"};
	HelpLink3Click.getLabel= function($element){return $element.attr(this.params.url_attr);};
	tracker.addEvent(HelpLink3Click);

	// - FindAStore #2
	var FindAStore = new AnalyticsClickEvent("FindAStore", tracker.defaultEvent());
	FindAStore.options.action = 'Account';
	FindAStore.options.label = "FindAStore";
	FindAStore.domContainer = "#dropdown-find-store";
	tracker.addEvent(FindAStore);

	// - AccountGlobal #3
	var AccountGlobal = new AnalyticsClickEvent("AccountGlobal", tracker.defaultEvent());
	AccountGlobal.options.action = 'Account';
	AccountGlobal.options.label = "Account - Global";
	AccountGlobal.domContainer = "a.dropdown-account";
	tracker.addEvent(AccountGlobal);
			
	// - AccountmyAccount #3.1
	var AccountmyAccount = new AnalyticsClickEvent("AccountmyAccount", tracker.defaultEvent());
	AccountmyAccount.options.action = 'Account';
	AccountmyAccount.options.label = "Account - MyAccount";
	AccountmyAccount.domContainer = "#accountLink";
	tracker.addEvent(AccountmyAccount);
			
	// - AccountMyLoyaltyAdvandtages #3.2
	var AccountMyLoyaltyAdvandtages = new AnalyticsClickEvent("AccountMyLoyaltyAdvandtages", tracker.defaultEvent());
	AccountMyLoyaltyAdvandtages.options.action = 'Account';
	AccountMyLoyaltyAdvandtages.options.label = "Account - MyLoyaltyAdvandtages";
	AccountMyLoyaltyAdvandtages.domContainer = "#loyaltyLink";
	tracker.addEvent(AccountMyLoyaltyAdvandtages);
			
	// - AccountMyPurchases #3.3
	var AccountMyPurchases = new AnalyticsClickEvent("AccountMyPurchases", tracker.defaultEvent());
	AccountMyPurchases.options.action = 'Account';
	AccountMyPurchases.options.label = "Account - MyPurchases";
	AccountMyPurchases.domContainer = "#purchasesLink";
	tracker.addEvent(AccountMyPurchases);

	// - AccountMyFavoriteStore #3.4
	var AccountMyFavoriteStore = new AnalyticsClickEvent("AccountMyFavoriteStore", tracker.defaultEvent());
	AccountMyFavoriteStore.options.action = 'Account';
	AccountMyFavoriteStore.options.label = "Account - MyFavoriteStore";
	AccountMyFavoriteStore.domContainer = "#storeLink";
	tracker.addEvent(AccountMyFavoriteStore);
	// - AccountMyFavoriteStore #3.4b
	var AccountMyFavoriteStoreSelected = new AnalyticsClickEvent("AccountMyFavoriteStoreSelected", tracker.defaultEvent());
	AccountMyFavoriteStoreSelected.options.action = 'Account';
	AccountMyFavoriteStoreSelected.options.label = "Account - MyFavoriteStore - ClickStore";
	AccountMyFavoriteStoreSelected.domContainer = "#header-my-account .store-name";
	tracker.addEvent(AccountMyFavoriteStoreSelected);

	// - AccountLogout #3.5
	var AccountLogout = new AnalyticsClickEvent("AccountLogout", tracker.defaultEvent());
	AccountLogout.options.action = 'Account';
	AccountLogout.options.label = "Account - Logout";
	AccountLogout.domElement = "#header-my-account a[data-target='#logout-header-confirmation']";
	tracker.addEvent(AccountLogout);

	// - AccountLogout #3.5 - confirm
	var AccountLogoutConfirm = new AnalyticsClickEvent("AccountLogoutConfirm", tracker.defaultEvent());
	AccountLogoutConfirm.options.action = 'Account';
	AccountLogoutConfirm.options.label = "Account - Confirm Logout";
	AccountLogoutConfirm.domElement = "#header-my-account a.logoutLink";
	tracker.addEvent(AccountLogoutConfirm);

	// - Country #4
	var countryEvent = new AnalyticsClickEvent("countryEvent", tracker.defaultEvent());
	countryEvent.options.action = "Country";
	countryEvent.domContainer = ".dropdown.lang-choice-header";
	countryEvent.domElement = "li";
	countryEvent.params = {id_attr:"data-code"};
	countryEvent.getLabel = function($element){return $element.attr(this.params.id_attr);};
	tracker.addEvent(countryEvent);

	// headerProceedToCheckout
	var headerProceedToCheckout = new AnalyticsClickEvent("headerProceedToCheckout", tracker.defaultEvent());
	headerProceedToCheckout.domContainer = "#header-my-cart";
	headerProceedToCheckout.domElement = "a#dropdown-cart, div.checkout a";
	headerProceedToCheckout.options.category = "Checkout - Basket";
	headerProceedToCheckout.options.action = "ProceedToCheckout";
	headerProceedToCheckout.options.label = "HeaderBasketLayout";
	headerProceedToCheckout.getValue = function($element){
		if ($element.closest(this.domContainer).find('[data-tracking-cart-amount]').length)
			return $element.closest(this.domContainer).find('[data-tracking-cart-amount]').data('tracking-cart-amount');
		else
			return $element.closest(this.domContainer).find('[data-tid="mini-cart-button"]').data('tracking-cart').split('|')[1];
	};
	tracker.addEvent(headerProceedToCheckout);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

// -- INIT
$(function() {
	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.commons.header.name);
});
(function($) {

	// TRACKER 'FOOTER'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.commons.footer);

	// - FOOTER LINKS
	var eventFooterLinks = new AnalyticsSlickEvent('eventFooterLinks', tracker.defaultEvent());
	eventFooterLinks.domContainer = '.container-footer-links .slick-slider';
	eventFooterLinks.domElement = 'a:not(.accordion-section-title)';
	eventFooterLinks.trackDots();
	eventFooterLinks.trackElements({
		vars: {
			selectorParent: '.slick-slide',
			selectorAttribute: 'href',
			selectorTitle: 'h3',
			splitCharacter: '/',
		},
		getLabel: function($element) {
			var $slide = $element.closest(this.vars.selectorParent);
			var arrLink = $element.attr(this.vars.selectorAttribute).split(this.vars.splitCharacter);
			
			var _menuType = $slide.find(this.vars.selectorTitle).text();
			var _pageName = arrLink[arrLink.length-1];
			
			if (!_pageName) {
				if ($element.attr('href').indexOf('recruitment')) _pageName = 'join-us';
			}
			
			return _menuType + AnalyticsConstants.concatenator + _pageName;
		}
	});
	tracker.addEvent(eventFooterLinks);

	// - FIND US
	var eventFindUs = new AnalyticsClickEvent('eventFindUs', tracker.defaultEvent());
	eventFindUs.domContainer = '.container-footer-newsletter-social';
	eventFindUs.domElement = '.image-social a';
	eventFindUs.params = {attributeToFind: 'class', classToRemove: 'social-icon', strToFind: 'image-', strToReplace: ''};
	eventFindUs.getLabel = function($element) {
		return $element.clone().removeClass(this.params.classToRemove).attr(this.params.attributeToFind).replace(this.params.strToFind, this.params.strToReplace);
	};
	tracker.addEvent(eventFindUs);

	// - CHANGE COUNTRY
	var eventChangeCountry = new AnalyticsClickEvent('eventChangeCountry', tracker.defaultEvent());
	eventChangeCountry.domContainer = '.container-footer-countries';
	eventChangeCountry.domElement = 'ul.drop-countries-list li';
	eventChangeCountry.params = {prefix: 'ChangeCountry_'};
	eventChangeCountry.getLabel = function($element) {
		return this.params.prefix + $element.text();
	};
	tracker.addEvent(eventChangeCountry);
	

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
$(function() {
	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.commons.footer.name);
});
(function($) {
	
	var fwk = CUBE.Analytics;
	// TRACKER 'FILTERS'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.commons.filters);
	var isSearch = tc_vars.env_template === 'internal_search' ? true : false;
	var baseEvent = {};

	if (isSearch) {
		baseEvent = AnalyticsConstants.trackers.commons.search.defaultEvent;
		baseEvent.action = "AdditionalSearch";
	} else {
		baseEvent = AnalyticsConstants.trackers.commons.filters.defaultEvent;
	}

	// - BTN TOGGLE FILTER
	var eventBtnToggle = new AnalyticsTriggerEvent('btnToggle', baseEvent);

	eventBtnToggle.trigger = 'click';
	eventBtnToggle.domContainer = '#main-container';
	eventBtnToggle.domElement = '#product-filters .m-filters-settings-item.toggler-col';

	eventBtnToggle.params = {};
	eventBtnToggle.params.valueOpen = 'Open';
	eventBtnToggle.params.valueClose = 'Close';
	eventBtnToggle.params.selectorSub = 'a';
	eventBtnToggle.params.dataTextOpened = 'close-text-long';
	eventBtnToggle.getLabel = function($element, data, jqEvent, jqData) {
		if ($element.text().trim() == $element.find(this.params.selectorSub).data(this.params.dataTextOpened))
			return this.params.valueClose;
		return this.params.valueOpen;
	};

	tracker.addEvent(eventBtnToggle);

	// - FILTER ON 'SELECT'
	var eventFilterSelect = new AnalyticsTriggerEvent('filterSelect', baseEvent);

	eventFilterSelect.trigger = 'change';
	eventFilterSelect.domContainer = '#main-container';
	eventFilterSelect.domElement = '.m-filters-faceting-content select';

	eventFilterSelect.params = {};
	eventFilterSelect.params.type = 'select';
	eventFilterSelect.params.selectorName = 'option:first-child';
	eventFilterSelect.params.selectorValue = 'option:selected';
	eventFilterSelect.constructLabel = function($element) {
		var _type = this.params.type;
		var _name = $element.find(this.params.selectorName).text().trim();
		var _value = $element.find(this.params.selectorValue).text().trim();
		return _type + AnalyticsConstants.concatenator + _name + AnalyticsConstants.concatenator + _value;
	};
	eventFilterSelect.getLabel = function($element) { return optionnalSearchedPhrase() + eventFilterSelect.constructLabel($element); };

	tracker.addEvent(eventFilterSelect);

	// - FILTER ON 'RANGE'
	var eventFilterRange = new AnalyticsTriggerEvent('filterRange', baseEvent);

	eventFilterRange.trigger = 'rangeChange';
	eventFilterRange.domContainer = '#product-filters';
	eventFilterRange.domElement = '#range_filter';
	eventFilterRange.params = {};
	eventFilterRange.params.type = 'range';
	eventFilterRange.getLabel = function($element, data, jqEvent, jqData) {
		var _type = this.params.type;
		return optionnalSearchedPhrase() + _type + AnalyticsConstants.concatenator + jqData.from + AnalyticsConstants.concatenator + jqData.to;
	};

	tracker.addEvent(eventFilterRange);

	// - FILTER ON 'COLOR'
	var eventFilterColor = new AnalyticsTriggerEvent('filterColor', baseEvent);

	eventFilterColor.trigger = 'click';
	eventFilterColor.flagSend = false;
	//eventFilterColor.domContainer = '#main-container';
	eventFilterColor.domElement = '.m-filters-list-colors div.checkbox';
	// |--> We 'hack' the init for this event : for an unknow reason, 'eventFilterColor' is triggered twice...
	// | The modification consists to call the jQuery method 'one' (instead of 'on') in order to send it only once
	eventFilterColor.init = function() { $(this.domElement).one(this.trigger + '.' + AnalyticsConstants.namespace, this.bind()); };
	eventFilterColor.preInit = function() { this.flagSend = false; };
	eventFilterColor.postAction(function($element, data, jqEvent, jqData, event) { event.flagSend = true; });
	eventFilterColor.stopEvent = function() { return this.flagSend; };
	eventFilterColor.params = {};
	eventFilterColor.params.type = 'color';
	eventFilterColor.params.selectorName = 'input.checkboxFilter';
	eventFilterColor.params.attributeName = 'title';
	eventFilterColor.getLabel = function($element, data, jqEvent, jqData) {
		var _type = this.params.type;
		var _value = $element.find(this.params.selectorName).attr(this.params.attributeName);
		return optionnalSearchedPhrase() + _type + AnalyticsConstants.concatenator + _value;
	};
	tracker.addEvent(eventFilterColor);

	// - FILTER ON 'CATEGORY'
	var eventFilterCategory = new AnalyticsSlickEvent('category', baseEvent);
	eventFilterCategory.domContainer = '#product-list-categories';
	eventFilterCategory.domElement = '.product-categories-list.slick-slider a';
	eventFilterCategory.options.action = 'CategoryCarrousel';
	eventFilterCategory.trackArrows({
		getLabel: function($element) {
			if ($element.hasClass('slick-next'))
				return "Next";
			if ($element.hasClass('slick-prev'))
				return "Previous";
			return "";
		}
	});
	eventFilterCategory.trackElements({
		params: {
			findAttribute: 'href', checkElement: 'a.deselect', parentElement: 'div',
			valueOpen: 'Open-', valueClose: 'Close-',
		},
		getLabel: function($element) {
			var _elementSelected = $element.closest(this.params.parentElement).find(this.params.checkElement);
			if (_elementSelected.length)
				return this.params.valueClose + fwk.utils.getInfoNavFromURLForShoppingTool($element.attr(this.params.findAttribute));
			else
				return this.params.valueOpen + fwk.utils.getInfoNavFromURLForShoppingTool($element.attr(this.params.findAttribute));
		}
	});
	tracker.addEvent(eventFilterCategory);
	
	// FILTER ON 'CATEGORIZED BY' (checkbox faceting)
	var eventFilterCheckbox = new AnalyticsTriggerEvent('filterCheckbox', baseEvent);
	eventFilterCheckbox.trigger = 'change';
	eventFilterCheckbox.domContainer = '.m-filters-item-scroll';
	eventFilterCheckbox.domElement = 'input';
	eventFilterCheckbox.getLabel = function($element) {
		var filterType = "checkbox";
		var filterName = $element.closest('.m-filters-item-content').find('legend').text().trim();
		var filterValue = $element.parent().text().trim();
		return optionnalSearchedPhrase() + filterType + AnalyticsConstants.concatenator + filterName + AnalyticsConstants.concatenator + filterValue;
	};
	tracker.addEvent(eventFilterCheckbox);

	// FILTER 'SORT BY'
	var eventSortBy = new AnalyticsTriggerEvent('filterSortBy', baseEvent);
	eventSortBy.trigger = 'change';
	eventSortBy.options.action = 'Sort';
	eventSortBy.domContainer = '#main-container';
	eventSortBy.domElement = '#product-filters-top select.selectSortOption';
	eventSortBy.getLabel = function($element) {
		var selectedIndex = $element[0].selectedIndex;
		return optionnalSearchedPhrase() + $element.parent().find('[data-original-index="'+selectedIndex+'"]').text().trim();
	};
	tracker.addEvent(eventSortBy);

	// FILTER 'SORT BY' ( -- TRIGGER 'open' on open)
	var eventOpenSortBy = new AnalyticsClickEvent('filterOpenSortBy', baseEvent);
	eventOpenSortBy.options.action = 'Sort';
	eventOpenSortBy.domContainer = '#main-container';
	eventOpenSortBy.domElement = '#product-filters-top .selectSortOption .btn';
	eventOpenSortBy.options.label = 'Open';
	tracker.addEvent(eventOpenSortBy);


	CUBE.Analytics.trackers.add(tracker);
	
	var optionnalSearchedPhrase = function() {
		if (isSearch) return tc_vars.search_keyword + AnalyticsConstants.concatenator;
		else return '';
	};

})(jQuery);

// -- INIT
if($("#product-filters").length > 0){
	$(function() {
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.commons.filters.name);
	});
}
(function($) {

	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separator;
	
	var clearText = function(text){
		if(text !== null){
			return text.replace(/(\r\n|\n|\r)/gm,"").trim();
		}
		return null;
	};

    // TRACKER 'NAVIGATION'
    var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.commons.navigation);

	// - 1 Click75sportsMenu
	var click75sportsMenu = new AnalyticsClickEvent("click75sportsMenu", tracker.defaultEvent());
	click75sportsMenu.options.action = "Click75sportsMenu";
	click75sportsMenu.options.label="75sports";
	click75sportsMenu.domContainer = ".menu-all-sports";
	click75sportsMenu.domElement = '[aria-controls="submenu-sports-75-opeco"]';
	tracker.addEvent(click75sportsMenu);
	
	// - 1 Click75sportsMenu > Sport
	var click75sportsSubMenu = new AnalyticsClickEvent("click75sportsSubMenu", tracker.defaultEvent());
	click75sportsSubMenu.options.action = "Click75sportsMenu";
	click75sportsSubMenu.domContainer = ".sports-list-container-content";
	click75sportsSubMenu.domElement = 'a.sport-link';
	click75sportsSubMenu.getLabel = function($element) {
		var position = $element.closest(this.domContainer).find(this.domElement).index($element) + 1;
		var sport = $element.data('ordering-text');
		return sport + sep + position;
	};
	tracker.addEvent(click75sportsSubMenu);
	
	/*
	// - 1.1 Click75sportsMenuSub
	var click75sportsMenuSub = new AnalyticsClickEvent("click75sportsMenuSub", tracker.defaultEvent());
	click75sportsMenuSub.options.action="Click75sportsMenu";
	click75sportsMenuSub.domContainer = "div.nav-sports";
	click75sportsMenuSub.domElement = ".sport-link";

	click75sportsMenuSub.getLabel = function($element){
		var index = this.getElementPosition($element);
		var sportName = clearText($element.find("div.text").text());
		return sportName+AnalyticsConstants.concatenator + index;
	};
	tracker.addEvent(click75sportsMenuSub);
	*/

	// - 2 ClickSportsMenu
	var clickSportsMenu = new AnalyticsClickEvent("clickSportsMenu", tracker.defaultEvent());
	clickSportsMenu.options.action="ClickSportsMenu";
	clickSportsMenu.domContainer =  ".menu-content .menu-sports ul[role=tablist]";
	clickSportsMenu.domElement ="li[role=presentation]:not(.sports-75)";
	clickSportsMenu.getLabel = function($element){
		var index = this.getElementPosition($element);
		var sportName = clearText($element.find("div.text").text());
		return sportName+AnalyticsConstants.concatenator + index;
	};
	tracker.addEvent(clickSportsMenu);
	// - 2.1 ClickSportsMenu
	var clickSportsMenuSub1 = new AnalyticsClickEvent("clickSportsMenuSub1", tracker.defaultEvent());
	clickSportsMenuSub1.options.action="ClickSportsMenu";
	clickSportsMenuSub1.domContainer =  ".sport-details";
	clickSportsMenuSub1.domElement ="a.thirdLevelLink";

	clickSportsMenuSub1.getLabel = function($element){
		var index = this.getElementPosition($element);
		var sportName = clearText($element.text());
		return sportName+AnalyticsConstants.concatenator + index;
	};
	tracker.addEvent(clickSportsMenuSub1);
	
	// - 2.2 ClickSportsMenu	
	var clickSportsMenuSub2 = new AnalyticsClickEvent("clickSportsMenuSub2", tracker.defaultEvent());
	clickSportsMenuSub2.options.action="ClickSportsMenu";
	clickSportsMenuSub2.domContainer =  ".sport-details";
	clickSportsMenuSub2.domElement ="a.thirdLevelCategory";

	clickSportsMenuSub2.getLabel = function($element){
		var index = this.getElementPosition($element);
		var subCategory = clearText($element.text());
		var categoryname = clearText($element.closest(".links-group").find("a.title.thirdLevelLink").text());
		return categoryname+AnalyticsConstants.concatenator+ subCategory+AnalyticsConstants.concatenator + index;

	};
	tracker.addEvent(clickSportsMenuSub2);
	
	// - 2.3 ClickSportsMenu
	var clickSportsMenuAbout = new AnalyticsClickEvent("clickSportsMenuAbout", tracker.defaultEvent());
	clickSportsMenuAbout.options.action="ClickSportsMenu";
	clickSportsMenuAbout.domContainer =  ".sport-details";
	clickSportsMenuAbout.domElement ="a.allAbout";

	clickSportsMenuAbout.getLabel = function($element){
		var sportName = clearText($("li[role=presentation].active").text());
		return "all" +AnalyticsConstants.concatenator + sportName;

	};	
	tracker.addEvent(clickSportsMenuAbout);
	
	// - 3 ClickSecondaryMenu
	var clickSecondaryMenu = new AnalyticsClickEvent("clickSecondaryMenu", tracker.defaultEvent());
	clickSecondaryMenu.options.action="ClickSecondaryMenu";
	clickSecondaryMenu.domContainer =  ".menu-categories";
	clickSecondaryMenu.domElement =".submenu-categories";

	clickSecondaryMenu.getLabel = function($element){
		var index = this.getElementPosition($element);
		var categoryname = clearText($element.text());
		return categoryname+AnalyticsConstants.concatenator + index;

	};
	tracker.addEvent(clickSecondaryMenu);
	
	// - 3.1 ClickSecondaryMenu	
	var clickSecondaryMenuSub1 = new AnalyticsClickEvent("clickSecondaryMenuSub1", tracker.defaultEvent());
	clickSecondaryMenuSub1.options.action="ClickSecondaryMenu";
	clickSecondaryMenuSub1.domContainer =  ".category-details";
	clickSecondaryMenuSub1.domElement ="a.secondLevelCategory, .title.thirdLevelLink";    

	clickSecondaryMenuSub1.getLabel = function($element){
		var index = this.getElementPosition($element);
		var categoryname = clearText($element.text());
		return categoryname+AnalyticsConstants.concatenator+ index;

	};
	tracker.addEvent(clickSecondaryMenuSub1);

	// - 3.2 ClickSecondaryMenu	
	var clickSecondaryMenuSub2 = new AnalyticsClickEvent("clickSecondaryMenuSub2", tracker.defaultEvent());
	clickSecondaryMenuSub2.options.action="ClickSecondaryMenu";
	clickSecondaryMenuSub2.domContainer = ".category-details";
	clickSecondaryMenuSub2.domElement ="a.thirdLevelCategory";

	clickSecondaryMenuSub2.getLabel = function($element){
		var index = this.getElementPosition($element);
		var subCategory = clearText($element.text());
		var categoryname = $element.closest(".links-group").find("a.title").html().replace(/(\r\n|\n|\r)/gm,"");
		return categoryname+AnalyticsConstants.concatenator+ subCategory+AnalyticsConstants.concatenator + index;


	};
	tracker.addEvent(clickSecondaryMenuSub2);
	
	// - 3.3 ClickSecondaryMenu
	var clickSecondaryMenuAllAbout = new AnalyticsClickEvent("clickSecondaryMenuAllAbout", tracker.defaultEvent());
	clickSecondaryMenuAllAbout.options.action="ClickSecondaryMenu";
	clickSecondaryMenuAllAbout.domContainer =  ".category-details";
	clickSecondaryMenuAllAbout.domElement ="a.allAbout";

	clickSecondaryMenuAllAbout.getLabel = function($element){
		var categoryName = clearText($("li[role=presentation].active").text());
		return "all" +AnalyticsConstants.concatenator+ categoryName;

	};	
	tracker.addEvent(clickSecondaryMenuAllAbout);
	
	
	// - 1.2 +2.3 + 3.4 CloseMainMenu
	var closeMainMenu = new AnalyticsClickEvent("closeMainMenu", tracker.defaultEvent());
	closeMainMenu.options.action="CloseMainMenu";
	closeMainMenu.domContainer =   ".menu-close-button";
	closeMainMenu.getLabel = function($element){
		var activeMenu = $("li[role=presentation].active");
		if(activeMenu.hasClass("sports-75"))
			return "sports-75";
		if(activeMenu.hasClass("sport"))
			return "sport";  
		if(activeMenu.hasClass("category"))
			return "category";  
	};
	tracker.addEvent(closeMainMenu);

	// - 4.1 HamburgerMenu
	var hamburgerMenu = new AnalyticsClickEvent("hamburgerMenu", tracker.defaultEvent());
	hamburgerMenu.options.action="HamburgerMenu";
	hamburgerMenu.options.label = window.location.href ;
	hamburgerMenu.domContainer =  ".menu-toggler";
	hamburgerMenu.stopEvent = function($element, data, jqEvent, jqData) {
		if (jqEvent.which) return false;
		return true;
	};
	tracker.addEvent(hamburgerMenu);
	
	// - 4.2 Click-BreadCrumb
	var clickBreadCrumb = new AnalyticsClickEvent("clickBreadCrumb", tracker.defaultEvent());
	clickBreadCrumb.options.action="Click-BreadCrumb";
	clickBreadCrumb.domContainer =  ".breadcrumbs";
	clickBreadCrumb.domElement ="li a";

	clickBreadCrumb.getLabel = function($element){
		var index = this.getElementPosition($element);
		var category = clearText($element.attr('title'));
		return index +AnalyticsConstants.concatenator+ category;
	};	
	tracker.addEvent(clickBreadCrumb);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

// -- INIT
$(function() {
	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.commons.navigation.name);
});
(function($) {
	'use strict';

	var fwk = CUBE.Analytics || {};

	// TRACKER 'SEARCH'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.commons.search);
	var storage = AnalyticsConstants.ref.pendingSearch;
	var sep = AnalyticsConstants.separator;
	
	if (tc_vars.env_template == 'list' || tc_vars.env_template == 'internal_search')
		localStorage.removeItem(storage);

	// SEARCH - NO RESULT
	var noresultEvent = new AnalyticsConditionalEvent("noresultEvent", tracker.defaultEvent());
	noresultEvent.options.action = "Search-noresult";
	noresultEvent.condition = "tc_vars['env_template'] == 'internal_search' && tc_vars.search_results_number == '0'";
	noresultEvent.getLabel = function() {
		return tc_vars.search_keyword;
	};
	noresultEvent.postAction(function() { localStorage.removeItem(storage); });
	tracker.addEvent(noresultEvent);

	// SEARCH - COUNT RESULT
	var resultsCountEvent = new AnalyticsConditionalEvent("resultsCountEvent", tracker.defaultEvent());
	resultsCountEvent.options.action = "Search-result";
	resultsCountEvent.condition = "tc_vars['env_template'] == 'internal_search' && tc_vars.search_results_number != '0'";
	resultsCountEvent.getLabel = function() {
		return tc_vars.search_keyword + sep + tc_vars.search_results_number;
	};
	resultsCountEvent.postAction(function() { localStorage.removeItem(storage); });
	tracker.addEvent(resultsCountEvent);

	// AUTO REDIRECTION Product
	var productReferenceRedirectionEvent = new AnalyticsConditionalEvent("productReferenceRedirectionEvent", tracker.defaultEvent());
	productReferenceRedirectionEvent.options.action = "ProductReferenceRedirection";
	productReferenceRedirectionEvent.condition = "tc_vars['env_template'] == 'product' && localStorage.getItem(AnalyticsConstants.ref.pendingSearch) != null && localStorage.getItem(AnalyticsConstants.ref.pendingSearch) != undefined";
	productReferenceRedirectionEvent.getLabel = function() {
		var _curSearch = localStorage.getItem(storage);
		var _modelId = CUBE.Analytics.utils.productpage.getSelectedModelId();
		return _curSearch + sep + _modelId;
	};
	productReferenceRedirectionEvent.postAction(function() { localStorage.removeItem(storage); });
	productReferenceRedirectionEvent.stopEvent = function() { return this.getLabel().indexOf('undefined') > -1; };
	tracker.addEvent(productReferenceRedirectionEvent);

	// SAVE SEARCH - 'Empty' event : used only to store the keyword in localstorage
	var searchEvent = new AnalyticsTriggerEvent("searchEvent", tracker.defaultEvent());
	searchEvent.domElement = window;
	searchEvent.trigger = 'beforeunload';
	searchEvent.stopEvent = function($element) {
		if (getKeyword() !== "") saveKeyword();
		return true;
	};
	tracker.addEvent(searchEvent);

	// SEARCH - Product Suggestion
	var productSuggestionEvent = new AnalyticsClickEvent("productSuggestionEvent", tracker.defaultEvent());
	productSuggestionEvent.options.action = "ProductSuggestion";
	productSuggestionEvent.domContainer = "#header .tt-menu";
	productSuggestionEvent.domElement = ".tt-dataset-products a.tt-suggestion";
	productSuggestionEvent.getLabel = function($element) {
		if ($element.data("id") !== "") {
			return searchedKeyword + sep + $element.data("id");
		} else {
			return searchedKeyword + sep + $element.attr('href').split('/R-p-')[1];
		}
	};
	tracker.addEvent(productSuggestionEvent);

	// SEARCH - Category Suggestion
	var categorieSuggestionEvent = new AnalyticsClickEvent("categorieSuggestionEvent", tracker.defaultEvent());
	categorieSuggestionEvent.options.action = "CategorySuggestion";
	categorieSuggestionEvent.domContainer = "#header .tt-menu";
	categorieSuggestionEvent.domElement = ".tt-dataset-categories a.tt-suggestion";
	categorieSuggestionEvent.getLabel = function($element) {
		return searchedKeyword + sep + $element.attr('href');
	};
	tracker.addEvent(categorieSuggestionEvent);

	// SEARCH - Search Suggestion
	var suggestionEvent = new AnalyticsClickEvent("suggestionEvent", tracker.defaultEvent());
	suggestionEvent.options.action = "Suggestion";
	suggestionEvent.domContainer = "#search-result-top";
	suggestionEvent.domElement = ".categories a";
	suggestionEvent.getLabel = function($element) {
		var _href = $element.attr('href');
		var _didYouMean = _href.indexOf('search') > -1 ? sep + 'didyoumean' : '';
		
		return tc_vars.search_keyword + _didYouMean + sep + fwk.utils.getInfoNavFromURL(_href, false);
	};
	tracker.addEvent(suggestionEvent);
	
	
	CUBE.Analytics.trackers.add(tracker);

	// UTILS METHODS
	var getKeyword = function() { return $('#search-autocomplete').val(); };
	var saveKeyword = function() { localStorage.setItem(storage, getKeyword()); };
	
	// Save the typed keyword
	var searchedKeyword = '';
	$('#search-autocomplete').on('keyup', function() { searchedKeyword = $(this).val(); });

})(jQuery);

// -- INIT
$(function() {
	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.commons.search.name);
});
(function($) {

	// TRACKER 'SUGGESTIONS'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.suggestions.crosssell);
	var sep = AnalyticsConstants.separatorST;
	var fwk = CUBE.Analytics;
	
	var containerCrossSellProduct = '#often-bought-list .plv2-element';

	// CrossSell - Move to cart
	var eventAddToCartCrossSell = new AnalyticsEvent('virtualEventAddToCartCrossSell', tracker.defaultEvent());
	tracker.addEvent(eventAddToCartCrossSell);

	/*
	 * CROSSSELL PRODUCT
	 */
	var eventCrossSellProduct = new AnalyticsClickEvent('eventCrosssellSuggestions', tracker.defaultEvent());
	eventCrossSellProduct.options.action = 'PositionClick';
	eventCrossSellProduct.domContainer = containerCrossSellProduct;
	eventCrossSellProduct.domElement = '.plv2-el__images a';
	eventCrossSellProduct.getLabel = function($element) {
		var product = $element.closest('.plv2-element');
		var index = product.data("slick-index") + 1;
		return getLabel(product, index);
	};
	eventCrossSellProduct.getValue = getValue;
	tracker.addEvent(eventCrossSellProduct);
	
	CUBE.Analytics.trackers.add(tracker);

	var getLabel = function(element, index) {
		var model = fwk.utils.productpage.getCrossSellModel(element.data("productid"), 'SM');
		return AnalyticsConstants.slick.defaultValuePosition + index + sep + model.name + sep + model.id;
	};
	var getValue = function(element) {
		var model = fwk.utils.productpage.getCrossSellModel(element.data("productid"), 'SM');
		return model.price;
	};
	
	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').hasClass('our-suggestions-page')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.suggestions.crosssell.name);
	});
}
(function($) {

	// TRACKER 'MENU / CUSTOMER'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.menu);

	// MyDashboard
	var myDashboard = new AnalyticsClickEvent('menu-myDashboard', tracker.defaultEvent());
	myDashboard.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[href$='account/dashboard'])";
	myDashboard.options.action = 'MyDashboard';
	tracker.addEvent(myDashboard);

	// myProfile
	var myProfile = new AnalyticsClickEvent('menu-myProfile', tracker.defaultEvent());
	myProfile.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[href$='account/customer-details'])";
	myProfile.options.action = 'MyProfile';
	tracker.addEvent(myProfile);

	// myPurchase
	var myPurchase = new AnalyticsClickEvent('menu-myPurchase', tracker.defaultEvent());
	myPurchase.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[href$='account/myPurchase'])";
	myPurchase.options.action = 'MyPurchase';
	tracker.addEvent(myPurchase);

	// myRefunds
	var myRefunds = new AnalyticsClickEvent('menu-myRefunds', tracker.defaultEvent());
	myRefunds.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[href$='account/myRefunds'])";
	myRefunds.options.action = 'myRefunds';
	tracker.addEvent(myRefunds);
	
	// myReturns
	var myReturns = new AnalyticsClickEvent('menu-myReturns', tracker.defaultEvent());
	myReturns.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[href$='account/myPurchase/listReturns'])";
	myReturns.options.action = 'MyReturns';
	tracker.addEvent(myReturns);

	// myPreferences
	var myPreferences = new AnalyticsClickEvent('menu-myPreferences', tracker.defaultEvent());
	myPreferences.domElement = "#dashboard-account-nav .account-navigation div.panel:has(div[data-target='#preferences'])";
	myPreferences.options.action = 'MyPreferences';
	tracker.addEvent(myPreferences);
	
	// ... subMenu - myPreferences ...
	
	// myAddressBook
	var myAddressBook = new AnalyticsClickEvent('menu-myAddressBook', tracker.defaultEvent());
	myAddressBook.domElement = "#dashboard-account-nav #preferences li:has(a[href$='account/addressBook'])";
	myAddressBook.options.action = 'MyAddressBook';
	tracker.addEvent(myAddressBook);

	// myStore
	var myStore = new AnalyticsClickEvent('menu-myStore', tracker.defaultEvent());
	myStore.domElement = "#dashboard-account-nav #preferences li:has(a[href$='account/mystore'])";
	myStore.options.action = 'MyStore';
	tracker.addEvent(myStore);

	// mySubscription
	var mySubscription = new AnalyticsClickEvent('menu-mySubscription', tracker.defaultEvent());
	mySubscription.domElement = "#dashboard-account-nav #preferences li:has(a[href$='account/mysubscriptions'])";
	mySubscription.options.action = 'MySubscription';
	tracker.addEvent(mySubscription);

	// myLanguage
	var myLanguage = new AnalyticsClickEvent('menu-myLanguage', tracker.defaultEvent());
	myLanguage.domElement = "#dashboard-account-nav #preferences li:has(a[href$='account/myLanguage'])";
	myLanguage.options.action = 'MyLanguage';
	tracker.addEvent(myLanguage);
	
	// myMeansOfPayment
	var myMeansOfPayment = new AnalyticsClickEvent('menu-myMeansOfPayment', tracker.defaultEvent());
	myMeansOfPayment.domElement = "#dashboard-account-nav #preferences li:has(a[href$='account/myMeansOfPayment'])";
	myMeansOfPayment.options.action = 'MyMeansOfPayment';
	tracker.addEvent(myMeansOfPayment);
	
	// ... end subMenu ...

	// myLoyalty
	var myLoyalty = new AnalyticsClickEvent('menu-myLoyalty', tracker.defaultEvent());
	myLoyalty.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[href$='account/loyalty'])";
	myLoyalty.options.action = 'MyLoyalty';
	tracker.addEvent(myLoyalty);

	// logout
	var logout = new AnalyticsClickEvent('menu-logout', tracker.defaultEvent());
	logout.domElement = "#dashboard-account-nav .account-navigation div.panel:has(a[class$='logout'])";
	logout.options.action = 'Logout';
	logout.options.label = '';
	tracker.addEvent(logout);

	// confirmLogout
	var confirmLogout = new AnalyticsClickEvent('menu-confirmLogout', tracker.defaultEvent());
	confirmLogout.domElement = '#logout-confirmation a';
	confirmLogout.options.action = 'ConfirmLogout';
	confirmLogout.options.label = '';
	tracker.addEvent(confirmLogout);


	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('body').hasClass('dashboard')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.menu.name);
	});
}
(function($) {

	// TRACKER 'DASHBOARD'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.myDashboard);
	var classProductViewed = 'viewed';
	
	// ClickMenu
	/* => Moved to menu-tracker.js
	var clickMenu = new AnalyticsClickEvent('clickMenu', tracker.defaultEvent());
	clickMenu.domElement = '#dashboard-account-nav .account-navigation div.panel:nth-child(1)';
	clickMenu.options.label = 'ClickMenu';
	tracker.addEvent(clickMenu);
	*/

	// MyProfile
	var myProfile = new AnalyticsClickEvent('myProfile', tracker.defaultEvent());
	myProfile.domElement = 'div[data-tracking="card-my-profile"] .dash-card-footer';
	myProfile.options.label = 'MyProfile';
	tracker.addEvent(myProfile);

	// MyOrders
	var myOrders = new AnalyticsClickEvent('myOrders', tracker.defaultEvent());
	myOrders.domElement = 'div[data-tracking="card-my-order"] .dash-card-footer';
	myOrders.options.label = 'MyOrders';
	tracker.addEvent(myOrders);

	// Return
	var myReturn = new AnalyticsClickEvent('myReturn', tracker.defaultEvent());
	myReturn.domElement = 'div[data-tracking="card-my-returns"] .dash-card-footer';
	myReturn.options.label = 'Return';
	tracker.addEvent(myReturn);

	// Store
	var myStore = new AnalyticsClickEvent('myStore', tracker.defaultEvent());
	myStore.domElement = 'div[data-tracking="card-my-store"] .dash-card-footer';
	myStore.options.label = 'Store';
	tracker.addEvent(myStore);

	// Loyalty
	var myLoyalty = new AnalyticsClickEvent('myLoyalty', tracker.defaultEvent());
	myLoyalty.domElement = 'div[data-tracking="card-my-loyalty"] .dash-card-footer';
	myLoyalty.options.label = 'Loyalty';
	tracker.addEvent(myLoyalty);

	// Opinion
	var myOpinion = new AnalyticsClickEvent('myOpinion', tracker.defaultEvent());
	myOpinion.domElement = 'div[data-tracking="card-my-opinion"] .dash-card-footer';
	myOpinion.options.label = 'Opinion';
	tracker.addEvent(myOpinion);

	// - DOTS LVP
	var eventDotsLVP = new AnalyticsSlickEvent('dotsLVP', new AnalyticsTracker(AnalyticsConstants.trackers.customer.lvp).defaultEvent());
	eventDotsLVP.domContainer = '.dash-card.last-products .slick-slider';
	eventDotsLVP.domElement = '.slide';
	eventDotsLVP.options.action = "DashboardLvpDots";
	eventDotsLVP.trackDots();
	eventDotsLVP.postAction(function($element) {
		var indexLVP = $element.parent().find($element).index();
		if (indexLVP > 0) {
			sendImpressionLVP(indexLVP);
		}
	});

	var sendImpressionLVP = function(indexLVP) {
		$('.slick-current .lvp-element').each(function() { 
    		setProductLVPAsViewed(indexLVP, $(this));
    	});
    };
	
	var setProductLVPAsViewed = function(indexLVP, $product) {
		if (CUBE.Analytics.utils.isVisible($product) && !$product.hasClass(classProductViewed)) {
			var model = CUBE.Analytics.utils.perso.getLVPModel($product);
			CUBE.Analytics.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
		}
	};
	
	tracker.addEvent(eventDotsLVP);
	
	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('body').hasClass('dashboard')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.myDashboard.name);
	});
}
(function($) {

	if(!$('body').hasClass('login-page'))
		return;
	// TRACKER 'LOYALTY'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.account.login);

	// Queued 'analyticsLoginEvent' (will be sent from loginModule.js)
	var analyticsLoginEvent = new AnalyticsQueueEvent('analyticsLoginEvent', tracker.defaultEvent());
	analyticsLoginEvent.trigger = 'submit';
	analyticsLoginEvent.domElement = '#loginForm';
	analyticsLoginEvent.options.action = 'Login';
	analyticsLoginEvent.options.label = '';
	tracker.addEvent(analyticsLoginEvent);

	// Forgotten Password
	var loginForgottenPassword = new AnalyticsClickEvent('loginForgottenPassword', tracker.defaultEvent());
	loginForgottenPassword.domElement = '#linkLostPassword';
	loginForgottenPassword.options.action = 'ForgetPassword';
	loginForgottenPassword.options.label = 'Click';
	tracker.addEvent(loginForgottenPassword);

	// UN/CheckRememberMe
	var loginBoxRememberMe = new AnalyticsTriggerEvent('loginBoxRememberMe', tracker.defaultEvent());
	loginBoxRememberMe.trigger = 'change';
	loginBoxRememberMe.domElement = '#autoLogin';
	loginBoxRememberMe.getAction = function($element) {
		if ($element.is(':checked')) return 'CheckRememberMe';
		else return 'UncheckRememberMe';
	};
	loginBoxRememberMe.options.label = '';
	tracker.addEvent(loginBoxRememberMe);

	// Create Account With/Without ward
	var loginCreateAccount = new AnalyticsClickEvent('loginCreateAccount', tracker.defaultEvent());
	loginCreateAccount.domContainer = '.loyalty-bool';
	loginCreateAccount.domElement = '.cta';
	loginCreateAccount.getAction = function($element) {
		if ($element.attr('href').indexOf('loyalty') > -1) return 'CreateAccountWithCard';
		else return 'CreateAccountWithoutCard';
	};
	loginCreateAccount.options.label = '';
	tracker.addEvent(loginCreateAccount);


	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

$(function(){
	if($('body').hasClass('login-page')){
		// TODO : No event to init
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.account.login.name);
	}
});
(function($) {

	if($('#main-container #lost-password').length === 0)
		return;

		console.log('On charge les tracker lost password ....');

	// TRACKER 'LOST PASSWORD'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.account.lostPassword);

	// I click on continue / ...
	var lostPasswordClickContinue = new AnalyticsClickEvent('lostPasswordClickContinue', tracker.defaultEvent());
	lostPasswordClickContinue.domContainer = '#lostPasswordForm';
	lostPasswordClickContinue.domElement = '#lostPasswordButton';
	lostPasswordClickContinue.options.label = 'Click Continue';
	tracker.addEvent(lostPasswordClickContinue);
	// ... back
	var lostPasswordClickBack = new AnalyticsClickEvent('lostPasswordClickBack', tracker.defaultEvent());
	lostPasswordClickBack.domContainer = '#lostPasswordForm';
	lostPasswordClickBack.domElement = '#cancelLostPsw';
	lostPasswordClickBack.options.label = 'Click Back';
	tracker.addEvent(lostPasswordClickBack);

	// I choose the method
	var lostPasswordChooseMethod = new AnalyticsClickEvent('lostPasswordChooseMethod', tracker.defaultEvent());
	lostPasswordChooseMethod.domContainer = '#forgottenPasswordHow';
	lostPasswordChooseMethod.domElement = '.radio label';
	lostPasswordChooseMethod.getLabel = function($element) {
		return 'Select Method ' + $element.find('input[type="radio"]').val();
	};
	tracker.addEvent(lostPasswordChooseMethod);

	// I validate the method
	var lostPasswordValidateMethod = new AnalyticsClickEvent('lostPasswordValidateMethod', tracker.defaultEvent());
	lostPasswordValidateMethod.domContainer = '#forgottenPasswordHow';
	lostPasswordValidateMethod.domElement = '#chooseButton';
	lostPasswordValidateMethod.getLabel = function($element) {
		var selectedMethod = $('[name="optionsRadios"]:checked').val();
		return 'Confirm With Method ' + selectedMethod;
	};
	tracker.addEvent(lostPasswordValidateMethod);

	// I ask for a new code
	var lostPasswordResendCode = new AnalyticsClickEvent('lostPasswordResendCode', tracker.defaultEvent());
	lostPasswordResendCode.domContainer = '#verification-code-form';
	lostPasswordResendCode.domElement = '#sendSmsAgainResetPsw';
	lostPasswordResendCode.options.label = 'Resend Code';
	tracker.addEvent(lostPasswordResendCode);

	// I validate confirmation code / ...
	var lostPasswordValidateConfirmationCode = new AnalyticsClickEvent('lostPasswordValidateConfirmationCode', tracker.defaultEvent());
	lostPasswordValidateConfirmationCode.domContainer = '#verification-code-form';
	lostPasswordValidateConfirmationCode.domElement = '#validateCode';
	lostPasswordValidateConfirmationCode.options.label = 'Validate Code';
	tracker.addEvent(lostPasswordValidateConfirmationCode);
	// ... / back
	var lostPasswordValidateConfirmationCodeBack = new AnalyticsClickEvent('lostPasswordValidateConfirmationCodeBack', tracker.defaultEvent());
	lostPasswordValidateConfirmationCodeBack.domContainer = '#verification-code-form';
	lostPasswordValidateConfirmationCodeBack.domElement = '#cancelValidateCode';
	lostPasswordValidateConfirmationCodeBack.options.label = 'Back To Select Method';
	tracker.addEvent(lostPasswordValidateConfirmationCodeBack);

	// I validate my password reset
	var lostPasswordConfirmResetPassword = new AnalyticsClickEvent('lostPasswordConfirmResetPassword', tracker.defaultEvent());
	lostPasswordConfirmResetPassword.domContainer = '#resetPasswordForm';
	lostPasswordConfirmResetPassword.domElement = '#resetPswWithCode';
	lostPasswordConfirmResetPassword.options.label = 'Validate New Password';
	tracker.addEvent(lostPasswordConfirmResetPassword);
	

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

$(function(){
	if($('#main-container #lost-password').length > 0)
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.account.lostPassword.name);
});
(function($) {

	// TRACKER 'MY PROFILE'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.profile);
	
	/*
	 * CUSTOMER DASHBOARD - MY PROFILE
	 */

	/*
	 * -- LOGIN + MOBILE
	 */
	// editLogin
	var editLogin = new AnalyticsClickEvent('editLogin', tracker.defaultEvent());
	editLogin.domElement = '#editLogin';
	editLogin.options.label = 'Login';
	tracker.addEvent(editLogin);
	
	// saveLogin
	var saveLogin = new AnalyticsQueueEvent('saveLogin', tracker.defaultEvent());
	saveLogin.trigger = 'click';
	saveLogin.domElement = '#sumbitUpdateLoginForm';
	saveLogin.options.label = 'Login Save';
	tracker.addEvent(saveLogin);

	// backLogin
	var backLogin = new AnalyticsClickEvent('backLogin', tracker.defaultEvent());
	backLogin.domElement = '#cancelLoginForm';
	backLogin.options.label = 'Login Back';
	tracker.addEvent(backLogin);
	
	// mobileSendCode
	var mobileSendCode = new AnalyticsClickEvent('mobileSendCode', tracker.defaultEvent());
	mobileSendCode.domElement = '.sendVerificationCodeUpdateLogin';
	mobileSendCode.options.label = 'PhoneModify Send Code';
	tracker.addEvent(mobileSendCode);
	
	// mobileResendCode
	var mobileResendCode = new AnalyticsClickEvent('mobileResendCode', tracker.defaultEvent());
	mobileResendCode.trigger = 'click';
	mobileResendCode.domElement = '.resendCode';
	mobileResendCode.options.label = 'PhoneModify Resend Code';
	tracker.addEvent(mobileResendCode);

	
	/*
	 * -- PASSWORD
	 */
	// editPassword
	var editPassword = new AnalyticsClickEvent('editPassword', tracker.defaultEvent());
	editPassword.domElement = '#editPassword';
	editPassword.options.label = 'Password';
	tracker.addEvent(editPassword);
	
	// savePassword
	var savePassword = new AnalyticsQueueEvent('savePassword', tracker.defaultEvent());
	savePassword.trigger = 'click';
	savePassword.domElement = '#updatePasswordButton';
	savePassword.options.label = 'Password Save';
	tracker.addEvent(savePassword);

	// backPassword
	var backPassword = new AnalyticsClickEvent('backPassword', tracker.defaultEvent());
	backPassword.domElement = '#cancelPasswordForm';
	backPassword.options.label = 'Password Back';
	tracker.addEvent(backPassword);
	
	/*
	 * -- HOME ADDRESS
	 */
	// editHomeAddress
	var editHomeAddress = new AnalyticsClickEvent('editHomeAddress', tracker.defaultEvent());
	editHomeAddress.domElement = '#editHomeAddress';
	editHomeAddress.options.label = 'HomeAddress';
	tracker.addEvent(editHomeAddress);
	
	// saveHomeAddress
	var saveHomeAddress = new AnalyticsQueueEvent('saveHomeAddress', tracker.defaultEvent());
	saveHomeAddress.trigger = 'click';
	saveHomeAddress.domElement = '#updateHomeAddressButton';
	saveHomeAddress.options.label = 'HomeAddress Save';
	tracker.addEvent(saveHomeAddress);

	// backHomeAddress
	var backHomeAddress = new AnalyticsClickEvent('backHomeAddress', tracker.defaultEvent());
	backHomeAddress.domElement = '#cancelHomeAddressForm';
	backHomeAddress.options.label = 'HomeAddress Back';
	tracker.addEvent(backHomeAddress);
	

	/*
	 * -- PERSONAL INFORMATION
	 */
	// editInfoPerso
	var editInfoPerso = new AnalyticsClickEvent('editInfoPerso', tracker.defaultEvent());
	editInfoPerso.domElement = '#editPersonalData';
	editInfoPerso.options.label = 'PersonalData';
	tracker.addEvent(editInfoPerso);
	
	// saveInfoPerso
	var saveInfoPerso = new AnalyticsQueueEvent('saveInfoPerso', tracker.defaultEvent());
	saveInfoPerso.trigger = 'click';
	saveInfoPerso.domElement = '#savePersonalData';
	saveInfoPerso.options.label = 'PersonalData Save';
	tracker.addEvent(saveInfoPerso);

	// backInfoPerso
	var backInfoPerso = new AnalyticsClickEvent('backInfoPerso', tracker.defaultEvent());
	backInfoPerso.domElement = '#cancelPersonalDataForm';
	backInfoPerso.options.label = 'PersonalData Back';
	tracker.addEvent(backInfoPerso);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('.ua-container').hasClass('profil')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.profile.name);
	});
}
(function($) {

	// TRACKER 'MY PURCHASES'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.purchases);

	// changeFilter
	var changeFilter = new AnalyticsTriggerEvent('menu-changeFilter', tracker.defaultEvent());
	changeFilter.trigger = 'change';
	changeFilter.domElement = '#order-filter';
	changeFilter.getLabel = function($element) {
		var val = $element.val();
		if (val === "current") return 'CurrentOrder';
		if (val === "cancelled") return 'CancelledOrder';
		if (val === "complete") return 'CompleteOrder';
		if (val === "all") return 'AllOrder';
		return 'ChangeOrderFilter';
	};
	tracker.addEvent(changeFilter);
	
	
	// -----
	// Main View :
	
	// purchasesMakeReturn
	var purchasesMakeReturn = new AnalyticsClickEvent('purchasesMakeReturn', tracker.defaultEvent());
	purchasesMakeReturn.domElement = '[data-tracking="return"]';
	purchasesMakeReturn.options.label = 'Return';
	tracker.addEvent(purchasesMakeReturn);

	// purchasesDetails
	var purchasesDetails = new AnalyticsClickEvent('purchasesDetails', tracker.defaultEvent());
	purchasesDetails.domElement = '[data-tracking="details"]';
	purchasesDetails.options.label = 'Detail';
	tracker.addEvent(purchasesDetails);
	
	// purchasesCancel
	var purchasesCancel = new AnalyticsClickEvent('purchasesCancel', tracker.defaultEvent());
	purchasesCancel.domElement = '[data-tracking="cancel"]';
	purchasesCancel.options.label = 'Cancel';
	tracker.addEvent(purchasesCancel);
	
	// purchasesPay
	var purchasesPay = new AnalyticsClickEvent('purchasesPay', tracker.defaultEvent());
	purchasesPay.domElement = '[data-tracking="payment"]';
	purchasesPay.options.label = 'Pay';
	tracker.addEvent(purchasesPay);


	// -----
	// Return view :
	
	// Return-back
	var purchasesReturnBack = new AnalyticsClickEvent('purchasesReturnBack', tracker.defaultEvent());
	purchasesReturnBack.domElement = '.return-info .row a.cta.grey';
	purchasesReturnBack.options.label = 'ViewReturnBack';
	tracker.addEvent(purchasesReturnBack);
	
	// Return-validate
	var purchasesReturnValidate = new AnalyticsClickEvent('purchasesReturnValidate', tracker.defaultEvent());
	purchasesReturnValidate.domElement = '#validateReturnButton';
	purchasesReturnValidate.options.label = 'View Return Validate';
	tracker.addEvent(purchasesReturnValidate);
	
	// Return-back
	var purchasesReturnOtherStore = new AnalyticsClickEvent('purchasesReturnOtherStore', tracker.defaultEvent());
	purchasesReturnOtherStore.domElement = '.return-info #selectStore';
	purchasesReturnOtherStore.options.label = 'ViewReturnSelectStore';
	tracker.addEvent(purchasesReturnOtherStore);
	

	// -----
	// Details view :
	
	// Details-back
	var purchasesDetailsBack = new AnalyticsClickEvent('purchasesDetailsBack', tracker.defaultEvent());
	purchasesDetailsBack.domElement = '#my-purchase-details .address-infos #backButton';
	purchasesDetailsBack.options.label = 'View Details Back';
	tracker.addEvent(purchasesDetailsBack);
	
	// Details-cancelOrder
	var purchasesDetailsCancel = new AnalyticsClickEvent('purchasesDetailsCancel', tracker.defaultEvent());
	purchasesDetailsCancel.domElement = '#my-purchase-details a#order-cancellation';
	purchasesDetailsCancel.options.label = 'View Details CancelOrder';
	tracker.addEvent(purchasesDetailsCancel);
	// Details-returnOrder
	var purchasesDetailsReturn = new AnalyticsClickEvent('purchasesDetailsReturn', tracker.defaultEvent());
	purchasesDetailsReturn.domElement = '#my-purchase-details a[data-tracking="btn-return"]';
	purchasesDetailsReturn.options.label = 'View Details Return';
	tracker.addEvent(purchasesDetailsReturn);
	// Details-payOrder
	var purchasesDetailsPayment = new AnalyticsClickEvent('purchasesDetailsPayment', tracker.defaultEvent());
	purchasesDetailsPayment.domElement = '#my-purchase-details a[data-tracking="btn-payment"]';
	purchasesDetailsPayment.options.label = 'View Details Payment';
	tracker.addEvent(purchasesDetailsPayment);
	
	
	// Cancel view :
	
	
	
	
	
	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('.ua-container').hasClass('purchases')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.purchases.name);
	});
}
(function($) {

	// TRACKER 'LOYALTY'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.loyalty);


	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('.ua-container').hasClass('loyalty')){
	$(function(){
	// TODO : No event to init
    	//CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.loyalty.name);
	});
}
(function($) {

	// TRACKER 'CUSTOMER-ADDRESS-BOOK'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.addressBook);

	// - ClickMenu ==> MOVED TO 'menu-tracker.js'
	//var clickMenu = new AnalyticsClickEvent('clickMenu', tracker.defaultEvent());
	//clickMenu.domElement = '#preferences > ul > li:first-child';
	//clickMenu.options.label = 'ClickMenu';
	//tracker.addEvent(clickMenu);

	
	// - NewAdressBookClick
	var newAdressBookClick = new AnalyticsClickEvent('newAdressBookClick', tracker.defaultEvent());
	newAdressBookClick.domElement = '#address-book-list > div.options-nav > a';
	newAdressBookClick.options.label = 'NewAdressBookClick';
	newAdressBookClick.postAction(function(){
		sessionStorage.setItem(AnalyticsConstants.ref.addrBookEdit, false);
	});
	tracker.addEvent(newAdressBookClick);

	// - ModifiyAdressBookClick
	var modifiyAdressBookClick = new AnalyticsClickEvent('modifiyAdressBookClick', tracker.defaultEvent());
	modifiyAdressBookClick.domElement = '#address-book-list-table div.address-container a.modify-item';
	modifiyAdressBookClick.options.label = 'ModifiyAdressBookClick';
	modifiyAdressBookClick.postAction(function(){
		sessionStorage.setItem(AnalyticsConstants.ref.addrBookEdit, true);
	});
	tracker.addEvent(modifiyAdressBookClick);


	// - NEW/MODIFY AdressBookValidation
	var adressBookValidation = new AnalyticsQueueEvent('adressBookValidation', tracker.defaultEvent());
	adressBookValidation.trigger = 'click';
	adressBookValidation.domElement = '#add-shipping-btn';
	adressBookValidation.getLabel = function() {
		if (sessionStorage.getItem(AnalyticsConstants.ref.addrBookEdit) &&
				JSON.parse(sessionStorage.getItem(AnalyticsConstants.ref.addrBookEdit)) === true)
			return 'ModifiyAdressBookValidation';
		else
			return 'NewAdressBookValidation';
	};
	adressBookValidation.postAction(function(){ sessionStorage.removeItem(AnalyticsConstants.ref.addrBookEdit); });
	tracker.addEvent(adressBookValidation);

	
	// - NEW/MODIFYAdressBookBack
	var modifiyAdressBookBack = new AnalyticsClickEvent('modifiyAdressBookBack', tracker.defaultEvent());
	modifiyAdressBookBack.domElement = '#back-address-book-btn';
	modifiyAdressBookBack.getLabel = function() {
		if (sessionStorage.getItem(AnalyticsConstants.ref.addrBookEdit) &&
				JSON.parse(sessionStorage.getItem(AnalyticsConstants.ref.addrBookEdit)) === true)
			return 'ModifiyAdressBookBack';
		else
			return 'NewAdressBookBack';
	};
	modifiyAdressBookBack.postAction(function(){ sessionStorage.removeItem(AnalyticsConstants.ref.addrBookEdit); });
	tracker.addEvent(modifiyAdressBookBack);

	// - AdressBookDeletionClick
	var adressBookDeletionClick = new AnalyticsClickEvent('adressBookDeletionClick', tracker.defaultEvent());
	adressBookDeletionClick.domElement = '#address-book-list-table div.table-action a.delete-item';
	adressBookDeletionClick.options.label = 'AdressBookDeletionClick';
	tracker.addEvent(adressBookDeletionClick);

	// - AdressBookDeletionValidationYes
	var adressBookDeletionValidationYes = new AnalyticsClickEvent('adressBookDeletionValidationYes', tracker.defaultEvent());
	adressBookDeletionValidationYes.domContainer = '.modal-delete-address';
	adressBookDeletionValidationYes.domElement = '.confirm-deletion';
	adressBookDeletionValidationYes.options.label = 'AdressBookDeletionValidationYes';
	tracker.addEvent(adressBookDeletionValidationYes);

	// - AdressBookDeletionValidationNo
	var adressBookDeletionValidationNo = new AnalyticsClickEvent('adressBookDeletionValidationNo', tracker.defaultEvent());
	adressBookDeletionValidationNo.domContainer = '.modal-delete-address';
	adressBookDeletionValidationNo.domElement = '.cancel-deletion';
	adressBookDeletionValidationNo.options.label = 'AdressBookDeletionValidationNo';
	tracker.addEvent(adressBookDeletionValidationNo);

	// - FavoriteAdressBookModification
	var favoriteAdressBookModification = new AnalyticsTriggerEvent('favoriteAdressBookModification', tracker.defaultEvent());
	favoriteAdressBookModification.trigger = 'change';
	favoriteAdressBookModification.domElement = '#address-book-list-table div.radio input[name="favoriteRadioButton"]';
	favoriteAdressBookModification.options.label = 'FavoriteAdressBookModification';
	tracker.addEvent(favoriteAdressBookModification);

	// - HomeAdressCheckBox
	var homeAdressCheckBox = new AnalyticsTriggerEvent('homeAdressCheckBox', tracker.defaultEvent());
	homeAdressCheckBox.trigger = 'change';
	homeAdressCheckBox.domContainer = '#add-address-container label[for="home-delivery"]';
	homeAdressCheckBox.domElement = 'input#home-delivery';
	homeAdressCheckBox.options.label = 'HomeAdressCheckBox';
	tracker.addEvent(homeAdressCheckBox);

	// - FavoriteAdressBookSelection
	var favoriteAdressBookSelection = new AnalyticsTriggerEvent('favoriteAdressBookSelection', tracker.defaultEvent());
	favoriteAdressBookSelection.trigger = 'change';
	favoriteAdressBookSelection.domContainer = '#add-address-container label[for="favorite-address"]';
	favoriteAdressBookSelection.domElement = 'input#favorite-address';
	favoriteAdressBookSelection.options.label = 'FavoriteAdressBookSelection';
	tracker.addEvent(favoriteAdressBookSelection);
	
	
	/*
	 * BILLING VIEW
	 */


	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('#address-book').length){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.addressBook.name);
	});
}
(function($) {

	// TRACKER 'MY STORE'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.store);

	// firstChooseStore
	var firstChooseStore = new AnalyticsClickEvent('menu-firstChooseStore', tracker.defaultEvent());
	firstChooseStore.domElement = '.ua-content.empty-content a';
	firstChooseStore.options.label = 'FirstChooseStore';
	tracker.addEvent(firstChooseStore);

	// storeItinerary
	var storeItinerary = new AnalyticsClickEvent('storeItinerary', tracker.defaultEvent());
	storeItinerary.domElement = '#itinary-mystore';
	storeItinerary.options.label = 'Itinerary';
	tracker.addEvent(storeItinerary);

	// storeAllInfo
	var storeAllInfo = new AnalyticsClickEvent('storeAllInfo', tracker.defaultEvent());
	storeAllInfo.domElement = '.edit-options a:nth-child(1)';
	storeAllInfo.options.label = 'Informations';
	tracker.addEvent(storeAllInfo);

	// storeChange
	var storeChange = new AnalyticsClickEvent('storeChange', tracker.defaultEvent());
	storeChange.domElement = '.edit-options a:nth-child(2)';
	storeChange.options.label = 'Change';
	tracker.addEvent(storeChange);


	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('#mystore-page').length){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.store.name);
	});
}
(function($) {

	// TRACKER 'SUBSCRIPTION'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.subscription);

	/*
	 * -- PERSONAL INFORMATION
	 */
	// changeSubscription
	var changeSubscription = new AnalyticsTriggerEvent('changeSubscription', tracker.defaultEvent());
	changeSubscription.trigger = 'change';
	changeSubscription.domElement = 'input[name="subscriptionRadio"]';
	changeSubscription.getLabel = function($element) {
		var value = $element.val();
		return value.charAt(0).toUpperCase() + value.slice(1);
	};
	tracker.addEvent(changeSubscription);
	
	// confirmChange
	var confirmChangeSubscription = new AnalyticsClickEvent('confirmChangeSubscription', tracker.defaultEvent());
	confirmChangeSubscription.domElement = '#validate-button';
	confirmChangeSubscription.options.label = 'Confirm';
	tracker.addEvent(confirmChangeSubscription);

	// cancelChange
	var cancelChangeSubscription = new AnalyticsClickEvent('cancelChangeSubscription', tracker.defaultEvent());
	cancelChangeSubscription.domElement = '#cancel-button';
	cancelChangeSubscription.options.label = 'Cancel';
	tracker.addEvent(cancelChangeSubscription);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('.ua-container').hasClass('subscriptions')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.subscription.name);
	});
}
(function($) {

	// TRACKER 'BASKET'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.global);

	// - breadcrumbClick
	var breadcrumbClick = new AnalyticsClickEvent('breadcrumbClick', tracker.defaultEvent());
	breadcrumbClick.domElement = 'a.dkt-checkout-breadcrumbs-item';
	breadcrumbClick.options.action = 'BreadcrumbClick';
	breadcrumbClick.getCategory = function($element) {
		if($('body').hasClass('checkout-cart')) return 'Checkout - Basket';
		if($('body').hasClass('checkout-delivery')) return 'Checkout - Delivery';
		if($('body').hasClass('checkout-payment')) return 'Checkout - Payment';
		if($('body').hasClass('checkout-login')) return 'Checkout - Login';
		// TODO - no link to page
		if($('body').hasClass('checkout-register')) return 'Checkout - AccountCreation';
		return '';
	};
	breadcrumbClick.getLabel = function($element) { return $element.data('at-name'); };
	tracker.addEvent(breadcrumbClick);

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').is('.checkout, .checkout-login')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.global.name);
	});
}
(function($) {

	// TRACKER 'BASKET'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.basket);
	var sep = AnalyticsConstants.separatorST;
	var fwk = CUBE.Analytics;

	var getProductDetails = function($element) {
		var model = fwk.utils.basketpage.getModel($element.closest('.faux-table-wrapper'));
		if (model) {
			var productNature = 'PRODUCT_NATURE'; // TODO
			var productName = model.name;
			var productId = model.id;
			return productName + sep + productId;
		} else {
			var productNature = 'PRODUCT_NATURE'; // TODO
			var productName = $element.closest('.product-item').find('.product-title [data-tprop="product-name"]').text().trim()
			var productId = $element.closest('.product-item').find('.modify-product[model-id]').attr('model-id');
			return productName + sep + productId;
		}
	};

	// - ChangeQuantityCart on click on '+' / '-'
	var changeQuantityCart = new AnalyticsClickEvent('changeQuantityBtn', tracker.defaultEvent());
	changeQuantityCart.domContainer = 'div.quantity-selector';
	changeQuantityCart.domElement = 'button.icon';
	changeQuantityCart.getAction = function($element) { return $element.hasClass('icon-minus') ? 'RemoveQuantityCart' : 'AddQuantityCart'; };
	changeQuantityCart.getLabel = function($element){
		return getProductDetails($element);
	};
	tracker.addEvent(changeQuantityCart);

	// - ChangeQuantityCart on change from the input
	var changeQuantityCartFromInput = new AnalyticsTriggerEvent('changeQuantityInput', tracker.defaultEvent());
	changeQuantityCartFromInput.trigger = 'change';
	changeQuantityCartFromInput.domContainer = 'div.quantity-selector';
	changeQuantityCartFromInput.domElement = 'input.quantity-input';
	changeQuantityCartFromInput.options.action = 'ChangeQuantityCart';
	changeQuantityCartFromInput.getLabel = function($element){
		return getProductDetails($element);
	};
	tracker.addEvent(changeQuantityCartFromInput);
	
	// - RemoveProduct
	var removeProduct = new AnalyticsClickEvent('removeProduct', tracker.defaultEvent());
	removeProduct.options.action = 'RemoveProduct';
	removeProduct.domElement = 'div.cart-element span.delete-item';
	removeProduct.getLabel = function($element) {
		return getProductDetails($element);
	};
	tracker.addEvent(removeProduct);

	// - ProceedToOrder
	var proceedToOrder = new AnalyticsQueueEvent('proceedToOrder', tracker.defaultEvent());
	proceedToOrder.trigger = 'click';
	proceedToOrder.domElement = '#pay-order-btn';
	proceedToOrder.options.action = 'ProceedToOrder';
	proceedToOrder.options.label = 'OrderBasketPage';
	proceedToOrder.getValue = function() {
		return parseInt($("[data-tracking-basket-amount]").data('tracking-basket-amount'));
	};
	tracker.addEvent(proceedToOrder);

	// - ContinueShopping
	var continueShopping = new AnalyticsClickEvent('continueShopping', tracker.defaultEvent());
	continueShopping.options.action = 'ContinueShopping';
	continueShopping.options.label = '';
	continueShopping.domElement = '.payment-bar-content a.l-back.white, .cart-empty a.cta';
	tracker.addEvent(continueShopping);

	// - GoBackToProduct
	var goBackToProduct = new AnalyticsClickEvent('goBackToProduct', tracker.defaultEvent());
	goBackToProduct.options.action = 'GoBackToProduct';
	goBackToProduct.domContainer = '#cartridgeDivId';
	goBackToProduct.domElement = 'div.product-img, div.product-title a:not([href="#"])';
	goBackToProduct.getLabel = function($element) {
		return getProductDetails($element);
	};
	tracker.addEvent(goBackToProduct);
	
	// CrossSell - Move to cart
	var eventAddToCartCrossSell = new AnalyticsEvent('virtualEventAddToCartCrossSell', tracker.defaultEvent());
	tracker.addEvent(eventAddToCartCrossSell);

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').hasClass('checkout-cart')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.basket.name);
	});
}
(function($) {

	// TRACKER 'BASKET'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.savelater);
	var sep = AnalyticsConstants.separatorST;
	var fwk = CUBE.Analytics;

	var getModel = function($element) {
		var model, refId;
		var $eltProduct = $element.closest('.faux-table-wrapper');
		var $eltProducts = $element.closest('.table-wrapper').find('.faux-table-wrapper');
		refId = $eltProduct.find('[data-product-reference]').data('product-reference');
		model = fwk.utils.datalayer.getModel(refId);
		model.position = $eltProducts.index($eltProduct) + 1;
		return model;
	};

	var getProductDetails = function($element) {
		var model = getModel($element);
		this.model = model;
		return model.variant + sep + model.name + sep + model.modelId;
	};
	var getProductValue = function($element) {
		return this.model.price;
	};


	// Save to 'Buy Later'
	var addToSaveLater = new AnalyticsClickEvent('addToSaveLater', tracker.defaultEvent());
	addToSaveLater.domContainer = '#cartridgeDivId';
	addToSaveLater.domElement = '.buy-later-btn';
	addToSaveLater.options.action = 'AddToSavedForLater';
	addToSaveLater.getLabel = function($element){
		return getProductDetails.bind(this)($element);
	};
	addToSaveLater.getValue = function($element) {
		return getProductValue.bind(this)($element);
	};
	tracker.addEvent(addToSaveLater);

	// Move to Cart
	var removeFromSaveLater = new AnalyticsClickEvent('removeFromSaveLater', tracker.defaultEvent());
	removeFromSaveLater.domContainer = '#cartridgeDivBuyLaterId';
	removeFromSaveLater.domElement = '.buy-later-to-cart-btn';
	removeFromSaveLater.options.action = 'AddToCart';
	removeFromSaveLater.getLabel = function($element){
		return getProductDetails.bind(this)($element);
	};
	removeFromSaveLater.getValue = function($element) {
		return getProductValue.bind(this)($element);
	};
	removeFromSaveLater.postAction(function($element) {
		// EnhancedEcommerce - Add To Cart

	});
	// TODO - SHOPPING TOOL ?
	tracker.addEvent(removeFromSaveLater);

	// Delete All Wishlist
	var deleteAllWishlist = new AnalyticsClickEvent('deleteAllWishlist', tracker.defaultEvent());
	deleteAllWishlist.domContainer = '#cartridgeDivBuyLaterId';
	deleteAllWishlist.domElement = '#delete-all-products, .delete-products.js-delete-all-from-buy-later';
	deleteAllWishlist.options.action = 'DeleteAllSavedForLater';
	deleteAllWishlist.options.label = '';
	tracker.addEvent(deleteAllWishlist);

	// Delete 1 product
	var deleteOneFromWishlist = new AnalyticsClickEvent('deleteOneFromWishlist', tracker.defaultEvent());
	deleteOneFromWishlist.domContainer = '#cartridgeDivBuyLaterId';
	deleteOneFromWishlist.domElement = '.js-delete-from-buy-later';
	deleteOneFromWishlist.options.action = 'DeleteOneSavedForLater';
	deleteOneFromWishlist.getLabel = function($element){
		return getProductDetails.bind(this)($element);
	};
	deleteOneFromWishlist.getValue = function($element) {
		return getProductValue.bind(this)($element);
	};
	tracker.addEvent(deleteOneFromWishlist);

	// Go back to 1 product
	var savelaterGoBackToProduct = new AnalyticsClickEvent('savelaterGoBackToProduct', tracker.defaultEvent());
	savelaterGoBackToProduct.domContainer = '#cartridgeDivBuyLaterId';
	savelaterGoBackToProduct.domElement = '.product-img a';
	savelaterGoBackToProduct.options.action = 'GoBackToProduct';
	savelaterGoBackToProduct.getLabel = function($element){
		return getProductDetails.bind(this)($element);
	};
	tracker.addEvent(savelaterGoBackToProduct);

//---------------
/*
	// Modify 1 article (from cart)
	var modifyOneFromCart = new AnalyticsClickEvent('modifyOneFromCart', tracker.defaultEvent());
	modifyOneFromCart.domContainer = '#cartridgeDivId';
	modifyOneFromCart.domElement = '.modify-product';
	modifyOneFromCart.options.action = 'ModifyProduct';
	modifyOneFromCart.getLabel = function($element){
		return getProductDetails.bind(this)($element);
	};
	modifyOneFromCart.getValue = function($element) {
		return getProductValue($element);
	};
	tracker.addEvent(modifyOneFromCart);

	// Confirmation article modification
	var confirmModifyOneFromCart = new AnalyticsClickEvent('confirmModifyOneFromCart', tracker.defaultEvent());
	confirmModifyOneFromCart.domContainer = '#cartridgeDivId';
	confirmModifyOneFromCart.domElement = '#confirm_modification';
	confirmModifyOneFromCart.options.action = 'ConfirmModifyProduct';
	confirmModifyOneFromCart.getLabel = function($element){
		return getProductDetails.bind(this)($element);
	};
	confirmModifyOneFromCart.getValue = function($element) {
		return getProductValue($element);
	};
	tracker.addEvent(confirmModifyOneFromCart);
*/
//----------------------
	// CrossSell - Move to cart
	//var eventAddToCartCrossSell = new AnalyticsEvent('virtualEventAddToCartCrossSell', tracker.defaultEvent());
	//tracker.addEvent(eventAddToCartCrossSell);

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').hasClass('checkout-cart')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.savelater.name);
	});
}
(function($) {

	// TRACKER 'DELIVERY'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.delivery);

	var fwk = CUBE.Analytics;

	// ProceedToPayment
	var proceedToPayment = new AnalyticsQueueEvent('proceedToPayment', tracker.defaultEvent());
	proceedToPayment.trigger = 'click';
	proceedToPayment.options.action = 'ProceedToPayment';
	proceedToPayment.domElement = '#pay-order-btn, #pay-order-mob-btn';
	proceedToPayment.getLabel = function($element) {
		return getLabelDelivery();
	};
	proceedToPayment.postAction(function($elt) {
		var deliveryInfo = this.options.label || ''
		var orderInfo = tc_vars.order_id || ''
		fwk.setStorage('dl-delivery-'+orderInfo, deliveryInfo)
	})
	tracker.addEvent(proceedToPayment);

	// OpenDeliveryMethodBox
	var changeDeliveryMethodBox = new AnalyticsTriggerEvent('changeDeliveryMethodBox', tracker.defaultEvent());
	changeDeliveryMethodBox.trigger = 'click';
	changeDeliveryMethodBox.options.action = 'changeDeliveryMethodBox';
	changeDeliveryMethodBox.domElement = 'fieldset.panel>.accordion-toggle';
	changeDeliveryMethodBox.getAction = function($element) {
		if ($element.hasClass('collapsed')) return 'OpenDeliveryMethodBox';
		else return 'CloseDeliveryMethodBox';
	};
	changeDeliveryMethodBox.getLabel = function($element) {
		return $element.data('target').replace('#', '');
	};
	changeDeliveryMethodBox.stopEvent = function($element, data, jqEvent, jqData) {
		if (jqEvent.which) return false;
		return true;
	};
	tracker.addEvent(changeDeliveryMethodBox);


 	// ChangeDeliveryMethod
 	var changeDeliveryMethod = new AnalyticsClickEvent('changeDeliveryMethod', tracker.defaultEvent());
 	changeDeliveryMethod.delay = 50;
 	changeDeliveryMethod.options.action = 'ChangeDeliveryMethod';
 	changeDeliveryMethod.domContainer = '.panel-group';
 	changeDeliveryMethod.domElement = '.radio>label';
 	changeDeliveryMethod.getLabel = function($element) {
 		return getLabelDelivery();
 	};
 	tracker.addEvent(changeDeliveryMethod);

 	// OpenMyLocationStoreList
 	var openMyLocationStoreList = new AnalyticsTriggerEvent('openMyLocationStoreList', tracker.defaultEvent());
 	openMyLocationStoreList.trigger = 'click';
 	openMyLocationStoreList.options.action = 'OpenMyLocationStoreList';
 	openMyLocationStoreList.options.label = '';
 	openMyLocationStoreList.domElement = '.delivery-location button#dropdown';
 	openMyLocationStoreList.stopEvent = function($element) {
 		if ($element.siblings('#result-layout-location').is(':visible')) return true;
 	};
 	tracker.addEvent(openMyLocationStoreList);

 	// ChangeNameForPickUp
 	var changeNameForPickUp = new AnalyticsTriggerEvent('changeNameForPickUp', tracker.defaultEvent());
 	changeNameForPickUp.trigger = 'blur';
 	changeNameForPickUp.options.action = 'ChangeNameForPickUp';
 	changeNameForPickUp.domElement = '.js-pickup-friend-name';
 	changeNameForPickUp.options.label = '';
 	tracker.addEvent(changeNameForPickUp);

 	// ViewMoreStore
 	var viewMoreStore = new AnalyticsClickEvent('viewMoreStore', tracker.defaultEvent());
 	viewMoreStore.options.action = 'ViewMoreStore';
 	viewMoreStore.domElement = '#bt-more-stores';
 	viewMoreStore.options.label = '';
 	tracker.addEvent(viewMoreStore);
 	

	// Common method
	// %DELIVERY_METHOD% + %DELIVERY_DETAILS%
	var getLabelDelivery = function() {
		var selectedRadio = $('input[name="delivery-type"]:checked');
		var deliverySelected = '';
		var deliveryMethod = selectedRadio.closest('.panel-collapse').attr('id');
		if (deliveryMethod === "pick-up")
			deliverySelected += selectedRadio.val() + AnalyticsConstants.concatenator;
		deliverySelected += selectedRadio.siblings('.indicator').text().trim();
		return deliveryMethod + AnalyticsConstants.concatenator + deliverySelected;
	};

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').hasClass('checkout-delivery')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.delivery.name);
	});
}
(function($) {

	if(!$('body').hasClass('checkout-payment'))
		return;
		
	var fwk = CUBE.Analytics;

	// TRACKER 'PAYMENT'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.payment);
	var lastMeanOfPayment = $('#secondary-block [name="paymentTypeId"]:checked').attr('id').replace('type-', '');

	// ProceedToConfirmation
	var proceedToConfirmation = new AnalyticsQueueEvent('proceedToConfirmation', tracker.defaultEvent());
	proceedToConfirmation.trigger = 'click';
	proceedToConfirmation.domElement = '#pay-order-btn, #pay-order-mob-btn';
	proceedToConfirmation.options.action = 'ProceedToConfirmation';
	proceedToConfirmation.getLabel = function() {
		return tc_vars.order_id + '|' + getLastMeanOfPayment()
	}
	proceedToConfirmation.options.value = tc_vars.order_amount_ati_with_sf;
	proceedToConfirmation.postAction(function($elt) {
		var orderInfo = tc_vars.order_id || ''
		fwk.setStorage('dl-payment-'+orderInfo, getLastMeanOfPayment())
	})
	tracker.addEvent(proceedToConfirmation);

	// ChangeDeliveryMethodBox
	var changePaymentMethodBox = new AnalyticsTriggerEvent('changePaymentMethodBox', tracker.defaultEvent());
	changePaymentMethodBox.trigger = 'click';
	changePaymentMethodBox.options.action = 'changePaymentMethodBox';
	changePaymentMethodBox.domElement = 'fieldset.panel>.accordion-toggle';
	changePaymentMethodBox.getAction = function($element) {
		if ($element.hasClass('collapsed')) return 'OpenPaymentMethodBox ';
		else return 'ClosePaymentMethodBox ';
	};
	changePaymentMethodBox.getLabel = function($element) {
		return $element.data('target').replace('#', '');
	};
	changePaymentMethodBox.stopEvent = function($element, data, jqEvent, jqData) {
		if (jqEvent.which) return false;
		return true;
	};
	tracker.addEvent(changePaymentMethodBox);
	
	// OpenGiftPaymentList
 	var openGiftPaymentList = new AnalyticsTriggerEvent('openGiftPaymentList', tracker.defaultEvent());
 	openGiftPaymentList.trigger = 'change';
 	openGiftPaymentList.domElement = '#choose-voucher';
 	openGiftPaymentList.options.action = 'SelectGiftPaymentList';
 	openGiftPaymentList.getLabel = function($elt) {
		var lblGiftPayment = ($elt.find('[value="'+$elt.val()+'"]').text() || 'none').trim();
		return lblGiftPayment;
	 }
 	tracker.addEvent(openGiftPaymentList);

	// SelectGiftPaymentList
 	var selectGiftPaymentList = new AnalyticsClickEvent('selectGiftPaymentMethod', tracker.defaultEvent());
 	selectGiftPaymentList.domContainer = '.choose-discount';
 	selectGiftPaymentList.domElement = '[data-id="choose-voucher"]';
 	selectGiftPaymentList.options.action = 'SelectGiftPaymentMethod';
 	selectGiftPaymentList.options.label = '';
 	tracker.addEvent(selectGiftPaymentList);

	// selectPaymentMethod
	var selectPaymentMethod = new AnalyticsTriggerEvent('selectPaymentMethod', tracker.defaultEvent());
	selectPaymentMethod.trigger = 'change';
	selectPaymentMethod.options.action = 'SelectPaymentMethod';
	selectPaymentMethod.domElement = '#secondary-block [name="paymentTypeId"]';
	selectPaymentMethod.getLabel = function($element) {
		lastMeanOfPayment = $element.attr('id').replace('type-', '');
		return $element.attr('id').replace('type-', '');
	};
	tracker.addEvent(selectPaymentMethod);

	// selectPaymentMethod--e-bank
	var selectPaymentMethodEBank = new AnalyticsClickEvent('selectPaymentMethodEBank', tracker.defaultEvent());
	selectPaymentMethodEBank.options.action = 'SelectPaymentMethod';
	selectPaymentMethodEBank.domElement = '#secondary-block [type="image"]';
	selectPaymentMethodEBank.getLabel = function($element) {
		var first = $element.closest('.panel').find('input[name="paymentTypeId"]').attr('id').replace('type-', '');
		var second = $element.val();
		lastMeanOfPayment = first + AnalyticsConstants.concatenator + second;
		return first + AnalyticsConstants.concatenator + second;
	};
	tracker.addEvent(selectPaymentMethodEBank);

	// selectFapiaoMethod
	var selectFapiaoMethod = new AnalyticsTriggerEvent('selectFapiaoMethod', tracker.defaultEvent());
	selectFapiaoMethod.trigger = 'change';
	selectFapiaoMethod.options.action = 'SelectFapiaoMethod';
	selectFapiaoMethod.domElement = '#fapiao-block #fapiao-invoice';
	selectFapiaoMethod.getLabel = function($element) {
		return $element.find('option:selected').val();
	};
	tracker.addEvent(selectFapiaoMethod);



	CUBE.Analytics.trackers.add(tracker);

	// UTIL METHOD
	var getLastMeanOfPayment = function() {
		var last = lastMeanOfPayment;
		var $cards = $('ul.cards-showcase li:not(.hidden)')

		// is Payment With Giftcards ?
		if ($cards.length > 0) {
			// Get all types of cards
			var arrTypes = [];
			$cards.each(function() {
				var $card = $(this);
				if ($card.find('.amounts .form-group').length > 0) {
					var type = $card.find('span.first img').attr('alt')
					if (arrTypes.indexOf(type) === -1)
						arrTypes.push(type)
				}
			})
			// arrTypes now contains all types of giftcards / vouchers / ...

			/*
			> is Order Fully Paid With Giftcards ?
				'.panel-empty' is only displayed when there is no payment type selection
				(i.e. when the order is fully paid with gift card) > no need to send 'lastMeanOfPayment' info in this case
			*/
			if ($('#secondary-block .panel-empty').hasClass('hidden')) {
				// Specific panel is hidden > There is still some payment options, so we add the selected one to array of Types
				arrTypes.unshift(lastMeanOfPayment)
				return arrTypes.join(' - ')
			} else {
				// Panel is hidden > Order fully paid with giftcards / vouchers / ...
				return arrTypes.join(' - ')
			}
		} else {
			// Payment without giftcards
			return lastMeanOfPayment;
		}
	}

})(jQuery);

// -- INIT
if($('body').hasClass('checkout-payment')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.payment.name);
	});
}
(function($) {

	// TRACKER 'ACCOUNT CREATION'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.account.creation);
	
	// Account Creation
	var accountCreated = new AnalyticsQueueEvent('accountCreated', tracker.defaultEvent());
	accountCreated.trigger = 'click';
	accountCreated.domElement = '#submitCreateAccount';
	accountCreated.options.action = 'AccountCreated';
	accountCreated.options.label = '';
	accountCreated.options.value = 1;
	tracker.addEvent(accountCreated);
	
	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('.container').hasClass('create-account')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.account.creation.name);
	});
}
(function($) {

	// TRACKER 'BASKET'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.express);
	var sep = AnalyticsConstants.separator;
	var fwk = CUBE.Analytics;

	var productNature = '%PRODUCT_NATURE%'; // tc_vars.product_nature;
	var productName = tc_vars.product_label_displayed;
	var productId = tc_vars.product_id_model;

	var returnLabel = function() { return productName + sep + fwk.utils.productpage.getSelectedModelId(); };
	var returnValue = function() { return fwk.utils.productpage.getSelectedQuantity() * fwk.utils.productpage.getSelectedPrice(); };
	
	var commonEvent = function(commonGetters) {
		if (typeof commonGetters == 'undefined') commonGetters = true;
		var commonEvent = new AnalyticsClickEvent('event', tracker.defaultEvent());
		commonEvent.domContainer = '#modal-express-payment-layout';
		if (commonGetters) {
			commonEvent.getLabel = returnLabel;
			commonEvent.getValue = returnValue;
		}
		return commonEvent;
	};

	//tracker.addEvent(event);

	// "Make Your Choice" screen
	var expressCheckout = commonEvent();
	expressCheckout.name = 'expressCheckout';
	delete expressCheckout.domContainer;
	expressCheckout.domElement = '#express-payment-cta';
	expressCheckout.options.action = 'Express Payment';
	tracker.addEvent(expressCheckout);
	
	
	// "Login" screen
	var expressCheckoutLogin = commonEvent();
	expressCheckoutLogin.name = 'expressCheckoutLogin';
	expressCheckoutLogin.domElement = '#loginForm .m-login-panel-footer button.cta';
	expressCheckoutLogin.options.action = 'Login';
	tracker.addEvent(expressCheckoutLogin);
	
	
	// "Summary" screen
	var expressCheckoutModifyShipping = commonEvent();
	expressCheckoutModifyShipping.name = 'expressCheckoutModifyShipping';
	expressCheckoutModifyShipping.domElement = '#express-checkout-shipping-method-modify-btn';
	expressCheckoutModifyShipping.options.action = 'Summary Modify Shipping';
	tracker.addEvent(expressCheckoutModifyShipping);
	
	var expressCheckoutModifyPayment = commonEvent();
	expressCheckoutModifyPayment.name = 'expressCheckoutModifyPayment';
	expressCheckoutModifyPayment.domElement = '#express-checkout-payment-method-modify-btn';
	expressCheckoutModifyPayment.options.action = 'Summary Modify Payment';
	tracker.addEvent(expressCheckoutModifyPayment);
	
	var expressCheckoutOtherOptions = commonEvent();
	expressCheckoutOtherOptions.name = 'expressCheckoutOtherOptions';
	expressCheckoutOtherOptions.domElement = '#pay-order-btn-other';
	expressCheckoutOtherOptions.options.action = 'Summary Other options';
	tracker.addEvent(expressCheckoutOtherOptions);
	
	var expressCheckoutOrderPay = commonEvent();
	expressCheckoutOrderPay.name = 'expressCheckoutOrderPay';
	expressCheckoutOrderPay.domElement = '#pay-order-btn-xpress';
	expressCheckoutOrderPay.options.action = 'Summary Order & Pay';
	tracker.addEvent(expressCheckoutOrderPay);
	
	
	// "Shipping" modify screen
	var expressCheckoutShippingConfirm = commonEvent();
	expressCheckoutShippingConfirm.name = 'expressCheckoutShippingConfirm';
	expressCheckoutShippingConfirm.domElement = '#express-shipping-content #validate-shipping';
	expressCheckoutShippingConfirm.options.action = 'Shipping Confirm';
	tracker.addEvent(expressCheckoutShippingConfirm);

	var expressCheckoutShippingCancel = commonEvent();
	expressCheckoutShippingCancel.name = 'expressCheckoutShippingCancel';
	expressCheckoutShippingCancel.domElement = '#express-shipping-content #cancel-shipping, #express-shipping-content .bullet.nav-step.prev-step';
	expressCheckoutShippingCancel.options.action = 'Shipping Cancel';
	tracker.addEvent(expressCheckoutShippingCancel);

	var expressCheckoutShippingSelectShipping = commonEvent();
	expressCheckoutShippingSelectShipping.name = 'expressCheckoutShippingSelectShipping';
	expressCheckoutShippingSelectShipping.domElement = '.shipping-method .method-option > .radio > label';
	expressCheckoutShippingSelectShipping.getAction = function($element) {
		return 'Shipping Select ' + sep + ' ' + $element.find('.indicator span').text().trim();
	};
	tracker.addEvent(expressCheckoutShippingSelectShipping);

	var expressCheckoutShippingSelectAddress = commonEvent();
	expressCheckoutShippingSelectAddress.trigger = 'change';
	expressCheckoutShippingSelectAddress.name = 'expressCheckoutShippingSelectAddress';
	expressCheckoutShippingSelectAddress.domElement = '#addressbook_picker';
	expressCheckoutShippingSelectAddress.getAction = function($element) {
		return 'Shipping Change Address ' + sep + ' Position-' + ($element[0].selectedIndex + 1);
	};
	tracker.addEvent(expressCheckoutShippingSelectAddress);

	var expressCheckoutShippingSelectCarrier = commonEvent();
	expressCheckoutShippingSelectCarrier.name = 'expressCheckoutShippingSelectCarrier';
	expressCheckoutShippingSelectCarrier.domElement = '#shipping-home-delivery-container .shipping-block > .radio > label';
	expressCheckoutShippingSelectCarrier.getAction = function($element) {
		return 'Shipping Change Carrier ' + sep + ' ' + $element.find('input.radio-input').attr('id').toUpperCase();
	};
	tracker.addEvent(expressCheckoutShippingSelectCarrier);
	
	
	// "Payment" modify screen
	var expressCheckoutPaymentChange = commonEvent();
	expressCheckoutPaymentChange.name = 'expressCheckoutPaymentChange';
	expressCheckoutPaymentChange.domElement = '#express-payment-content .method-option';
	expressCheckoutPaymentChange.getAction = function($element) {
		return 'Payment Select ' + sep + ' ' + $element.find('.indicator').text().trim();
	};
	tracker.addEvent(expressCheckoutPaymentChange);

	var expressCheckoutPaymentCancel = commonEvent();
	expressCheckoutPaymentCancel.name = 'expressCheckoutPaymentCancel';
	expressCheckoutPaymentCancel.domElement = '#express-payment-content #cancel-payment, #express-payment-content .bullet.nav-step.prev-step';
	expressCheckoutPaymentCancel.options.action = 'Payment Cancel';
	tracker.addEvent(expressCheckoutPaymentCancel);

	var expressCheckoutPaymentConfirm = commonEvent();
	expressCheckoutPaymentConfirm.name = 'expressCheckoutPaymentConfirm';
	expressCheckoutPaymentConfirm.domElement = '#express-payment-content #validate-payment';
	expressCheckoutPaymentConfirm.options.action = 'Payment Confirm';
	tracker.addEvent(expressCheckoutPaymentConfirm);
	
	
	/*
	 * "Empty Events" > Executes code trough function 'triggerVirtual' (for Virtual Page)
	 * 	then returns 'true' to 'stepEvent()'
	 */
	
	// VIRTUAL PAGE - LOGIN
	var expressCheckoutVirtualLogin = new AnalyticsEvent('expressCheckoutVirtualLogin', tracker.defaultEvent());
	tracker.addEvent(expressCheckoutVirtualLogin);
	
	var expressCheckoutVirtualMissingInformation = new AnalyticsEvent('expressCheckoutVirtualMissingInformation', tracker.defaultEvent());
	tracker.addEvent(expressCheckoutVirtualMissingInformation);
	
	var expressCheckoutVirtualSummary = new AnalyticsEvent('expressCheckoutVirtualSummary', tracker.defaultEvent());
	tracker.addEvent(expressCheckoutVirtualSummary);
	
	// VIRTUAL PAGE - SHIPPING
	var expressCheckoutVirtualShipping = new AnalyticsEvent('expressCheckoutVirtualShipping', tracker.defaultEvent());
	tracker.addEvent(expressCheckoutVirtualShipping);
	
	// VIRTUAL PAGE - PAYMENT
	var expressCheckoutVirtualPayment = new AnalyticsEvent('expressCheckoutVirtualPayment', tracker.defaultEvent());
	tracker.addEvent(expressCheckoutVirtualPayment);

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').hasClass('product-page')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.express.name);
	});
}
(function($) {

	// TRACKER 'PRODUCT-CONVERSION'
	
	var sep = AnalyticsConstants.concatenator;
	var fwk = CUBE.Analytics;
	var utils = fwk.utils.productpage;
	
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.conversion);

	var getProductLabel = function() {
		var productName = tc_vars.product_label_displayed;
		var productNature = '%PRODUCT_NATURE%'; // TODO : tc_vars.product_nature;
		var modelId = utils.getSelectedModelId();
		return productName + sep + modelId;
	};
	var getPrice = function() { return utils.getSelectedPrice(); };
	var getTotalPrice = function() { return utils.getSelectedPrice() * utils.getSelectedQuantity(); };

	// MakeYourChoice
	var makeYourChoice = new AnalyticsClickEvent('makeYourChoice', tracker.defaultEvent());
	makeYourChoice.options.action = 'Make your choice';
	makeYourChoice.domElement = '#modal-product-cta';
	makeYourChoice.getLabel = getProductLabel;
	makeYourChoice.getValue = getPrice;
	tracker.addEvent(makeYourChoice);

	// CloseConversion
	var closeConversion = new AnalyticsClickEvent('closeConversion', tracker.defaultEvent());
	closeConversion.options.action = 'CloseConversionLayer';
	closeConversion.domContainer = '#modal-product-layout';
	closeConversion.domElement = '#close-modal-product-layout';
	closeConversion.getLabel = getProductLabel;
	closeConversion.getValue = getPrice;
	tracker.addEvent(closeConversion);

	// Colorama
	var colorama = new AnalyticsClickEvent('colorama', tracker.defaultEvent());
	colorama.options.action = 'Colorama';
	colorama.domContainer = '#modal-product-layout';
	colorama.domElement = '.thumbs-product-list .slick-slide';
	colorama.getLabel = function($element) {
		return tc_vars.product_label_displayed + sep + $element.data('model-id');
	};
	colorama.getValue = function($element) {
		var modelId = $element.data('model-id');
		return $("#model-price-" + modelId + " .price").data("price");
	};
	tracker.addEvent(colorama);

	// SelectSize
	var selectSize = new AnalyticsClickEvent('selectSize', tracker.defaultEvent());
	selectSize.delay = 50;
	selectSize.options.action = 'SelectSize';
	selectSize.domContainer = '#modal-product-layout';
	selectSize.domElement = '.size-selection li a';
	selectSize.getLabel = function($element){ return getProductLabel() + sep + $element.attr('title'); };
	selectSize.getValue = getPrice;
	tracker.addEvent(selectSize);

	// SizeGuide
	var sizeGuide = new AnalyticsClickEvent('sizeGuide', tracker.defaultEvent());
	sizeGuide.options.action = 'ViewSizeGuide';
	sizeGuide.domContainer = 'section.size-selection';
	sizeGuide.domElement = 'a.cta-link';
	sizeGuide.getLabel = getProductLabel;
	sizeGuide.getValue = getPrice;
	tracker.addEvent(sizeGuide);

	// Change Quantity
	var changeQuantity = new AnalyticsClickEvent('changeQuantity', tracker.defaultEvent());
	changeQuantity.domContainer = 'div.quantity-selector';
	changeQuantity.domElement = 'button.icon';
	changeQuantity.getAction = function($element) { return $element.hasClass('icon-minus') ? 'RemoveQuantity' : 'AddQuantity'; };
	changeQuantity.getLabel = getProductLabel;
	changeQuantity.getValue = getPrice;
	tracker.addEvent(changeQuantity);

	// Add to cart
	var addToCart = new AnalyticsClickEvent('addToCart', tracker.defaultEvent());
	addToCart.domContainer = 'div.product-button';
	addToCart.domElement = '#ctaButton';
	addToCart.options.action = 'AddToCart';
	addToCart.getLabel = getProductLabel;
	addToCart.getValue = getTotalPrice;
	addToCart.postAction(function() {
		// Get current Enhanced ECommerce Informations
		var enhancedActual = fwk.enhanced.getActual();
		// Update MODEL ID
		enhancedActual.id = fwk.utils.productpage.getSelectedModelId();
		// Persist it
		fwk.enhanced.set(enhancedActual);
		fwk.enhanced.persist();
	});
	tracker.addEvent(addToCart);
	
	// Select Delivery
	var selectDelivery = new AnalyticsClickEvent('selectDelivery', tracker.defaultEvent());
	selectDelivery.domContainer = '#shipping-information';
	selectDelivery.domElement = '.shipping-type .shipping-mode, .shipping-type .shipping-stores-list>li>strong';
	selectDelivery.options.action = 'SelectDelivery';
	selectDelivery.getLabel = function($element){
		var shippingMode = $element.closest('.shipping-type').find('.shipping-mode>strong').text();
		var shippingDetail = $element.is('strong') ? sep + $element.text() : '';
		return getProductLabel() + sep + shippingMode + shippingDetail;
	};
	selectDelivery.getValue = getPrice;
	tracker.addEvent(selectDelivery);

	// Modify my location
	var modifyMyLocation = new AnalyticsClickEvent('modifyMyLocation', tracker.defaultEvent());
	modifyMyLocation.options.action = 'ModifyMyLocation';
	modifyMyLocation.domContainer = '#shipping-wrapper';
	modifyMyLocation.domElement = '[data-target="#location-modal"]';
	modifyMyLocation.getLabel = getProductLabel;
	modifyMyLocation.getValue = getPrice;
	tracker.addEvent(modifyMyLocation);

	// CrossSell - Move to cart
	var eventAddToCartCrossSell = new AnalyticsEvent('virtualEventAddToCartCrossSell', tracker.defaultEvent());
	tracker.addEvent(eventAddToCartCrossSell);
	
	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('body').hasClass('product-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.conversion.name);
	});
}
(function($) {

	// TRACKER 'PRODUCT-MEDIA'

	var sep = AnalyticsConstants.concatenator;
	var fwk = CUBE.Analytics;
	var utils = fwk.utils.productpage;
	
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.media);

	var getProductLabel = function() {
		var productName = tc_vars.product_label_displayed;
		var productNature = '%PRODUCT_NATURE%'; // TODO : tc_vars.product_nature;
		var modelId = utils.getSelectedModelId();
		return productName + sep + modelId;
	};
	
	// MoreViews
	var moreInformations = new AnalyticsClickEvent('moreInformations', tracker.defaultEvent());
	moreInformations.domElement = '.product-informations > a';
	moreInformations.options.action = 'MoreInformations';
	moreInformations.getLabel = getProductLabel;
	tracker.addEvent(moreInformations);
	
	// MoreViews
	var moreViews = new AnalyticsClickEvent('moreViews', tracker.defaultEvent());
	moreViews.domElement = '[data-toggle="gallery"]';
	moreViews.options.action = 'MoreViews';
	moreViews.getLabel = getProductLabel;
	tracker.addEvent(moreViews);
	
	// tabContent
	var tabContent = new AnalyticsClickEvent('tabContent', tracker.defaultEvent());
	tabContent.domContainer = 'nav#sticky-product-nav';
	tabContent.domElement = 'a';
	tabContent.getAction = function($element) {
		var indexTab = $element.closest('nav').find('a').index($element) + 1;
		var labelTab = $element.attr('id').replace('_Tab', '');
		return 'Tab-' + indexTab + '-' + labelTab;
	};
	tabContent.getLabel = getProductLabel;
	//tabContent.getValue = function(){ return productPrice; };
	tracker.addEvent(tabContent);

	// Slick Pictures
	var productPicture = new AnalyticsSlickEvent('productPicture', tracker.defaultEvent());
	productPicture.domContainer = '.slick-pp-pictures-img';
	productPicture.trackArrows({
		getAction: function($element) {
			if ($element.hasClass(AnalyticsConstants.slick.selectorCssArrowNext.replace('.', ''))) return 'Pictures-NextPicture';
			if ($element.hasClass(AnalyticsConstants.slick.selectorCssArrowPrev.replace('.', ''))) return 'Pictures-PreviousPicture';
			return '';
		},
		getLabel: getProductLabel
	});
	tracker.addEvent(productPicture);

	// Swiper Pictures
	var swipeProductPicture = new AnalyticsClickEvent('swipeProductPicture', tracker.defaultEvent());
	swipeProductPicture.domElement = '.swiper-container div[class^="swiper-button"]';
	swipeProductPicture.getAction = function($element) {
		var action = "Pictures-";
		if ($element.hasClass('swiper-button-prev'))
			action += 'PreviousPicture';
		else
			action += 'NextPicture';
		return action;
	};
	swipeProductPicture.getLabel = getProductLabel;
	tracker.addEvent(swipeProductPicture);
	
	

	// -------------
	// GALLERY EVENTS

	// GALLERY - Arrows
	var galleryArrows = new AnalyticsClickEvent('galleryArrows', tracker.defaultEvent());
	galleryArrows.domContainer = '#myGallery';
	galleryArrows.domElement = 'div.gallery-tool-previous, div.gallery-tool-next';
	galleryArrows.getAction = function($element) {
		if ($element.hasClass('gallery-tool-next')) return 'Zoom-ArrowNextPicture';
		if ($element.hasClass('gallery-tool-previous')) return 'Zoom-ArrowPreviousPicture';
		return '';
	};
	galleryArrows.getLabel = getProductLabel;
	tracker.addEvent(galleryArrows);

	// GALLERY - Category
	var galleryCategory = new AnalyticsClickEvent('galleryCategory', tracker.defaultEvent());
	galleryCategory.domContainer = '#myGallery';
	galleryCategory.domElement = '.gallery-panel-category a';
	galleryCategory.getAction = function($element) {
		var value = $element.text().trim();
		return 'Zoom-ClickCategory-' + value;
	};
	galleryCategory.getLabel = getProductLabel;
	tracker.addEvent(galleryCategory);
	
	// GALLERY - Picture list
	var galleryPictureList = new AnalyticsClickEvent('galleryPictureList', tracker.defaultEvent());
	galleryPictureList.domContainer = '#myGallery .gallery-panel-media ul.picture, #myGallery .gallery-panel-media ul.video';
	galleryPictureList.domElement = 'li';
	galleryPictureList.getAction = function($element) {
		var indexElement = $element.closest('ul').find('li').index($element) + 1;
		var typeList = $element.closest('ul').hasClass('picture') ? 'Picture' : 'Video';
		return 'Zoom-Click' + typeList + '-' + indexElement;
	};
	galleryPictureList.getLabel = getProductLabel;
	tracker.addEvent(galleryPictureList);
	
	// GALLERY - Zoom (scroll) in big picture
	var galleryBigZoom = new AnalyticsTriggerEvent('galleryBigZoom', tracker.defaultEvent());
	galleryBigZoom.trigger = 'mousewheel';
	galleryBigZoom.domContainer = '#myGallery';
	galleryBigZoom.domElement = '.gallery-panel-viewer';
	galleryBigZoom.getAction = function() {
		var indexElement = $('.gallery-panel-media ul.picture li').index($('.gallery-panel-media ul.picture li.active')) + 1;
		return 'Big-Zoom-' + indexElement;
	};
	galleryBigZoom.getLabel = getProductLabel;
	tracker.addEvent(galleryBigZoom);
	
	// GALLERY - Close button
	var galleryClose = new AnalyticsClickEvent('galleryClose', tracker.defaultEvent());
	galleryClose.domContainer = '#myGallery';
	galleryClose.domElement = '.gallery-tool-close';
	galleryClose.options.action = 'Zoom-Close';
	galleryClose.getLabel = getProductLabel;
	tracker.addEvent(galleryClose);

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('body').hasClass('product-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.media.name);
	});
}
(function($) {

	// TRACKER 'PRODUCT-CONVERSION'
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.review);

	var productNature = '%PRODUCT_NATURE%'; // tc_vars.product_nature;
	var productName = tc_vars.product_label_displayed;
	var productId = tc_vars.product_id_model;
	var productPrice = tc_vars.product_currentprice_ati;

	var returnLabel = productName + AnalyticsConstants.concatenator + productId;

	// reviewAnchor
	var reviewAnchor = new AnalyticsClickEvent('reviewAnchor', tracker.defaultEvent());
	reviewAnchor.domElement = '.link-review.goTo';
	reviewAnchor.options.action = 'Product_Click-Review-Anchor';
	reviewAnchor.options.label = returnLabel;
	tracker.addEvent(reviewAnchor);

	// reviewTab
	var reviewTab = new AnalyticsClickEvent('reviewTab', tracker.defaultEvent());
	reviewTab.domElement = 'a[href^="#floor_user_reviews"]';
	reviewTab.options.action = 'Product_Click-Review-Tab';
	reviewTab.options.label = returnLabel;
	tracker.addEvent(reviewTab);

	// menuWriteReview
	var menuWriteReview = new AnalyticsClickEvent('menuWriteReview', tracker.defaultEvent());
	menuWriteReview.domElement = '[data-tracking="btn-write-review"]';
	menuWriteReview.options.action = 'Product_WriteMenu';
	menuWriteReview.options.label = returnLabel;
	tracker.addEvent(menuWriteReview);

	// menuSeeReviews
	var menuSeeReviews = new AnalyticsClickEvent('menuSeeReviews', tracker.defaultEvent());
	menuSeeReviews.domElement = '[data-tracking="btn-see-reviews"]';
	menuSeeReviews.options.action = 'Product_Click-All-Reviews';
	menuSeeReviews.options.label = returnLabel;
	tracker.addEvent(menuSeeReviews);

	// reviewReadMore
	var reviewReadMore = new AnalyticsClickEvent('reviewReadMore', tracker.defaultEvent());
	reviewReadMore.domElement = '.view-full-review';
	reviewReadMore.options.action = 'Product_ReadMore';
	reviewReadMore.getLabel = function($element) {
		return this.getReviewId($element);
	};
	reviewReadMore.stopEvent = function($element) {
 		if ($element.find('.ico-less').length) return true;
 	};
 	reviewReadMore.getReviewId = function($element) {
 		var data = $element.closest('.review-txt').siblings('iframe').attr('src').split('/');
 		return data[(data.length-2)];
 	};
	tracker.addEvent(reviewReadMore);


	// reviewNotation
	var reviewNotation = new AnalyticsClickEvent('reviewNotation', tracker.defaultEvent());
	reviewNotation.domElement = '.notation-box .notation-filter a';
	reviewNotation.options.action = 'Product_ReadMore';
	reviewNotation.getAction = function($element) {
		var note = $element.closest('.notation-filter').find('.rate-text').text();
		return 'Product_Clik-' + note;
	};
	reviewNotation.options.label = returnLabel;
	tracker.addEvent(reviewNotation);
	
	
	// Pagination
	
	// Click on page number // TODO : Waiting for datalyer informations
	/*
	var reviewPaginationEvent = new AnalyticsClickEvent('reviewPagination', tracker.defaultEvent());
	reviewPaginationEvent.domElement = 'a';
	reviewPaginationEvent.domContainer = 'ul.pagination';
	reviewPaginationEvent.options.action = 'Product_Pagination';
	reviewPaginationEvent.getLabel = function($element) {
		var note = $element.closest('.notation-filter').find('.rate-text').text();
		return 'Product_Clik-' + note;
	};
	tracker.addEvent(reviewPaginationEvent);
	*/

	CUBE.Analytics.trackers.add(tracker);
	
})(jQuery);

if($('body').hasClass('product-page') || $('body').hasClass('reviews-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.review.name);
	});
}
(function($) {

	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separator;
	
	// DEFINE 'productList' TRACKER
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.productList);
	
	var containerSpotlight = '#lpt-tg div.slick-track';
	var containerSpotlightFloor = '#spotlightFloor div.product';
	var containerProductFloor = '#listing-product';
	var containerCrossSellProduct = '#often-bought-list .plv2-element';
	
	/*
	 * SPOTLIGHT
	 */
	var eventSpotlight = new AnalyticsClickEvent('eventSpotlight', tracker.defaultEvent());
	eventSpotlight.options.action = 'PushSpotlight';
	eventSpotlight.domContainer = containerSpotlight;
	eventSpotlight.domElement = 'a';
	eventSpotlight.getLabel = function($element) {
		var slide = $element.closest('.slick-slide');
		var index = (slide.closest('.slick-track').find('> .slick-slide:not(.slick-cloned)').index(slide) + 1);
		return getLabel($element, index);
	};
	eventSpotlight.getValue = getValue;
//	eventSpotlight.postAction(fwk.shoppingtool.reBind.bind(fwk.shoppingtool));
	tracker.addEvent(eventSpotlight);
	
	/*
	 * SPOTLIGHT FLOOR
	 */
	var eventSpotlightFloor = new AnalyticsClickEvent('eventSpotlightFloor', tracker.defaultEvent());
	eventSpotlightFloor.options.action = 'PushSpotlightFloor';
	eventSpotlightFloor.domContainer = containerSpotlightFloor;
	eventSpotlightFloor.domElement = 'a';
	eventSpotlightFloor.getLabel = function($element) {
		var product = $element.closest('.product');
		var index = ($('.product').index(product) + 1);
		return getLabel($element, index);
	};
	eventSpotlightFloor.getValue = getValue;
//	eventSpotlightFloor.postAction(fwk.shoppingtool.reBind.bind(fwk.shoppingtool));
	tracker.addEvent(eventSpotlightFloor);
	
	/*
	 * LISTING PRODUCT
	 */
	var eventListingProduct = new AnalyticsClickEvent('eventListingProduct', tracker.defaultEvent());
	eventListingProduct.options.action = 'PositionClick';
	eventListingProduct.domContainer = containerProductFloor;
	eventListingProduct.domElement = 'div.product a';
	eventListingProduct.getLabel = function($element) {
		var product = $element.closest('.product');
		var index = ($('.product').index(product) + 1);
		return getLabel($element, index);
	};
	eventListingProduct.getValue = getValue;
//	eventListingProduct.postAction(fwk.shoppingtool.reBind.bind(fwk.shoppingtool));
	tracker.addEvent(eventListingProduct);

	CUBE.Analytics.trackers.add(tracker);

	var getLabel = function(element, index) {
		var model = fwk.utils.pagelist.getModel(element);
		return AnalyticsConstants.slick.defaultValuePosition + index + sep + model.name + sep + model.id;
	};
	var getValue = function(element) {
		var model = fwk.utils.pagelist.getModel(element);
		return model.price;
	};

})(jQuery);

if($('body').hasClass('listing-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.productList.name);
	});
}
(function($) {

	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separator;
	
	var containerCrossSellProduct = '#often-bought-list .plv2-element';

	/*
	 * CROSSSELL PRODUCT
	 */
	var tracker;
	if (tc_vars.env_template === "product") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.crosssell);
	} else if (tc_vars.env_template === "suggestions") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.suggestions.crosssell);
	}
	
	if (tracker !== undefined) {
		var eventCrossSellProduct = new AnalyticsClickEvent('eventCrosssellProduct', tracker.defaultEvent());
		eventCrossSellProduct.options.action = 'PositionClick';
		eventCrossSellProduct.domContainer = containerCrossSellProduct;
		eventCrossSellProduct.domElement = '.plv2-el__image a';
		eventCrossSellProduct.getLabel = function($element) {
			var product = $element.closest('.plv2-element');
			var index = product.data("index");
			return getLabel(product, index);
		};
		eventCrossSellProduct.getValue = getValue;
		tracker.addEvent(eventCrossSellProduct);
		
		CUBE.Analytics.trackers.add(tracker);
	}

	var getLabel = function(element, index) {
		var model = fwk.utils.productpage.getCrossSellModel(element.data("productid"), 'SM');
		return AnalyticsConstants.slick.defaultValuePosition + index + sep + model.name + sep + model.id;
	};
	var getValue = function(element) {
		var model = fwk.utils.productpage.getCrossSellModel(element.data("productid"), 'SM');
		return model.price;
	};

})(jQuery);

if($('body').hasClass('product-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.crosssell.name);
	});
}
if($('body').hasClass('our-suggestions-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.suggestions.crosssell.name);
	});
}

(function($) {

	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separator;
	
	var containerLvpProduct = '#perso-lvp-list .lvp-element';

	/*
	 * LVP PRODUCT
	 */
	var tracker;
	if (tc_vars.env_template === "homepage") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.homepage.lvp);
	} else if (tc_vars.env_template === "product") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.lvp);
	} else if (tc_vars.env_template === "checkout") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.funnel.lvp);
	} else if (tc_vars.env_template === "list" || tc_vars.env_template === "internal_search") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.productList.lvp);
	} else if (tc_vars.env_template === "other_myaccount") {
		tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.lvp);
		containerLvpProduct = ".slick-lvp .lvp-element";
	} else
		return;
	
	if (tracker !== undefined) {
		var eventLvpProduct = new AnalyticsClickEvent('eventLvpProduct', tracker.defaultEvent());
		eventLvpProduct.trigger = 'click';
		eventLvpProduct.options.action = 'PositionClick';
		eventLvpProduct.domContainer = containerLvpProduct;
		eventLvpProduct.domElement = 'a.clickable-area';
		eventLvpProduct.getLabel = function($element) {
			return getLabel($element.closest('.lvp-element'));
		};
		eventLvpProduct.getValue = function($element) {
			return getValue($element.closest('.lvp-element'));

		};
		tracker.addEvent(eventLvpProduct);
	}
	
	var getLabel = function($currentLVP) {
		var index = $('.lvp-element').index($currentLVP) + 1;
		return AnalyticsConstants.slick.defaultValuePosition + index + sep + $currentLVP.find(".product-name").text() + sep + $currentLVP.data("model-id");
	};
	var getValue = function($currentLVP) {
		return $currentLVP.find('.price-container .price').data("price");
	};

	CUBE.Analytics.trackers.add(tracker);
	
	

})(jQuery);
if($('body').hasClass('homepage')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.homepage.lvp.name);
	});
}
if($('body').hasClass('product-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.lvp.name);
	});
}
if($('body').hasClass('checkout')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.funnel.lvp.name);
	});
}
if($('body').hasClass('listing-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.productList.lvp.name);
	});
}
if($('body').hasClass('dashboard-page')){
	$(function(){
    	CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.customer.lvp.name);
	});
}
(function($) {

	// TRACKER 'HOMEPAGE'
	var sep = AnalyticsConstants.concatenator;
	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var classProductViewed = 'viewed';
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.panoply);
	
	var getProductLabel = function() {
		var productName = tc_vars.product_label_displayed;
		var modelId = utils.productpage.getSelectedModelId();
		return productName + sep + modelId;
	};
	var getPrice = function() { return utils.productpage.getSelectedPrice(); };
	

	var arrowLeftPanoply = new AnalyticsClickEvent('arrowLeftPanoply', tracker.defaultEvent());
	arrowLeftPanoply.options.action = AnalyticsConstants.slick.defaultValueArrowLeft;
	arrowLeftPanoply.domElement = '#product-bundles .slick-prev';
	arrowLeftPanoply.getLabel = getProductLabel;
	arrowLeftPanoply.getValue = getPrice;
	arrowLeftPanoply.postAction(function($element) {
		var indexPanoply = $("#product-bundles .slick-slide.slick-active").index();
		if (indexPanoply === -1) {
			indexPanoply = 0;
		}
		sendImpressionPanoply(indexPanoply, $element);
	});
	tracker.addEvent(arrowLeftPanoply);
	
	var arrowRightPanoply = new AnalyticsClickEvent('arrowRightPanoply', tracker.defaultEvent());
	arrowRightPanoply.options.action = AnalyticsConstants.slick.defaultValueArrowRight;
	arrowRightPanoply.domElement = '#product-bundles .slick-next';
	arrowRightPanoply.getLabel = getProductLabel;
	arrowRightPanoply.getValue = getPrice;
	arrowRightPanoply.postAction(function($element) {
		var indexPanoply = $("#product-bundles .slick-slide.slick-active").index();
		if (indexPanoply === -1) {
			indexPanoply = 0;
		}
		sendImpressionPanoply(indexPanoply, $element);
	});
	tracker.addEvent(arrowRightPanoply);
	
	var getAction = function(element) { 
		return AnalyticsConstants.slick.defaultValuePagination + (element.parent().find(element).index() + 1); 
	};
	
	var paginationPanoply = new AnalyticsClickEvent('paginationPanoply', tracker.defaultEvent());
	paginationPanoply.getAction = getAction;
	paginationPanoply.domElement = '#product-bundles .slick-dots li';
	paginationPanoply.getLabel = getProductLabel;
	paginationPanoply.getValue = getPrice;
	paginationPanoply.postAction(function($element) {
		var indexPanoply = $element.parent().find($element).index();
		sendImpressionPanoply(indexPanoply, $element);
	});
	tracker.addEvent(paginationPanoply);

	
	CUBE.Analytics.trackers.add(tracker);
	
	
	var sendImpressionPanoply = function(indexPanoply, $element) {
		$('.slick-active .pb-el__product').each(function() { 
    		setProductPanoplyAsViewed(indexPanoply, $(this));
    	});
    };
	
	var setProductPanoplyAsViewed = function(indexPanoply, $product) {
		if (utils.isVisible($product) && !$product.hasClass(classProductViewed)) {
			var model = utils.productpage.getPanoplyModel(indexPanoply, $product.data("productid"), "SM");
            fwk.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
		}
	};
	
})(jQuery);

// -- INIT
if($('body').hasClass('product-page')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.panoply.name);
	});
}

(function($) {

	// TRACKER PRODUCT PAGE PANOPLY
	var tracker = new AnalyticsTracker(AnalyticsConstants.trackers.product.addPanoply);
	var sep = AnalyticsConstants.separator;
	var fwk = CUBE.Analytics;

	var productName = tc_vars.product_label_displayed;
	var productId = tc_vars.product_id_model;

	// CloseConversion
	var closeConversion = new AnalyticsClickEvent('closeConversion', tracker.defaultEvent());
	closeConversion.options.action = 'CloseConversionLayer';
	closeConversion.domContainer = '#modal-product-bundles';
	closeConversion.domElement = '.ms__close';
	closeConversion.getLabel = returnLabel;
	closeConversion.getValue = returnValue;
	tracker.addEvent(closeConversion);
	
	var returnLabel = function() { return productName + sep + fwk.utils.productpage.getSelectedModelId(); };
	var returnValue = function() { fwk.utils.productpage.getSelectedPrice(); };
	
	var commonEvent = function(commonGetters) {
		if (typeof commonGetters == 'undefined') commonGetters = true;
		var commonEvent = new AnalyticsClickEvent('event', tracker.defaultEvent());
		commonEvent.domContainer = '#modal-express-payment-layout';
		if (commonGetters) {
			commonEvent.getLabel = returnLabel;
			commonEvent.getValue = returnValue;
		}
		return commonEvent;
	};

	// VIRTUAL PAGE - ADD TO PANOPLY
	var addPanoplyVirtualDetail = new AnalyticsEvent('addPanoplyVirtualDetail', tracker.defaultEvent());
	tracker.addEvent(addPanoplyVirtualDetail);

	CUBE.Analytics.trackers.add(tracker);

})(jQuery);

// -- INIT
if($('body').hasClass('product-page')){
	$(function(){
		CUBE.Analytics.trackers.init(AnalyticsConstants.trackers.product.addPanoply.name);
	});
}
$(function() {
	/*
	 * 
	 * - FIXME -
	 * ---------
	 * Direct ShoppingTool is now located in CUBE.Analytics.shoppingtool.init(), as it's the default event
	 * ---------
	 * 
	// Execute only on Product Page
	if(tc_vars.env_template === "product") {
		
		console.log('Shopping-Tool - Direct');
		var checkRef = "localhost:9000"; // decathlon. // TODO - UPDATE for non-local
		
		var referrer = document.referrer;
		if (referrer === "" || referrer.indexOf(checkRef) === -1) {
			// It's a direct access
			CUBE.Analytics.shoppingtool.set("direct", "access");
		}
		
	}
	*/
});
$(function() {
	
	/* SHOPPING TOOL - HOMEPAGE */
	
	if (tc_vars.env_template !== "homepage")
		return;

	var fwk = CUBE.Analytics;
	var utils = fwk.utils.homepage;
	var sep = AnalyticsConstants.separatorST;
	
	var stType = "merchandising-hp";

    var trackerName = AnalyticsConstants.trackers.homepage.homepage.name;
    if (!CUBE.Analytics.trackers.list[trackerName])
        return;

    var eventName = "hpPushProduct";
    if (!CUBE.Analytics.trackers.list[trackerName].events[eventName])
        return;
        
    // Get the 'hpPushProduct' event
    var event = CUBE.Analytics.trackers.list[trackerName].events[eventName];
    
    event.postAction(function($element) {
		
		var positionFloor = utils.getFloorIndex($element);
		var positionProduct = utils.getProductIndex($element);
		
		fwk.shoppingtool.set(stType, 'floor' + sep + positionFloor + sep + 'position' + sep + positionProduct);
    	
    });
	
});
$(function() {
	
	/* SHOPPING TOOL - NAVIGATION */
	
	var fwk = CUBE.Analytics;
	
	var stType = "navigation";
	
	// CLICK on navigation menu link
	$("#menu-global").on('click.st', 'a[href^="/"][data-submenu],a[href^="/"][role="menuitem"],a.sport-link', function() {
		var _urlCategory = fwk.utils.getInfoNavFromURLForShoppingTool($(this).attr('href'));
		if (_urlCategory !== null && _urlCategory !== "" && _urlCategory.endsWith("_")) {
			_urlCategory = _urlCategory.substr(0,_urlCategory.length -2);
		}
		
		if (_urlCategory !== null && _urlCategory !== "") {
			var _splitUrlCategory = _urlCategory.split("/");
			_urlCategory = _splitUrlCategory[_splitUrlCategory.length - 1];
		}
		
		CUBE.Analytics.shoppingtool.set("navigation", _urlCategory);
	});
		
});
$(function() {
	
	/* SHOPPING TOOL - BREADCRUMB */

	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	
	var stType = "navigation-breadcrumb";
	
	// CSS Selector : 'breadcrumb menu'
	var breadcrumbSelector = "ul.breadcrumbs";
	
	// CLICK on 'breadcrumb menu' link
	$(breadcrumbSelector).on('click.st', 'a', function() {
		
		var position = $(this).closest('ul').find('a').index($(this));
		
		fwk.shoppingtool.set(stType + '', fwk.utils.getInfoNavFromURLForShoppingTool($(this).attr('href')) + sep + 'level' + sep + position);
	});
		
});
$(function() {
	
	/* SHOPPING TOOL - TG & PUSH */
	
	if (!(tc_vars.env_template === "list" || tc_vars.env_template === "internal_search" || tc_vars.env_template === "product"))
		return;
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	var lock = AnalyticsConstants.shoppingtool.lock;

	// ShoppingTool
	var st = fwk.shoppingtool.get();
	var stType = 'merchandising';
	
	if (st && st.st)
		stType = st.st;
	
	// Events name
	var nameEventSpotlight = 'eventSpotlight';
	var nameEventSpotlightFloor = 'eventSpotlightFloor';
	var nameEventListingProduct = 'eventListingProduct';

    var trackerName = AnalyticsConstants.trackers.product.productList.name;
    if (!CUBE.Analytics.trackers.list[trackerName])
        return;
    
    // Get events
    var eventSpotlight = CUBE.Analytics.trackers.list[trackerName].events[nameEventSpotlight];
    var eventSpotlightFloor = CUBE.Analytics.trackers.list[trackerName].events[nameEventSpotlightFloor];
    var eventListingProduct = CUBE.Analytics.trackers.list[trackerName].events[nameEventListingProduct];

    if (eventSpotlight) {
    	// Click on SPOTLIGHT products
	    eventSpotlight.postAction(function($element) {
			var sticker = fwk.utils.pagelist.getStickerValue(fwk.utils.pagelist.getStickerSpotlight());
			var model = fwk.utils.pagelist.getModel($element);
			
			var slide = $element.closest('.pl-element.slick-slide');
			var position = slide.data('slick-index') + 1;
			
			var stDetail = sticker + 'position' + sep + position;
			fwk.shoppingtool.set('merchandising-spotlight-top', stDetail, fwk.colorama.getDetail(model.id));
	    });
    }

    if (eventSpotlightFloor) {
    	// Click on SPOTLIGHT FLOOR products
    	eventSpotlightFloor.postAction(function($element) {
			var sticker = fwk.utils.pagelist.getStickerValue(fwk.utils.pagelist.getSticker($element));
			var model = fwk.utils.pagelist.getModel($element);
			
    		var product = $element.closest('.product');
    		var position = $('.product').index(product) + 1;
    		var wide = product.hasClass('wide') ? sep + 'wide' : '';

    		var stDetail = sticker + 'position' + sep + position + wide;
    		fwk.shoppingtool.set('merchandising-spotlightfloor-bottom', stDetail, fwk.colorama.getDetail(model.id));
	    });
    }

    if (eventListingProduct) {
    	// Click on SPOTLIGHT FLOOR products
    	eventListingProduct.postAction(function($element) {
    		var st = fwk.shoppingtool.getActual();
			var model = fwk.utils.pagelist.getModel($element);

    		var product = $element.closest('.product');
    		var position = $('.product').index(product) + 1;

    		fwk.shoppingtool.set(st.st, st.std, fwk.colorama.getDetail(model.id));
	    });
    }
}); 
$(function() {
	
	/* SHOPPING TOOL - CAROUSEL CATEGORY */
	
	if (tc_vars.env_template !== "list")
		return;

	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	
	var stType = "navigation-carousel-category";
	
	// CSS Selector : 'carousel category'
	var carouselSelector = "#product-list-categories";
	
	// NAVIGATION Carousel-Category
	$(carouselSelector).on('click.st', '.category.slick-slide', function() {
		
		var categoryName = $(this).find('h3.title').text().trim().toLowerCase().split(' ').join('-');
		
		fwk.shoppingtool.set(stType, categoryName);
	});
		
});
$(function() {
	
	/* SHOPPING TOOL - COLORAMA */
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	
	/**
	 * COLORAMA on PAGELIST (Spotlightlist + Productlist)
	 * 
	 * 	- If colorama changes : we add the 'model id' in the listColorama
	 * 
	 */
	if (tc_vars.env_template === "list" || tc_vars.env_template === "internal_search") {
		
		var coloramaProductListSelector = '.product, #lpt-tg .pl-wrapper .slick-slide';
		$(coloramaProductListSelector).on('afterChange', function(e, slick, index) {
			
			var model = fwk.utils.pagelist.getModel($(this).find('.inner-element'));
			
			// Add COLORAMMA to list
			if (index !== 0) // Index == 0 > Default product (no colorama)
				fwk.colorama.add(model.id, 'pagelist');
		});
	}
	

	/**
	 * COLORAMA on PRODUCT PAGE
	 * 
	 * 	- If we land on product page with a previous colorama : we save it in the listColorama for the default 'model id'
	 * 	- If colorama changes : we add the information (product or conversion) and the model id to the listColorama
	 * 	- After each change : we update and persist the current state of the ST Colorama
	 * 
	 */
	if (tc_vars.env_template === "product") {
		
		// If we land here with a previous colorama (e.g. pagelist), we persist it for the default product
		var stPage = fwk.shoppingtool.get();
		if (stPage.stc)
			fwk.colorama.add(tc_vars.product_id_model, stPage.stc.replace('colorama-', ''));
 
		var coloramaProductPageSelector = '.m-product-wrapper .product-visual-wrapper';
		$(coloramaProductPageSelector).on('afterChange', function(e, slick, index) {
			addColoramaToStForProductPage(slick, index, false);
		});
	
		var addColoramaToStForProductPage = function(slick, index, isCrossSell) { 
			var currentSlide = slick.$slides.get(index);
			var modelId = $(currentSlide).data('model-id');
			
			// Add COLORAMMA to list
			if (index !== 0) { // Index == 0 > Default product (previous colorama, if any)
				if (fwk.utils.productpage.isConversionOpen())
					fwk.colorama.add(modelId, 'conversion');
				else {
					if (!isCrossSell) 
						fwk.colorama.add(modelId, 'product');
				}
					
			}
			
			// Update & persist ST Colorama
			var st = fwk.shoppingtool.getActual();
			fwk.shoppingtool.set(st.st, st.std, fwk.colorama.getDetail(modelId));
			fwk.shoppingtool.persist();
			
		};
	}

	/**
	 * COLORAMA on LVP
	 *
	 *	When a colorama is change on a LVP, save the modelId to keep trace
	 *	(except for the reference model id > default color, no colorama)
	 *
	 */
	if ($('#perso-lvp-list').length !== 0) {
		$('#perso-lvp-list .slider-models').on('afterChange', function(e, slick, index) {
			if (!$(this).closest('.lvp-element').hasClass('direct-add'))
				return;
			var currentSlide = slick.$slides.get(index);
			var modelId = $(currentSlide).data('model-id');
			var refModelId = $(this).closest('.lvp-element').data('model-id');

			if (modelId != refModelId)
				fwk.colorama.add(modelId, 'lvp');

			var st = fwk.shoppingtool.getActual();

			if ($(this).closest('.lvp-element').hasClass('fully-loaded'))
				fwk.shoppingtool.setTmp(st.st, st.std, st.label, st.value, fwk.colorama.getDetail(modelId));
		});
	}
	
});
$(function() {
	
	/* SHOPPING TOOL - INTERNAL SEARCH */
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	var lock = AnalyticsConstants.shoppingtool.lock;
	
	var stType = 'internal-search';
	
	// CSS Selectors for the differents Typeahead elements
	var typeahead = ".twitter-typeahead";
	var selectorInput = '#search-autocomplete';
	var selectorBtn = '#search-button';
	var selectorSuggestion = '.tt-dataset a';
	
	// KEYDOWN - Manual search
	$(typeahead).on('keydown.st', selectorInput, function(e) {
		if (e.keyCode === 13) {
			if (lock.search) fwk.shoppingtool.set(stType + '-autocompletion', $(this).val().trim());
			else fwk.shoppingtool.set(stType + '-standard', $(this).val().trim());
		} else if (e.keyCode > 27)
			lock.search = false;
	});
	
	// CLICK on 'search' button
	$(typeahead).on('click.st', selectorBtn, function(e) {
		fwk.shoppingtool.set(stType + '-standard', $(this).closest('form').find(selectorInput).val().trim());
	});
	
	// CLICK on suggestion
	$(typeahead).on('click.st', selectorSuggestion, function(e) {
		
		if ($(this).closest('.tt-dataset').hasClass('tt-dataset-products')) {
			// Click on PRODUCT
			fwk.shoppingtool.set(stType + '-autocompletion-product', $(this).data('id'));
		} else if ($(this).closest('.tt-dataset').hasClass('tt-dataset-categories')) {
			// Click on CATEGORY
			if ($(this).hasClass('tt-empty')) {
				// EMPTY (standard search)
				fwk.shoppingtool.set(stType + '-standard', $(this).find('strong').text().trim());
			} else {
				// NOT EMPTY
				fwk.shoppingtool.set(stType + '-autocompletion-category', $(this).text().trim());
			}
		}
		
	});
	
	// EVENT : Select a suggestion (autocomplete)
	$(typeahead).on('typeahead:autocomplete', function(e, elt) { lock.search = true; });
	$(typeahead).on('typeahead:select', function(e, elt) { lock.search = true; });
	// Note : "lock.search = true" = the current research is made by an autocompletion
	
});
$(function() {
	
	/*
		SHOPPING TOOL - OPECO
	*/
	
	if (typeof getURLParameter !== 'function') return;
	
	var url = window.location.href.replace('#', '?');
	
	var paramType = getURLParameterFromUrlString(url, 'type');
	if (!paramType) return;
	
	var paramOpeco = getURLParameterFromUrlString(url, paramType);
	if (!paramOpeco) return;
	
	var _datas = paramOpeco.split(':');
	var _st = _datas[0];
	var _std = _datas[1];
	
	CUBE.Analytics.shoppingtool.set(_st, _std);
	
	// TODO - Check if other shoppingtools needs to be locked
		
	// TODO - Is it possible to land directly on a product page with an OPECO ?
	
});
$(function() {
	/* SHOPPING TOOL - CROSS SELL */
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	var lock = AnalyticsConstants.shoppingtool.lock;
	
	var stType = 'merchandising';

	// CSS Selector : 'cross' on Product Page and Add To Cart Page
	var crosssellAddProductPageAndAddToCartPageSelector = '#often-bought-list a.cta.cart';
	var crosssellProductPageAndAddToCartPageSelector = '#often-bought-list a:not(.cta.cart)';
	
	// CSS Selector : 'cross' on Basket Page
	var crosssellAddBasketPageSelector = '.cross-sell .csp__cta a';
	
	// Click to CrossSell product on Product Page cross-sell and Add To Cart Page
	$(crosssellProductPageAndAddToCartPageSelector).on('click.st', function() {
		var idModel, position, $product;
		
		$product = $(this).closest('.plv2-element');
		position = fwk.crosssell.getPosition($product, '.plv2-element', '.product-list-v2');
		idModel = fwk.crosssell.getIdModelProductPage($product);
		
		var label = tc_vars.list_crosssells[position-1].list_crosssell_label_displayed;
		var value = tc_vars.list_crosssells[position-1].list_crosssell_currentprice_ati;
		
		var crosssell_st = fwk.crosssell.hasColoramaSelected(position);
		if (!crosssell_st) {
			var type_page = 'product-page';
			if (tc_vars.env_template === "suggestions") {
				type_page = 'addtocart-page';
			}
			crosssell_st = fwk.crosssell.buildStDetail(type_page, position, idModel, '');
		}
		fwk.shoppingtool.set(stType, crosssell_st);
	});
	
	// Click to Add on Product Page cross-sell and Add To Cart Page
	$(crosssellAddProductPageAndAddToCartPageSelector).on('click.st', function() {
		var idModel, position, $product, stColorama;
		
		$product = $(this).closest('.plv2-element');
		position = fwk.crosssell.getPosition($product, '.plv2-element', '.product-list-v2');
		idModel = fwk.crosssell.getIdModelProductPage($product);
		stColorama = (tc_vars.list_crosssells[position-1].list_crosssell_id_model == idModel) ? '' : 'colorama-crosssell';

		var label = tc_vars.list_crosssells[position-1].list_crosssell_label_displayed;
		var value = tc_vars.list_crosssells[position-1].list_crosssell_currentprice_ati;
		
		var type_page = 'product-page';
		var trackers_page = AnalyticsConstants.trackers.product.crosssellMoveToCart.name;
		if (tc_vars.env_template === "suggestions") {
			type_page = 'addtocart-page';
			trackers_page = AnalyticsConstants.trackers.suggestions.crosssellMoveToCart.name;
		}
		fwk.shoppingtool.setTmp(stType, fwk.crosssell.buildStDetail(type_page, position, idModel, stColorama), label, value);
		
		var eventAddToCartCrossSell = fwk.utils.getEvent('virtualEventAddToCartCrossSell', trackers_page);
		eventAddToCartCrossSell.params.refId = idModel;
		CUBE.Analytics.utils.sendEvent('virtualEventAddToCartCrossSell', trackers_page);
	});
	
	// Click to Add on Basket Page cross-sell
	$(crosssellAddBasketPageSelector).on('click.st', function() {
		var $product = $(this).parents(".cs-product");
		var refId = $product.data("productid");
		var position = fwk.crosssell.getPosition($product, '.cs-product', '.cross-sell');
		
		var modelId = tc_vars.list_crosssells[position-1].list_crosssell_id_model;
		var label = tc_vars.list_crosssells[position-1].list_crosssell_label_displayed;
		var value = tc_vars.list_crosssells[position-1].list_crosssell_currentprice_ati;
		fwk.shoppingtool.setTmp(stType, fwk.crosssell.buildStDetail('basket-page', position, modelId, ''), label, value);
		
		var eventAddToCartCrossSell = fwk.utils.getEvent('virtualEventAddToCartCrossSell', AnalyticsConstants.trackers.funnel.crosssellMoveToCart.name);
		eventAddToCartCrossSell.params.refId = refId;
		CUBE.Analytics.utils.sendEvent('virtualEventAddToCartCrossSell', AnalyticsConstants.trackers.funnel.crosssellMoveToCart.name);
	});



		
});
$(function() {
	/* SHOPPING TOOL - LAST VIEWED PRODUCTS */
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	var lock = AnalyticsConstants.shoppingtool.lock;
	
	var stType = 'merchandising';
	
	var trackerName;
	if (tc_vars.env_template === "homepage") {
		trackerName = AnalyticsConstants.trackers.homepage.lvp.name;
	} else if (tc_vars.env_template === "product") {
		trackerName = AnalyticsConstants.trackers.product.lvp.name;
	} else if (tc_vars.env_template === "checkout") {
		trackerName = AnalyticsConstants.trackers.funnel.lvp.name;
	} else if (tc_vars.env_template === "list" || tc_vars.env_template === "internal_search") {
		trackerName = AnalyticsConstants.trackers.product.productList.lvp.name;
	} else if (tc_vars.env_template === "other_myaccount") {
		trackerName = AnalyticsConstants.trackers.customer.lvp.name;
	} 
    if (!CUBE.Analytics.trackers.list[trackerName])
        return;

	// $("#perso-lvp-list .lvp-element a.clickable-area, #perso-lvp-list .lvp-element .lvp-btn button, .dash-card.last-products .lvp-element").on('click.st', function() {
	var clickableAreas = [
		'#perso-lvp-list .lvp-element .lvp-product',			// LVP Display
		'#perso-lvp-list .lvp-element .lvp-btn .cta',		// LVP More Informations > Add To Cart Button
		'.dash-card.last-products .lvp-element'			// LVP On Dashboards
	];
	$(clickableAreas.join(', ')).on('click.st', function() {

		if ($(this).hasClass('disabled'))
			return;
		
		var $currentLVP = $(this).closest('.lvp-element');
		var idSuperModel = $currentLVP.data("super-model-id");
		var idModel = $currentLVP.data("model-id");
		var idSku = $currentLVP.data("sku-id");
		var position = $('.lvp-element').index($currentLVP) + 1;

		var label = $currentLVP.find('.lvp-info .product-name').text().trim();
		var value = $currentLVP.find('.price-container:visible').find('.price').data('price');

    	// Get the selected model
        var model = fwk.utils.perso.getLVPModel($currentLVP);

		var _page = "";
		if (tc_vars.env_template === "homepage") {
			_page = "homepage";
		} else if (tc_vars.env_template === "product") {
			_page = "product-page";
		} else if (tc_vars.env_template === "checkout") {
			_page = "basket-page";
		} else if (tc_vars.env_template === "list") {
			_page = "list-page";
		} else if (tc_vars.env_template === "internal_search") {
			_page = "search-page";
		} else if (tc_vars.env_template === "other_myaccount") {
			position -= 1;
			_page = "customer-dashboard";
			tracker = new AnalyticsTracker(AnalyticsConstants.trackers.customer.lvp);
			var eventLvpProduct = new AnalyticsClickEvent('eventLvpProduct', tracker.defaultEvent());
			eventLvpProduct.trigger = 'click';
			eventLvpProduct.options.action = 'PositionClick';
			eventLvpProduct.domContainer = ".slick-lvp .lvp-element";
			eventLvpProduct.domElement = 'a.clickable-area';
			eventLvpProduct.options.label = AnalyticsConstants.slick.defaultValuePosition + position + sep + label + sep + idModel;
			eventLvpProduct.options.value = value;
			
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
		    
			fwk.sendEvent(window, eventLvpProduct);
		}

		if ($currentLVP.hasClass('direct-add') && $(this).hasClass('cta')) {
			// Id Model is different
			idModel = $currentLVP.find('.slider-models .slick-current').data('model-id') || $currentLVP.data('model-id');
			idSku = $currentLVP.find('.slider-sizes:visible .slick-current').data('sku-id');
			
			fwk.shoppingtool.setTmp(stType, 'lvp' + sep + _page + sep + 'position' + sep + position, label + sep + idModel + sep + idSku, value, fwk.colorama.getDetail(idModel));
			// fwk.shoppingtool.sendAddToCart() will be send in 'addtocart.js' global method
	        
			// Swap 'Actual' enhanced ecommerce informations
			var currentEC = AnalyticsConstants.enhanced.actual;
			// And put it back a second later
			setTimeout(function() { AnalyticsConstants.enhanced.actual = currentEC; }, 1000);

			AnalyticsConstants.enhanced.actual = {id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand};
			fwk.enhanced.sendAddToCart(model);


            // trying to add to cart
            throwEvent(Events.CART_ITEM_ADDED, idSku, idSuperModel, 1, $(this));
		} else {
			fwk.shoppingtool.set(stType, 'lvp' + sep + _page + sep + 'position' + sep + position, fwk.colorama.getDetail(idModel));
		}

	});
	
});
$(function() {
	/* SHOPPING TOOL - LAST VIEWED PRODUCTS */
	
	var fwk = CUBE.Analytics;
	var sep = AnalyticsConstants.separatorST;
	
	var stType = 'merchandising-cart';
	
	if (tc_vars.env_template !== "checkout")
		return;

    // 'savelaterGoBackToProduct' -- CLICK - to product page
    var event = CUBE.Analytics.utils.getEvent('savelaterGoBackToProduct');
    event.postAction(function($element) {
		var model = this.model;
		fwk.shoppingtool.set(stType, 'savelater' + sep + 'position' + sep + model.position);
    });

    // 'removeToSaveLater' -- ADDTOCART
    event = CUBE.Analytics.utils.getEvent('removeFromSaveLater');
    event.postAction(function($element) {
		var model = this.model;

		fwk.shoppingtool.setTmp(stType, 'savelater' + sep + 'position' + sep + model.position, this.getLabel($element), this.getValue($element));
    });

	
});
$(function() {
	
	var prefix;
	if (tc_vars.env_template === "list")
		prefix = 'list';
	else if (tc_vars.env_template === "internal_search")
		prefix = 'search';
	else
		return;
	
	/* ENHANCED E-COMMERCE - IMPRESSION - PAGELIST */
		/* SPOTLIGHT FLOORS & PRODUCTS FLOOR */

	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var classProductViewed = 'viewed';
	var selectorProduct = '#spotlightFloor .inner-element, #listing-product .inner-element';
	var selectorProductNotViewed = '#spotlightFloor .inner-element:not(.' + classProductViewed + '), #listing-product .inner-element:not(.' + classProductViewed + ')';
	var hasSendLVPImpression = false;
	var nbLVPImpression = 0;

	var bindEvents = function() {
		
		// IMPRESSION on SCROLL
		$(window).off('scroll.ec');
	    $(window).on('scroll.ec', function() { $(selectorProductNotViewed).each(function() { setProductAsViewed($(this), true); }); });
	
		// IMPRESSION on COLORAMA
	    $(selectorProduct).off('afterChange.ec');
	    $(selectorProduct).on('afterChange.ec', function() { setProductAsViewed($(this), true); });
	};
    
	/**
	 * IMPRESSION on SCROLL FOR LAST VIEWED PRODUCTS
	 */
    $(window).on('scroll', function() { 
    	$('.lvp-element.loaded').each(function() { 
    		setProductLVPAsViewed($(this)); 
    	}); 
    	
    	//Send an event for LVP products
    	if (!hasSendLVPImpression && nbLVPImpression > 0) {
    		sendEventForScroll('LVP', '.lvp-element.loaded');
	        hasSendLVPImpression=true;
    	}
    });
    
    var sendEventForScroll = function(_type, _selector) {
    	var eventScroll = new AnalyticsEvent('eventScroll', {});
    	eventScroll.options.category = 'ListPage - ' + _type;
    	eventScroll.options.action = 'PositionScroll';
    	eventScroll.options.label = 'EC-PrintProducts';
    	eventScroll.options.value = $(_selector + '.' + classProductViewed).length;
        fwk.sendEvent(window, eventScroll);
    };
    
    var setProductLVPAsViewed = function($product) {
		if (utils.isVisible($product) && !$product.hasClass("slick-cloned") && !$product.hasClass(classProductViewed)) {
			var model = utils.perso.getLVPModel($product);
            fwk.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
            
            nbLVPImpression++;
		}
	};
	
    /**
     * SET PRODUCT AS VIEWED
     * 	- If element is visible, and $selectedProduct hasn't been seen yet
     */
    var setProductAsViewed = function(product, sendImpression) {

    	if (!sendImpression || fwk.utils.isVisible(product)) {

	    	var $product = utils.pagelist.getProduct(product);
	    	var $productSelected = utils.pagelist.getSelectedProduct(product);
	    	
	    	if (!$productSelected.hasClass(classProductViewed) && sendImpression) {
	    		var model = utils.pagelist.getModel(product);
	    		fwk.enhanced.sendImpression(model);
	    		$productSelected.addClass(classProductViewed);
	    	}
	    	
	    	if (!$product.hasClass(classProductViewed))
	    		$product.addClass(classProductViewed);
	    	
	    	if (!$productSelected.hasClass(classProductViewed))
	    		$productSelected.addClass(classProductViewed);
    	}
    };

    // First, bind events
	bindEvents();
    
    // When the list loads more products : rebind events & trigger scroll
    $(document).ajaxComplete(function(evt, res, settings) {
    	if (settings.data && settings.data.indexOf('MC_ResultsList') > -1) {    		
    		bindEvents();
    		$(document).trigger('scroll');
    	}
	});


	// IMPRESSION on INIT
	$(document).on('ready', function() {
		var nbProductToPrint = 0;
		// By default, we send the 'n' first product impression at the 'pageview' event (with TagCommander)
		// In order to not send those products twice, we set them as viewed.
		if (typeof GAFramework !== 'undefined' && typeof GAFramework.getNumberOfProductsToPrinted() !== 'undefined')
			nbProductToPrint = GAFramework.getNumberOfProductsToPrinted();
		
		$(selectorProduct).slice(0, nbProductToPrint).each(function() { setProductAsViewed($(this), false); });
	});
});
$(function() {
	
	if (!(tc_vars.env_template === "list" || tc_vars.env_template === "internal_search"))
		return;
	
	/* ENHANCED E-COMMERCE - IMPRESSION - PAGELIST */
				/* SPOTLIGHT */

	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var classSpotlightViewed = 'viewed';
	var selectorSpotlight = '#lpt-tg .pl-element:not(.slick-cloned)';
	var selectorSpotlightNotViewed = selectorSpotlight + ':not(.' + classSpotlightViewed + ')';

    
    /**
     * SET SPOTLIGHT AS VIEWED
     * 	- If element is visible, and $selectedSpotlight hasn't been seen yet
     */
    var setSpotlightAsViewed = function(sendImpression) {
    	
    	var $spotlight = fwk.utils.pagelist.getSpotlight();
    	var $productSelected = utils.pagelist.getSelectedProduct($spotlight);
    	
    	if (!$productSelected.hasClass(classSpotlightViewed)) {
    		var model = utils.pagelist.getModel($productSelected);
    		if (model) {
    			if (sendImpression)
    				fwk.enhanced.sendImpression(model);
    			
    			$productSelected.addClass(classSpotlightViewed);
    		}
    	}

    };

	$(document).on('ready', function() {
		
		// IMPRESSION on INIT (1st spotlight -- timeout to delay after carousel render)
		setTimeout(function() { setSpotlightAsViewed(false); }, 1);

		// IMPRESSION on SPOTLIGHT CHANGE (& COLORAMA)
	    $('#lpt-tg').on('afterChange.ec', function() { setSpotlightAsViewed(true); });
	});

		
});
$(function() {

    /**
     * ON UNLOAD
     * 	If products had been added to Impression, we send an empty event,
     * 	when the user leaves the page, to get those products
     */
    $(window).on('beforeunload', function() {

		if (typeof GAFramework !== 'undefined' && typeof GAFramework.getNumberOfProductsPrinted !== 'undefined') {
			var nbProductPrinted = GAFramework.getNumberOfProductsPrinted();
			
			if (nbProductPrinted > 0) {
		        var eventUnload = new AnalyticsEvent('eventUnload', {});
		        eventUnload.options.category = 'Browser';
		        eventUnload.options.action = 'Unload';
		        eventUnload.options.label = 'EC-PrintProducts';
		        eventUnload.options.value = nbProductPrinted;
		        eventUnload.send();
			}
		}
	});
	
	if (tc_vars.env_template !== "homepage")
		return;
	
	/* ENHANCED E-COMMERCE - IMPRESSION - HOMEPAGE */

	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var classProductViewed = 'viewed';
	var hasSendProductImpression = false;
	var hasSendLVPImpression = false;
	var nbProductImpression = 0;
	var nbLVPImpression = 0;

	/**
	 * IMPRESSION on SCROLL
	 */
    $(window).on('scroll', function() { 
    	$('.inner-product').each(function() { 
    		setProductAsViewed($(this));
    	}); 
    	
    	$('.lvp-element.loaded').each(function() { 
    		setProductLVPAsViewed($(this));
    	});
    	
    	//Send an event for products
    	/*if (!hasSendProductImpression && nbProductImpression > 0) {
    		sendEventForScroll('Product', '.inner-product');
    		hasSendProductImpression=true;
    	}*/
    	
    	//Send an event for LVP products
    	if (!hasSendLVPImpression && nbLVPImpression > 0) {
    		sendEventForScroll('LVP', '.lvp-element.loaded');
	        hasSendLVPImpression=true;
    	}
    });
    
    var sendEventForScroll = function(_type, _selector) {
    	var eventScroll = new AnalyticsEvent('eventScroll', {});
    	eventScroll.options.category = 'HomePage - ' + _type;
    	eventScroll.options.action = 'PositionScroll';
    	eventScroll.options.label = 'EC-PrintProducts';
    	eventScroll.options.value = $(_selector + '.' + classProductViewed).length;
        fwk.sendEvent(window, eventScroll);
    };
    
    /**
     * SET PRODUCT AS VIEWED
     * 	If the element is visible, and has not been seen yet > trigger an Enhanced Ecommerce Impression
     */
    var setProductAsViewed = function($product) {
    	if (utils.isVisible($product)) {
    		if (!$product.hasClass(classProductViewed)) {
    			var model = utils.homepage.getModel($product);
	            fwk.enhanced.sendImpression(model);
	            $product.addClass(classProductViewed);
	            
	            nbProductImpression++;
    		}
    	}
    };
    
    var setProductLVPAsViewed = function($product) {
		if (utils.isVisible($product) && !$product.hasClass("slick-cloned") && !$product.hasClass(classProductViewed)) {
			var model = utils.perso.getLVPModel($product);
            fwk.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
            
            nbLVPImpression++;
		}
	};
});
$(function() {
	
	if ($('#perso-lvp-list').length < -1)
		return;
	
	/* ENHANCED E-COMMERCE - IMPRESSION - PRODUCT */

	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var classProductViewed = 'viewed';
	var selectorCrossSellToScroll = '#often-bought-list .plv2-element';
	var hasSendCrossSellImpression = false;
	var hasSendLVPImpression = false;
	var hasSendPanoplyImpression = false;
	var nbCrossSellImpression = 0;
	var nbLVPImpression = 0;
	var nbPanoplyImpression = 0;
    
	/**
	 * IMPRESSION CROSSSELL & LAST VIEWED PRODUCTS & PANOPLIES on SCROLL
	 */
    $(window).on('scroll', function() { 
    	//Last viewed products
    	$('.lvp-element.loaded:not(.'+classProductViewed+')').each(function() { 
    		setProductLVPAsViewed($(this));
    	});
    	
    	//Cross sell products
    	$(selectorCrossSellToScroll).each(function() { 
    		setProductCrossSellAsViewed($(this));
    	});
    	
    	//Panoplies products
    	$('.slick-active .pb-el__product').each(function() { 
    		setProductPanoplyAsViewed($(this));
    	});
    	
    	//Send an event for Cross sell products
    	if (!hasSendCrossSellImpression && nbCrossSellImpression > 0) {
    		sendEventForScroll('CrossSell', selectorCrossSellToScroll);
	        hasSendCrossSellImpression=true;
    	}
    	
    	//Send an event for LVP products
    	if (!hasSendLVPImpression && nbLVPImpression > 0) {
    		sendEventForScroll('LVP', '.lvp-element');
	        hasSendLVPImpression=true;
    	}
    	
    	//Send an event for Panoplies products
    	if (!hasSendPanoplyImpression && nbPanoplyImpression > 0) {
    		sendEventForScroll('Panoply', '.slick-active .pb-el__product');
	        hasSendPanoplyImpression=true;
    	}
    });
    
    var sendEventForScroll = function(_type, _selector) {
    	var eventScroll = new AnalyticsEvent('eventScroll', {});
    	eventScroll.options.category = 'ProductPage - ' + _type;
    	eventScroll.options.action = 'PositionScroll';
    	eventScroll.options.label = 'EC-PrintProducts';
    	eventScroll.options.value = $(_selector + '.' + classProductViewed).length;
        fwk.sendEvent(window, eventScroll);
    };
    
    /**
     * SET PRODUCT AS VIEWED
     * 	If the element is visible, and has not been seen yet > trigger an Enhanced Ecommerce Impression
     */
    var setProductCrossSellAsViewed = function($product) {
    	if (utils.isVisible($product)) {
    		if (!$product.hasClass(classProductViewed)) {
    			var model = utils.productpage.getCrossSellModel($product.data("productid"), "SM");
	            fwk.enhanced.sendImpression(model);
	            $product.addClass(classProductViewed);
	            
	            nbCrossSellImpression++;
    		}
    	}
    };
    
    var setProductLVPAsViewed = function($product) {
		if (utils.isVisible($product) && !$product.hasClass("slick-cloned") && !$product.hasClass(classProductViewed)) {
			var model = utils.perso.getLVPModel($product);
            fwk.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
            
            nbLVPImpression++;
		}
	};
		
	var setProductPanoplyAsViewed = function($product) {
		if (utils.isVisible($product) && !$product.hasClass(classProductViewed)) {
			var model = utils.productpage.getPanoplyModel(0, $product.data("productid"), "SM");
            fwk.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
            
            nbPanoplyImpression++;
		}
	};
});
$(function() {
	
	if (tc_vars.env_template !== "checkout")
		return;
	
	/* ENHANCED E-COMMERCE - IMPRESSION - BASKET */

	var fwk = CUBE.Analytics;
	var utils = fwk.utils;
	
	var classProductViewed = 'viewed';
	var hasSendLVPImpression = false;
	var nbLVPImpression = 0;
    
    /**
	 * IMPRESSION on SCROLL FOR LAST VIEWED PRODUCTS
	 */
    $(window).on('scroll', function() { 
        $('.lvp-element').each(function() { 
            setProductLVPAsViewed($(this)); 
        }); 

        $('.savelater-element').each(function() { 
            setProductSaveLaterAsViewed($(this)); 
        }); 
    	
    	//Send an event for LVP products
    	if (!hasSendLVPImpression && nbLVPImpression > 0) {
    		sendEventForScroll('LVP', '.lvp-element');
	        hasSendLVPImpression=true;
    	}
    });
    
    var sendEventForScroll = function(_type, _selector) {
    	var eventScroll = new AnalyticsEvent('eventScroll', {});
    	eventScroll.options.category = 'BasketPage - ' + _type;
    	eventScroll.options.action = 'PositionScroll';
    	eventScroll.options.label = 'EC-PrintProducts';
    	eventScroll.options.value = $(_selector + '.' + classProductViewed).length;
        fwk.sendEvent(window, eventScroll);
    };
    /*
     *  IMPRESSION - LVP PRODUCTS
     */
    var setProductLVPAsViewed = function($product) {
        if (utils.isVisible($product) && !$product.hasClass("slick-cloned") && !$product.hasClass(classProductViewed)) {
            var model = utils.perso.getLVPModel($product);
            model.list = '/checkout/cart';
            fwk.enhanced.sendImpression(model);
            $product.addClass(classProductViewed);
            
            nbLVPImpression++;
        }
    };
    
    /*
     *  IMPRESSIONS - SAVE LATER PRODUCTS
     */
    var pool = [];
    var setProductSaveLaterAsViewed = function($product) {
        if (utils.isVisible($product) && !$product.hasClass(classProductViewed)) {

            var refId = $product.find('[data-catalogrefid]').data('catalogrefid');
            
            var model = fwk.utils.datalayer.getModel(refId);
            model.list = '/checkout/cart';

            if (pool.indexOf(refId) == -1) {
	            fwk.enhanced.sendImpression(model);
	            $product.addClass(classProductViewed);
	            pool.push(refId);
            }
        }
    };
});
$(function() {

	if (!(tc_vars.env_template === "list" || tc_vars.env_template === "internal_search" || tc_vars.env_template === "product" || tc_vars.env_template === "suggestions" || tc_vars.env_template === "checkout"))
		return;
	
	/* ENHANCED E-COMMERCE - CLICK */

	var fwk = CUBE.Analytics;

	var tracker, event;
    var listEvent;
	var clickPostAction;

    var bindFunctionToEvents = function(func, events) {
	    for (var evt in events)
	        if (events[evt].trigger && events[evt].trigger == 'click')
	            events[evt].postAction(func);
    };
    
	// PAGE LIST
	if (tc_vars.env_template === "list" || tc_vars.env_template === "internal_search") {

		// PAGELIST PRODUCTS
		tracker = CUBE.Analytics.trackers.list[AnalyticsConstants.trackers.product.productList.name];
	    if (!tracker) return;
	    clickPostAction = function($element) {
	        // Get the selected model
	        var model = fwk.utils.pagelist.getModel($element);
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, tracker.events);
	    
	    // LVP PRODUCTS
		event = CUBE.Analytics.utils.getEvent('eventLvpProduct', AnalyticsConstants.trackers.product.productList.lvp.name);
	    if (!event) return;
	    clickPostAction = function($element) {
	    	// Get the selected model
	        var model = fwk.utils.perso.getLVPModel($element.closest('.lvp-element'));
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, [event]);
	}
	
	// PRODUCT PAGE
	if (tc_vars.env_template === "product") {

		// CROSS SELL PRODUCT
		tracker = CUBE.Analytics.trackers.list[AnalyticsConstants.trackers.product.crosssell.name];
	    if (!tracker) return;
	    clickPostAction = function($element) {
	        // Get the selected model
	    	var product = $element.closest('.plv2-element');
	        var model = fwk.utils.productpage.getCrossSellModel(product.data("productid"), 'SM');
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, tracker.events);
		
	    // LVP PRODUCT
		event = CUBE.Analytics.utils.getEvent('eventLvpProduct', AnalyticsConstants.trackers.product.lvp.name);
	    if (!event) return;
	    clickPostAction = function($element) {
	    	// Get the selected model
	        var model = fwk.utils.perso.getLVPModel($element.closest('.lvp-element'));
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, [event]);
	}

	// BASKET PAGE
	if (tc_vars.env_template === "checkout") {

	    // LVP PRODUCT
		tracker = CUBE.Analytics.trackers.list[AnalyticsConstants.trackers.funnel.lvp.name];
	    if (!tracker) return;
	    clickPostAction = function($element) {
	        var model = fwk.utils.perso.getLVPModel($element.closest('.lvp-element'));
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, tracker.events);

	    // SAVELATER PRODUCT
		event = CUBE.Analytics.utils.getEvent('savelaterGoBackToProduct');
	    if (!event) return;
	    clickPostAction = function($element) {
	        var model = this.model; // postAction autobind event as 'this' value
	        fwk.enhanced.set({id:model.id, position: model.position, list: '/checkout/cart', variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, [event]);
	}
    
	//SUGGESTIONS PAGE
	if (tc_vars.env_template === "suggestions") {

		tracker = CUBE.Analytics.trackers.list[AnalyticsConstants.trackers.suggestions.crosssell.name];
	    if (!tracker) return;
	    clickPostAction = function($element) {
	        // Get the selected model
	    	var product = $element.closest('.plv2-element');
	        var model = fwk.utils.productpage.getCrossSellModel(product.data("productid"), 'SM');
	        // Save the position in the ENHANCED storage
	        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
	        fwk.enhanced.sendClick(model);
	    };
	    bindFunctionToEvents(clickPostAction, tracker.events);
		
	}
		
});
$(function() {

	if (tc_vars.env_template !== "homepage")
		return;
	
	/* ENHANCED E-COMMERCE - CLICK - HOMEPAGE */

	var fwk = CUBE.Analytics;
	var utils = CUBE.Analytics.utils;
    
    var trackerName = AnalyticsConstants.trackers.homepage.homepage.name;
    if (!CUBE.Analytics.trackers.list[trackerName])
        return;

    var eventName = "hpPushProduct";
    if (!CUBE.Analytics.trackers.list[trackerName].events[eventName])
        return;
        
    // Get, and iterates over all events in the tracker
    var event = CUBE.Analytics.trackers.list[trackerName].events[eventName];
    
    event.postAction(function($element) {
        // Get the selected model
        var model = fwk.utils.homepage.getModel($element);
        // Save the position in the ENHANCED storage
        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
        fwk.enhanced.sendClick(model);
    });
    
    //Click on LVP Products
    if(CUBE.Analytics.trackers.list[AnalyticsConstants.trackers.homepage.lvp.name] !== undefined ){
        var event1 = CUBE.Analytics.trackers.list[AnalyticsConstants.trackers.homepage.lvp.name].events.eventLvpProduct;
        event1.postAction(function($element) {
            // Get the selected model
            var model = fwk.utils.perso.getLVPModel($element.closest('.lvp-element'));
            // Save the position in the ENHANCED storage
            fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
            fwk.enhanced.sendClick(model);
        });
    }
});
$(function() {
	
	/* ENHANCED E-COMMERCE - DISPLAY */

    /* HANDLE BY TAGCOMMANDER */
		
});
$(function() {
	
	if (tc_vars.env_template !== "product")
		return;
	
	/* ENHANCED E-COMMERCE - ADD TO CART */

	var fwk = CUBE.Analytics;
        
    /*
     * 	ADD TO CART - From 'AddToCart' button
     */
    var eventAddToCart = fwk.utils.getEvent('addToCart', AnalyticsConstants.trackers.product.conversion.name);
    if (!!eventAddToCart) {
    	eventAddToCart.postAction(function() {
        	var model = fwk.utils.productpage.getModel();
        	
        	var ecInfo = CUBE.Analytics.utils.getProperty(AnalyticsConstants.enhanced.actual, undefined);
        	if (typeof ecInfo === "object" && (model.category === undefined || model.category === "")) {
        		model.category = ecInfo.category;
        	}
        	if (typeof ecInfo === "object" && (model.variant === undefined || model.variant === "")) {
        		model.variant = ecInfo.variant;
        	}
            fwk.enhanced.sendAddToCart(model);
        });
    }
    
});
$(function() {
	
	if (!(tc_vars.env_template === "product" || tc_vars.env_template === "checkout" || tc_vars.env_template === "suggestions"))
		return;
	

	/* ENHANCED E-COMMERCE - ADD TO CART CROSS SELL */

	var fwk = CUBE.Analytics;
        
    // Get event for CrossSell on Basket page
	if (tc_vars.env_template === "checkout") {
	    var eventAddToCartCrossSellBasketPage = fwk.utils.getEvent('virtualEventAddToCartCrossSell', AnalyticsConstants.trackers.funnel.crosssellMoveToCart.name);
	    if (!!eventAddToCartCrossSellBasketPage) {
	    	eventAddToCartCrossSellBasketPage.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
	    	eventAddToCartCrossSellBasketPage.triggerVirtual = function() {
	    		var model = fwk.utils.basketpage.getCrossSellModel(this.params.refId);
	    		fwk.enhanced.sendAddToCart(model);
	    		fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
			};
	    }    
	} else {
		// Get event for CrossSell on Product page or Add to Cart page
		var tracker_page = AnalyticsConstants.trackers.product.crosssellMoveToCart.name;
		var fwk_utils = fwk.utils.productpage;
	    if (tc_vars.env_template === "suggestions" ) {
	    	tracker_page = AnalyticsConstants.trackers.suggestions.crosssellMoveToCart.name;
	    	fwk_utils = fwk.utils.suggestionspage;
	    }
	    var eventAddToCartCrossSell = fwk.utils.getEvent('virtualEventAddToCartCrossSell', tracker_page);
	    if (!!eventAddToCartCrossSell) {
	    	eventAddToCartCrossSell.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
	    	eventAddToCartCrossSell.triggerVirtual = function() {

				// Swap 'Actual' enhanced ecommerce informations
				var currentEC = AnalyticsConstants.enhanced.actual;
				// And put it back a second later
				setTimeout(function() { AnalyticsConstants.enhanced.actual = currentEC; }, 1000);

	    		var model = fwk_utils.getCrossSellModel(this.params.refId, "M");
				AnalyticsConstants.enhanced.actual = {id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand};
	    		fwk.enhanced.sendAddToCart(model);

			};
	    }  
	}

	
	
});
$(function() {
	
	if (tc_vars.page_name !== "/checkout/cart")
		return;
	
	/* ENHANCED E-COMMERCE - REMOVE FROM CART */

	var fwk = CUBE.Analytics;
    
    var trackerNameBasket = AnalyticsConstants.trackers.funnel.basket.name;
    var clickEventName = 'changeQuantityBtn';
    var changeEventName = 'changeQuantityInput';
    var removeEventName = 'removeProduct';

    var trackerNameSavelater = AnalyticsConstants.trackers.funnel.savelater.name;
    var addSaveLaterEventName = 'addToSaveLater';
    var removeSaveLaterEventName = 'removeFromSaveLater';
    
    var _findProduct = '.faux-table-wrapper';
    var _findProductReference = 'data-product-reference';
    
    if (!CUBE.Analytics.trackers.list[trackerNameBasket])
        return;
    if (!CUBE.Analytics.trackers.list[trackerNameSavelater])
        return;
    
    // Get events
    var eventClick = CUBE.Analytics.trackers.list[trackerNameBasket].events[clickEventName];
    var eventChange = CUBE.Analytics.trackers.list[trackerNameBasket].events[changeEventName];
    var eventRemove = CUBE.Analytics.trackers.list[trackerNameBasket].events[removeEventName];

    var eventAddSavelater = CUBE.Analytics.trackers.list[trackerNameSavelater].events[addSaveLaterEventName];
    var eventRemoveSavelater = CUBE.Analytics.trackers.list[trackerNameSavelater].events[removeSaveLaterEventName];
    
    /*
     * 	CHANGE QUANTITY (from Add / Remove btn)
     */
    eventClick.postAction(function($element) {

    	var $product = $element.closest(_findProduct);
        var refId = $product.find('[data-product-reference]').data('product-reference');
        var model = fwk.utils.datalayer.getModel(refId);
        if (Object.keys(model).length === 0) {
            refId = $product.find('[product-id]').attr("product-id");
            model = fwk.utils.datalayer.getModel(refId);
        }

        model.quantity = 1; // Always 1 quantity
        model.list = '/checkout/cart';
        
        if ($element.hasClass('icon-minus'))
            fwk.enhanced.sendRemoveToCart(model); // Remove quantity
        else
            fwk.enhanced.sendAddToCart(model); // Add quantity
    });
    
    
    /*
     * 	CHANGE QUANTITY (from input)
     */
    eventChange.postAction(function($element) {

        var $product = $element.closest(_findProduct);
        var refId = $product.find('[data-product-reference]').data('product-reference');
        var model = fwk.utils.datalayer.getModel(refId);
        if (Object.keys(model).length === 0) {
            refId = $product.find('[product-id]').attr("product-id");
            model = fwk.utils.datalayer.getModel(refId);
        }

        // Compute quantity
        var _oldVal = $element.data('quantity');
        var _newVal = $element.val();
        var _diff = parseInt(_newVal) - parseInt(_oldVal);
        
        model.quantity = Math.abs(_diff);
        model.list = '/checkout/cart';
        
        if (_diff < 0)
            fwk.enhanced.sendRemoveToCart(model); // Remove quantity
        else
            fwk.enhanced.sendAddToCart(model); // Add quantity
    });
    
    
    /*
     * 	REMOVE PRODUCT (from basket)
     */
    eventRemove.postAction(function($element) {

        var $product = $element.closest(_findProduct);
        var refId = $product.find('[data-product-reference]').data('product-reference');
        var model = fwk.utils.datalayer.getModel(refId);
        if (Object.keys(model).length === 0) {
            refId = $product.find('[product-id]').attr("product-id");
            model = fwk.utils.datalayer.getModel(refId);
        }

        model.quantity = $product.find('[data-quantity]').data('quantity');
        model.list = '/checkout/cart';
        
        fwk.enhanced.sendRemoveToCart(model); // Remove quantity
    });

    /*
     *  ADD TO BUY LATER - REMOVE PRODUCT (from cart)
     */
    eventAddSavelater.postAction(function($element) {
        
        var $product = $element.closest(_findProduct);
        modelId = $product.find('['+_findProductReference+']').attr(_findProductReference);
        
        var model = fwk.utils.datalayer.getModel(modelId);
        if (Object.keys(model).length === 0) {
            refId = $product.find('[product-id]').attr("product-id");
            model = fwk.utils.datalayer.getModel(refId);
        }

        model.quantity = $product.find('[data-quantity]').data('quantity');
        model.list = '/checkout/cart';
        
        fwk.enhanced.sendRemoveToCart(model); // Remove quantity

    });

    /*
     *  REMOVE FROM BUY LATER - ADD PRODUCT (to cart)
     */
    eventRemoveSavelater.postAction(function($element) {
        
        var $product = $element.closest(_findProduct);
        modelId = $product.find('['+_findProductReference+']').attr(_findProductReference);
        var model = fwk.utils.datalayer.getModel(modelId);
        if (Object.keys(model).length === 0) {
            rrefId = $product.find('[product-id]').attr("product-id");
            model = fwk.utils.datalayer.getModel(refId);
        }
        
        model.quantity = 1;
        model.list = '/checkout/cart';
        
        fwk.enhanced.set({id:model.id, position: model.position, list: model.list, variant:model.variant, category:model.category, label:model.name, brand:model.brand});
        fwk.enhanced.sendAddToCart(model); // Remove quantity

    });

});
$(function() {
	
	if (tc_vars.env_template !== "product")
		return;
	
	var fwk = CUBE.Analytics;
	
	/*
	 * STEPS NAMES (order_checkout_step)
	 * 	+ Associated LOCKS (avoid mutiple sending)
	 */
	
	var stepLogin = 'LOGIN_STEP_2';
	var lockLogin = false;
	
	var stepMissingInformations = 'MISSINGINFORMATIONS_STEP_0';
	var lockMissingInformations = false;
	
	var stepExpress = 'EXPRESS_STEP_1';
	var lockExpress = false;
	
	var stepShipping = 'SHIPPING_STEP_3';
	var lockShipping = false;
	
	var stepPayment = 'PAYMENT_STEP_4';
	var lockPayment = false;
	

	/**
	 * ENHANCED E-COMMERCE for EXPRESS CHECKOUT
	 * 
	 * 	Starts at 'Add To Cart' (previous actions are handled in a classical way) 
	 */
    
	// > ADD TO CART
	// Triggered by 'Express Payment' button (conversion area)
    var eventAddToCartExpress = fwk.utils.getEvent('expressCheckout', AnalyticsConstants.trackers.funnel.express.name);
    if (!!eventAddToCartExpress) {
    	eventAddToCartExpress.postAction(function() {
        	var model = fwk.utils.productpage.getModel();
            fwk.enhanced.sendAddToCart(model);
        });
    }
    
    // > LOGIN (Virtual Page)
    var eventLoginExpress = fwk.utils.getEvent('expressCheckoutVirtualLogin', AnalyticsConstants.trackers.funnel.express.name);
    if (!!eventLoginExpress) {
    	eventLoginExpress.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
    	eventLoginExpress.triggerVirtual = function() {
    		
    		if (!lockLogin)
    			triggerVirtualPage(stepLogin);
    		lockLogin = true;
    		
    		/*
        	var model = fwk.utils.productpage.getModel();
            fwk.enhanced.sendProductCheckout(model, stepLogin);
            */
        };
    }
    // > MISSING INFORMATION ON LOGIN
    var eventMissingInformationExpress = fwk.utils.getEvent('expressCheckoutVirtualMissingInformation', AnalyticsConstants.trackers.funnel.express.name);
    if (!!eventMissingInformationExpress) {
    	eventMissingInformationExpress.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
    	eventMissingInformationExpress.triggerVirtual = function() {
    		
    		if (!lockMissingInformations)
    			triggerVirtualPage(stepMissingInformations);
    		lockMissingInformations = true;
        };
    }
    
    // > SUMMARY (Virtual Page)
    var eventSummaryExpress = fwk.utils.getEvent('expressCheckoutVirtualSummary', AnalyticsConstants.trackers.funnel.express.name);
    if (!!eventSummaryExpress) {
    	eventSummaryExpress.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
    	eventSummaryExpress.triggerVirtual = function() {
    		
    		if (!lockExpress)
    			triggerVirtualPage(stepExpress);
    		lockExpress = true;
    		
    		/*
        	var model = fwk.utils.productpage.getModel();
            fwk.enhanced.sendProductCheckout(model, stepExpress);
            */
        };
    }
    
    // > SHIPPING METHOD (Virtual Page)
    var eventShippingtExpress = fwk.utils.getEvent('expressCheckoutVirtualShipping', AnalyticsConstants.trackers.funnel.express.name);
    if (!!eventShippingtExpress) {
    	eventShippingtExpress.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
    	eventShippingtExpress.triggerVirtual = function() {
    		
    		if (!lockShipping)
    			triggerVirtualPage(stepShipping);
    		lockShipping = true;
    		
    		/*
        	var model = fwk.utils.productpage.getModel();
            fwk.enhanced.sendProductCheckout(model, stepShipping);
            */
        };
    }
    
    // > PAYMENT METHOD (Virtual Page)
    var eventPaymentExpress = fwk.utils.getEvent('expressCheckoutVirtualPayment', AnalyticsConstants.trackers.funnel.express.name);
    if (!!eventPaymentExpress) {
    	eventPaymentExpress.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
    	eventPaymentExpress.triggerVirtual = function() {
    		
    		if (!lockPayment)
    			triggerVirtualPage(stepPayment);
    		lockPayment = true;
    		
    		/*
        	var model = fwk.utils.productpage.getModel();
            fwk.enhanced.sendProductCheckout(model, stepPayment);
            */
        };
    }
    
    /**
     * VIRTUAL PAGE METHOD
     */
    var triggerVirtualPage = function(name) {
    	
    	var frame = window.frames['virtual-page'];
    	var urlPage = '/assets/virtual.html';
    	
    	frame.src = urlPage + "?page=" + name;
    	
    };
    
});

$(function() {
	
	if (tc_vars.env_template !== "product")
		return;
	
	var fwk = CUBE.Analytics;
	
	var lockAddPanoply = false;
	/**
	 * ENHANCED E-COMMERCE for ADD PANOPLY
	 *  
	 */
        
    // > LOGIN (Virtual Page)
    var addPanoplyVirtualDetail = fwk.utils.getEvent('addPanoplyVirtualDetail', AnalyticsConstants.trackers.product.addPanoply.name);
    if (!!addPanoplyVirtualDetail) {
    	addPanoplyVirtualDetail.stopEvent = function() { if (!!this.triggerVirtual) this.triggerVirtual(); return true; };
    	addPanoplyVirtualDetail.triggerVirtual = function() {
    		
    		if (!lockAddPanoply)
    			triggerVirtualPage();
    		lockAddPanoply = true;
        };
    }
    
    /**
     * VIRTUAL PAGE METHOD
     */
    var triggerVirtualPage = function() {
    	
    	var frame = window.frames['virtual-page'];
    	var urlPage = '/assets/virtual.html';
    	
    	frame.src = urlPage + "?add_panoply=1";
    	
    };
    
});

/* LAST VIEWED PRODUCT */

var CUBE = CUBE || {};
(function($) {
	"use strict";
	
	var fwk = CUBE.Analytics;
	var lvpConfig = {};
	var ajaxURL = "/"+tc_vars.env_language+"/ajax/retrieveProductModels?productId=";
	var isDirectAddToCart = true;
	var isDashboard = false;
	
	CUBE.Analytics.perso = CUBE.Analytics.perso || {};

	CUBE.Analytics.perso.lvp = {

		init: function() {

			if ($('#perso-lvp-list').length === 0)
				return;

			if (tc_vars.page_name === '/account/dashboard')
				isDashboard = true;

			lvpConfig = $('#lvp-slick-config').data();

			this.initSlider();

			if (isDirectAddToCart)
				this.initDirectAddToCart();

			// Load displayed elements
			if (!isDashboard)
				$('.lvp-element.new.slick-active').removeClass('new').each(this.fetchLVP());
			else
				$('.slick-active .lvp-element.new').removeClass('new').each(this.loadLVP);

		},

		fetchLVP: function() {
			if (isDirectAddToCart)
				return this.loadFullLVP;
			else
				return this.loadLVP;
		},

		initSlider: function() {
			// Init global-slider
			if (!isDashboard)
				$('#perso-lvp-list').slick(this.config.slider.slickConfGlobal(lvpConfig));
			else
				$('.slick-lvp').slick({dots: true, rows:2, slidesPerRow: 1, arrows: false});
				
			$('#perso-lvp-list').on('afterChange', function(event, slick) {
				// Load all new element
				if (slick.$slider.attr('id') == 'perso-lvp-list')
					$('.lvp-element.new').removeClass('new').each(fwk.perso.lvp.fetchLVP());
			});

			// Display full product's name on hover (if it's hidden (text too long))
			$('#perso-lvp-list .lvp-element').hover(function() {
				$(this).find('.lvp-info').animate({height: $(this).find('.lvp-info').get(0).scrollHeight});
			}, function() {
				var defaultHeight = $(this).find('.lvp-info').data('default-height');
				$(this).find('.lvp-info').animate({height: defaultHeight || 80});
			});
		},

		initDirectAddToCart: function() {
			// Init sliders
			$('.slider-products').slick(this.config.slider.slickConfHeadProducts);
			$('.slider-models').slick(this.config.slider.slickConfModels);

			$('.slider-models').on('beforeChange', modelBeforeChange);
			$('.slider-models').on('afterChange', handleDisableAddToCart);

			/*
			 * IN CASE OF 'DIRECT-ADD-TO-CART' :
			 *	> Links are disabled
			 *	> Hoverring LVP opens details (Colors, sizes) and displays an add to cart button
			 *	> On mobile, clicking LVP opens a modal window with direct add to cart button
			 *
			 * Each time the mouse is over an LVP product, displays the LVP-details panel
			 */
			 var tOut = [];
			$('#perso-lvp-list .lvp-element').hover(function() {
				// SHOW MODELS + SIZES
				var $lvp = $(this);
				var refId = $lvp.data('sku-id');
				clearTimeout(tOut[refId]);

				$lvp.find('.lvp-more-products').show();
				$lvp.find('.slider-models').slick('setPosition');
				$lvp.find('.lvp-size[data-sku-id="'+refId+'"]').closest('.slider-sizes').slick('setPosition');

			}, function() {
				// HIDE MODELS + SIZES
				var refId = $(this).data('sku-id');
				tOut[refId] = setTimeout(function() { $(this).find('.lvp-more-products').hide(); }.bind(this), 200);
			});

		},

		loadLVP: function() {
			var $currentLVP = $(this);
			var superModelId = $currentLVP.data('super-model-id');
			var refModelId = '';//$currentLVP.data('model-id');
			var refSkuId = $currentLVP.data('sku-id');

			$.ajax({
				type: 'POST', dataType: 'json', url: ajaxURL + superModelId, 
				success: function(data) {
					var stock = 0;
					// Iterates all Models
					data.responseTO.data.map(function(model) {
						// Iterates all Skus and add availableQuantity
						model.skus.map(function(sku) { if (sku.availableQuantity) stock += sku.availableQuantity; });
					});
					if (stock === 0)
						return isDashboard ? removeCurrentLVPDashboard($currentLVP) : removeCurrentLVP($currentLVP);

					// Iterates all Models
					data.responseTO.data.map(function(model) {
						if (model.media === null || model.media.images === null) return false;

						// Iterates on all Skus
						model.skus.filter(function(sku) { return sku.id == refSkuId; }).map(function(sku) {

							refModelId = model.id;

							// Add Product Image
							$currentLVP.find('.slider-products').append(templateSlideProduct(model));

							// Add '.price-container', and display it
							var $priceContainer = $(sku.displayPriceContainer).attr('data-sku-id', sku.id);
							$currentLVP.find('.lvp-product .lvp-price').append($priceContainer);
							$currentLVP.find('.price-container').show();
						});
					});

					// Set DataAttribute for ModelId
					$currentLVP.attr('data-model-id', refModelId);
					$currentLVP.addClass('loaded');

					// Wrap Link around LVP (make LVP clickable)
					_wrapLink($currentLVP);
				}
			});

		},

		loadFullLVP: function() {
			var $currentLVP = $(this);
			var refSuperModelId = $currentLVP.data('super-model-id');
			var refModelId = '';//$currentLVP.data('model-id');
			var refSkuId = $currentLVP.data('sku-id');

			if (refSuperModelId == tc_vars.product_id_super_model){
				return removeCurrentLVP($currentLVP);
			}

			$.ajax({
				type: 'POST', dataType: 'json', url: ajaxURL + refSuperModelId, 
				success: function(data) {
					// Define 'slider-models' as navigation for 'slider-products' (& vice-versa)
					$currentLVP.find('.slider-products').slick('slickSetOption', 'asNavFor', '.lvp-element[data-super-model-id="'+refSuperModelId+'"] .slider-models');
					$currentLVP.find('.slider-models').slick('slickSetOption', 'asNavFor', '.lvp-element[data-super-model-id="'+refSuperModelId+'"] .slider-products');

					var nbModels = data.responseTO.data.filter(function(model) { return model.media !== null; }).length;

					var stock = 0;
					// Iterates all Models
					data.responseTO.data.map(function(model) {
						// Iterates all Skus and add availableQuantity
						model.skus.map(function(sku) { if (sku.availableQuantity) stock += sku.availableQuantity; });
					});
					if (stock === 0){
						return removeCurrentLVP($currentLVP);
					}

					// Iterates all Models
					data.responseTO.data.map(function(model) {

						if (model.media === null || model.media.images === null) return false;

						if (nbModels > 1) {
							// Add 1 model image in '& 'slider-models'
							var isAllSkuUnavailable = model.skus.every(function(sku) { return !sku.available; });
							$currentLVP.find('.slider-models').slick('slickAdd', templateSlideModel(model, isAllSkuUnavailable));
						} else
							$currentLVP.find('.slider-models').hide();

						// Add 1 model image in 'slider-products' 
						$currentLVP.find('.slider-products').slick('slickAdd', templateSlideProduct(model));

						// Add 1 sizes-container, transform it in slider
						$currentLVP.find('.lvp-sizes').append(templateSliderSizes(model.id));


						// Init Slick Slider on sliderSize
						var $sliderSize = $currentLVP.find('.slider-sizes[data-model-id="'+model.id+'"]');
						$sliderSize.slick(fwk.perso.lvp.config.slider.slickConfModels);
						$sliderSize.on('beforeChange', sizeBeforeChange);
						$sliderSize.on('afterChange', handleDisableAddToCart);

						// Iterates on all Skus
						model.skus.map(function(sku) {

							// Add 1 'lvp-size'
							$sliderSize.slick('slickAdd', templateSlideSize(sku));

							// Add 1 '.price-container'
							var $priceContainer = $(sku.displayPriceContainer).attr('data-sku-id', sku.id);
							$currentLVP.find('.lvp-price').append($priceContainer);

							// refSku = currentSku => Model Found !
							if (sku.id == refSkuId)
								refModelId = model.id;
						});

					});
					
					// Set DataAttribute for ModelId
					$currentLVP.attr('data-model-id', refModelId);
					$currentLVP.addClass('loaded');

					// Display good 'slider-sizes', based on refModelId
					var $currentSizes = $currentLVP.find('.slider-sizes[data-model-id="'+refModelId+'"]');
					$currentSizes.show();
					// Display good 'slider-models', based on refModelId
					if (nbModels > 1) $currentLVP.find('.slider-models .lvp-model[data-model-id="'+refModelId+'"]:not(.slick-cloned)').click();

					// Display the good 'price-container', based on refSkuId
					$currentLVP.find('.price-container[data-sku-id="'+refSkuId+'"]').show();

					// Go to good size slide (base on skuId)
					var indexSize = $currentLVP.find('.lvp-size[data-sku-id="'+refSkuId+'"]').data('slick-index');
					$currentSizes.slick('slickGoTo', indexSize);
					$currentSizes.slick('setPosition');

 					if ($currentLVP.find('.lvp-size[data-sku-id="'+refSkuId+'"]').hasClass('disabled'))
 						$currentLVP.find('.lvp-btn .cta.cart').addClass('disabled');

					$currentLVP.addClass('direct-add');

					// If we are on checkout / cart > Add 'reresh' class to reload cart on AddToCart
					if (tc_vars.page_name === "/checkout/cart")
						$currentLVP.find('.lvp-btn .cta.cart').addClass('refresh');

					// Make LVP clickable, but not for mobile
					if (!$('body').hasClass('mobile'))
						_wrapLink($currentLVP);

					setTimeout(function() {
						// Wait for the basic changes (models / sizes selection) to be done
						// then only after, add 'fully-loaded' to the LVP
						// (> avoid useless shoppingtool-colorama updates)
						$currentLVP.addClass('fully-loaded');
					}, 1000);
				}
			});
		},

		config: {
			slider: {
				slickConfGlobal: function(lvpSlickConfig) { return {
					rows:1,
			        infinite: false, dots: true, arrows: false, draggable: false,
					slidesToShow: lvpSlickConfig.amountDesktop, slidesToScroll: lvpSlickConfig.amountDesktop,
			        responsive: [
			            {
			            	breakpoint: decathlon.uxBreakpoints.smMin,
			            	settings: {
			            		slidesToShow: lvpSlickConfig.amountTablet, slidesToScroll: lvpSlickConfig.amountTablet
			            	}
			            },
			            {
			            	breakpoint: decathlon.uxBreakpoints.xsMin,
			            	settings: {
			            		slidesToShow: lvpSlickConfig.amountMobile, slidesToScroll: lvpSlickConfig.amountMobile
			            	}
			            }
			        ]
			    }; },
				slickConfHeadProducts: {
					arrows: false, dots: false,
					slidesToShow: 1, infinite: false, fade: true
				},
				slickConfModels: {
					arrows: true, dots: false, focusOnSelect: true,
					slidesToShow: 1, slidesToScroll: 1, variableWidth: true, infinite: false, centerMode: true
				},
				slickConfSizes: {
					slidesToShow: 1, slidesToScroll: 1, variableWidth: true, infinite: false, centerMode: true,
					draggable: true
				},
			}
		}

	};



	/****************************
	 SLICK SLIDERS CONFIGURATION
	*****************************/

	// SLICK - GLOBAL (Responsive)
	var slickConfGlobal = '';

	// SLICK - HEAD PRODUCTS
	var slickConfHeadProducts = '';

	// SLICK - MODELS
	var slickConfModels = '';

	// SLICK - SIZES
	var slickConfSizes = '';


	/**************
	 EVENT HANDLER
	***************/

	// ON CHANGE - MODEL
	// - 1 - Display the good 'slider-sizes'
	// - 2 - Display the good 'price-container'
	var modelBeforeChange = function (event, slick, currentSlide, nextSlide) {

		var $currentLVP = $(this).closest('.lvp-element');
		var modelId = $(slick.$slides.get(nextSlide)).data('model-id');

		// - 1 -
		$currentLVP.find('.lvp-sizes .slider-sizes').hide();
		var $selectedSliderSize = $currentLVP.find('.slider-sizes[data-model-id="'+modelId+'"]');
		$selectedSliderSize.show();
		$selectedSliderSize.slick('setPosition');
		
		// - 2 -
		var skuId = $selectedSliderSize.find('.slick-current').data('sku-id');
		showPriceContainer($currentLVP, skuId);
		//handleDisableAddToCart($currentLVP, skuId);

	};

	// ON CHANGE - SIZE
	// - 1 - Display the good 'price-container'
	var sizeBeforeChange = function (event, slick, currentSlide, nextSlide) {

		var $currentLVP = $(this).closest('.lvp-element');
		var skuId = $(slick.$slides.get(nextSlide)).data('sku-id');

		// -1 - 
		showPriceContainer($currentLVP, skuId);
		//handleDisableAddToCart($currentLVP, skuId);
	};

	var showPriceContainer = function($currentLVP, skuId) {
		$currentLVP.find('.price-container').hide();
		$currentLVP.find('.price-container[data-sku-id="'+skuId+'"]').show();
	};

	var handleDisableAddToCart = function (event, slick, currentSlide, nextSlide) {

		var $currentLVP = $(this).closest('.lvp-element');
		var isSizeDisabled = false;
		
		var selectedModel = $currentLVP.find('.slider-models .slick-current').data('model-id');

		if (selectedModel)
 			isSizeDisabled = $currentLVP.find('.slider-sizes[data-model-id="'+selectedModel+'"] .slick-current').hasClass('disabled');
 		else
 			isSizeDisabled = $currentLVP.find('.slider-sizes .slick-current').hasClass('disabled');

		var productSellableOnLine = $currentLVP.data('product-sellable-online');
		
		if (isSizeDisabled || !productSellableOnLine)
			$currentLVP.find('.lvp-btn .cta.cart').addClass('disabled');
		else {
			$currentLVP.find('.lvp-btn .cta.cart').removeClass('disabled');
		}
	};

	var _wrapLink = function($currentLVP) {

		var url = $currentLVP.data('default-url');
		
		// TODO - WARNING - Special workaround for new locale URL
		if (window.location.href.indexOf('/nl/') === -1){
			url = url.replace('/nl/', '/');
		}
		
		var target = (lvpConfig.targetBlank) ? ' target="_blank" ' : '';
		var link = '<a class="clickable-area" href="' + url + '" '+target+'></a>';

		// Add Link
		$currentLVP.find('.lvp-product')
					.wrap(link);

		// Change cursor to pointer
		$currentLVP.find('.lvp-product').css('cursor', 'pointer');
	};

	var removeCurrentLVPDashboard = function($currentLVP) {
		var $lvpSlider = $currentLVP.closest('#perso-lvp-list');
		var refSuperModelId = $currentLVP.data('super-model-id');

		// Search LVP Index and remove it from slider
		$lvpSlider.slick('unslick');
		$lvpSlider.find('.lvp-element[data-super-model-id="'+refSuperModelId+'"]').remove();

		$('.slick-lvp').slick({dots: true, rows:2,
				slidesPerRow: 1, arrows: false});

		$lvpSlider.find('.lvp-element.new').removeClass('new').each(fwk.perso.lvp.loadLVP);
		
		if ($('.lvp-element').length === 0)
			$lvpSlider.closest('.col-sm-4').remove();
	};
	var removeCurrentLVP = function($currentLVP) {

		var $floor = $currentLVP.closest('section');

		// Search LVP Index and remove it from slider
		var index = $currentLVP.closest('.slick-slider').find('.lvp-element').index($currentLVP);
		$currentLVP.closest('.slick-slider').slick('slickRemove', index);
		
		// Load the new displayed LVP (if any)
		$('.lvp-element.slick-active.new').removeClass('new').each(fwk.perso.lvp.fetchLVP());

		// If there no more LVP to display, remove LVP FLOOR and link from NAVIGATION BR
		if ($('.lvp-element').length === 0) {
			var linkAnchor = $floor.find('>a').data('dynamic-nav');
			var $linkNavigation = $('a[href="#'+linkAnchor+'"]');

			$floor.remove();
			$linkNavigation.remove();
		}
	};


	/**********
	 TEMPLATES
	***********/

	// TEMPLATE - SLIDE HEAD PRODUCT
	var templateSlideProduct = function(model) {

    	var idModel = model.id;
    	var name = model.media.images[0].name;
    	var url = model.media.images[0].url;

		return '<div class="lvp-product-img" role="radio" data-model-id="' + idModel + '">' +
        '<picture alt="' + name + '" aria-hidden="true">' +
             '<!--[if IE 9]><video style="display: none;"><![endif]-->' +
             '<source data-srcset="' + url + '?f=250x250" media="(min-width: 801px)">' +
             '<source data-srcset="' + url + '?f=250x250" media="(min-width: 481px)">' +
             '<source data-srcset="' + url + '?f=250x250" media="(max-width: 480px)">' +
             '<!--[if IE 9]></video><![endif]-->' +
             '<img class="lazyload"  src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="' + name + '">' +
             '</picture>' +
          '</div>';
	};

	// TEMPLATE - SLIDE MODEL
	var templateSlideModel = function(model, isUnvailable) {

    	var idModel = model.id;
    	var name = model.media.images[0].name;
    	var url = model.media.images[0].url;

		return '<div class="lvp-color lvp-model '+(isUnvailable ? 'unavailable' : '')+'" role="radio" data-model-id="' + idModel + '">' +
        '<picture alt="' + name + '" aria-hidden="true">' +
             '<!--[if IE 9]><video style="display: none;"><![endif]-->' +
             '<source data-srcset="' + url + '?f=250x250" media="(min-width: 801px)">' +
             '<source data-srcset="' + url + '?f=250x250" media="(min-width: 481px)">' +
             '<source data-srcset="' + url + '?f=250x250" media="(max-width: 480px)">' +
             '<!--[if IE 9]></video><![endif]-->' +
             '<img class="lazyload"  src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="' + name + '" style="height: 40px;">' +
             '</picture>' +
          '</div>';
	};

	// TEMPLATE - SLIDER SIZES (container)
	var templateSliderSizes = function(idModel) {
		return '<div class="size-content"><div class="lvp-sizes-container slider-sizes medium contour" data-model-id="' + idModel + '"></div></div>';
	};

	// TEMPLATE - SLIDE SIZE
	var templateSlideSize = function(sku) {
		return '<div class="lvp-size '+ (sku.available ? '' : 'disabled') +'" data-sku-id="' + sku.id + '">' + sku.size + '</div>';
	};


	var $watchOnScroll = $('[id*="last-viewed-products"],.dash-card.last-products')
	if ($watchOnScroll.length > 0) {
		
		// If an element is watchable : check if its visible, then trigger LVP Init (once)
		var alreadyInit = false
		$(window).on('scroll', function() { 
			if (fwk.utils.isVisible($watchOnScroll, 250) && !alreadyInit) {
				alreadyInit = true
				CUBE.Analytics.perso.lvp.init();
			}
		});

		// For checkout only : trigger a 'scroll' event to load LVP on page init
		if (tc_vars.env_template === 'checkout' || tc_vars.env_template === 'other_myaccount')
			$(window).trigger('scroll')

	}


})(jQuery);

// CUBE ANALYTICS INIT
$(function(){
	var intervalGAInitID;
	function initGAFramework() {
		if (typeof GAFramework !== "undefined") {
			clearInterval(intervalGAInitID);
			CUBE.Analytics.init();
		}
	}
	
	intervalGAInitID = window.setInterval(initGAFramework, 1000);
});